Disassembly Listing for vpc-32vga
Generated From:
/home/jacques/github/vpc-32vga/dist/default/production/vpc-32vga.production.elf
2018-01-25 09:56:03

---  /opt/microchip/xc32/v1.44/pic32mx/include/peripheral/uart.h  ---------------------------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  // Section: Constants & Data Types
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  
84:                  //DOM-IGNORE-BEGIN
85:                  /****
86:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
87:                         the device file.  Also the UART register set could also be placed there
88:                  *****/
89:                  typedef struct
90:                  {
91:                      volatile UINT   reg;
92:                      volatile UINT   clr;
93:                      volatile UINT   set;
94:                      volatile UINT   inv;
95:                  }REG_SET;
96:                  
97:                  typedef struct
98:                  {
99:                      volatile REG_SET    mode;
100:                     volatile REG_SET    sta;
101:                     volatile REG_SET    tx;
102:                     volatile REG_SET    rx;
103:                     volatile REG_SET    brg;
104:                 }UART_REGS;
105:                 
106:                 extern UART_REGS * const uartReg[];
107:                 //DOM-IGNORE-END
108:                 
109:                 // *****************************************************************************
110:                 /* UART Module
111:                 
112:                   Summary:
113:                     UART modules supported.
114:                 
115:                   Description:
116:                     This enumeration identifies the available UART modules.
117:                 */
118:                 
119:                 typedef enum
120:                 {
121:                 #if defined _UART1
122:                     // UART1 Module ID.
123:                     UART1 = 0,
124:                 #endif
125:                 #if defined _UART2
126:                     // UART2 Module ID.
127:                     UART2,
128:                 #endif
129:                 #ifdef _UART3
130:                     // UART3 Module ID.
131:                     UART3,
132:                 #endif
133:                 #ifdef _UART4
134:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
135:                     UART4,
136:                 #endif
137:                 #ifdef _UART5
138:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
139:                     UART5,
140:                 #endif
141:                 #ifdef _UART6
142:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
143:                     UART6,
144:                 #endif
145:                     // Number of available UART modules.
146:                     UART_NUMBER_OF_MODULES
147:                 
148:                 } UART_MODULE;
149:                 
150:                 
151:                 // *****************************************************************************
152:                 /* UART Enable Modes
153:                 
154:                   Summary:
155:                     Operating modes of UART.
156:                 
157:                   Description:
158:                     This enumeration defines the supported modes in which the UART may be
159:                     enabled or disbled.
160:                 
161:                   Remarks:
162:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
163:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
164:                     has been pre-loaded with data.
165:                 
166:                     The caller should not rely on the specific numbers assigned to any of these
167:                     values as they may change from one processor to the next.
168:                 */
169:                 
170:                 typedef enum
171:                 {
172:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
173:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
174:                 
175:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
176:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
177:                 
178:                 
179:                     // UART Module, receiver and transmitter functionality is not.
180:                     // enabled or disabled
181:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
182:                 
183:                     // UART Module receiver.
184:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
185:                 
186:                     // UART Module transmitter.
187:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
188:                 
189:                 
190:                 } UART_ENABLE_MODE;
191:                 
192:                 // *****************************************************************************
193:                 /* UART Enable Helper Macro
194:                 
195:                   Summary:
196:                     Macro for enabling module operating modes.
197:                 
198:                   Description:
199:                     This macro creates the proper flags for enabling operating modes of the UART module.
200:                 
201:                   Example:
202:                     <code>
203:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
204:                     </code>
205:                 
206:                   Remarks:
207:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
208:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
209:                     has been pre-loaded with data.
210:                 */
211:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
212:                 
213:                 // *****************************************************************************
214:                 /* UART Disable Helper Macro
215:                 
216:                   Summary:
217:                     Macro for disabling module operating modes.
218:                 
219:                   Description:
220:                     This macro creates the proper flags for disabling operating modes of the UART module.
221:                 
222:                   Example:
223:                     <code>
224:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
225:                     </code>
226:                 
227:                 */
228:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
229:                 
230:                 // *****************************************************************************
231:                 /* UART Configuration Settings
232:                 
233:                   Summary:
234:                     Supported configuration flags for the UART module.
235:                 
236:                   Description:
237:                     This enumeration defines the various configuration options for the UART
238:                     module.  These values can be OR'd together to create a configuration mask
239:                     passed to the UARTConfigure routine.
240:                 
241:                   Remarks:
242:                     Several of the configuration options are mutually exclusive:
243:                     * Only one of the "ENABLE_PINS" modes can be used at a time
244:                     * Only one of the "RTS_WHEN" modes can be used at a time
245:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
246:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
247:                 
248:                     The caller should not rely on the specific numbers assigned to any of these
249:                     values as they may change from one processor ot the next.
250:                 */
251:                 
252:                 typedef enum
253:                 {
254:                     // Enables high-speed range of the UART (see UARTSetBitRate).
255:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
256:                 
257:                     // Inverts polarity of data interpretation the received (RX) pin.
258:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
259:                 
260:                     // Enables UART TX-to-RX Loop-back mode.
261:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
262:                 
263:                     // Enables Wake-up of the part when a start bit is received.
264:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
265:                 
266:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
267:                     // cannot be used in bit-clock/IrDA mode).
268:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
269:                 
270:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
271:                     // cannot be used in CTS/RTS mode).
272:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
273:                 
274:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
275:                     // be used in RTS-Only mode).
276:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
277:                 
278:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
279:                     // the default mode and this parameter can be left out if it is desired).
280:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
281:                 
282:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
283:                     // is not full (i.e., the UART is ready to receive data).  This is also known
284:                     // as "RTS Flow-Control Mode".
285:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
286:                 
287:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
288:                     // is not empty (i.e., when the UART has data ready to send).  This is also
289:                     // known as "RTS Simplex Mode".
290:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
291:                 
292:                     // Enable the IrDA encoder/decoder.
293:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
294:                 
295:                     // Enables stopping of the UART operation to save power when the core has
296:                     // been put in idle mode.
297:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
298:                 
299:                     // Inverts the polarity of data sent on the transmit (TX) pin.
300:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
301:                 
302:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
303:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
304:                     // Note:  The address must still be set using UARTEnableAddressDetect
305:                     // to support IEEE-485 protocol.
306:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
307:                 
308:                 } UART_CONFIGURATION;
309:                 
310:                 
311:                 // *****************************************************************************
312:                 /* UART FIFO Modes
313:                 
314:                   Summary:
315:                     Supported FIFO modes for the UART module.
316:                 
317:                   Description:
318:                     This enumeration defines supported FIFO modes that determine when the Tx
319:                     and Rx interrupts will occur.
320:                 
321:                   Remarks:
322:                     These modes consist of two sets of mutially exclusive modes:
323:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
324:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
325:                 
326:                     The caller should not rely on the specific numbers assigned to any of these
327:                     values as they may change from one processor ot the next.
328:                 
329:                 */
330:                 
331:                 typedef enum
332:                 {
333:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
334:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
337:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
338:                 
339:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
340:                     // full (i.e. there is space available for more data)  This is the default.
341:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
342:                 
343:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
344:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
345:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
346:                 
347:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
348:                     // (three-quarter) full.
349:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
350:                 
351:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
352:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
353:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
354:                 
355:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
356:                     // data.
357:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
358:                 
359:                 } UART_FIFO_MODE;
360:                 
361:                 
362:                 // *****************************************************************************
363:                 /* UART Line Control Mode
364:                 
365:                   Summary:
366:                     UART line control mode.
367:                 
368:                   Description:
369:                     This data type defines the supported line control modes for the UART.
370:                 
371:                   Remarks:
372:                     Some of the line-control options are mutually exclusive:
373:                     * Only one of the "DATA_SIZE" options can be used at a time
374:                     * Only one of the "PARITY" options can be used at a time
375:                     * Only one of the "STOP_BITS" options can be used at a time
376:                 
377:                     The caller should not rely on the specific numbers assigned to any of these
378:                     values as they may change from one processor ot the next.
379:                 */
380:                 
381:                 typedef enum
382:                 {
383:                     // Sets the data transfer size to 8-bits per frame.
384:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
385:                 
386:                     // Sets the data transfer size to 9-bits per frame.
387:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
388:                 
389:                     // Enables parity bit generation for odd parity.
390:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
391:                 
392:                     // Enables parity bit generation for even parity.
393:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
394:                 
395:                     // Disables parity bit generation.
396:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
397:                 
398:                     // Enables generation of 2 stop bits per frame.
399:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
400:                 
401:                     // Enables generation of 1 stop bit per frame (default).
402:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
403:                 
404:                 } UART_LINE_CONTROL_MODE;
405:                 
406:                 
407:                 // *****************************************************************************
408:                 /* UART Line Status Flags
409:                 
410:                   Summary:
411:                     UART line-status bitmask flags.
412:                 
413:                   Description:
414:                     This enumeration defines the UART line-status bits.  These values are
415:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
416:                 
417:                   Remarks:
418:                     The caller should not rely on the specific numbers assigned to any of these
419:                     values as they may change from one processor ot the next.
420:                 */
421:                 
422:                 typedef enum
423:                 {
424:                     // The transmitter is able to accept data to transmit.
425:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
426:                 
427:                     // The transmitter is empty (no data is available to transmit).
428:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
429:                 
430:                     // The receiver is currently idle.
431:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
432:                 
433:                     // A received data parity error was detected.
434:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
435:                 
436:                     // Data was received that violated the framing protocol (the data word did
437:                     // not start or stop at the appropriate place).  Note:  A break condition
438:                     // will always indicate a framing error.
439:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
440:                 
441:                     // The UART has received more data than it can buffer.  Data has been lost.
442:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
443:                 
444:                     // UART data has been received and is avaiable in the FIFO.
445:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
446:                 
447:                 } UART_LINE_STATUS;
448:                 
449:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
450:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
451:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
452:                 
453:                 
454:                 
455:                 // *****************************************************************************
456:                 /* UART Data
457:                 
458:                   Summary:
459:                     UART data.
460:                 
461:                   Description:
462:                     This data type defines the supported data sizes for the UART.
463:                 */
464:                 
465:                 typedef union
466:                 {
467:                     // 8-bit data
468:                     struct
469:                     {
470:                         UINT16  data8bit    : 8;
471:                     };
472:                 
473:                     // 9-bit data
474:                     struct
475:                     {
476:                         UINT16  data9bit    : 9;
477:                     };
478:                 
479:                     UINT16 __data;
480:                 } UART_DATA;
481:                 
482:                 
483:                 // *****************************************************************************
484:                 // *****************************************************************************
485:                 // Section: UART Peripheral Library Interface Routines
486:                 // *****************************************************************************
487:                 // *****************************************************************************
488:                 
489:                 
490:                 /*******************************************************************************
491:                   Function:
492:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
493:                 
494:                   Summary:
495:                     Enables or disables the given UART module in the desired mode.
496:                 
497:                   Description:
498:                     This routine enables or disables the given UART module in the desired mode.
499:                 
500:                   Precondition:
501:                     The UART module should be appropriately configured before being enabled.
502:                 
503:                   Parameters:
504:                     id    - Identifies the desired UART module.
505:                 
506:                     mode  - Identifies the desired mode of UART operation.
507:                 
508:                   Returns:
509:                     None
510:                 
511:                   Example:
512:                     <code>
513:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
514:                     </code>
515:                 
516:                   Remarks:
517:                     Enabling UART transmissions will immediately cause a TX interrupt to
518:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
519:                     was pre-loaded with data.
520:                   *****************************************************************************/
521:                 
522:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
523:                 
524:                 
525:                 /*******************************************************************************
526:                   Function:
527:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
528:                 
529:                   Summary:
530:                     UART module configuration routine.
531:                 
532:                   Description:
533:                     This routine allows the caller to configure various features of the UART
534:                     module for desired operation.
535:                 
536:                   Precondition:
537:                     None
538:                 
539:                   Parameters:
540:                     id      - Identifies the desired UART module.
541:                 
542:                     flags   - Bit-wise OR of the desired module configuration settings.
543:                 
544:                   Returns:
545:                     None
546:                 
547:                   Example:
548:                     <code>
549:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
550:                     </code>
551:                 
552:                   Remarks:
553:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
554:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
555:                     of these values will result in a value that is not explicitly defined in
556:                     the enumeration.
557:                   *****************************************************************************/
558:                 
559:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
560:                 
561:                 
562:                 /*******************************************************************************
563:                   Function:
564:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
565:                 
566:                   Summary:
567:                     Controls UART module TX and RX FIFO operation.
568:                 
569:                   Description:
570:                     This routine allows the caller to configure when interrupts occur relative
571:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
572:                     or empty the FIFOs are).
573:                 
574:                   Precondition:
575:                     None
576:                 
577:                   Parameters:
578:                     id      - Identifies the desired UART module.
579:                 
580:                     mode    - Bit-wise OR of the desired FIFO mode values.
581:                 
582:                   Returns:
583:                     None
584:                 
585:                   Example:
586:                     <code>
587:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
588:                     </code>
589:                 
590:                   Remarks:
591:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
592:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
593:                     of these values will result in a value that is not explicitly defined in
594:                     the enumeration.
595:                   *****************************************************************************/
596:                 
597:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
598:                 
599:                 
600:                 /*******************************************************************************
601:                   Function:
602:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
603:                 
604:                   Summary:
605:                     Routine to set the UART module's desired data data rate.
606:                 
607:                   Description:
608:                     This routine allows the caller to set the desired data rate for the UART.
609:                 
610:                   Precondition:
611:                     The source clock's frequency must be operating at the frequency passed in the
612:                     "sourceClock" parameter.
613:                 
614:                   Parameters:
615:                     id          - Identifies the desired UART module.
616:                 
617:                     sourceClock - Frequency (Hz) of the source clock being provided to the
618:                                   UART module.
619:                 
620:                     dataRate     - Desired data rate (bits per second).
621:                 
622:                   Returns:
623:                     Actual bit rate selected
624:                 
625:                   Example:
626:                     <code>
627:                     #define PERIPHERAL_CLOCK    10000000
628:                     #define DESIRED_DATA_RATE   19200
629:                 
630:                     UINT32    actualDataRate;
631:                 
632:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
633:                     </code>
634:                 
635:                   Remarks:
636:                     Actual data rate selected may be slightly different than the data rate
637:                     requested due to truncation error.
638:                 
639:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
640:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
641:                     the maximum data rate is sourceClock/4.
642:                   *****************************************************************************/
643:                 
644:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
645:                 
646:                 
647:                 /*******************************************************************************
648:                   Function:
649:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
650:                 
651:                   Summary:
652:                     Routine to get the UART module's current data data rate.
653:                 
654:                   Description:
655:                     This routine allows the caller to get the current data rate for the UART module.
656:                 
657:                   Precondition:
658:                     The source clock's frequency must be operating at the frequency passed in the
659:                     "sourceClock" parameter.
660:                 
661:                   Parameters:
662:                     id          - Identifies the desired UART module.
663:                 
664:                     sourceClock - Frequency (Hz) of the source clock being provided to the
665:                                   UART module.
666:                 
667:                   Returns:
668:                     The UART's current data rate (bits per second).
669:                 
670:                   Example:
671:                     <code>
672:                     #define PERIPHERAL_CLOCK    10000000
673:                 
674:                     UINT32    currentDataRate;
675:                 
676:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
677:                     </code>
678:                 
679:                   Remarks:
680:                     The current (actual) data rate returned may be slightly different than bit
681:                     rate requested due to truncation error.
682:                   *****************************************************************************/
683:                 
684:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
685:                 
686:                 
687:                 /*******************************************************************************
688:                   Function:
689:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
690:                 
691:                   Summary:
692:                     Routine to set the UART module's desired line control parameters.
693:                 
694:                   Description:
695:                     This routine allows the caller to select the desired size of the UART data
696:                     frame, the generation of parity and framing parameters (collectively
697:                     referred to as the "line control" mode).
698:                 
699:                   Precondition:
700:                 
701:                   Parameters:
702:                     id      - Identifies the desired UART module.
703:                 
704:                     mode    - This is a bit-wise OR of the desired line control mode flags.
705:                 
706:                   Returns:
707:                     None
708:                 
709:                   Example:
710:                     <code>
711:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
712:                     </code>
713:                 
714:                   Remarks:
715:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
716:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
717:                     of these values will result in a value that is not explicitly defined in
718:                     the enumeration.
719:                   *****************************************************************************/
720:                 
721:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
722:                 
723:                 
724:                 /*******************************************************************************
725:                   Function:
726:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
727:                 
728:                   Summary:
729:                     Provides current UART line status.
730:                 
731:                   Description:
732:                     This routine allows the caller to get the current line status of the UART,
733:                     indicating the current state of the transmitter and receiver buffers, and
734:                     if any errors have occurred.
735:                 
736:                   Precondition:
737:                     None
738:                 
739:                   Parameters:
740:                     id      - Identifies the desired UART module.
741:                 
742:                   Returns:
743:                     A bit-wise OR of the current line status flags.
744:                 
745:                   Example:
746:                     <code>
747:                     UART_LINE_STATUS lineStatus;
748:                 
749:                     lineStatus = UARTGetLineStatus(UART1);
750:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
751:                     {
752:                         // Handle receiver error
753:                     }
754:                     </code>
755:                 
756:                   Remarks:
757:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
758:                     status flag.
759:                 
760:                     The receiver line status flags are only valid when data has been received
761:                     and for the data at the top of the RX FIFO.
762:                 
763:                     Note that the bitmask resulting from the bit-wise OR of these values will
764:                     result in a value that is not explicitly defined in the enumeration.
765:                   *****************************************************************************/
766:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
767:                 {
768:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
769:                 }
770:                 
771:                 
772:                 /*******************************************************************************
773:                   Function:
774:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
775:                 
776:                   Summary:
777:                     Routine to detect if the transmitter is ready to accept data to transmit.
778:                 
779:                   Description:
780:                     This routine determines if the transmitter is ready to accept more data to
781:                     be transmitted.
782:                 
783:                   Precondition:
784:                     The UART module should have been appropriately configured and enabled.
785:                 
786:                   Parameters:
787:                     id      - Identifies the desired UART module.
788:                 
789:                   Returns:
790:                     Boolean identifying whether or not the transmitter is ready:
791:                     * TRUE    - If the transmitter is ready to accept more data
792:                     * FALSE   - If the transmitter is not ready to accept more data
793:                 
794:                   Example:
795:                     <code>
796:                     unsigned char data;
797:                 
798:                     data = 'a';
799:                 
800:                     if (UARTTransmitterIsReady(UART1))
801:                     {
802:                         UARTSendDataByte(UART1, data);
803:                     }
804:                     </code>
805:                 
806:                   Remarks:
807:                   *****************************************************************************/
808:                 
809:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
810:                 {
811:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D011860  00042080   SLL A0, A0, 2
9D011864  3C029D02   LUI V0, -25342
9D011868  2442995C   ADDIU V0, V0, -26276
9D01186C  00821021   ADDU V0, A0, V0
9D011870  8C430000   LW V1, 0(V0)
9D011874  8C620010   LW V0, 16(V1)
9D011878  30420200   ANDI V0, V0, 512
9D0119C8  3C029D02   LUI V0, -25342
9D0119CC  2442995C   ADDIU V0, V0, -26276
9D0119D0  00621021   ADDU V0, V1, V0
9D0119D4  8C430000   LW V1, 0(V0)
9D0119D8  8C620010   LW V0, 16(V1)
9D0119DC  30420200   ANDI V0, V0, 512
812:                 }
813:                 
814:                 
815:                 /*******************************************************************************
816:                   Function:
817:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
818:                 
819:                   Summary:
820:                     Routine to send a byte of data.
821:                 
822:                   Description:
823:                     This routine allows the caller to send a byte of data.
824:                 
825:                   Precondition:
826:                     The UART should have been appropriately configured.  The configuration must
827:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
828:                     have been ready, although not necessarily enabled yet.
829:                 
830:                   Parameters:
831:                     id      - Identifies the desired UART module.
832:                 
833:                     data    - Data byte to be sent.
834:                 
835:                   Returns:
836:                     None
837:                 
838:                   Example:
839:                     <code>
840:                     unsigned char data;
841:                 
842:                     data = 'a';
843:                 
844:                     if (UARTTransmitterIsReady(UART1))
845:                     {
846:                         UARTSendDataByte(UART1, data);
847:                     }
848:                     </code>
849:                 
850:                   Remarks:
851:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
852:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
853:                     data.
854:                   *****************************************************************************/
855:                 
856:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
857:                 {
858:                     uartReg[id]->tx.reg = data;
9D011884  30A500FF   ANDI A1, A1, 255
9D011888  AC650020   SW A1, 32(V1)
9D01188C  03E00008   JR RA
9D011890  00000000   NOP
9D0119EC  30C600FF   ANDI A2, A2, 255
9D0119F0  AC660020   SW A2, 32(V1)
859:                 }
860:                 
861:                 
862:                 /*******************************************************************************
863:                   Function:
864:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
865:                 
866:                   Summary:
867:                     Routine to send data through the UART.
868:                 
869:                   Description:
870:                     This routine allows the caller to send data of any permitted size through
871:                     the UART.
872:                 
873:                   Precondition:
874:                     The UART module should have been appropriately configured.  The configuration must
875:                     have been for desired data size.  The transmitter must have been ready,
876:                     although not necessarily enabled yet.
877:                 
878:                   Parameters:
879:                     id      - Identifies the desired UART module.
880:                 
881:                     data    - Data to be sent.
882:                 
883:                   Returns:
884:                     None
885:                 
886:                   Example:
887:                     <code>
888:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
889:                 
890:                     if (UARTTransmitterIsReady(UART1))
891:                     {
892:                         UARTSendData(UART1, data);
893:                     }
894:                     </code>
895:                 
896:                   Remarks:
897:                     Size of the data word size depends on the current configuration (see
898:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
899:                   *****************************************************************************/
900:                 
901:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
902:                 {
903:                     uartReg[id]->tx.reg = data.__data;
904:                 }
905:                 
906:                 /*******************************************************************************
907:                   Function:
908:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
909:                 
910:                   Summary:
911:                     Routine to detect if the UART module has finshed transmitting the most recent
912:                     data.
913:                 
914:                   Description:
915:                     This routine determines if the transmitter has finished sending all
916:                     available data.
917:                 
918:                   Preconditions:
919:                     The UART module should have been appropriately configured and enabled and data
920:                     sent to the UART TX buffer.
921:                 
922:                   Parameters:
923:                     id      - Identifies the desired UART module.
924:                 
925:                   Returns:
926:                     Boolean identifying if the transmission has completed:
927:                     * TRUE    - If the transmitter has completed sending the data
928:                     * FALSE   - If the transmitter is still busy sending the data
929:                 
930:                   Example:
931:                     <code>
932:                     if (UARTTransmissionHasCompleted(UART1))
933:                     {
934:                         // Perform any tasks necessary when all data has been sent
935:                     }
936:                     </code>
937:                 
938:                   Remarks:
939:                   *****************************************************************************/
940:                 
941:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
942:                 {
943:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
9D011A00  00042080   SLL A0, A0, 2
9D011A04  3C029D02   LUI V0, -25342
9D011A08  2442995C   ADDIU V0, V0, -26276
9D011A0C  00821021   ADDU V0, A0, V0
9D011A10  8C430000   LW V1, 0(V0)
9D011A14  8C620010   LW V0, 16(V1)
9D011A18  30420100   ANDI V0, V0, 256
944:                 }
945:                 
946:                 
947:                 /*******************************************************************************
948:                   Function:
949:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
950:                 
951:                   Summary:
952:                     Routine to detect if the receiver has data available.
953:                 
954:                   Description:
955:                     This routine determines if the receiver has data available to be read.
956:                 
957:                   Precondition:
958:                     The UART module must have been configured appropriately and enabled. A complete
959:                     data frame must have been sent to the UART before it will return a TRUE.
960:                 
961:                   Parameters:
962:                     id      - Identifies the desired UART module.
963:                 
964:                   Returns:
965:                     Boolean identifying whether or not data is available:
966:                     * TRUE    - If the receiver has data available
967:                     * FALSE   - If the receiver does not have data availble
968:                 
969:                   Example:
970:                     <code>
971:                     UART_DATA data;
972:                 
973:                     if (UARTReceivedDataIsAvailable(UART1))
974:                     {
975:                         data = UARTGetData(UART1);
976:                     }
977:                     </code>
978:                 
979:                   Remarks:
980:                     This routine provides the same information as the UART_DATA_READY line
981:                     status flag.
982:                   *****************************************************************************/
983:                 
984:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
985:                 {
986:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D01182C  00042080   SLL A0, A0, 2
9D011830  3C029D02   LUI V0, -25342
9D011834  2442995C   ADDIU V0, V0, -26276
9D011838  00822021   ADDU A0, A0, V0
9D01183C  8C830000   LW V1, 0(A0)
9D011840  8C640010   LW A0, 16(V1)
9D011844  30840001   ANDI A0, A0, 1
9D011930  00048880   SLL S1, A0, 2
9D011934  3C029D02   LUI V0, -25342
9D011938  2442995C   ADDIU V0, V0, -26276
9D01193C  02228821   ADDU S1, S1, V0
9D011940  8E230000   LW V1, 0(S1)
9D011944  8C620010   LW V0, 16(V1)
9D011948  30420001   ANDI V0, V0, 1
9D011968  3C029D02   LUI V0, -25342
9D01196C  2442995C   ADDIU V0, V0, -26276
9D011978  8C430010   LW V1, 16(V0)
9D01197C  30630001   ANDI V1, V1, 1
9D011A60  00048080   SLL S0, A0, 2
9D011A64  3C029D02   LUI V0, -25342
9D011A68  2442995C   ADDIU V0, V0, -26276
9D011A6C  02028021   ADDU S0, S0, V0
9D011A78  8C670010   LW A3, 16(V1)
9D011A7C  30E70001   ANDI A3, A3, 1
9D011B50  00042080   SLL A0, A0, 2
9D011B54  3C029D02   LUI V0, -25342
9D011B58  2442995C   ADDIU V0, V0, -26276
9D011B5C  00822021   ADDU A0, A0, V0
9D011B60  8C830000   LW V1, 0(A0)
9D011B64  8C640010   LW A0, 16(V1)
9D011B68  30840001   ANDI A0, A0, 1
987:                 }
988:                 
989:                 
990:                 /*******************************************************************************
991:                   Function:
992:                     BYTE UARTGetDataByte ( UART_MODULE id )
993:                 
994:                   Summary:
995:                     Routine to get a byte of data received by the UART.
996:                 
997:                   Description:
998:                     This routine allows the caller to read a byte of data received by the UART.
999:                 
1000:                  Precondition:
1001:                    The UART module must have been appropriately configured, the configuration must
1002:                    have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
1003:                    been enabled.  Also, a complete data frame must have been received by the UART.
1004:                
1005:                  Parameters:
1006:                    id      - Identifies the desired UART module.
1007:                
1008:                  Returns:
1009:                    A byte of data received by the UART.
1010:                
1011:                  Example:
1012:                    <code>
1013:                    unsigned char data;
1014:                
1015:                    if (UARTReceivedDataIsAvailable(UART1))
1016:                    {
1017:                        data = UARTGetDataByte(UART1);
1018:                    }
1019:                    </code>
1020:                
1021:                  Remarks:
1022:                    This routine is optimized for receiving 8-bit data through the UART.
1023:                  *****************************************************************************/
1024:                
1025:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1026:                {
1027:                    return (BYTE)uartReg[id]->rx.reg;
9D011850  8C620030   LW V0, 48(V1)
9D011954  8C620030   LW V0, 48(V1)
9D011988  8C420030   LW V0, 48(V0)
9D011A88  8C650030   LW A1, 48(V1)
9D011B74  8C620030   LW V0, 48(V1)
1028:                }
1029:                
1030:                
1031:                /*******************************************************************************
1032:                  Function:
1033:                    UART_DATA UARTGetData ( UART_MODULE id )
1034:                
1035:                  Summary:
1036:                    Routine to get data received by the UART.
1037:                
1038:                  Description:
1039:                    This routine allows the caller to read a data word received by the UART.
1040:                
1041:                  Precondition:
1042:                    The module must have been appropriately configured, the UART module must have been
1043:                    enabled, and a complete data frame must have been received by the UART.
1044:                
1045:                  Parameters:
1046:                    id      - Identifies the desired UART module.
1047:                
1048:                  Returns:
1049:                    Data received by the UART.
1050:                
1051:                  Example:
1052:                    <code>
1053:                    UART_DATA data;
1054:                
1055:                    if (UARTReceivedDataIsAvailable(UART1))
1056:                    {
1057:                        data = UARTGetData(UART1);
1058:                    }
1059:                    </code>
1060:                
1061:                  Remarks:
1062:                    Size of the data word depends on the current configuration (see
1063:                    UARTSetLineControl).
1064:                  *****************************************************************************/
1065:                
1066:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1067:                {
1068:                    UART_DATA data;
1069:                
1070:                    data.__data = uartReg[id]->rx.reg;
1071:                
1072:                    return data;
1073:                }
1074:                
1075:                
1076:                /*******************************************************************************
1077:                  Function:
1078:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1079:                
1080:                  Summary:
1081:                    Routine to program the address for which the UART module may watch.
1082:                
1083:                  Description:
1084:                    This routine programs the 8-bit address for which the module may watch.
1085:                
1086:                  Precondition:
1087:                    None
1088:                
1089:                  Parameters:
1090:                    id      - Identifies the desired UART module.
1091:                
1092:                    address - 8-bit address for which the module will watch.
1093:                
1094:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1095:                              * TRUE - Enable address watch mode
1096:                              * FALSE - Disable address watch mode
1097:                
1098:                  Returns:
1099:                    None.
1100:                
1101:                  Example:
1102:                    <code>
1103:                    #define SLAVE_ADDRESS  0x42
1104:                
1105:                    UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1106:                    </code>
1107:                
1108:                  Remarks:
1109:                    The module can be placed into a mode where it will ignore all data received
1110:                    until it identifies the programmed adress.  After the programmed address
1111:                    has been identified, it will begin receiving data normally.  This mode is
1112:                    particularly useful for supporting the IEEE-485 protocol.
1113:                  *****************************************************************************/
1114:                
1115:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1116:                
1117:                
1118:                /*******************************************************************************
1119:                  Function:
1120:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1121:                
1122:                  Summary:
1123:                    Routine to enable or disable recognition of the programmed address byte.
1124:                
1125:                  Description:
1126:                    This routine can enable or disable the "address watch" mode.  In this mode,
1127:                    the UART module will ignore all data until it recognizes the programmed address.
1128:                
1129:                  Precondition:
1130:                    UART should have already been enabled and set with watch address.
1131:                
1132:                  Parameters:
1133:                    id      - Identifies the desired UART module.
1134:                
1135:                    watch   - Determines if the "address watch" mode will be enabled or
1136:                              disabled.
1137:                              * TRUE - Enable address watch mode
1138:                              * FALSE - Disable address watch mode
1139:                
1140:                  Returns:
1141:                    None.
1142:                
1143:                  Example:
1144:                    <code>
1145:                    #define SLAVE_ADDRESS 0x42
1146:                
1147:                    // Set the address, but don't enable the watch until later,
1148:                    // UART continues to receive data normally
1149:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1150:                
1151:                    // ...
1152:                
1153:                    // Now begin to ignore all UART traffic until we are addressed
1154:                    UARTWatchForAddress(UART1, TRUE);
1155:                    </code>
1156:                
1157:                  Remarks:
1158:                    The UART module can be placed into a mode where it will ignore all data received
1159:                    until it identifies the programmed address.  After the programmed address
1160:                    has been identified, it will begin receiving data normally.  This mode is
1161:                    particularly useful for supporting the IEEE-485 protocol.
1162:                  *****************************************************************************/
1163:                
1164:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1165:                
1166:                
1167:                /*******************************************************************************
1168:                  Function:
1169:                    void UARTSendBreak ( UART_MODULE id )
1170:                
1171:                  Summary:
1172:                    Routine to send a break signal from the UART.
1173:                
1174:                  Description:
1175:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1176:                
1177:                  Precondition:
1178:                    The UART should have been appropriately configured.  The transmitter should
1179:                    be idle, although not necessarily enabled yet.
1180:                
1181:                  Parameters:
1182:                    id      - Identifies the desired UART module.
1183:                
1184:                  Returns:
1185:                    None
1186:                
1187:                  Example:
1188:                    <code>
1189:                    if (UARTTransmissionHasCompleted(UART1))
1190:                    {
1191:                        UARTSendBreak(UART1);
1192:                    }
1193:                    </code>
1194:                
1195:                  Remarks:
1196:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1197:                    data may be pre-loaded into the FIFO and it will be send immediately
1198:                    following the break signal.
1199:                  *****************************************************************************/
1200:                
1201:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1202:                {
1203:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1204:                }
1205:                
1206:                
1207:                /*******************************************************************************
1208:                  Function:
1209:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1210:                
1211:                  Summary:
1212:                    Routine to automatically determine the data rate (bits-per-second) of an
1213:                    external transmitter to the UART.
1214:                
1215:                  Description:
1216:                    This routine initiates the process of automatically determining the data
1217:                    rate (bits-per-second) of an external transmitter to the UART.
1218:                
1219:                  Precondition:
1220:                    The UART should have been appropriately configured.  The transmitter should
1221:                    be idle, although not necessarily enabled yet.
1222:                
1223:                  Parameters:
1224:                    id      - Identifies the desired UART module.
1225:                
1226:                  Returns:
1227:                    None
1228:                
1229:                  Example:
1230:                    <code>
1231:                    // See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1232:                    // methods to detect a Break.
1233:                
1234:                    if (breakDetected && useAutoRateDetect)
1235:                    {
1236:                        UARTStartAutoDataRateDetect (UART1);
1237:                    }
1238:                    </code>
1239:                
1240:                  Remarks:
1241:                    The UART module begins measuring the data rate beginning at the next start
1242:                    bit.  The external transmitter should send an alternating pattern (0x55)
1243:                    for the byte to be measured for an effective rate detection.  To ensure
1244:                    an effective measurement sequence, this can be done immediately following
1245:                    a break reception. It is important that this UART module is not
1246:                    transmitting data while it is trying to detect RX baud rate, see the
1247:                    "PIC32 Family Reference Manual, Sect. 21 UART".
1248:                  *****************************************************************************/
1249:                
1250:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1251:                {
1252:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1253:                }
1254:                
1255:                
1256:                
1257:                /*******************************************************************************
1258:                  Function:
1259:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1260:                
1261:                  Summary:
1262:                    Routine to identify when automatic data rate detection has completed.
1263:                
1264:                  Description:
1265:                    This routine checks to see if automatic data rate detection has completed.
1266:                
1267:                  Precondition:
1268:                    Automatic rate detection should have been previously started.
1269:                
1270:                  Parameters:
1271:                    id      - Identifies the desired UART module.
1272:                
1273:                  Returns:
1274:                    * TRUE    - Indicates that automatic rate detection has completed.
1275:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1276:                
1277:                  Example:
1278:                    <code>
1279:                    #define PERIPHERAL_CLOCK    10000000
1280:                
1281:                    UINT32 currentRate;
1282:                
1283:                    if (UARTDataRateDetected(UART1))
1284:                    {
1285:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1286:                    }
1287:                    </code>
1288:                
1289:                  Remarks:
1290:                    This routine returns FALSE after automatic rate detection
1291:                    has been started but before rate is detectdd, it will return TRUE
1292:                    at any other time.
1293:                  *****************************************************************************/
1294:                
1295:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1296:                {
1297:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1298:                }
1299:                
1300:                #ifdef __cplusplus
1301:                  }
1302:                #endif
1303:                
1304:                #endif // _UART_h_
1305:                
---  /opt/microchip/xc32/v1.44/pic32mx/include/peripheral/system.h  -------------------------------------
1:                   /********************************************************************
2:                   
3:                       System Library Interface Definition
4:                   
5:                       Summary:
6:                           This file contains the interface definition for the System
7:                           peripheral library.
8:                   
9:                       Description:
10:                          This library provides functions for configuring the peripheral
11:                          clock, cache settings, and wait states.  For details on the
12:                          register and bit settings used by these functions, refer to the
13:                          PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:        System.h
20:                   * Dependencies:
21:                   * Processor:       PIC32
22:                   * Hardware:        N/A
23:                   * Assembler:       N/A
24:                   * Linker:          N/A
25:                   * Company:         Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the “Company”) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company’s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:
92:                      unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                  
94:                   Description:
95:                      The function sets the PB divider to the optimum value.
96:                  
97:                   PreCondition:
98:                      None
99:                  
100:                  Parameters:
101:                     sys_clock - system clock in Hz
102:                 
103:                  Returns:
104:                     the PB clock frequency in Hz
105:                 
106:                  Side Effects:
107:                     The PB clock may be changed
108:                 
109:                  Overview:
110:                     The function sets the PB divider to the optimum value.
111:                 
112:                  Remarks:
113:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                 
116:                  Example:
117:                     <code>
118:                     SYSTEMConfigPB(72000000);
119:                     </code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
131:                         pb_clock >>= 1;
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:
146:                     void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                 
148:                   Description:
149:                     The function sets the Flash Wait states to the optimum value.
150:                 
151:                   PreCondition:
152:                     None
153:                 
154:                   Parameters:
155:                     sys_clock - system clock in Hz
156:                 
157:                   Returns:
158:                     None
159:                 
160:                   Side Effects:
161:                     The Wait States may be changed
162:                 
163:                   Remarks:
164:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                 
167:                   Example:
168:                     <code>
169:                     SYSTEMConfigWaitStates(72000000);
170:                     </code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:
197:                         unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                 
199:                   Description:
200:                     The function sets the PB divider and the Flash Wait states to the optimum value.
201:                 
202:                   PreCondition:
203:                     None
204:                 
205:                   Parameters:
206:                     sys_clock - system clock in Hz
207:                 
208:                   Returns:
209:                     the PB clock frequency in Hz
210:                 
211:                   Side Effects:
212:                     The PB clock and wait states may be changed
213:                 
214:                   Remarks:
215:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                 
218:                   Example:
219:                     <code>
220:                     SYSTEMConfigWaitStatesAndPB(72000000);
221:                     </code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
246:                     mCheConfigure(wait_states);
247:                     INTRestoreInterrupts(int_status);
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:
255:                     unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                 
257:                   Description:
258:                     The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 
261:                   PreCondition:
262:                     None
263:                 
264:                   Parameters:
265:                     sys_clock - system clock in Hz
266:                 
267:                   Output:
268:                     the PB clock frequency in Hz
269:                 
270:                   Side Effects:
271:                     Sets the PB and Flash Wait states
272:                 
273:                   Remarks:
274:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                 
277:                   Example:
278:                     <code>
279:                     SYSTEMConfigPerformance(72000000);
280:                     </code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:
311:                     unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                 
313:                   Description:
314:                     The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value,
315:                     based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 
318:                   PreCondition:
319:                     None
320:                 
321:                   Parameters:
322:                     sys_clock - system clock frequency in Hz
323:                     flags -
324:                         *    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                 
329:                   Returns:
330:                     the PB clock frequency in Hz
331:                 
332:                   Side Effects:
333:                     Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                 
336:                 
337:                   Remarks:
338:                     The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                 
341:                   Example:
342:                     <code>
343:                     SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                     </code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
9D00DF14  0F406655   JAL INTDisableInterrupts
9D00DF18  AFB00010   SW S0, 16(SP)
355:                 
356:                     mBMXDisableDRMWaitState();
9D00DF1C  24100040   ADDIU S0, ZERO, 64
9D00DF20  3C03BF88   LUI V1, -16504
9D00DF24  AC702004   SW S0, 8196(V1)
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
9D00DF28  3C03BF81   LUI V1, -16511
9D00DF2C  8C63F000   LW V1, -4096(V1)
381:                 
382:                     INTRestoreInterrupts(int_status);
9D00DF30  0F406624   JAL INTRestoreInterrupts
9D00DF34  00402021   ADDU A0, V0, ZERO
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  /home/jacques/github/vpc-32vga/vpcBASIC/vm.S  ------------------------------------------------------
                                                  1:     /*  Nom: vm.S
                                                  2:      *  Auteur: Jacques Deschênes
                                                  3:      *  Description:
                                                  4:      *      machine viruelle à piles qui exécute du bytecode.
                                                  5:      *      le programme utilisant la VM doit l'appellé en utilisant le prototype de
                                                  6:      *      fonction suivant: void StackVM( char *ip, int* user);
                                                  7:      *         ip pointe vers le bytecode à exécuter
                                                  8:      *         user pointe vers un tableau de variables utilisé par le programme.
                                                  9:      *  rev: 2017-08-01
                                                  10:     */
                                                  11:    
                                                  12:    #define _ASM_CODE_
                                                  13:        
                                                  14:    #include <p32xxxx.h>
                                                  15:    //#include "vm.h"
                                                  16:    
                                                  17:    .extern sys_ticks
                                                  18:    .extern comm_channel    
                                                  19:    .extern put_char
                                                  20:    .extern get_key
                                                  21:    .extern wait_key
                                                  22:    .extern print_int
                                                  23:    .extern print_hex
                                                  24:    .extern print  
                                                  25:    .extern readline    
                                                  26:    .extern print_float
                                                  27:    .extern rnd
                                                  28:    //math fonctions
                                                  29:    .extern sinf
                                                  30:    .extern cosf
                                                  31:    .extern tanf
                                                  32:    .extern acosf
                                                  33:    .extern asinf
                                                  34:    .extern atanf
                                                  35:    .extern sqrtf
                                                  36:    .extern fabsf
                                                  37:    .extern powf
                                                  38:    .extern expf
                                                  39:    .extern logf
                                                  40:    .extern log10f
                                                  41:    .extern rintf
                                                  42:    .extern floorf
                                                  43:    .extern ceilf
                                                  44:    
                                                  45:    
                                                  46:    #define _getch get_key
                                                  47:    #define _putch put_char
                                                  48:    #define _print print
                                                  49:    #define _readln readline
                                                  50:    #define _key   wait_key
                                                  51:    
                                                  52:    
                                                  53:    /*************** macros *************/
                                                  54:    
                                                  55:    .macro _tpush
                                                  56:    addiu dp,dp, CELL_SIZE
                                                  57:    sw T, 0(dp)
                                                  58:    .endm
                                                  59:    
                                                  60:    .macro _tpop
                                                  61:    lw T, 0(dp)
                                                  62:    addiu dp,dp,-CELL_SIZE
                                                  63:    .endm
                                                  64:    
                                                  65:    .macro _rpush
                                                  66:    addiu rp,rp,CELL_SIZE
                                                  67:    sw R, 0(rp)
                                                  68:    .endm
                                                  69:    
                                                  70:    .macro _rpop
                                                  71:    lw R, 0(rp)
                                                  72:    addiu rp,rp,-CELL_SIZE
                                                  73:    .endm
                                                  74:    
                                                  75:    .macro _inc_ip
                                                  76:    addiu ip,ip,1
                                                  77:    .endm
                                                  78:    
                                                  79:    .macro _back_jump
                                                  80:        lbu t0,0(ip)
                                                  81:        b next
                                                  82:        sub ip,ip,t0
                                                  83:    .endm
                                                  84:        
                                                  85:    .macro _fore_jump
                                                  86:        lbu t0,0(ip)
                                                  87:        b next
                                                  88:        add ip,ip,t0
                                                  89:    .endm
                                                  90:        
                                                  91:    /* utilisation des regitres MIPS */
                                                  92:    ip=s0  /* pointeur d'instruction VM */
                                                  93:    dp=s1  /* pointeur pile de données */
                                                  94:    rp=s2  /* pointeur pile de contrôle */
                                                  95:    w=s3  /* pointeur de travail */
                                                  96:    T=s4  /* sommet de la pile des données */
                                                  97:    R=s5  /* sommet de la pile des retours */
                                                  98:    U=s6  /* pointeur variables utilisateur */
                                                  99:    L=s7  /* limite boucle do...loop */
                                                  100:   I=s8  /* compteur boucle do...looop */ 
                                                  101:   
                                                  102:   STDIO=1
                                                  103:   
                                                  104:   RAM_SEG=0xA000
                                                  105:   CODE_SEG=0x9D00
                                                  106:   SFR_SEG=0xBF80
                                                  107:   CFG_SEG=0xBFC0
                                                  108:       
                                                  109:   CELL_SIZE=4
                                                  110:       
                                                  111:   DSTACK_SIZE=80
                                                  112:   RSTACK_SIZE=64
                                                  113:   TIB_SIZE=80
                                                  114:   PAD_SIZE=80
                                                  115:       
                                                  116:   SFR_CLEAR=4
                                                  117:   SFR_SET=8
                                                  118:   SFR_INV=12
                                                  119:   
                                                  120:       
                                                  121:   .bss
                                                  122:   
                                                  123:   // piles
                                                  124:   dstack: .space DSTACK_SIZE
                                                  125:   rstack: .space RSTACK_SIZE
                                                  126:   
                                                  127:   .text
                                                  128:   .align 2, 0xff
                                                  129:   .set noreorder
                                                  130:   .set macro
                                                  131:   
                                                  132:   
                                                  133:   .global StackVM
                                                  134:   .ent StackVM
                                                  135:   StackVM:  // VM initialization
9D00C340  27BDFFD8   ADDIU SP, SP, -40            136:       addiu sp, sp, -40 // save registers
9D00C344  AFBF0024   SW RA, 36(SP)                137:       sw  ra, 36(sp)
9D00C348  AFB00000   SW S0, 0(SP)                 138:       sw  s0, 0(sp)
9D00C34C  AFB10004   SW S1, 4(SP)                 139:       sw  s1, 4(sp)
9D00C350  AFB20008   SW S2, 8(SP)                 140:       sw  s2, 8(sp)
9D00C354  AFB3000C   SW S3, 12(SP)                141:       sw  s3,12(sp)
9D00C358  AFB40010   SW S4, 16(SP)                142:       sw  s4,16(sp)
9D00C35C  AFB50014   SW S5, 20(SP)                143:       sw  s5,20(sp)
9D00C360  AFB60018   SW S6, 24(SP)                144:       sw  s6,24(sp)
9D00C364  AFB7001C   SW S7, 28(SP)                145:       sw  s7,28(sp)
9D00C368  AFBE0020   SW S8, 32(SP)                146:       sw  s8,32(sp)
9D00C36C  00808021   ADDU S0, A0, ZERO            147:       move ip, a0   // pointeur bytecode à exécuter
9D00C370  00A0B021   ADDU S6, A1, ZERO            148:       move U, a1    // pointeur tableau de variables
9D00C374  3C13A000   LUI S3, -24576               149:       lui w, RAM_SEG
9D00C378  367147A8   ORI S1, S3, 18344            150:       ori dp, w, dstack
9D00C37C  367247F8   ORI S2, S3, 18424            151:       ori rp, w, rstack
                                                  152:       
                                                  153:   // VM instruction loop
                                                  154:   next:
9D00C380  92080000   LBU T0, 0(S0)                155:       lbu   t0, 0(ip)
9D00C384  00084080   SLL T0, T0, 2                156:       sll   t0, t0, 2   
9D00C388  3C099D01   LUI T1, -25343               157:       la t1,opcodes_table
9D00C390  01284821   ADDU T1, T1, T0              158:       addu t1,t1,t0
9D00C394  8D290000   LW T1, 0(T1)                 159:       lw    t1, 0(t1)
9D00C398  01200008   JR T1                        160:       jr    t1
9D00C39C  26100001   ADDIU S0, S0, 1              161:       _inc_ip
                                                  162:   
                                                  163:   bye:   // 'bye' ( -- ) exit virtual machine
9D00C3A0  1000021C   BEQ ZERO, ZERO, 0x9D00CC14   164:       b exit_vm
9D00C3A4  02801021   ADDU V0, S4, ZERO            165:       move v0,T  // return T
                                                  166:   
                                                  167:   qrx: // '?key' ( -- ch -1 | 0 )
9D00C3A8  3C04A000   LUI A0, -24576               168:       la a0,comm_channel
9D00C3B0  90840000   LBU A0, 0(A0)                169:       lbu a0,0(a0)
9D00C3B4  0F402D77   JAL 0x9D00B5DC               170:       jal _getch
9D00C3B8  34040001   ORI A0, ZERO, 1              171:       ori a0,zero,STDIO
9D00C3BC  26310004   ADDIU S1, S1, 4              172:       _tpush
9D00C3C4  04400005   BLTZ V0, 0x9D00C3DC          173:       bltz v0, qrx_exit
9D00C3C8  24480001   ADDIU T0, V0, 1              174:       addiu t0,v0,1
9D00C3CC  0040A021   ADDU S4, V0, ZERO            175:       move T, v0
9D00C3D0  2408FFFF   ADDIU T0, ZERO, -1           176:       addiu t0,zero,-1
9D00C3D4  26310004   ADDIU S1, S1, 4              177:       _tpush
                                                  178:   qrx_exit:
9D00C3DC  1000FFE8   BEQ ZERO, ZERO, 0x9D00C380   179:       b next
9D00C3E0  0100A021   ADDU S4, T0, ZERO            180:       move T, t0
                                                  181:   
                                                  182:   emit:   // 'emit' ( ch -- ) transmet charactère au terminal
9D00C3E4  3C04A000   LUI A0, -24576               183:       la a0,comm_channel
9D00C3EC  90840000   LBU A0, 0(A0)                184:       lbu a0,0(a0)
9D00C3F0  02802821   ADDU A1, S4, ZERO            185:       move  a1, T
9D00C3F4  8E340000   LW S4, 0(S1)                 186:       lw T, 0(dp)
9D00C3F8  0F402B85   JAL 0x9D00AE14               187:       jal _putch
9D00C3FC  2631FFFC   ADDIU S1, S1, -4             188:       addiu dp,dp,-CELL_SIZE
9D00C400  1000FFDF   BEQ ZERO, ZERO, 0x9D00C380   189:       b next
9D00C404  00000000   NOP                          190:       nop
                                                  191:   
                                                  192:   cr: // 'cr' ( -- ) émet un carriage return line feed
9D00C408  3C04A000   LUI A0, -24576               193:       la a0,comm_channel
9D00C410  90840000   LBU A0, 0(A0)                194:       lbu a0,0(a0)
9D00C414  2405000D   ADDIU A1, ZERO, 13           195:       addiu a1,zero,13
9D00C418  0F402B85   JAL 0x9D00AE14               196:       jal _putch
9D00C41C  00000000   NOP                          197:       nop
9D00C420  1000FFD7   BEQ ZERO, ZERO, 0x9D00C380   198:       b next
9D00C424  00000000   NOP                          199:       nop
                                                  200:       
                                                  201:       
                                                  202:   lit:    // 'lit' ( -- n) empile un entier
9D00C428  26310004   ADDIU S1, S1, 4              203:       _tpush
9D00C430  8A140003   LWL S4, 3(S0)                204:       ulw T,0(ip)
9D00C438  1000FFD1   BEQ ZERO, ZERO, 0x9D00C380   205:       b next
9D00C43C  26100004   ADDIU S0, S0, 4              206:       addiu ip,ip,CELL_SIZE
                                                  207:   
                                                  208:   clit:   // 'clit' ( -- byte ) empile un octet signe étendu sur 32 bits
9D00C440  26310004   ADDIU S1, S1, 4              209:       _tpush
9D00C448  82140000   LB S4, 0(S0)                 210:       lb T, 0(ip)
9D00C44C  1000FFCC   BEQ ZERO, ZERO, 0x9D00C380   211:       b next
9D00C450  26100001   ADDIU S0, S0, 1              212:       _inc_ip
                                                  213:   
                                                  214:   wlit:  // 'wlit' ( -- w16  ) empile un mot de 16 bits
9D00C454  26310004   ADDIU S1, S1, 4              215:       _tpush
9D00C45C  9A140000   LWR S4, 0(S0)                216:       lwr T,0(ip)
9D00C460  3294FFFF   ANDI S4, S4, -1              217:       andi T,T,0xffff
9D00C464  1000FFC6   BEQ ZERO, ZERO, 0x9D00C380   218:       b next
9D00C468  26100002   ADDIU S0, S0, 2              219:       addiu ip,ip,2
                                                  220:   
                                                  221:   docol:   // 'call' (R: -- addr_ret ) appelle mot de haut niveau
9D00C46C  8A080003   LWL T0, 3(S0)                222:       ulw t0,0(ip)
9D00C474  26520004   ADDIU S2, S2, 4              223:       _rpush
9D00C47C  0200A821   ADDU S5, S0, ZERO            224:       move R, ip
9D00C480  1000FFBF   BEQ ZERO, ZERO, 0x9D00C380   225:       b next
9D00C484  01008021   ADDU S0, T0, ZERO            226:       move ip, t0
                                                  227:   
                                                  228:   //rcall:  # 'rcall' (R: -- addr_ret ) appelle sous-routine VM en mémoire RAM
                                                  229:   //    lui t2, RAM_SEG
                                                  230:   //    b fcall_1
                                                  231:   //    lbu t0, 0(ip)
                                                  232:   
                                                  233:   exit:  // ';' (R: addr_ret -- ) sortie d'un mot de haut niveau
9D00C488  02A08021   ADDU S0, S5, ZERO            234:       move ip, R
9D00C48C  8E550000   LW S5, 0(S2)                 235:       lw R, 0(rp)
9D00C490  1000FFBB   BEQ ZERO, ZERO, 0x9D00C380   236:       b next
9D00C494  2652FFFC   ADDIU S2, S2, -4             237:       addiu rp,rp, -CELL_SIZE
                                                  238:   
                                                  239:   bra:   // 'branch' ( -- ) branchement incondionnnel (adresse relative +127,-128)
9D00C498  82080000   LB T0, 0(S0)                 240:       lb t0, 0(ip)
                                                  241:   //    _inc_ip
9D00C49C  1000FFB8   BEQ ZERO, ZERO, 0x9D00C380   242:       b next
9D00C4A0  02088021   ADDU S0, S0, T0              243:       addu ip, ip, t0  // branchement relatif à ip, intervale -128 à +127
                                                  244:   
                                                  245:   qbra: // '?bra' ( t|f -- ) branche si sommet pile est vrai (tos!=0)
9D00C4A4  02804021   ADDU T0, S4, ZERO            246:       move t0, T
9D00C4A8  8E340000   LW S4, 0(S1)                 247:       _tpop
9D00C4B0  1100FFB3   BEQ T0, ZERO, 0x9D00C380     248:       beqz t0, next
9D00C4B4  26100001   ADDIU S0, S0, 1              249:       _inc_ip
9D00C4B8  8208FFFF   LB T0, -1(S0)                250:       lb t0, -1(ip)
9D00C4BC  1000FFB0   BEQ ZERO, ZERO, 0x9D00C380   251:       b next
9D00C4C0  02088021   ADDU S0, S0, T0              252:       addu ip,ip,t0
                                                  253:   
                                                  254:   qbraz:  // '?braz' ( t|f -- ) branche si sommet pile est faux (tos==0)
9D00C4C4  02804021   ADDU T0, S4, ZERO            255:       move t0, T
9D00C4C8  8E340000   LW S4, 0(S1)                 256:       _tpop
9D00C4D0  1500FFAB   BNE T0, ZERO, 0x9D00C380     257:       bne t0, zero, next
9D00C4D4  26100001   ADDIU S0, S0, 1              258:       _inc_ip
9D00C4D8  8208FFFF   LB T0, -1(S0)                259:       lb t0, -1(ip)
9D00C4DC  1000FFA8   BEQ ZERO, ZERO, 0x9D00C380   260:       b next
9D00C4E0  02088021   ADDU S0, S0, T0              261:       addu ip,ip,t0
                                                  262:   
                                                  263:   exec:  // 'exec' ( addr -- ) appelle sous-routine à partir de la pile
9D00C4E4  26520004   ADDIU S2, S2, 4              264:       _rpush
9D00C4EC  0200A821   ADDU S5, S0, ZERO            265:       move R, ip
9D00C4F0  02808021   ADDU S0, S4, ZERO            266:       move  ip, T
9D00C4F4  8E340000   LW S4, 0(S1)                 267:       lw T,0(dp)
9D00C4F8  1000FFA1   BEQ ZERO, ZERO, 0x9D00C380   268:       b next
9D00C4FC  2631FFFC   ADDIU S1, S1, -4             269:       addiu dp,dp,-CELL_SIZE
                                                  270:   
                                                  271:   store:  // '!' ( n addr -- )  variable = n
9D00C500  8E280000   LW T0, 0(S1)                 272:       lw t0, 0(dp)
9D00C504  AA880003   SWL T0, 3(S4)                273:       usw t0,0(T)
9D00C50C  8E34FFFC   LW S4, -4(S1)                274:       lw T,-CELL_SIZE(dp)
9D00C510  1000FF9B   BEQ ZERO, ZERO, 0x9D00C380   275:       b next
9D00C514  2631FFF8   ADDIU S1, S1, -8             276:       addiu dp,dp,-2*CELL_SIZE
                                                  277:       
                                                  278:   // load variable in T
                                                  279:   fetch:  // '@' ( addr -- n ) T= *addr
9D00C518  02804021   ADDU T0, S4, ZERO            280:       move t0, T
9D00C51C  89140003   LWL S4, 3(T0)                281:       ulw T,0(t0)
9D00C524  1000FF96   BEQ ZERO, ZERO, 0x9D00C380   282:       b next
9D00C528  00000000   NOP                          283:       nop
                                                  284:   
                                                  285:   cstore:  // 'c!' ( char addr --  ) *addr = char
9D00C52C  8E280000   LW T0, 0(S1)                 286:       lw t0, 0(dp)
9D00C530  A2880000   SB T0, 0(S4)                 287:       sb t0, 0(T)
9D00C534  8E34FFFC   LW S4, -4(S1)                288:       lw T, -CELL_SIZE(dp)
9D00C538  1000FF91   BEQ ZERO, ZERO, 0x9D00C380   289:       b next
9D00C53C  2631FFF8   ADDIU S1, S1, -8             290:       addiu dp,dp,-2*CELL_SIZE
                                                  291:   
                                                  292:   cfetch:  // 'c@' ( addr -- char )  T = (char)*addr
9D00C540  1000FF8F   BEQ ZERO, ZERO, 0x9D00C380   293:       b next
9D00C544  82940000   LB S4, 0(S4)                 294:       lb T, 0(T)
                                                  295:   
                                                  296:   rfetch:   // 'r@'  ( -- n R: n -- n )  empile le sommet de la pile des retours
9D00C548  26310004   ADDIU S1, S1, 4              297:       _tpush
9D00C550  1000FF8B   BEQ ZERO, ZERO, 0x9D00C380   298:       b next
9D00C554  02A0A021   ADDU S4, S5, ZERO            299:       move T, R
                                                  300:   
                                                  301:   ufetch: // 'u@'  ( -- a-addr ) empile U
9D00C558  26310004   ADDIU S1, S1, 4              302:       _tpush
9D00C560  1000FF87   BEQ ZERO, ZERO, 0x9D00C380   303:       b next
9D00C564  02C0A021   ADDU S4, S6, ZERO            304:       move T, U
                                                  305:   
                                                  306:   ustore: // 'u!'  ( a-addr -- ) transfert T dans U
9D00C568  0280B021   ADDU S6, S4, ZERO            307:       move U, T
9D00C56C  8E340000   LW S4, 0(S1)                 308:       lw T, 0(dp)
9D00C570  1000FF83   BEQ ZERO, ZERO, 0x9D00C380   309:       b next
9D00C574  2631FFFC   ADDIU S1, S1, -4             310:       addiu dp,dp,-CELL_SIZE
                                                  311:   
                                                  312:   user: // 'user'  ( n -- a-addr) empile le pointeur de la variable
                                                  313:         // utilisateur d'indice n.
9D00C578  0014A080   SLL S4, S4, 2                314:         sll  T,T,2
9D00C57C  1000FF80   BEQ ZERO, ZERO, 0x9D00C380   315:         b next
9D00C580  02D4A021   ADDU S4, S6, S4              316:         addu T, U, T
                                                  317:   
                                                  318:   
                                                  319:   tor:  // '>r' ( n -- ) (R: -- n ) envoie T sur pile retour
9D00C584  26520004   ADDIU S2, S2, 4              320:       _rpush
9D00C58C  0280A821   ADDU S5, S4, ZERO            321:       move R, T
9D00C590  8E340000   LW S4, 0(S1)                 322:       lw T, 0(dp)
9D00C594  1000FF7A   BEQ ZERO, ZERO, 0x9D00C380   323:       b next
9D00C598  2631FFFC   ADDIU S1, S1, -4             324:       addiu dp, dp, -CELL_SIZE
                                                  325:   
                                                  326:   rfrom:  // 'r>' ( -- n ) (R: n -- )  envoie R dans T
9D00C59C  26310004   ADDIU S1, S1, 4              327:       _tpush
9D00C5A4  02A0A021   ADDU S4, S5, ZERO            328:       move T, R
9D00C5A8  8E550000   LW S5, 0(S2)                 329:       lw  R, 0(rp)
9D00C5AC  1000FF74   BEQ ZERO, ZERO, 0x9D00C380   330:       b next
9D00C5B0  2652FFFC   ADDIU S2, S2, -4             331:       addiu rp,rp, -CELL_SIZE
                                                  332:   
                                                  333:   
                                                  334:   dcnt:  // 'dcnt' ( -- n) nombre d'éléments sur la pile de données
9D00C5B4  3C08A000   LUI T0, -24576               335:       la t0,dstack
9D00C5BC  02284023   SUBU T0, S1, T0              336:       subu t0,dp,t0
9D00C5C0  26310004   ADDIU S1, S1, 4              337:       _tpush
9D00C5C8  1000FF6D   BEQ ZERO, ZERO, 0x9D00C380   338:       b next
9D00C5CC  0008A083   SRA S4, T0, 2                339:       sra T, t0,2
                                                  340:   
                                                  341:   rcnt:  // 'rcnt' ( -- n ) nombre d'éléments sur la pile des retours
9D00C5D0  26310004   ADDIU S1, S1, 4              342:       _tpush
9D00C5D8  3C08A000   LUI T0, -24576               343:       la t0,rstack
9D00C5E0  0248A023   SUBU S4, S2, T0              344:       subu T,rp,t0
9D00C5E4  1000FF66   BEQ ZERO, ZERO, 0x9D00C380   345:       b next
9D00C5E8  0014A083   SRA S4, S4, 2                346:       sra T,T,2
                                                  347:   
                                                  348:   ipfetch: // 'ip@' ( -- ip ) empile la valeur courante du pointeur d''instructions
9D00C5EC  26310004   ADDIU S1, S1, 4              349:       _tpush
9D00C5F4  1000FF62   BEQ ZERO, ZERO, 0x9D00C380   350:       b next
9D00C5F8  0200A021   ADDU S4, S0, ZERO            351:       move T, ip
                                                  352:   
                                                  353:   ipstore: // 'ip!' ( ip -- ) initialise le pointeur d''insturctions
9D00C5FC  02808021   ADDU S0, S4, ZERO            354:       move ip, T
9D00C600  8E340000   LW S4, 0(S1)                 355:       lw T, 0(dp)
9D00C604  1000FF5E   BEQ ZERO, ZERO, 0x9D00C380   356:       b next
9D00C608  2631FFFC   ADDIU S1, S1, -4             357:       addiu dp,dp, -CELL_SIZE
                                                  358:   
                                                  359:   drop:  // 'drop' ( n -- )
9D00C60C  8E340000   LW S4, 0(S1)                 360:       lw T, 0(dp)
9D00C610  1000FF5B   BEQ ZERO, ZERO, 0x9D00C380   361:       b next
9D00C614  2631FFFC   ADDIU S1, S1, -4             362:       addiu dp,dp,-CELL_SIZE
                                                  363:   
                                                  364:   twodrop: // '2drop' ( n1 n2 -- )
9D00C618  8E34FFFC   LW S4, -4(S1)                365:       lw T, -CELL_SIZE(dp)
9D00C61C  1000FF58   BEQ ZERO, ZERO, 0x9D00C380   366:       b next
9D00C620  2631FFF8   ADDIU S1, S1, -8             367:       addiu dp,dp,-2*CELL_SIZE
                                                  368:   
                                                  369:   dup:  // 'dup' ( n -- n n )
9D00C624  26310004   ADDIU S1, S1, 4              370:       addiu dp,dp,CELL_SIZE
9D00C628  1000FF55   BEQ ZERO, ZERO, 0x9D00C380   371:       b next
9D00C62C  AE340000   SW S4, 0(S1)                 372:       sw T, 0(dp)
                                                  373:   
                                                  374:   twodup: // (n2 n1 -- n2 n1 n2 n1)
9D00C630  8E280000   LW T0, 0(S1)                 375:       lw t0, 0(dp)
9D00C634  26310008   ADDIU S1, S1, 8              376:       addiu dp,dp,2*CELL_SIZE
9D00C638  AE34FFFC   SW S4, -4(S1)                377:       sw T, -CELL_SIZE(dp)
9D00C63C  1000FF50   BEQ ZERO, ZERO, 0x9D00C380   378:       b next
9D00C640  AE280000   SW T0, 0(S1)                 379:       sw t0, 0(dp)
                                                  380:   
                                                  381:   qdup:   // ?dup ( n -- n n | n ) duplique n si n!=0
9D00C644  1280FF4E   BEQ S4, ZERO, 0x9D00C380     382:       beq T,zero, next
9D00C648  00000000   NOP                          383:       nop
9D00C64C  26310004   ADDIU S1, S1, 4              384:       addiu dp,dp,CELL_SIZE
9D00C650  1000FF4B   BEQ ZERO, ZERO, 0x9D00C380   385:       b next
9D00C654  AE340000   SW S4, 0(S1)                 386:       sw T, 0(dp)
                                                  387:   
                                                  388:   swap: // 'swap' (n2 n1 -- n1 n2 )
9D00C658  02804021   ADDU T0, S4, ZERO            389:       move t0, T
9D00C65C  8E340000   LW S4, 0(S1)                 390:       lw T, 0(dp)
9D00C660  1000FF47   BEQ ZERO, ZERO, 0x9D00C380   391:       b next
9D00C664  AE280000   SW T0, 0(S1)                 392:       sw t0, 0(dp)
                                                  393:   
                                                  394:   over:   // 'over' ( n2 n1 -- n2 n1 n2 )
9D00C668  26310004   ADDIU S1, S1, 4              395:       _tpush
9D00C670  1000FF43   BEQ ZERO, ZERO, 0x9D00C380   396:       b next
9D00C674  8E34FFFC   LW S4, -4(S1)                397:       lw T, -CELL_SIZE(dp)
                                                  398:   
                                                  399:   rot: // ( n3 n2 n1 -- n2 n1 n3)
9D00C678  02804021   ADDU T0, S4, ZERO            400:       move t0, T
9D00C67C  8E290000   LW T1, 0(S1)                 401:       lw t1, 0(dp)
9D00C680  8E34FFFC   LW S4, -4(S1)                402:       lw T, -CELL_SIZE(dp)
9D00C684  AE280000   SW T0, 0(S1)                 403:       sw t0, 0(dp)
9D00C688  1000FF3D   BEQ ZERO, ZERO, 0x9D00C380   404:       b next
9D00C68C  AE29FFFC   SW T1, -4(S1)                405:       sw t1, -CELL_SIZE(dp)
                                                  406:   
                                                  407:   plus:  // '+'   ( n1 n2 -- n1+n2 )
9D00C690  8E280000   LW T0, 0(S1)                 408:       lw t0,0(dp)
9D00C694  0288A021   ADDU S4, S4, T0              409:       addu T,T,t0
9D00C698  1000FF39   BEQ ZERO, ZERO, 0x9D00C380   410:       b next
9D00C69C  2631FFFC   ADDIU S1, S1, -4             411:       addiu dp,dp,-CELL_SIZE
                                                  412:   
                                                  413:   oneplus:  // '1+'  (n -- n+1 )
9D00C6A0  1000FF37   BEQ ZERO, ZERO, 0x9D00C380   414:       b next
9D00C6A4  26940001   ADDIU S4, S4, 1              415:       addiu T, T, 1
                                                  416:   
                                                  417:   plusstore:  // '+!'  ( n addr -- ) *addr  = *addr+n
9D00C6A8  8A880003   LWL T0, 3(S4)                418:       ulw t0,0(T)
9D00C6B0  8E290000   LW T1, 0(S1)                 419:       lw t1,0(dp)
9D00C6B4  01284020   ADD T0, T1, T0               420:       add t0,t1,t0
9D00C6B8  AA880003   SWL T0, 3(S4)                421:       usw t0,0(T)
9D00C6C0  8E34FFFC   LW S4, -4(S1)                422:       lw T,-CELL_SIZE(dp)
9D00C6C4  1000FF2E   BEQ ZERO, ZERO, 0x9D00C380   423:       b next
9D00C6C8  2631FFF8   ADDIU S1, S1, -8             424:       addiu dp,dp,-2*CELL_SIZE
                                                  425:   
                                                  426:   minus:   //  '-' ( n1 n2 -- n1-n2 )
9D00C6CC  8E280000   LW T0, 0(S1)                 427:       lw t0,0(dp)
9D00C6D0  0114A023   SUBU S4, T0, S4              428:       subu T,t0,T
9D00C6D4  1000FF2A   BEQ ZERO, ZERO, 0x9D00C380   429:       b next
9D00C6D8  2631FFFC   ADDIU S1, S1, -4             430:       addiu dp,dp,-CELL_SIZE
                                                  431:   
                                                  432:   oneminus:   // '1-' ( n -- n-1 )
9D00C6DC  1000FF28   BEQ ZERO, ZERO, 0x9D00C380   433:       b next
9D00C6E0  2694FFFF   ADDIU S4, S4, -1             434:       addiu T, T, -1
                                                  435:   
                                                  436:   star:   // '*' ( n1 n2 -- n1*n2 ) multiplication signé, résultat simple précision.
9D00C6E4  8E280000   LW T0, 0(S1)                 437:       lw t0,0(dp) 
9D00C6E8  7114A002   MUL S4, T0, S4               438:       mul T,t0,T
9D00C6EC  1000FF24   BEQ ZERO, ZERO, 0x9D00C380   439:       b next
9D00C6F0  2631FFFC   ADDIU S1, S1, -4             440:       addiu dp,dp,-CELL_SIZE
                                                  441:   
                                                  442:   ustar:   // 'U*' ( u1 u2 -- u3 ) multiplication non signe, résultat simple précision
9D00C6F4  8E280000   LW T0, 0(S1)                 443:       lw t0,0(dp)
9D00C6F8  01140019   MULTU 0, T0, S4              444:       multu  t0, T
9D00C6FC  0000A012   MFLO S4                      445:       mflo T
9D00C700  1000FF1F   BEQ ZERO, ZERO, 0x9D00C380   446:       b next
9D00C704  2631FFFC   ADDIU S1, S1, -4             447:       addiu dp,dp,-CELL_SIZE
                                                  448:   
                                                  449:   mstar:  // 'M*' ( n1 n2 -- d) multiplication signée avec résultat double précision.
9D00C708  8E280000   LW T0, 0(S1)                 450:       lw t0, 0(dp)
9D00C70C  01140018   MULT 0, T0, S4               451:       mult t0,T
9D00C710  00004012   MFLO T0                      452:       mflo t0
9D00C714  0000A010   MFHI S4                      453:       mfhi T
9D00C718  1000FF19   BEQ ZERO, ZERO, 0x9D00C380   454:       b next
9D00C71C  AE280000   SW T0, 0(S1)                 455:       sw t0, 0(dp)
                                                  456:   
                                                  457:   umstar: // 'UM*' ( u1 u2 -- ud ) multiplication non signé avec résultat double précision.
9D00C720  8E280000   LW T0, 0(S1)                 458:       lw t0, 0(dp)
9D00C724  01140019   MULTU 0, T0, S4              459:       multu t0,T
9D00C728  00004012   MFLO T0                      460:       mflo t0
9D00C72C  0000A010   MFHI S4                      461:       mfhi T
9D00C730  1000FF13   BEQ ZERO, ZERO, 0x9D00C380   462:       b next
9D00C734  AE280000   SW T0, 0(S1)                 463:       sw t0, 0(dp)
                                                  464:   
                                                  465:   slash:  // '/' ( n1 n2 -- n1/n2 )  division signée
9D00C738  8E280000   LW T0, 0(S1)                 466:       lw t0, 0(dp)
9D00C73C  028001F4   TEQ S4, ZERO                 467:       div t0,T
9D00C758  0000A012   MFLO S4                      468:       mflo T
9D00C75C  1000FF08   BEQ ZERO, ZERO, 0x9D00C380   469:       b next
9D00C760  2631FFFC   ADDIU S1, S1, -4             470:       addiu dp,dp,-CELL_SIZE
                                                  471:   
                                                  472:   uslash:  // 'U/'  (u1 u2 -- u3)  division non signée
9D00C764  8E280000   LW T0, 0(S1)                 473:       lw t0,0(dp)
9D00C768  028001F4   TEQ S4, ZERO                 474:       divu t0,T
9D00C774  0000A012   MFLO S4                      475:       mflo T
9D00C778  1000FF01   BEQ ZERO, ZERO, 0x9D00C380   476:       b next
9D00C77C  2631FFFC   ADDIU S1, S1, -4             477:       addiu dp,dp,-CELL_SIZE
                                                  478:   
                                                  479:   twostar:  # '2*'  ( n  -- 2*n ) multiply by 2 (shift left 1 bit)
9D00C780  1000FEFF   BEQ ZERO, ZERO, 0x9D00C380   480:       b next
9D00C784  0014A040   SLL S4, S4, 1                481:       sll T,T,1
                                                  482:   
                                                  483:   twoslash: // '2/'  ( n -- n/2 )  divide by 2 ( arithmetic shift right 1 bit)
9D00C788  1000FEFD   BEQ ZERO, ZERO, 0x9D00C380   484:       b next
9D00C78C  0014A043   SRA S4, S4, 1                485:       sra T,T,1
                                                  486:   
                                                  487:   divmod:  // '/mod'  ( n1 n2 -- n1%n2 n1/n2 )
9D00C790  8E280000   LW T0, 0(S1)                 488:       lw t0, 0(dp)
9D00C794  028001F4   TEQ S4, ZERO                 489:       div t0, T  # n1/n2
9D00C7B0  00004010   MFHI T0                      490:       mfhi t0    #  remainder
9D00C7B4  AE280000   SW T0, 0(S1)                 491:       sw t0, 0(dp)
9D00C7B8  1000FEF1   BEQ ZERO, ZERO, 0x9D00C380   492:       b next
9D00C7BC  0000A012   MFLO S4                      493:       mflo T     # quotient
                                                  494:   
                                                  495:   lshift:  // '<<' ( n1 u -- n1<<u )
9D00C7C0  8E280000   LW T0, 0(S1)                 496:       lw t0, 0(dp)
9D00C7C4  0288A004   SLLV S4, T0, S4              497:       sllv T,t0,T
9D00C7C8  1000FEED   BEQ ZERO, ZERO, 0x9D00C380   498:       b next
9D00C7CC  2631FFFC   ADDIU S1, S1, -4             499:       addiu dp,dp,-CELL_SIZE
                                                  500:   
                                                  501:   rshift:  // '>>'  ( n1 u -- n1>>u )
9D00C7D0  8E280000   LW T0, 0(S1)                 502:       lw t0,0(dp)
9D00C7D4  0288A006   SRLV S4, T0, S4              503:       srlv T,t0,T
9D00C7D8  1000FEE9   BEQ ZERO, ZERO, 0x9D00C380   504:       b next
9D00C7DC  2631FFFC   ADDIU S1, S1, -4             505:       addiu dp,dp,-CELL_SIZE
                                                  506:   
                                                  507:   modulo:  // 'mod' ( n1 n2 -- n1%n2 )
9D00C7E0  8E280000   LW T0, 0(S1)                 508:       lw t0, 0(dp)
9D00C7E4  028001F4   TEQ S4, ZERO                 509:       div t0,T
9D00C800  0000A010   MFHI S4                      510:       mfhi T
9D00C804  1000FEDE   BEQ ZERO, ZERO, 0x9D00C380   511:       b next
9D00C808  2631FFFC   ADDIU S1, S1, -4             512:       addiu dp,dp,-CELL_SIZE
                                                  513:   
                                                  514:   // division non signée d'un double précision par un simple, retourne quotient et reste
                                                  515:   umsmod: // UM/MOD (ud1 u1 -- u2 u3) u2=reste, u3=quotient
9D00C80C  8E28FFFC   LW T0, -4(S1)                516:           lw      t0, -CELL_SIZE(dp)  # 32 bits poids faible
9D00C810  8E290000   LW T1, 0(S1)                 517:           lw      t1, 0(dp)           # 32 bits poids fort
9D00C814  1D20000D   BGTZ T1, 0x9D00C84C          518:           bgtz    t1, long_div
9D00C818  00000000   NOP                          519:           nop
9D00C81C  028001F4   TEQ S4, ZERO                 520:           divu    t0, T
9D00C828  00004010   MFHI T0                      521:           mfhi    t0              # reste
9D00C82C  0000A012   MFLO S4                      522:           mflo    T               # quotient
9D00C830  AE28FFFC   SW T0, -4(S1)                523:           sw      t0, -CELL_SIZE(dp)
9D00C834  1000FED2   BEQ ZERO, ZERO, 0x9D00C380   524:           b       next
9D00C838  2631FFFC   ADDIU S1, S1, -4             525:           addiu   dp, dp, -CELL_SIZE
9D00C83C  2414FFFF   ADDIU S4, ZERO, -1           526:   1:      li      T, -1             # quotient > 32 bits
9D00C840  AE34FFFC   SW S4, -4(S1)                527:           sw      T, -CELL_SIZE(dp)
9D00C844  1000FECE   BEQ ZERO, ZERO, 0x9D00C380   528:           b       next
9D00C848  2631FFFC   ADDIU S1, S1, -4             529:           addiu   dp,dp,-CELL_SIZE
                                                  530:   long_div:
9D00C84C  028001F4   TEQ S4, ZERO                 531:           divu    t1,T
9D00C858  00005812   MFLO T3                      532:           mflo    t3      #quotient
9D00C85C  1D60FFF7   BGTZ T3, 0x9D00C83C          533:           bgtz    t3, 1b
9D00C860  00004810   MFHI T1                      534:           mfhi    t1      #reste
9D00C864  240A0020   ADDIU T2, ZERO, 32           535:           li      t2, 32  # compteur de boucle
9D00C868  0560FFF4   BLTZ T3, 0x9D00C83C          536:   2:      bltz    t3, 1b  # overflow
9D00C86C  000B5840   SLL T3, T3, 1                537:           sll     t3,t3,1
9D00C870  01346023   SUBU T4, T1, S4              538:           subu    t4,t1,T
9D00C874  05800003   BLTZ T4, 0x9D00C884          539:           bltz    t4,3f
9D00C878  00000000   NOP                          540:           nop
9D00C87C  01804821   ADDU T1, T4, ZERO            541:           move    t1, t4
9D00C880  356B0001   ORI T3, T3, 1                542:           ori     t3,t3,1
9D00C884  254AFFFF   ADDIU T2, T2, -1             543:   3:      addiu   t2,t2,-1  # décrémente le compteur de boucle
9D00C888  11400007   BEQ T2, ZERO, 0x9D00C8A8     544:           beqz    t2, 5f    # division terminée si 0
9D00C88C  00000000   NOP                          545:           nop
9D00C890  00094840   SLL T1, T1, 1                546:           sll     t1,t1,1   # décale à gauche t1:t0
9D00C894  05010002   BGEZ T0, 0x9D00C8A0          547:           bgez    t0, 4f
9D00C898  00000000   NOP                          548:           nop
9D00C89C  35290001   ORI T1, T1, 1                549:           ori     t1,t1,1
9D00C8A0  1000FFF1   BEQ ZERO, ZERO, 0x9D00C868   550:   4:      b 2b
9D00C8A4  00084040   SLL T0, T0, 1                551:           sll     t0,t0,1
9D00C8A8  0160A021   ADDU S4, T3, ZERO            552:   5:      move    T, t3                 # quotient
9D00C8AC  AE29FFFC   SW T1, -4(S1)                553:           sw      t1, -CELL_SIZE(dp)    # reste
9D00C8B0  1000FEB3   BEQ ZERO, ZERO, 0x9D00C380   554:           b       next
9D00C8B4  2631FFFC   ADDIU S1, S1, -4             555:           addiu   dp,dp,-CELL_SIZE
                                                  556:   
                                                  557:   
                                                  558:     // division signée d'un double par un simple, retourne quotient et reste
                                                  559:     // les 32 bits les plus significatifs du double sont ignorés.
                                                  560:     //  Il s'agit dans les fait d'une division simple/simple.
                                                  561:   msmod:   # M/MOD  (d1 n1 - n2 n3 )  n2=reste, n3=quotient
9D00C8B8  8E28FFFC   LW T0, -4(S1)                562:           lw      t0, -CELL_SIZE(dp)
9D00C8BC  028001F4   TEQ S4, ZERO                 563:           div     t0, T
9D00C8D8  00004010   MFHI T0                      564:           mfhi    t0
9D00C8DC  0000A012   MFLO S4                      565:           mflo    T
9D00C8E0  AE28FFFC   SW T0, -4(S1)                566:           sw      t0, -CELL_SIZE(dp)
9D00C8E4  1000FEA6   BEQ ZERO, ZERO, 0x9D00C380   567:           b       next
9D00C8E8  2631FFFC   ADDIU S1, S1, -4             568:           addiu   dp,dp,-CELL_SIZE
                                                  569:   
                                                  570:   
                                                  571:   min:  // min (n1 n2 -- min )  conserve le plus petit
9D00C8EC  8E280000   LW T0, 0(S1)                 572:       lw t0, 0(dp)
9D00C8F0  01144823   SUBU T1, T0, S4              573:       subu t1,t0,T
9D00C8F4  0520FEA2   BLTZ T1, 0x9D00C380          574:       bltz t1, next
9D00C8F8  2631FFFC   ADDIU S1, S1, -4             575:       addiu dp,dp,-CELL_SIZE
9D00C8FC  0100A021   ADDU S4, T0, ZERO            576:       move T,t0
9D00C900  1000FE9F   BEQ ZERO, ZERO, 0x9D00C380   577:       b next
9D00C904  00000000   NOP                          578:       nop
                                                  579:   
                                                  580:   max:  // max (n1 n2 -- max ) conserve le plus grand
9D00C908  8E280000   LW T0, 0(S1)                 581:       lw t0,0(dp)
9D00C90C  02884823   SUBU T1, S4, T0              582:       subu t1,T,t0
9D00C910  0520FE9B   BLTZ T1, 0x9D00C380          583:       bltz t1, next
9D00C914  2631FFFC   ADDIU S1, S1, -4             584:       addiu dp,dp,-CELL_SIZE
9D00C918  0100A021   ADDU S4, T0, ZERO            585:       move T,t0
9D00C91C  1000FE98   BEQ ZERO, ZERO, 0x9D00C380   586:       b next
9D00C920  00000000   NOP                          587:       nop
                                                  588:   
                                                  589:   abs:  // 'abs' ( n -- abs(n) )
9D00C924  0681FE96   BGEZ S4, 0x9D00C380          590:       bgez T, next
9D00C928  00000000   NOP                          591:       nop
9D00C92C  1000FE94   BEQ ZERO, ZERO, 0x9D00C380   592:       b next
9D00C930  0014A023   SUBU S4, ZERO, S4            593:       negu T
                                                  594:   
                                                  595:   ltz:  // '0<'  ( n -- t|f )
9D00C934  1000FE92   BEQ ZERO, ZERO, 0x9D00C380   596:       b next
9D00C938  0280A02A   SLT S4, S4, ZERO             597:       slt T,T,zero
                                                  598:   
                                                  599:   zequal: // '0=' ( n -- t|f ) vrai si n == 0 sinon faux
9D00C93C  1000FE90   BEQ ZERO, ZERO, 0x9D00C380   600:       b next
9D00C940  2E940001   SLTIU S4, S4, 1              601:       sltiu T,1
                                                  602:   
                                                  603:   bitand: // 'and' ( n1 n2 -- n1&n2)
9D00C944  8E280000   LW T0, 0(S1)                 604:       lw t0, 0(dp)
9D00C948  0288A024   AND S4, S4, T0               605:       and T,T,t0
9D00C94C  1000FE8C   BEQ ZERO, ZERO, 0x9D00C380   606:       b next
9D00C950  2631FFFC   ADDIU S1, S1, -4             607:       addiu dp,dp,-CELL_SIZE
                                                  608:   
                                                  609:   bitor:  // 'or' ( n1 n2 -- n1|n2)
9D00C954  8E280000   LW T0, 0(S1)                 610:       lw t0, 0(dp)
9D00C958  0288A025   OR S4, S4, T0                611:       or T,T,t0
9D00C95C  1000FE88   BEQ ZERO, ZERO, 0x9D00C380   612:       b next
9D00C960  2631FFFC   ADDIU S1, S1, -4             613:       addiu dp,dp,-CELL_SIZE
                                                  614:   
                                                  615:   bitxor: // 'xor' ( n1 n2 -- n1^n2)
9D00C964  8E280000   LW T0, 0(S1)                 616:       lw t0, 0(dp)
9D00C968  0288A026   XOR S4, S4, T0               617:       xor T,T,t0
9D00C96C  1000FE84   BEQ ZERO, ZERO, 0x9D00C380   618:       b next
9D00C970  2631FFFC   ADDIU S1, S1, -4             619:       addiu dp,dp,-CELL_SIZE
                                                  620:   
                                                  621:   bitnot: // 'not' ( n1 -- ~n1 )
9D00C974  1000FE82   BEQ ZERO, ZERO, 0x9D00C380   622:       b next
9D00C978  0280A027   NOR S4, S4, ZERO             623:       not T,T
                                                  624:   
                                                  625:   equal:  // '='  ( n1 n2 -- t|f ) n1==n2?
9D00C97C  8E280000   LW T0, 0(S1)                 626:       lw t0,0(dp)
9D00C980  2631FFFC   ADDIU S1, S1, -4             627:       addiu dp,dp,-CELL_SIZE
9D00C984  1288FE7E   BEQ S4, T0, 0x9D00C380       628:       beq T,t0,next
9D00C988  2414FFFF   ADDIU S4, ZERO, -1           629:       li T, -1
9D00C98C  1000FE7C   BEQ ZERO, ZERO, 0x9D00C380   630:       b next
9D00C990  24140000   ADDIU S4, ZERO, 0            631:       li T, 0
                                                  632:   
                                                  633:   nequal: // '<>' ( n1 n2 -- t|f ) n1<>n2?
9D00C994  8E280000   LW T0, 0(S1)                 634:       lw t0,0(dp)
9D00C998  2631FFFC   ADDIU S1, S1, -4             635:       addiu dp,dp,-CELL_SIZE
9D00C99C  1514FE78   BNE T0, S4, 0x9D00C380       636:       bne t0,T, next
9D00C9A0  2414FFFF   ADDIU S4, ZERO, -1           637:       li T, -1
9D00C9A4  1000FE76   BEQ ZERO, ZERO, 0x9D00C380   638:       b next
9D00C9A8  24140000   ADDIU S4, ZERO, 0            639:       li T, 0
                                                  640:   
                                                  641:   less:  //  '<'  ( n1 n2 -- t|f ) n1<n2?
9D00C9AC  8E280000   LW T0, 0(S1)                 642:       lw t0,0(dp)
9D00C9B0  2631FFFC   ADDIU S1, S1, -4             643:       addiu dp,dp,-CELL_SIZE
9D00C9B4  01144023   SUBU T0, T0, S4              644:       subu t0,t0,T
9D00C9B8  0500FE71   BLTZ T0, 0x9D00C380          645:       bltz t0, next
9D00C9BC  2414FFFF   ADDIU S4, ZERO, -1           646:       li T, -1
9D00C9C0  1000FE6F   BEQ ZERO, ZERO, 0x9D00C380   647:       b next
9D00C9C4  24140000   ADDIU S4, ZERO, 0            648:       li T, 0
                                                  649:   
                                                  650:   greater:  // '>'  ( n1 n2 -- t|f ) n1>n2?
9D00C9C8  8E280000   LW T0, 0(S1)                 651:       lw t0,0(dp)
9D00C9CC  2631FFFC   ADDIU S1, S1, -4             652:       addiu dp,dp,-CELL_SIZE
9D00C9D0  01144023   SUBU T0, T0, S4              653:       subu t0,t0,T
9D00C9D4  1D00FE6A   BGTZ T0, 0x9D00C380          654:       bgtz t0, next
9D00C9D8  2414FFFF   ADDIU S4, ZERO, -1           655:       li T, -1
9D00C9DC  1000FE68   BEQ ZERO, ZERO, 0x9D00C380   656:       b next
9D00C9E0  24140000   ADDIU S4, ZERO, 0            657:       li T, 0
                                                  658:   
                                                  659:   ltez:  // '<=' ( n1 n2 -- t|f ) n1<=n2?
9D00C9E4  8E280000   LW T0, 0(S1)                 660:       lw t0,0(dp)
9D00C9E8  2631FFFC   ADDIU S1, S1, -4             661:       addiu dp,dp,-CELL_SIZE
9D00C9EC  01144023   SUBU T0, T0, S4              662:       subu t0,t0,T
9D00C9F0  1900FE63   BLEZ T0, 0x9D00C380          663:       blez t0, next
9D00C9F4  2414FFFF   ADDIU S4, ZERO, -1           664:       li T,-1
9D00C9F8  1000FE61   BEQ ZERO, ZERO, 0x9D00C380   665:       b next
9D00C9FC  24140000   ADDIU S4, ZERO, 0            666:       li T, 0
                                                  667:   
                                                  668:   gtez:  // '>=' ( n1 n2 -- t|f ) n1>=n2?
9D00CA00  8E280000   LW T0, 0(S1)                 669:       lw t0,0(dp)
9D00CA04  2631FFFC   ADDIU S1, S1, -4             670:       addiu dp,dp,-CELL_SIZE
9D00CA08  01144023   SUBU T0, T0, S4              671:       subu t0,t0,T
9D00CA0C  0501FE5C   BGEZ T0, 0x9D00C380          672:       bgez t0, next
9D00CA10  2414FFFF   ADDIU S4, ZERO, -1           673:       li T, -1
9D00CA14  1000FE5A   BEQ ZERO, ZERO, 0x9D00C380   674:       b next
9D00CA18  24140000   ADDIU S4, ZERO, 0            675:       li T, 0
                                                  676:   
                                                  677:   key:  // ( -- char ) attend réception caractère par terminal
9D00CA1C  3C04A000   LUI A0, -24576               678:       la a0,comm_channel
9D00CA24  90840000   LBU A0, 0(A0)                679:       lbu a0,0(a0)
9D00CA28  0F402D86   JAL 0x9D00B618               680:       jal _key
9D00CA2C  26310004   ADDIU S1, S1, 4              681:       _tpush
9D00CA34  1000FE52   BEQ ZERO, ZERO, 0x9D00C380   682:       b next
9D00CA38  0040A021   ADDU S4, V0, ZERO            683:       move T, v0  // T=v0
                                                  684:   
                                                  685:   
                                                  686:   dotq: // '."' ( -- ) ip pointe vers le texte, le premier octet est le compte.
9D00CA3C  92130000   LBU S3, 0(S0)                687:       lbu w, 0(ip)
9D00CA40  26100001   ADDIU S0, S0, 1              688:       _inc_ip
                                                  689:   1:
9D00CA44  1260FE4E   BEQ S3, ZERO, 0x9D00C380     690:       beqz w, next
9D00CA48  2673FFFF   ADDIU S3, S3, -1             691:       addiu w,w,-1
9D00CA4C  3C04A000   LUI A0, -24576               692:       la a0,comm_channel
9D00CA54  90840000   LBU A0, 0(A0)                693:       lbu a0,0(a0)
9D00CA58  82050000   LB A1, 0(S0)                 694:       lb a1, 0(ip)
9D00CA5C  0F402B85   JAL 0x9D00AE14               695:       jal _putch
9D00CA60  26100001   ADDIU S0, S0, 1              696:       _inc_ip
9D00CA64  1000FFF7   BEQ ZERO, ZERO, 0x9D00CA44   697:       b 1b
9D00CA68  00000000   NOP                          698:       nop
                                                  699:   
                                                  700:   dot: // "." ( n -- ) imprime un entier en format libre
9D00CA6C  3C04A000   LUI A0, -24576               701:       la a0,comm_channel
9D00CA74  90840000   LBU A0, 0(A0)                702:       lbu a0,0(a0)
9D00CA78  02802821   ADDU A1, S4, ZERO            703:       move a1,T
9D00CA7C  00003021   ADDU A2, ZERO, ZERO          704:       move a2,zero
9D00CA80  0F402C58   JAL 0x9D00B160               705:       jal print_int
9D00CA84  8E340000   LW S4, 0(S1)                 706:       lw T,0(dp)
9D00CA88  1000FE3D   BEQ ZERO, ZERO, 0x9D00C380   707:       b next
9D00CA8C  2631FFFC   ADDIU S1, S1, -4             708:       addiu dp,dp,-CELL_SIZE
                                                  709:       
                                                  710:       
                                                  711:   delay: // 'delay' ( msec -- ) delais en millisecondes
9D00CA90  3C13A000   LUI S3, -24576               712:       la w,sys_ticks
9D00CA98  8E680000   LW T0, 0(S3)                 713:       lw t0, 0(w)
9D00CA9C  02884021   ADDU T0, S4, T0              714:       addu t0, T,t0
9D00CAA0  8E340000   LW S4, 0(S1)                 715:       lw T, 0(dp)
9D00CAA4  8E690000   LW T1, 0(S3)                 716:   1:  lw t1, 0(w)
9D00CAA8  1528FFFE   BNE T1, T0, 0x9D00CAA4       717:       bne t1, t0, 1b
9D00CAAC  00000000   NOP                          718:       nop
9D00CAB0  1000FE33   BEQ ZERO, ZERO, 0x9D00C380   719:       b next
9D00CAB4  2631FFFC   ADDIU S1, S1, -4             720:       addiu dp, dp, -CELL_SIZE
                                                  721:   
                                                  722:   ticks:  // 'ticks'  ( -- n ) empile le compteur sys_tick
9D00CAB8  26310004   ADDIU S1, S1, 4              723:       _tpush
9D00CAC0  3C13A000   LUI S3, -24576               724:       la w,sys_ticks
9D00CAC8  1000FE2D   BEQ ZERO, ZERO, 0x9D00C380   725:       b next
9D00CACC  8E740000   LW S4, 0(S3)                 726:       lw T, 0(w)
                                                  727:   
                                                  728:   dodo: // 'do' ( n1 n2 -- R: -- L J ) initialise une boucle do...loop 
9D00CAD0  26520004   ADDIU S2, S2, 4              729:       _rpush
9D00CAD8  02E0A821   ADDU S5, S7, ZERO            730:       move R, L  // R: -- L
9D00CADC  8E370000   LW S7, 0(S1)                 731:       lw L, 0(dp) // L=n1
9D00CAE0  2631FFFC   ADDIU S1, S1, -4             732:       addiu dp,dp,-CELL_SIZE
9D00CAE4  26520004   ADDIU S2, S2, 4              733:       _rpush
9D00CAEC  03C0A821   ADDU S5, S8, ZERO            734:       move R,I // R: -- L J
9D00CAF0  0280F021   ADDU S8, S4, ZERO            735:       move I,T
9D00CAF4  8E340000   LW S4, 0(S1)                 736:       lw T, 0(dp)
9D00CAF8  1000FE21   BEQ ZERO, ZERO, 0x9D00C380   737:       b next
9D00CAFC  2631FFFC   ADDIU S1, S1, -4             738:       addiu dp,dp,-CELL_SIZE
                                                  739:   
                                                  740:   unloop: // ( R: L J -- ) restitue les valeurs originales de L et I
9D00CB00  02A0F021   ADDU S8, S5, ZERO            741:       move I,R
9D00CB04  8E550000   LW S5, 0(S2)                 742:       _rpop
9D00CB0C  02A0B821   ADDU S7, S5, ZERO            743:       move L,R
9D00CB10  8E550000   LW S5, 0(S2)                 744:       lw R,0(rp)
9D00CB14  1000FE1A   BEQ ZERO, ZERO, 0x9D00C380   745:       b next
9D00CB18  2652FFFC   ADDIU S2, S2, -4             746:       addiu rp,rp,-CELL_SIZE
                                                  747:       
                                                  748:   ifetch: // 'I' ( -- n ) empile le compteur de boucle I
9D00CB1C  26310004   ADDIU S1, S1, 4              749:       _tpush
9D00CB24  1000FE16   BEQ ZERO, ZERO, 0x9D00C380   750:       b next
9D00CB28  03C0A021   ADDU S4, S8, ZERO            751:       move T, I
                                                  752:   
                                                  753:   jfetch: // 'J' ( -- n ) empile la valeur J
9D00CB2C  26310004   ADDIU S1, S1, 4              754:       _tpush
9D00CB34  02A0A021   ADDU S4, S5, ZERO            755:       move T,R
9D00CB38  8E550000   LW S5, 0(S2)                 756:       lw R,0(rp)
9D00CB3C  1000FE10   BEQ ZERO, ZERO, 0x9D00C380   757:       b next
9D00CB40  2652FFFC   ADDIU S2, S2, -4             758:       addiu rp,rp,-CELL_SIZE
                                                  759:       
                                                  760:       
                                                  761:   loop: //  'loop'  incrémente I et si I==L quittte la boucle
9D00CB44  27DE0001   ADDIU S8, S8, 1              762:       addiu I,I,1  
9D00CB48  13D70003   BEQ S8, S7, 0x9D00CB58       763:       beq  I, L, 1f
9D00CB4C  92080000   LBU T0, 0(S0)                764:       _back_jump
9D00CB58  1000FFE9   BEQ ZERO, ZERO, 0x9D00CB00   765:   1:  b unloop
9D00CB5C  26100001   ADDIU S0, S0, 1              766:       addiu ip,ip,1
                                                  767:   
                                                  768:   ploop: // '+loop' ( n -- ) soustrait n à X, si X>0 boucle sinon quitte la boucle
9D00CB60  03C04021   ADDU T0, S8, ZERO            769:       move t0,I
9D00CB64  03D4F021   ADDU S8, S8, S4              770:       addu I,I,T
9D00CB68  8E340000   LW S4, 0(S1)                 771:       _tpop
9D00CB70  01174023   SUBU T0, T0, S7              772:      subu t0,t0,L
9D00CB74  05000006   BLTZ T0, 0x9D00CB90          773:      bltz t0, 3f
9D00CB78  26E8FFFF   ADDIU T0, S7, -1             774:      addiu t0,L,-1
9D00CB7C  011E4023   SUBU T0, T0, S8              775:      subu t0,t0,I
9D00CB80  0501FFF5   BGEZ T0, 0x9D00CB58          776:      bgez t0,1b
9D00CB84  92080000   LBU T0, 0(S0)                777:      _back_jump
9D00CB90  03D74023   SUBU T0, S8, S7              778:   3: subu t0,I,L
9D00CB94  0501FFF0   BGEZ T0, 0x9D00CB58          779:      bgez t0,1b
9D00CB98  92080000   LBU T0, 0(S0)                780:      _back_jump
                                                  781:      
                                                  782:      
                                                  783:   pick: // ( xu...,x1,x0,u -- xu...,x1,x0,xu ) empile une copie du Uième élément de la pile
9D00CBA4  0014A080   SLL S4, S4, 2                784:       sll  T, T, 2
9D00CBA8  02349823   SUBU S3, S1, S4              785:       subu w, dp,T
9D00CBAC  1000FDF4   BEQ ZERO, ZERO, 0x9D00C380   786:       b next
9D00CBB0  8E740000   LW S4, 0(S3)                 787:       lw T, 0(w)
                                                  788:   
                                                  789:   sine: // (angle -- sine)
9D00CBB4  02802021   ADDU A0, S4, ZERO            790:       move a0, T
9D00CBB8  0F4059D0   JAL 0x9D016740               791:       jal sinf
9D00CBBC  1000FDF0   BEQ ZERO, ZERO, 0x9D00C380   792:       b next
9D00CBC0  0040A021   ADDU S4, V0, ZERO            793:       move T, v0
                                                  794:   
                                                  795:   acos: // (angle -- cos)
9D00CBC4  02802021   ADDU A0, S4, ZERO            796:       move a0, T
9D00CBC8  0F405A17   JAL 0x9D01685C               797:       jal cosf
9D00CBCC  1000FDEC   BEQ ZERO, ZERO, 0x9D00C380   798:       b next
9D00CBD0  0040A021   ADDU S4, V0, ZERO            799:       move T, v0
                                                  800:   
                                                  801:   asin: // (sine -- angle)
9D00CBD4  02802021   ADDU A0, S4, ZERO            802:       move a0, T
9D00CBD8  0F40627F   JAL 0x9D0189FC               803:       jal asinf
9D00CBDC  1000FDE8   BEQ ZERO, ZERO, 0x9D00C380   804:       b next
9D00CBE0  0040A021   ADDU S4, V0, ZERO            805:       move T, v0
                                                  806:   
                                                  807:   random: //
9D00CBE4  0F406171   JAL 0x9D0185C4               808:       jal rand
9D00CBE8  26310004   ADDIU S1, S1, 4              809:       _tpush
9D00CBF0  1000FDE3   BEQ ZERO, ZERO, 0x9D00C380   810:       b next
9D00CBF4  0040A021   ADDU S4, V0, ZERO            811:       move T, v0
                                                  812:   
                                                  813:   trunc: // ( f -- i)
9D00CBF8  02802021   ADDU A0, S4, ZERO            814:       move a0, T
9D00CBFC  0F4065D6   JAL 0x9D019758               815:       jal rintf
9D00CC00  1000FDDF   BEQ ZERO, ZERO, 0x9D00C380   816:       b next
9D00CC04  0040A021   ADDU S4, V0, ZERO            817:       move T, v0
                                                  818:   
                                                  819:   num: //
                                                  820:   
9D00CC08  1000FDDD   BEQ ZERO, ZERO, 0x9D00C380   821:       b next
9D00CC0C  00000000   NOP                          822:       nop
                                                  823:   
                                                  824:   badop: //
9D00CC10  01001021   ADDU V0, T0, ZERO            825:       move v0,t0
                                                  826:   exit_vm:
9D00CC14  8FB00000   LW S0, 0(SP)                 827:       lw  s0,0(sp)
9D00CC18  8FB10004   LW S1, 4(SP)                 828:       lw  s1,4(sp)
9D00CC1C  8FB20008   LW S2, 8(SP)                 829:       lw  s2,8(sp)
9D00CC20  8FB3000C   LW S3, 12(SP)                830:       lw  s3,12(sp)
9D00CC24  8FB40010   LW S4, 16(SP)                831:       lw  s4,16(sp)
9D00CC28  8FB50014   LW S5, 20(SP)                832:       lw  s5,20(sp)
9D00CC2C  8FB60018   LW S6, 24(SP)                833:       lw  s6,24(sp)
9D00CC30  8FB7001C   LW S7, 28(SP)                834:       lw  s7, 28(sp)
9D00CC34  8FBE0020   LW S8, 32(SP)                835:       lw  s8, 32(sp)
9D00CC38  8FBF0024   LW RA, 36(SP)                836:       lw  ra,36(sp)
9D00CC3C  03E00008   JR RA                        837:       jr  ra
9D00CC40  27BD0028   ADDIU SP, SP, 40             838:       addiu sp,sp,40
                                                  839:   
                                                  840:   
                                                  841:   .end StackVM
                                                  842:   
                                                  843:   //.ent fetch_int
                                                  844:   //fetch_int:  // empile un entier little indian dans espace code VM, retourne dans v0
                                                  845:   //    lbu v0, 0(ip)
                                                  846:   //    lbu t0, 1(ip)
                                                  847:   //    ins v0,t0,8,8
                                                  848:   //    lbu t0, 2(ip)
                                                  849:   //    ins v0,t0,16,8
                                                  850:   //    lbu t0,3(ip)
                                                  851:   //    ins v0,t0,24,8
                                                  852:   //    j ra
                                                  853:   //    addiu ip,ip,CELL_SIZE
                                                  854:   //    
                                                  855:   //
                                                  856:   //.end fetch_int
                                                  857:   
                                                  858:   
                                                  859:   
                                                  860:   // routines names must be in same order as OP_CODES enum in vm.h    
                                                  861:   opcodes_table:
                                                  862:   .word lit,docol,exit,bra,qbra,exec,store,fetch,cstore
                                                  863:   .word cfetch,rfetch,ufetch,ustore,tor,rfrom,drop,dup,swap,over,pick
                                                  864:   .word plus,minus,star,ustar,mstar,umstar,slash,uslash,modulo,umsmod,msmod,ltz
                                                  865:   .word zequal, bitand,bitor
                                                  866:   .word bitxor,bitnot,clit, wlit, ticks, delay
                                                  867:   .word qdup, oneplus, oneminus,plusstore, twostar, twoslash, twodrop, rot, twodup
                                                  868:   .word  min, max, abs, lshift, rshift, divmod, qbraz, dcnt, rcnt
                                                  869:   .word equal,nequal, less, greater,ltez,gtez, dodo,unloop,ifetch,jfetch,loop, ploop,user
                                                  870:   .word sine, cos, tan, atan, acos, asin,random,trunc,num
                                                  871:   .word key,qrx,emit,dotq,cr,dot
                                                  872:   .word bye
                                                  873:       
                                                  874:   #undef _ASM_CODE_
---  /home/jacques/github/vpc-32vga/vpcBASIC/testVM.c  --------------------------------------------------
1:                   /*  StackVM test
2:                    */
3:                   
4:                   #if defined _VM_TEST_
5:                   
6:                   #include <string.h>
7:                   #include <plib.h>
8:                   
9:                   #include "vm.h"
10:                  #include "../console.h"
11:                  
12:                  extern int stackVM(const char* code, int* variables);
13:                  
14:                  
15:                  
16:                  // variables système Forth
17:                  #define BASE (0)
18:                  #define DP (BASE+CELL_SIZE)
19:                  #define TOIN (DP+CELL_SIZE)
20:                  #define TSOURCE (TOIN+CELL_SIZE) // adresse et longueur
21:                  #define LATEST (TSOURCE+2*CELL_SIZE) // lien dernière entrée dictionnaire
22:                  #define TIB (LATEST+CELL_SIZE)
23:                  #define PAD (TIB+CELL_SIZE)
24:                  #define STATE (PAD+CELL_SIZE)
25:                  #define HP (STATE+CELL_SIZE)
26:                  #define FIRST_USER (HP+CELL_SIZE)
27:                  
28:                  //const char* vm_words[]={
29:                  //    "BYE","LITERAL","DOCOL","RET","BRA","?BRA","EXEC","!","@","C!","C@",
30:                  //};
31:                  
32:                  const unsigned char test_code[]={
33:                      ICLIT,-1,ICLIT,2,IDO,IIFETCH,IDOT,ICLIT,-1,IPLOOP,5,ICR,
34:                      ICLIT,8,ICLIT,0,IDO,IIFETCH,IDOT,ICLIT,1,IPLOOP,5,ICR,
35:                      IDOTQ,5,'H','E','L','L','O',ICR,
36:                      IWLIT,24,0,ICLIT,4,ISTAR,ILIT,6,0,0,0,ISLASH,IBYE};
37:                  
38:                  //void compile(char *line,int size,int dp){
39:                  //    
40:                  //}
41:                  
42:                  void test_vm(){
9D018AF0  27BDFFE0   ADDIU SP, SP, -32
9D018AF4  AFBF001C   SW RA, 28(SP)
9D018AF8  AFB10018   SW S1, 24(SP)
9D018AFC  AFB00014   SW S0, 20(SP)
43:                      int* variables;
44:                      int dp=0,size;
45:                  //    unsigned char* code;
46:                  //    char line[80];
47:                  //    code=malloc(8192);
48:                  #define VAR_SIZE (128)    
49:                      variables=malloc(VAR_SIZE);
9D018B00  0F404DAF   JAL malloc
9D018B04  24040080   ADDIU A0, ZERO, 128
9D018B08  00408021   ADDU S0, V0, ZERO
50:                      print_int(LOCAL_CON,StackVM(test_code,strlen(test_code),variables,VAR_SIZE),0);
9D018B0C  3C119D02   LUI S1, -25342
9D018B10  0F405701   JAL strlen
9D018B14  262494E8   ADDIU A0, S1, -27416
9D018B18  262494E8   ADDIU A0, S1, -27416
9D018B1C  00402821   ADDU A1, V0, ZERO
9D018B20  02003021   ADDU A2, S0, ZERO
9D018B24  0F4030D0   JAL StackVM
9D018B28  24070080   ADDIU A3, ZERO, 128
9D018B2C  00002021   ADDU A0, ZERO, ZERO
9D018B30  00402821   ADDU A1, V0, ZERO
9D018B34  0F402C58   JAL print_int
9D018B38  00003021   ADDU A2, ZERO, ZERO
51:                  //    while (1){
52:                  //        if (!(size=readline(LOCAL_CON,line,80))) break;
53:                  //        upper(line);
54:                  //        if (!strcmp(line,"RUN")){
55:                  //            print_hex(LOCAL_CON,StackVM(code,variables),0);
56:                  //            print(LOCAL_CON," ok\r");
57:                  //            dp=0;
58:                  //            memset(code,0,8192);
59:                  //        }else{
60:                  //            compile(line,size,dp);
61:                  //        }
62:                  //    }
63:                      free(variables);
9D018B3C  0F40656A   JAL free
9D018B40  02002021   ADDU A0, S0, ZERO
64:                  //    free(code);
65:                  }
9D018B44  8FBF001C   LW RA, 28(SP)
9D018B48  8FB10018   LW S1, 24(SP)
9D018B4C  8FB00014   LW S0, 20(SP)
9D018B50  03E00008   JR RA
9D018B54  27BD0020   ADDIU SP, SP, 32
66:                  
67:                  #endif
---  /home/jacques/github/vpc-32vga/vpc-32.c  -----------------------------------------------------------
1:                   /*
2:                   * Copyright 2013,2016,2018 Jacques Deschênes
3:                   * This file is part of VPC-32VGA.
4:                   *
5:                   *     VPC-32VGA is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-3VGA is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /* 
20:                   * File:   vpc-32.c
21:                   * Author: Jacques Deschênes
22:                   *
23:                   * Created on 26 août 2013, 07:38
24:                   */
25:                  
26:                  
27:                  #include <stdio.h>
28:                  #include <stdlib.h>
29:                  #include <plib.h>
30:                  #include "graphics.h"
31:                  
32:                  #include "hardware/HardwareProfile.h"
33:                  #include "hardware/tvout/vga.h"
34:                  #include "hardware/serial_comm/serial_comm.h"
35:                  #include "hardware/ps2_kbd/keyboard.h"
36:                  #include "hardware/Pinguino/diskio.h"
37:                  #include "hardware/Pinguino/fileio.h"
38:                  #include "console.h"
39:                  #include "hardware/Pinguino/ff.h"
40:                  #include "vpcBASIC/vm.h"
41:                  #include "vpcBASIC/vpcBASIC.h"
42:                  #include "hardware/sound/sound.h"
43:                  
44:                  // PIC32MX150F128B Configuration Bit Settings
45:                  #include <xc.h>
46:                  
47:                  // DEVCFG3
48:                  // USERID = No Setting
49:                  #pragma config PMDL1WAY = OFF           // permet plusieurs configurations des périphériques.
50:                  #pragma config IOL1WAY = OFF            // permet plusieurs configuration des broches.
51:                  
52:                  // DEVCFG2
53:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
54:                  #if SYSCLK==50000000L
55:                  #pragma config FPLLMUL = MUL_20
56:                  #elif SYSCLK==40000000L
57:                  #pragma config FPLLMUL = MUL_16         // SYSCLK=40Mhz
58:                  #else
59:                  #pragma config FPLLMUL = MUL_15          // PLL Multiplier (15x Multiplier) SYSCLK=37,5Mhz
60:                  #endif
61:                  #pragma config FPLLODIV = DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
62:                  
63:                  // DEVCFG1
64:                  #pragma config FNOSC = PRIPLL           // Oscillator Selection Bits (Primary Osc w/PLL (XT+,HS+,EC+PLL))
65:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
66:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
67:                  #pragma config POSCMOD = HS             // Primary Oscillator Configuration (XT osc mode)
68:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
69:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
70:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
71:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
72:                  
73:                  // DEVCFG0
74:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
75:                  #pragma config ICESEL = RESERVED        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
76:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
77:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
78:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
79:                  
80:                  
81:                  
82:                  #if defined _DEBUG_
83:                  const char *msg1="video target\r";
84:                  const char *msg2="0123456789";
85:                  
86:                  
87:                  
88:                  void test_pattern(void){
89:                      int i,j;
90:                      for (i=0;i<VRES;i++){
91:                          video_bmp[i][0]=0x80000000;
92:                          video_bmp[i][HRES/32-1]=1;
93:                      }
94:                      for (i=0;i<HRES/32;i++){
95:                          video_bmp[0][i]=0xffffffff;
96:                          video_bmp[VRES-1][i]=0xffffffff;
97:                      }
98:                      for (i=VRES/4;i<VRES/2+VRES/4;i++){
99:                          video_bmp[i][2]=0xFF00FF00;
100:                         video_bmp[i][3]=0xF0F0F0F0;
101:                         video_bmp[i][4]=0xcccccccc;
102:                         video_bmp[i][5]=0xaaaaaaaa;
103:                     }//i
104:                     print(LOCAL_CON,msg1);
105:                     for (i=0;i<8;i++) print(LOCAL_CON,msg2);
106:                     delay_ms(1000);
107:                 }//test_pattern()
108:                 
109:                 const int pts[6]={HRES/2,VRES/2,HRES/2+HRES/3,VRES/2+VRES/3,HRES/2-HRES/3,VRES/2+VRES/3};
110:                 
111:                 void graphics_test(){ // test des fonctions graphiques
112:                     int i;
113:                 
114:                     rectangle(0,0,HRES-1,VRES-1);
115:                     polygon(pts,3);
116:                     circle(HRES/2,VRES/2,100);
117:                     for (i=0;i<100;i++){
118:                         ellipse(HRES/3+i,VRES/3+i,50,30);
119:                     }
120:                     bezier(20,200,20,40,300,40);
121:                     delay_ms(500);
122:                 }//graphics_test
123:                 
124:                 #endif
125:                 
126:                 const unsigned int e3k[]={ // rencontre du 3ième type
127:                 784,500, // sol4
128:                 880,500, // la4
129:                 698,500, // fa4
130:                 349,500, // fa3
131:                 523,500, // do4
132:                 0,0
133:                 };
134:                 
135:                 
136:                 
137:                 //__attribute__((mips16))
138:                 void main(void) {
9D017524  27BDFFE8   ADDIU SP, SP, -24
9D017528  AFBF0014   SW RA, 20(SP)
139:                 #if defined _DEBUG_
140:                     debug=-1;
141:                 #endif  
142:                     HardwareInit();
9D01752C  0F4037C3   JAL HardwareInit
9D017530  00000000   NOP
143:                     UartInit(STDIO,115200,DEFAULT_LINE_CTRL);
9D017534  24040001   ADDIU A0, ZERO, 1
9D017538  3C050001   LUI A1, 1
9D01753C  34A5C200   ORI A1, A1, -15872
9D017540  0F404625   JAL UartInit
9D017544  00003021   ADDU A2, ZERO, ZERO
144:                     heap_size=free_heap();
9D017548  0F40388E   JAL free_heap
9D01754C  00000000   NOP
9D017550  AF828058   SW V0, -32680(GP)
145:                 #if defined _DEBUG_
146:                     test_pattern();
147:                 #endif
148:                     DebugPrint("video initialization\r");
9D017554  3C049D01   LUI A0, -25343
9D017558  0F4046E7   JAL DebugPrint
9D01755C  24847DDC   ADDIU A0, A0, 32220
149:                     VideoInit();
9D017560  0F403AEF   JAL VideoInit
9D017564  00000000   NOP
150:                     DebugPrint("keyboard initialization\r");
9D017568  3C049D01   LUI A0, -25343
9D01756C  0F4046E7   JAL DebugPrint
9D017570  24847DF4   ADDIU A0, A0, 32244
151:                     KeyboardInit();
9D017574  0F4054AD   JAL KeyboardInit
9D017578  00000000   NOP
152:                 //    text_coord_t cpos;
153:                     DebugPrint("SD initialization: ");
9D01757C  3C049D01   LUI A0, -25343
9D017580  0F4046E7   JAL DebugPrint
9D017584  24847E10   ADDIU A0, A0, 32272
154:                     if (!mount(0)){
9D017588  0F4042F9   JAL mount
9D01758C  00002021   ADDU A0, ZERO, ZERO
9D017590  54400006   BNEL V0, ZERO, 0x9D0175AC
9D017594  3C049D01   LUI A0, -25343
155:                         DebugPrint("Failed\r");
9D017598  3C049D01   LUI A0, -25343
9D01759C  0F4046E7   JAL DebugPrint
9D0175A0  24847E24   ADDIU A0, A0, 32292
9D0175A4  0B405D6F   J 0x9D0175BC
9D0175A8  AF808068   SW ZERO, -32664(GP)
156:                         SDCardReady=FALSE;
157:                     }else{
158:                         DebugPrint("OK\r");
9D0175AC  0F4046E7   JAL DebugPrint
9D0175B0  24847E2C   ADDIU A0, A0, 32300
159:                         SDCardReady=TRUE;
9D0175B4  24020001   ADDIU V0, ZERO, 1
9D0175B8  AF828068   SW V0, -32664(GP)
160:                     }
161:                     DebugPrint("SRAM initialization\r");
9D0175BC  3C049D01   LUI A0, -25343
9D0175C0  0F4046E7   JAL DebugPrint
9D0175C4  24847E30   ADDIU A0, A0, 32304
162:                     sram_init();
9D0175C8  0F403EAF   JAL sram_init
9D0175CC  00000000   NOP
163:                     //test_vm();
164:                 #if defined _DEBUG_    
165:                     // sram test
166:                     circle(HRES/2,VRES/2,100);
167:                     delay_ms(1000);
168:                     sram_write_block(0,&video_bmp,HRES*VRES/8);
169:                     clear_screen();
170:                     delay_ms(1000);
171:                     sram_read_block(0,&video_bmp,HRES*VRES/8);
172:                     delay_ms(1000);
173:                     DebugPrint("sound test.\r");
174:                 #endif    
175:                     DebugPrint("initialization completed.\r");
9D0175D0  3C049D01   LUI A0, -25343
9D0175D4  0F4046E7   JAL DebugPrint
9D0175D8  24847E48   ADDIU A0, A0, 32328
176:                     tune((unsigned int*)&e3k[0]);
9D0175DC  3C049D01   LUI A0, -25343
9D0175E0  0F40499F   JAL tune
9D0175E4  24847E64   ADDIU A0, A0, 32356
177:                 //    set_cursor(CR_BLOCK); // sauvegare video_buffer dans SRAM
178:                 //    clear_screen();
179:                 //    unsigned char c;
180:                 //    while (1){
181:                 //        c=wait_key(LOCAL_CON);
182:                 //        put_char(LOCAL_CON,c);
183:                 //    }
184:                 #if defined _DEBUG_
185:                     graphics_test();
186:                     set_curpos(0,LINE_PER_SCREEN-1);
187:                     print(comm_channel,"test");
188:                     sram_write_block(100000,video_bmp,BMP_SIZE);
189:                     delay_ms(1000);
190:                     clear_screen();
191:                     delay_ms(1000);
192:                     sram_read_block(100000,video_bmp,BMP_SIZE);
193:                     delay_ms(1000);
194:                     clear_screen();
195:                 //    print(comm_channel,"heap_size: ");
196:                 //    print_int(comm_channel,heap_size,0);
197:                 //    crlf();
198:                 #endif
199:                     shell();
9D0175E8  0F402776   JAL shell
9D0175EC  00000000   NOP
200:                 } // main()
9D0175F0  8FBF0014   LW RA, 20(SP)
9D0175F4  03E00008   JR RA
9D0175F8  27BD0018   ADDIU SP, SP, 24
201:                 
202:                 
---  /home/jacques/github/vpc-32vga/shell.c  ------------------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  
20:                  /*
21:                   * File:   shell.h
22:                   * Author: Jacques Deschênes
23:                   *
24:                   * Created on 18 septembre 2013, 07:29
25:                   * Description: un environnement de commande simple pour le VPC-32.
26:                   *   liste des commandes:
27:                   *      ls     liste des fichiers sur la carte SD
28:                   *      rm     efface un fichier.
29:                   *      mv     renomme un fichier.
30:                   *      ed     ouvre l'éditeur
31:                   *      as     assemble un fichier écris en assembleur pour la machine virtuelle.
32:                   *      run    execute un programme compilé pour la machine virtuelle.
33:                   *      cp     copie un fichier
34:                   *      snd    envoie un fichier vers le port sériel
35:                   *      rcv    reçois un fichier par le port sériel
36:                   *      forth  lance l'environnement vpForth
37:                   *      puts mot  imprime à l'écran le mot qui suis
38:                   *      expr {expression}  évalue une expression et retourne le résultat
39:                   */
40:                  
41:                  #include <stdio.h>
42:                  #include <string.h>
43:                  #include <plib.h>
44:                  
45:                  #include "hardware/HardwareProfile.h"
46:                  #include "hardware/ps2_kbd/keyboard.h"
47:                  #include "console.h"
48:                  #include "hardware/Pinguino/ff.h"
49:                  #include "hardware/Pinguino/fileio.h"
50:                  #include "shell.h"
51:                  #include "vpcBASIC/vpcBASIC.h"
52:                  
53:                  #define MAX_LINE_LEN 80
54:                  #define MAX_TOKEN 5
55:                  
56:                  /*
57:                  typedef enum {
58:                      ERR_NONE=0,
59:                      ERR_NOT_DONE,
60:                      ERR_ALLOC,
61:                      ERR_USAGE,
62:                      ERR_FIL_OPEN,
63:                      ERR_CPY,
64:                      ERR_MKDIR,
65:                      ERR_NOTEXIST,
66:                      ERR_DENIED,
67:                      ERR_FIO
68:                  } SH_ERROR;
69:                  */
70:                  
71:                  const char *ERR_MSG[]={
72:                      "no error\r",
73:                      "not implemented yet.\r",
74:                      "Memory allocation error.\r",
75:                      "Bad usage.\r",
76:                      "File open error.\r",
77:                      "Copy error.\r",
78:                      "Mkdir error.\r",
79:                      "file does not exist.\r",
80:                      "operation denied.\r",
81:                      "disk operation error, code is %d \r",
82:                      "no SD card detected.\r"
83:                  };
84:                  
85:                  void print_error_msg(SH_ERROR err_code,const char *detail,FRESULT io_code){
9D008554  27BDFFE0   ADDIU SP, SP, -32
9D008558  AFBF001C   SW RA, 28(SP)
9D00855C  AFB20018   SW S2, 24(SP)
9D008560  AFB10014   SW S1, 20(SP)
9D008564  AFB00010   SW S0, 16(SP)
86:                      char *fmt;
87:                      if (err_code==ERR_FIO){
9D008568  24020009   ADDIU V0, ZERO, 9
9D00856C  14820012   BNE A0, V0, 0x9D0085B8
9D008570  00A08021   ADDU S0, A1, ZERO
9D008574  00C08821   ADDU S1, A2, ZERO
88:                          fmt=malloc(64);
9D008578  0F404DAF   JAL malloc
9D00857C  24040040   ADDIU A0, ZERO, 64
89:                          if (fmt){
9D008580  10400014   BEQ V0, ZERO, 0x9D0085D4
9D008584  00409021   ADDU S2, V0, ZERO
90:                              sprintf(fmt,ERR_MSG[ERR_FIO],io_code);
9D008588  00402021   ADDU A0, V0, ZERO
9D00858C  3C02A000   LUI V0, -24576
9D008590  8C4548BC   LW A1, 18620(V0)
9D008594  0F4062F0   JAL sprintf
9D008598  02203021   ADDU A2, S1, ZERO
91:                              print(comm_channel,fmt);
9D00859C  9784803C   LHU A0, -32708(GP)
9D0085A0  0F402C18   JAL print
9D0085A4  02402821   ADDU A1, S2, ZERO
92:                              free(fmt);
9D0085A8  0F40656A   JAL free
9D0085AC  02402021   ADDU A0, S2, ZERO
9D0085B0  0B402175   J 0x9D0085D4
9D0085B4  00000000   NOP
93:                          }
94:                      }else{
95:                         print(comm_channel,ERR_MSG[err_code]);
9D0085B8  00042080   SLL A0, A0, 2
9D0085BC  3C02A000   LUI V0, -24576
9D0085C0  24424898   ADDIU V0, V0, 18584
9D0085C4  00821021   ADDU V0, A0, V0
9D0085C8  9784803C   LHU A0, -32708(GP)
9D0085CC  0F402C18   JAL print
9D0085D0  8C450000   LW A1, 0(V0)
96:                      }
97:                      if (detail){
9D0085D4  12000003   BEQ S0, ZERO, 0x9D0085E4
9D0085D8  9784803C   LHU A0, -32708(GP)
98:                         print(comm_channel,detail);
9D0085DC  0F402C18   JAL print
9D0085E0  02002821   ADDU A1, S0, ZERO
99:                      }
100:                 }//print_error_msg()
9D0085E4  8FBF001C   LW RA, 28(SP)
9D0085E8  8FB20018   LW S2, 24(SP)
9D0085EC  8FB10014   LW S1, 20(SP)
9D0085F0  8FB00010   LW S0, 16(SP)
9D0085F4  03E00008   JR RA
9D0085F8  27BD0020   ADDIU SP, SP, 32
101:                 
102:                 typedef struct{
103:                     char buff[MAX_LINE_LEN]; // chaîne saisie par l'utilisateur.
104:                     unsigned char len;  // longueur de la chaîne.
105:                     unsigned char first; // position du premier caractère du mot
106:                     unsigned char next; // position du curseur de l'analyseur.
107:                 } input_buff_t;
108:                 
109:                 static input_buff_t cmd_line;
110:                 static char *cmd_tokens[MAX_TOKEN];
111:                 
112:                 typedef enum CMDS {CMD_CD, CMD_CLEAR,CMD_CPY,CMD_DATE,CMD_DEL,CMD_DIR,CMD_ED,CMD_EXPR,
113:                                    CMD_FREE,CMD_FORMAT,CMD_FORTH,CMD_HDUMP,CMD_HELP,CMD_MKDIR,CMD_MOUNT,CMD_MORE,
114:                                    CMD_PUTS,CMD_REBOOT,CMD_RCV,CMD_REN,CMD_SND,CMD_TIME,CMD_UMOUNT,CMD_UPTIME
115:                                    } cmds_t;
116:                 
117:                 #define CMD_LEN 24
118:                 const char *commands[CMD_LEN]={"cd","cls","copy","date","del","dir","edit",
119:                     "expr","free","format","forth","hdump","help","mkdir","mount","more","puts","reboot","receive",
120:                     "ren","send","time","umount","uptime"};
121:                 
122:                 
123:                 int cmd_search(char *target){
9D0085FC  27BDFFD8   ADDIU SP, SP, -40
9D008600  AFBF0024   SW RA, 36(SP)
9D008604  AFB30020   SW S3, 32(SP)
9D008608  AFB2001C   SW S2, 28(SP)
9D00860C  AFB10018   SW S1, 24(SP)
9D008610  AFB00014   SW S0, 20(SP)
9D008614  00809021   ADDU S2, A0, ZERO
9D008618  3C11A000   LUI S1, -24576
9D00861C  26314894   ADDIU S1, S1, 18580
124:                     int i;
125:                     for (i=CMD_LEN-1;i>=0;i--){
9D008620  24100017   ADDIU S0, ZERO, 23
9D008624  2413FFFF   ADDIU S3, ZERO, -1
9D00863C  2610FFFF   ADDIU S0, S0, -1
9D008640  1613FFF9   BNE S0, S3, 0x9D008628
9D008644  2631FFFC   ADDIU S1, S1, -4
126:                         if (!strcmp(target,commands[i])){
9D008628  02402021   ADDU A0, S2, ZERO
9D00862C  0F405988   JAL strcmp
9D008630  8E250000   LW A1, 0(S1)
9D008634  10400005   BEQ V0, ZERO, 0x9D00864C
9D008638  02001021   ADDU V0, S0, ZERO
127:                             break;
128:                         }
129:                     }
130:                     return i;
131:                 }//cmd_search()
9D008648  02001021   ADDU V0, S0, ZERO
9D00864C  8FBF0024   LW RA, 36(SP)
9D008650  8FB30020   LW S3, 32(SP)
9D008654  8FB2001C   LW S2, 28(SP)
9D008658  8FB10018   LW S1, 24(SP)
9D00865C  8FB00014   LW S0, 20(SP)
9D008660  03E00008   JR RA
9D008664  27BD0028   ADDIU SP, SP, 40
132:                 
133:                 void display_cmd_list(){
9D008668  27BDFFC8   ADDIU SP, SP, -56
9D00866C  AFBF0034   SW RA, 52(SP)
9D008670  AFB50030   SW S5, 48(SP)
9D008674  AFB4002C   SW S4, 44(SP)
9D008678  AFB30028   SW S3, 40(SP)
9D00867C  AFB20024   SW S2, 36(SP)
9D008680  AFB10020   SW S1, 32(SP)
9D008684  AFB0001C   SW S0, 28(SP)
9D008688  3C11A000   LUI S1, -24576
9D00868C  26314838   ADDIU S1, S1, 18488
134:                     int i;
135:                     text_coord_t pos;
136:                     for(i=0;i<CMD_LEN;i++){
9D008690  00008021   ADDU S0, ZERO, ZERO
9D0086A0  24130018   ADDIU S3, ZERO, 24
9D0086F4  26100001   ADDIU S0, S0, 1
9D0086F8  1613FFEA   BNE S0, S3, 0x9D0086A4
9D0086FC  26310004   ADDIU S1, S1, 4
137:                         pos=get_curpos();
9D0086A4  0F402CC3   JAL get_curpos
9D0086A8  27A40010   ADDIU A0, SP, 16
9D0086AC  02209021   ADDU S2, S1, ZERO
138:                         if (pos.x>(CHAR_PER_LINE-strlen(commands[i])-2)){
9D008694  2414004E   ADDIU S4, ZERO, 78
9D0086B0  0F405701   JAL strlen
9D0086B4  8E240000   LW A0, 0(S1)
9D0086B8  97A30010   LHU V1, 16(SP)
9D0086BC  02821023   SUBU V0, S4, V0
9D0086C0  0043182B   SLTU V1, V0, V1
9D0086C4  10600004   BEQ V1, ZERO, 0x9D0086D8
9D0086C8  9784803C   LHU A0, -32708(GP)
139:                             put_char(comm_channel,'\r');
9D0086CC  0F402B85   JAL put_char
9D0086D0  2405000D   ADDIU A1, ZERO, 13
140:                         }
141:                         print(comm_channel,commands[i]);
9D0086D4  9784803C   LHU A0, -32708(GP)
9D0086D8  0F402C18   JAL print
9D0086DC  8E450000   LW A1, 0(S2)
142:                         if (i<(CMD_LEN-1)){
9D0086E0  2A020017   SLTI V0, S0, 23
9D0086E4  10400003   BEQ V0, ZERO, 0x9D0086F4
9D0086E8  9784803C   LHU A0, -32708(GP)
143:                             print(comm_channel," ");
9D008698  3C159D01   LUI S5, -25343
9D00869C  26B5F564   ADDIU S5, S5, -2716
9D0086EC  0F402C18   JAL print
9D0086F0  02A02821   ADDU A1, S5, ZERO
144:                         }
145:                     }
146:                     put_char(comm_channel,'\r');
9D008700  9784803C   LHU A0, -32708(GP)
9D008704  0F402B85   JAL put_char
9D008708  2405000D   ADDIU A1, ZERO, 13
147:                 }
9D00870C  8FBF0034   LW RA, 52(SP)
9D008710  8FB50030   LW S5, 48(SP)
9D008714  8FB4002C   LW S4, 44(SP)
9D008718  8FB30028   LW S3, 40(SP)
9D00871C  8FB20024   LW S2, 36(SP)
9D008720  8FB10020   LW S1, 32(SP)
9D008724  8FB0001C   LW S0, 28(SP)
9D008728  03E00008   JR RA
9D00872C  27BD0038   ADDIU SP, SP, 56
148:                 
149:                 // imprime le temps depuis
150:                 // le démarrage de l'ordinateur
151:                 void cmd_uptime(){
9D008730  27BDFFC0   ADDIU SP, SP, -64
9D008734  AFBF003C   SW RA, 60(SP)
152:                     unsigned sys_ticks;
153:                     unsigned day,hour,min,sec,remainder;
154:                     char fmt[32];
155:                     
156:                     sys_ticks=ticks();
9D008738  0F40382F   JAL ticks
9D00873C  00000000   NOP
157:                     day=sys_ticks/86400000L;
158:                     remainder=sys_ticks%86400000L;
9D008740  3C0631B5   LUI A2, 12725
9D008744  34C6D43B   ORI A2, A2, -11205
9D008748  00460019   MULTU 0, V0, A2
9D00874C  00003010   MFHI A2
9D008750  00061E02   SRL V1, A2, 24
9D008754  3C040526   LUI A0, 1318
9D008758  24845C00   ADDIU A0, A0, 23552
9D00875C  70642802   MUL A1, V1, A0
9D008760  00451823   SUBU V1, V0, A1
159:                     hour=remainder/3600000L;
160:                     remainder%=3600000L;
9D008764  3C079521   LUI A3, -27359
9D008768  24E77CB1   ADDIU A3, A3, 31921
9D00876C  00670019   MULTU 0, V1, A3
9D008770  00003810   MFHI A3
9D008774  00071542   SRL V0, A3, 21
9D008778  00022080   SLL A0, V0, 2
9D00877C  000229C0   SLL A1, V0, 7
9D008780  00A42023   SUBU A0, A1, A0
9D008784  00821021   ADDU V0, A0, V0
9D008788  00022100   SLL A0, V0, 4
9D00878C  00821023   SUBU V0, A0, V0
9D008790  00022100   SLL A0, V0, 4
9D008794  00821023   SUBU V0, A0, V0
9D008798  000211C0   SLL V0, V0, 7
9D00879C  00621023   SUBU V0, V1, V0
161:                     min=remainder/60000;
9D0087A0  3C0345E7   LUI V1, 17895
9D0087A4  3463B273   ORI V1, V1, -19853
9D0087A8  00430019   MULTU 0, V0, V1
9D0087AC  00001810   MFHI V1
9D0087B0  00031B82   SRL V1, V1, 14
162:                     remainder%=60000;
9D0087B8  00032080   SLL A0, V1, 2
9D0087BC  000329C0   SLL A1, V1, 7
9D0087C0  00A42023   SUBU A0, A1, A0
9D0087C4  00831821   ADDU V1, A0, V1
9D0087C8  00032100   SLL A0, V1, 4
9D0087CC  00831823   SUBU V1, A0, V1
9D0087D0  00031940   SLL V1, V1, 5
9D0087D4  00431023   SUBU V0, V0, V1
163:                     sec=remainder/1000;
9D0087D8  3C041062   LUI A0, 4194
9D0087DC  24844DD3   ADDIU A0, A0, 19923
9D0087E0  00440019   MULTU 0, V0, A0
9D0087E4  00001010   MFHI V0
9D0087E8  00021182   SRL V0, V0, 6
164:                     sprintf(fmt,"%02dd%02dh%02dm%02ds\n",day,hour,min,sec);
9D0087B4  AFA30010   SW V1, 16(SP)
9D0087EC  AFA20014   SW V0, 20(SP)
9D0087F0  27A40018   ADDIU A0, SP, 24
9D0087F4  3C059D01   LUI A1, -25343
9D0087F8  24A5F568   ADDIU A1, A1, -2712
9D0087FC  00063602   SRL A2, A2, 24
9D008800  0F4062F0   JAL sprintf
9D008804  00073D42   SRL A3, A3, 21
165:                     print(comm_channel,fmt);
9D008808  9784803C   LHU A0, -32708(GP)
9D00880C  0F402C18   JAL print
9D008810  27A50018   ADDIU A1, SP, 24
166:                 }
9D008814  8FBF003C   LW RA, 60(SP)
9D008818  03E00008   JR RA
9D00881C  27BD0040   ADDIU SP, SP, 64
167:                 
168:                 
169:                 void cmd_format(int i){
9D008820  27BDFFE8   ADDIU SP, SP, -24
170:                     if (i==2){
9D008824  24020002   ADDIU V0, ZERO, 2
9D008828  14820007   BNE A0, V0, 0x9D008848
9D00882C  AFBF0014   SW RA, 20(SP)
171:                         print_error_msg(ERR_NOT_DONE,NULL,0);
9D008830  24040001   ADDIU A0, ZERO, 1
9D008834  00002821   ADDU A1, ZERO, ZERO
9D008838  0F402155   JAL print_error_msg
9D00883C  00003021   ADDU A2, ZERO, ZERO
9D008840  0B402217   J 0x9D00885C
9D008844  8FBF0014   LW RA, 20(SP)
172:                     }else{
173:                         print(comm_channel,"USAGE: format volume_name\r");
9D008848  9784803C   LHU A0, -32708(GP)
9D00884C  3C059D01   LUI A1, -25343
9D008850  0F402C18   JAL print
9D008854  24A5F580   ADDIU A1, A1, -2688
174:                     }
175:                 }
9D008858  8FBF0014   LW RA, 20(SP)
9D00885C  03E00008   JR RA
9D008860  27BD0018   ADDIU SP, SP, 24
176:                 
177:                 void cmd_forth(int i){
9D008864  27BDFFE8   ADDIU SP, SP, -24
9D008868  AFBF0014   SW RA, 20(SP)
178:                     test_vm();
9D00886C  0F4062BC   JAL test_vm
9D008870  00000000   NOP
9D0099CC  0F4062BC   JAL test_vm
9D0099D0  00000000   NOP
179:                 }
9D008874  8FBF0014   LW RA, 20(SP)
9D008878  03E00008   JR RA
9D00887C  27BD0018   ADDIU SP, SP, 24
180:                 
181:                 static int next_token(void){
182:                     unsigned char loop,quote,escape;
183:                     cmd_line.first=cmd_line.next;
9D009BE4  3C13A000   LUI S3, -24576
9D009C44  26624A5C   ADDIU V0, S3, 19036
9D009C48  90500052   LBU S0, 82(V0)
9D009C4C  A0500051   SB S0, 81(V0)
184:                     while (cmd_line.first<cmd_line.len && (cmd_line.buff[cmd_line.first]==' ' ||
9D009BE8  24110020   ADDIU S1, ZERO, 32
9D009BEC  24120009   ADDIU S2, ZERO, 9
9D009C50  90440050   LBU A0, 80(V0)
9D009C54  0204102B   SLTU V0, S0, A0
9D009C58  10400049   BEQ V0, ZERO, 0x9D009D80
9D009C5C  26634A5C   ADDIU V1, S3, 19036
9D009C60  0B402723   J 0x9D009C8C
9D009C64  02031021   ADDU V0, S0, V1
9D009C6C  0204102B   SLTU V0, S0, A0
9D009C70  14400006   BNE V0, ZERO, 0x9D009C8C
9D009C74  02031021   ADDU V0, S0, V1
9D009C78  3C02A000   LUI V0, -24576
9D009C7C  24424A5C   ADDIU V0, V0, 19036
9D009C80  A0500051   SB S0, 81(V0)
9D009C8C  80420000   LB V0, 0(V0)
9D009C90  5051FFF5   BEQL V0, S1, 0x9D009C68
9D009C94  26100001   ADDIU S0, S0, 1
9D009C98  5052FFF3   BEQL V0, S2, 0x9D009C68
9D009C9C  26100001   ADDIU S0, S0, 1
9D009CA0  26624A5C   ADDIU V0, S3, 19036
9D009CA4  A0500051   SB S0, 81(V0)
185:                             cmd_line.buff[cmd_line.first]==9)){
186:                         cmd_line.first++;
9D009C68  321000FF   ANDI S0, S0, 255
187:                     }
188:                     cmd_line.next=cmd_line.first;
9D009C84  0B402769   J 0x9D009DA4
9D009C88  A0500052   SB S0, 82(V0)
9D009CA8  A0500052   SB S0, 82(V0)
9D009D80  3C02A000   LUI V0, -24576
9D009D84  0B402769   J 0x9D009DA4
9D009D88  A0504AAE   SB S0, 19118(V0)
9D009D8C  A0430052   SB V1, 82(V0)
189:                     loop=TRUE;
190:                     quote=FALSE;
9D009CC0  00004021   ADDU T0, ZERO, ZERO
191:                     escape=FALSE;
9D009CBC  00003821   ADDU A3, ZERO, ZERO
192:                     while (loop && (cmd_line.next<cmd_line.len)){
9D009CAC  0204102B   SLTU V0, S0, A0
9D009CB0  1040003C   BEQ V0, ZERO, 0x9D009DA4
9D009CB4  02003021   ADDU A2, S0, ZERO
9D009CB8  02001821   ADDU V1, S0, ZERO
9D009D50  0064102B   SLTU V0, V1, A0
9D009D54  1440FFDC   BNE V0, ZERO, 0x9D009CC8
9D009D58  00603021   ADDU A2, V1, ZERO
9D009D5C  26624A5C   ADDIU V0, S3, 19036
9D009D60  A0430052   SB V1, 82(V0)
193:                         switch (cmd_line.buff[cmd_line.next]){
9D009BF0  24140022   ADDIU S4, ZERO, 34
9D009BF4  0B402711   J 0x9D009C44
9D009BF8  2415005C   ADDIU S5, ZERO, 92
9D009CC4  26694A5C   ADDIU T1, S3, 19036
9D009CC8  00691021   ADDU V0, V1, T1
9D009CCC  80420000   LB V0, 0(V0)
9D009CD0  1051000D   BEQ V0, S1, 0x9D009D08
9D009CD4  28450021   SLTI A1, V0, 33
9D009CD8  10A00005   BEQ A1, ZERO, 0x9D009CF0
9D009CDC  00000000   NOP
9D009CE0  10520009   BEQ V0, S2, 0x9D009D08
9D009CE4  00000000   NOP
9D009CF0  1054000D   BEQ V0, S4, 0x9D009D28
9D009CF4  00000000   NOP
9D009CF8  10550009   BEQ V0, S5, 0x9D009D20
9D009CFC  2CE20001   SLTIU V0, A3, 1
194:                             case ' ':
195:                             case 9: // TAB
196:                                 if (!quote){
9D009D08  55000010   BNEL T0, ZERO, 0x9D009D4C
9D009D0C  24C30001   ADDIU V1, A2, 1
197:                                     cmd_line.next--;
9D009D10  26624A5C   ADDIU V0, S3, 19036
9D009D14  2463FFFF   ADDIU V1, V1, -1
9D009D18  0B402765   J 0x9D009D94
9D009D1C  A0430052   SB V1, 82(V0)
198:                                     loop=FALSE;
199:                                 }
200:                                 break;
201:                             case '\\':
202:                                 if (quote){
203:                                     if (!escape){
9D009D20  0B402752   J 0x9D009D48
9D009D24  0048380B   MOVN A3, V0, T0
204:                                        escape=TRUE;
205:                                     }
206:                                     else{
207:                                         escape=FALSE;
208:                                     }
209:                                 }
210:                                 break;
211:                             case '"':
212:                                 if (!quote){
9D009D28  51000007   BEQL T0, ZERO, 0x9D009D48
9D009D2C  24080001   ADDIU T0, ZERO, 1
213:                                     quote=1;
214:                                 }
215:                                 else if (!escape){
9D009D30  10E00016   BEQ A3, ZERO, 0x9D009D8C
9D009D34  26624A5C   ADDIU V0, S3, 19036
216:                                     loop=FALSE;
217:                                 }else{
218:                                     escape=FALSE;
9D009D38  0B402752   J 0x9D009D48
9D009D3C  00003821   ADDU A3, ZERO, ZERO
219:                                 }
220:                                 break;
221:                             default:
222:                                 if (quote && escape){
9D009CE8  0B402752   J 0x9D009D48
9D009CEC  0008380B   MOVN A3, ZERO, T0
9D009D00  0B402750   J 0x9D009D40
9D009D04  0008380B   MOVN A3, ZERO, T0
223:                                     escape=FALSE;
224:                                 }
225:                         }//switch
226:                         cmd_line.next++;
9D009D40  0B402753   J 0x9D009D4C
9D009D44  24C30001   ADDIU V1, A2, 1
9D009D48  24C30001   ADDIU V1, A2, 1
9D009D4C  306300FF   ANDI V1, V1, 255
9D009D90  26624A5C   ADDIU V0, S3, 19036
9D009D94  90430052   LBU V1, 82(V0)
9D009D98  24630001   ADDIU V1, V1, 1
9D009D9C  0B402759   J 0x9D009D64
9D009DA0  A0430052   SB V1, 82(V0)
227:                     } // while
228:                     if (cmd_line.next>cmd_line.first)
9D009D64  26624A5C   ADDIU V0, S3, 19036
9D009D68  90570052   LBU S7, 82(V0)
229:                         return 1;
230:                     else
231:                         return 0;
232:                 }//next_token()
233:                 
234:                 void cd(int i){ // change le répertoire courant.
9D008880  27BDFFE8   ADDIU SP, SP, -24
9D008884  AFBF0014   SW RA, 20(SP)
9D008888  AFB00010   SW S0, 16(SP)
235:                     char *path;
236:                     if (!SDCardReady){
9D00888C  8F828068   LW V0, -32664(GP)
9D008890  1440000C   BNE V0, ZERO, 0x9D0088C4
9D008894  00808021   ADDU S0, A0, ZERO
237:                         if (!mount(0)){
9D008898  0F4042F9   JAL mount
9D00889C  00002021   ADDU A0, ZERO, ZERO
9D0088A0  14400007   BNE V0, ZERO, 0x9D0088C0
9D0088A4  24020001   ADDIU V0, ZERO, 1
238:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D0088A8  2404000A   ADDIU A0, ZERO, 10
9D0088AC  00002821   ADDU A1, ZERO, ZERO
9D0088B0  0F402155   JAL print_error_msg
9D0088B4  00003021   ADDU A2, ZERO, ZERO
239:                             return;
9D0088B8  0B402249   J 0x9D008924
9D0088BC  8FBF0014   LW RA, 20(SP)
240:                         }else{
241:                             SDCardReady=TRUE;
9D0088C0  AF828068   SW V0, -32664(GP)
242:                         }
243:                     }
244:                     FRESULT error=FR_OK;
245:                    if (i==2){
9D0088C4  24020002   ADDIU V0, ZERO, 2
9D0088C8  16020005   BNE S0, V0, 0x9D0088E0
9D0088CC  3C02A000   LUI V0, -24576
246:                        error=f_chdir(cmd_tokens[1]);
9D0088D0  0F4008E3   JAL f_chdir
9D0088D4  8C444A4C   LW A0, 19020(V0)
247:                    }
248:                    if (!error){
9D0088D8  14400012   BNE V0, ZERO, 0x9D008924
9D0088DC  8FBF0014   LW RA, 20(SP)
249:                        path=malloc(255);
9D0088E0  0F404DAF   JAL malloc
9D0088E4  240400FF   ADDIU A0, ZERO, 255
250:                        if (path){
9D0088E8  1040000D   BEQ V0, ZERO, 0x9D008920
9D0088EC  00408021   ADDU S0, V0, ZERO
251:                           error=f_getcwd(path,255);
9D0088F0  00402021   ADDU A0, V0, ZERO
9D0088F4  0F400910   JAL f_getcwd
9D0088F8  240500FF   ADDIU A1, ZERO, 255
252:                           if(!error){
9D0088FC  14400006   BNE V0, ZERO, 0x9D008918
9D008900  9784803C   LHU A0, -32708(GP)
253:                               print(comm_channel,path);
9D008904  0F402C18   JAL print
9D008908  02002821   ADDU A1, S0, ZERO
254:                               put_char(comm_channel,'\r');
9D00890C  9784803C   LHU A0, -32708(GP)
9D008910  0F402B85   JAL put_char
9D008914  2405000D   ADDIU A1, ZERO, 13
255:                           }
256:                           free(path);
9D008918  0F40656A   JAL free
9D00891C  02002021   ADDU A0, S0, ZERO
257:                        }
258:                    }
259:                 }//cd()
9D008920  8FBF0014   LW RA, 20(SP)
9D008924  8FB00010   LW S0, 16(SP)
9D008928  03E00008   JR RA
9D00892C  27BD0018   ADDIU SP, SP, 24
260:                 
261:                 void del(int i){ // efface un fichier
9D008930  27BDFFE0   ADDIU SP, SP, -32
9D008934  AFBF001C   SW RA, 28(SP)
9D008938  AFB10018   SW S1, 24(SP)
9D00893C  AFB00014   SW S0, 20(SP)
262:                     FILINFO *fi;
263:                     if (!SDCardReady){
9D008940  8F828068   LW V0, -32664(GP)
9D008944  1440000C   BNE V0, ZERO, 0x9D008978
9D008948  00808021   ADDU S0, A0, ZERO
264:                         if (!mount(0)){
9D00894C  0F4042F9   JAL mount
9D008950  00002021   ADDU A0, ZERO, ZERO
9D008954  14400007   BNE V0, ZERO, 0x9D008974
9D008958  24020001   ADDIU V0, ZERO, 1
265:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D00895C  2404000A   ADDIU A0, ZERO, 10
9D008960  00002821   ADDU A1, ZERO, ZERO
9D008964  0F402155   JAL print_error_msg
9D008968  00003021   ADDU A2, ZERO, ZERO
266:                             return;
9D00896C  0B402297   J 0x9D008A5C
9D008970  8FBF001C   LW RA, 28(SP)
267:                         }else{
268:                             SDCardReady=TRUE;
9D008974  AF828068   SW V0, -32664(GP)
269:                         }
270:                     }
271:                     FRESULT error=FR_OK;
272:                     if (i==2){
9D008978  24020002   ADDIU V0, ZERO, 2
9D00897C  1602002D   BNE S0, V0, 0x9D008A34
9D008980  24040003   ADDIU A0, ZERO, 3
273:                         fi=malloc(sizeof(FILINFO));
9D008984  0F404DAF   JAL malloc
9D008988  24040018   ADDIU A0, ZERO, 24
274:                         if (fi){
9D00898C  10400022   BEQ V0, ZERO, 0x9D008A18
9D008990  00408021   ADDU S0, V0, ZERO
275:                             error=f_stat(cmd_tokens[1],fi);
9D008994  3C02A000   LUI V0, -24576
9D008998  8C444A4C   LW A0, 19020(V0)
9D00899C  0F400B1D   JAL f_stat
9D0089A0  02002821   ADDU A1, S0, ZERO
276:                             if (!error){
9D0089A4  14400029   BNE V0, ZERO, 0x9D008A4C
9D0089A8  00408821   ADDU S1, V0, ZERO
277:                                 if (fi->fattrib & (ATT_DIR|ATT_RO)){
9D0089AC  92020008   LBU V0, 8(S0)
9D0089B0  30420011   ANDI V0, V0, 17
9D0089B4  1040000A   BEQ V0, ZERO, 0x9D0089E0
9D0089B8  3C02A000   LUI V0, -24576
278:                                     print_error_msg(ERR_DENIED,"can't delete directory or read only file.\r",0);
9D0089BC  24040008   ADDIU A0, ZERO, 8
9D0089C0  3C059D01   LUI A1, -25343
9D0089C4  24A5F59C   ADDIU A1, A1, -2660
9D0089C8  0F402155   JAL print_error_msg
9D0089CC  00003021   ADDU A2, ZERO, ZERO
279:                                 }
280:                                 else{
281:                                     error=f_unlink(cmd_tokens[1]);
9D0089E0  0F400C07   JAL f_unlink
9D0089E4  8C444A4C   LW A0, 19020(V0)
9D0089E8  00408821   ADDU S1, V0, ZERO
282:                                 }
283:                             }
284:                             free(fi);
9D0089D0  0F40656A   JAL free
9D0089D4  02002021   ADDU A0, S0, ZERO
9D0089EC  0F40656A   JAL free
9D0089F0  02002021   ADDU A0, S0, ZERO
9D008A4C  0F40656A   JAL free
9D008A50  02002021   ADDU A0, S0, ZERO
285:                             if (error){
9D0089F4  52200019   BEQL S1, ZERO, 0x9D008A5C
9D0089F8  8FBF001C   LW RA, 28(SP)
286:                                 print_error_msg(ERR_FIO,"",error);
9D0089FC  24040009   ADDIU A0, ZERO, 9
9D008A00  3C059D01   LUI A1, -25343
9D008A04  24A5F5C8   ADDIU A1, A1, -2616
9D008A08  0F402155   JAL print_error_msg
9D008A0C  02203021   ADDU A2, S1, ZERO
9D008A54  0B402280   J 0x9D008A00
9D008A58  24040009   ADDIU A0, ZERO, 9
287:                             }
288:                         }else{
289:                                print_error_msg(ERR_ALLOC,"delete failed.\r",0);
9D008A18  24040002   ADDIU A0, ZERO, 2
9D008A1C  3C059D01   LUI A1, -25343
9D008A20  24A5F5CC   ADDIU A1, A1, -2612
9D008A24  0F402155   JAL print_error_msg
9D008A28  00003021   ADDU A2, ZERO, ZERO
290:                         }
291:                    }else{
292:                        print_error_msg(ERR_USAGE, "delete file USAGE: del file_name\r",0);
9D008A34  3C059D01   LUI A1, -25343
9D008A38  24A5F5DC   ADDIU A1, A1, -2596
9D008A3C  0F402155   JAL print_error_msg
9D008A40  00003021   ADDU A2, ZERO, ZERO
293:                    }
294:                 }//del()
9D0089D8  0B402297   J 0x9D008A5C
9D0089DC  8FBF001C   LW RA, 28(SP)
9D008A10  0B402297   J 0x9D008A5C
9D008A14  8FBF001C   LW RA, 28(SP)
9D008A2C  0B402297   J 0x9D008A5C
9D008A30  8FBF001C   LW RA, 28(SP)
9D008A44  0B402297   J 0x9D008A5C
9D008A48  8FBF001C   LW RA, 28(SP)
9D008A5C  8FB10018   LW S1, 24(SP)
9D008A60  8FB00014   LW S0, 20(SP)
9D008A64  03E00008   JR RA
9D008A68  27BD0020   ADDIU SP, SP, 32
295:                 
296:                 void ren(int i){ // renomme un fichier
9D008A6C  27BDFFE8   ADDIU SP, SP, -24
9D008A70  AFBF0014   SW RA, 20(SP)
9D008A74  AFB00010   SW S0, 16(SP)
297:                     if (!SDCardReady){
9D008A78  8F828068   LW V0, -32664(GP)
9D008A7C  1440000C   BNE V0, ZERO, 0x9D008AB0
9D008A80  00808021   ADDU S0, A0, ZERO
298:                         if (!mount(0)){
9D008A84  0F4042F9   JAL mount
9D008A88  00002021   ADDU A0, ZERO, ZERO
9D008A8C  14400007   BNE V0, ZERO, 0x9D008AAC
9D008A90  24020001   ADDIU V0, ZERO, 1
299:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D008A94  2404000A   ADDIU A0, ZERO, 10
9D008A98  00002821   ADDU A1, ZERO, ZERO
9D008A9C  0F402155   JAL print_error_msg
9D008AA0  00003021   ADDU A2, ZERO, ZERO
300:                             return;
9D008AA4  0B4022BB   J 0x9D008AEC
9D008AA8  8FBF0014   LW RA, 20(SP)
301:                         }else{
302:                             SDCardReady=TRUE;
9D008AAC  AF828068   SW V0, -32664(GP)
303:                         }
304:                     }
305:                     if (i==3){
9D008AB0  24020003   ADDIU V0, ZERO, 3
9D008AB4  16020008   BNE S0, V0, 0x9D008AD8
9D008AB8  24040003   ADDIU A0, ZERO, 3
306:                         f_rename(cmd_tokens[1],cmd_tokens[2]);
9D008ABC  3C02A000   LUI V0, -24576
9D008AC0  24424A48   ADDIU V0, V0, 19016
9D008AC4  8C440004   LW A0, 4(V0)
9D008AC8  0F400D88   JAL f_rename
9D008ACC  8C450008   LW A1, 8(V0)
9D008AD0  0B4022BB   J 0x9D008AEC
9D008AD4  8FBF0014   LW RA, 20(SP)
307:                     }else{
308:                         print_error_msg(ERR_USAGE,"rename file, USAGE: ren name new_name\r",0);
9D008AD8  3C059D01   LUI A1, -25343
9D008ADC  24A5F600   ADDIU A1, A1, -2560
9D008AE0  0F402155   JAL print_error_msg
9D008AE4  00003021   ADDU A2, ZERO, ZERO
309:                     }
310:                 }//ren
9D008AE8  8FBF0014   LW RA, 20(SP)
9D008AEC  8FB00010   LW S0, 16(SP)
9D008AF0  03E00008   JR RA
9D008AF4  27BD0018   ADDIU SP, SP, 24
311:                 
312:                 void copy(int i){ // copie un fichier
9D008AF8  27BDFFD0   ADDIU SP, SP, -48
9D008AFC  AFBF002C   SW RA, 44(SP)
9D008B00  AFB30028   SW S3, 40(SP)
9D008B04  AFB20024   SW S2, 36(SP)
9D008B08  AFB10020   SW S1, 32(SP)
9D008B0C  AFB0001C   SW S0, 28(SP)
313:                     FIL *fsrc, *fnew;
314:                     char *buff;
315:                     int n;
316:                     if (!SDCardReady){
9D008B10  8F828068   LW V0, -32664(GP)
9D008B14  1440000C   BNE V0, ZERO, 0x9D008B48
9D008B18  00808021   ADDU S0, A0, ZERO
317:                         if (!mount(0)){
9D008B1C  0F4042F9   JAL mount
9D008B20  00002021   ADDU A0, ZERO, ZERO
9D008B24  14400007   BNE V0, ZERO, 0x9D008B44
9D008B28  24020001   ADDIU V0, ZERO, 1
318:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D008B2C  2404000A   ADDIU A0, ZERO, 10
9D008B30  00002821   ADDU A1, ZERO, ZERO
9D008B34  0F402155   JAL print_error_msg
9D008B38  00003021   ADDU A2, ZERO, ZERO
319:                             return;
320:                         }else{
321:                             SDCardReady=TRUE;
9D008B44  AF828068   SW V0, -32664(GP)
322:                         }
323:                     }
324:                     FRESULT error;
325:                     if (i==3){
9D008B48  24020003   ADDIU V0, ZERO, 3
9D008B4C  16020035   BNE S0, V0, 0x9D008C24
9D008B50  24040003   ADDIU A0, ZERO, 3
326:                         fsrc=malloc(sizeof(FIL));
9D008B54  0F404DAF   JAL malloc
9D008B58  24040028   ADDIU A0, ZERO, 40
9D008B5C  00408821   ADDU S1, V0, ZERO
327:                         fnew=malloc(sizeof(FIL));
9D008B60  0F404DAF   JAL malloc
9D008B64  24040028   ADDIU A0, ZERO, 40
9D008B68  00409821   ADDU S3, V0, ZERO
328:                         buff=malloc(512);
9D008B6C  0F404DAF   JAL malloc
9D008B70  24040200   ADDIU A0, ZERO, 512
329:                         error=FR_OK;
330:                         if (fsrc && fnew && buff){
9D008B74  12200025   BEQ S1, ZERO, 0x9D008C0C
9D008B78  00408021   ADDU S0, V0, ZERO
9D008B7C  12600024   BEQ S3, ZERO, 0x9D008C10
9D008B80  9784803C   LHU A0, -32708(GP)
9D008B84  10400021   BEQ V0, ZERO, 0x9D008C0C
9D008B88  02202021   ADDU A0, S1, ZERO
331:                             if ((error=f_open(fsrc,cmd_tokens[1],FA_READ)==FR_OK) &&
9D008B8C  3C02A000   LUI V0, -24576
9D008B90  8C454A4C   LW A1, 19020(V0)
9D008B94  0F400664   JAL f_open
9D008B98  24060001   ADDIU A2, ZERO, 1
9D008B9C  14400043   BNE V0, ZERO, 0x9D008CAC
9D008BA0  8FBF002C   LW RA, 44(SP)
9D008BB8  1440003C   BNE V0, ZERO, 0x9D008CAC
9D008BBC  8FBF002C   LW RA, 44(SP)
332:                                 (error=f_open(fnew,cmd_tokens[2],FA_CREATE_NEW|FA_WRITE)==FR_OK)){
9D008BA4  02602021   ADDU A0, S3, ZERO
9D008BA8  3C02A000   LUI V0, -24576
9D008BAC  8C454A50   LW A1, 19024(V0)
9D008BB0  0F400664   JAL f_open
9D008BB4  24060006   ADDIU A2, ZERO, 6
333:                                 while ((error=f_read(fsrc,buff,512,&n))==FR_OK){
9D008BC0  0B4022FB   J 0x9D008BEC
9D008BC4  02202021   ADDU A0, S1, ZERO
9D008BE8  02202021   ADDU A0, S1, ZERO
9D008BEC  02002821   ADDU A1, S0, ZERO
9D008BF0  24060200   ADDIU A2, ZERO, 512
9D008BF4  0F40070C   JAL f_read
9D008BF8  27A70010   ADDIU A3, SP, 16
9D008BFC  1040FFF2   BEQ V0, ZERO, 0x9D008BC8
9D008C00  00409021   ADDU S2, V0, ZERO
9D008C04  0B40231B   J 0x9D008C6C
9D008C08  00000000   NOP
334:                                     if (n){
9D008BC8  8FA60010   LW A2, 16(SP)
9D008BCC  10C0001B   BEQ A2, ZERO, 0x9D008C3C
9D008BD0  02602021   ADDU A0, S3, ZERO
335:                                         if (!((error=f_write(fnew,buff,n,&n))==FR_OK)){
9D008BD4  02002821   ADDU A1, S0, ZERO
9D008BD8  0F4007B8   JAL f_write
9D008BDC  27A70010   ADDIU A3, SP, 16
9D008BE0  14400022   BNE V0, ZERO, 0x9D008C6C
9D008BE4  00409021   ADDU S2, V0, ZERO
336:                                             break;
337:                                         }
338:                                     }else{
339:                                          break;
340:                                     }
341:                                 }//while
342:                                 f_close(fsrc);
9D008C3C  0F4008D2   JAL f_close
9D008C40  02202021   ADDU A0, S1, ZERO
9D008C6C  0F4008D2   JAL f_close
9D008C70  02202021   ADDU A0, S1, ZERO
343:                                 f_close(fnew);
9D008C44  0F4008D2   JAL f_close
9D008C48  02602021   ADDU A0, S3, ZERO
9D008C74  0F4008D2   JAL f_close
9D008C78  02602021   ADDU A0, S3, ZERO
344:                                 free(buff);
9D008C4C  0F40656A   JAL free
9D008C50  02002021   ADDU A0, S0, ZERO
9D008C7C  0F40656A   JAL free
9D008C80  02002021   ADDU A0, S0, ZERO
345:                                 free(fsrc);
9D008C54  0F40656A   JAL free
9D008C58  02202021   ADDU A0, S1, ZERO
9D008C84  0F40656A   JAL free
9D008C88  02202021   ADDU A0, S1, ZERO
346:                                 free(fnew);
9D008C5C  0F40656A   JAL free
9D008C60  02602021   ADDU A0, S3, ZERO
9D008C8C  0F40656A   JAL free
9D008C90  02602021   ADDU A0, S3, ZERO
347:                             }
348:                             if (error){
349:                                 print_error_msg(ERR_FIO,"copy failed.\r",error);
9D008C94  24040009   ADDIU A0, ZERO, 9
9D008C98  3C059D01   LUI A1, -25343
9D008C9C  24A5F658   ADDIU A1, A1, -2472
9D008CA0  0F402155   JAL print_error_msg
9D008CA4  02403021   ADDU A2, S2, ZERO
350:                             }
351:                         }else{
352:                             print(comm_channel,ERR_MSG[ERR_ALLOC]);
9D008C0C  9784803C   LHU A0, -32708(GP)
9D008C10  3C02A000   LUI V0, -24576
9D008C14  0F402C18   JAL print
9D008C18  8C4548A0   LW A1, 18592(V0)
353:                         }
354:                     }else{
355:                         print_error_msg(ERR_USAGE,"copy file USAGE: copy file_name new_file_name\r",0);
9D008C24  3C059D01   LUI A1, -25343
9D008C28  24A5F628   ADDIU A1, A1, -2520
9D008C2C  0F402155   JAL print_error_msg
9D008C30  00003021   ADDU A2, ZERO, ZERO
356:                     }
357:                 }//copy()
9D008B3C  0B40232B   J 0x9D008CAC
9D008B40  8FBF002C   LW RA, 44(SP)
9D008C1C  0B40232B   J 0x9D008CAC
9D008C20  8FBF002C   LW RA, 44(SP)
9D008C34  0B40232B   J 0x9D008CAC
9D008C38  8FBF002C   LW RA, 44(SP)
9D008C64  0B40232B   J 0x9D008CAC
9D008C68  8FBF002C   LW RA, 44(SP)
9D008CA8  8FBF002C   LW RA, 44(SP)
9D008CAC  8FB30028   LW S3, 40(SP)
9D008CB0  8FB20024   LW S2, 36(SP)
9D008CB4  8FB10020   LW S1, 32(SP)
9D008CB8  8FB0001C   LW S0, 28(SP)
9D008CBC  03E00008   JR RA
9D008CC0  27BD0030   ADDIU SP, SP, 48
358:                 
359:                 void cmd_send(int i){ // envoie un fichier via uart
9D008CC4  27BDFFE8   ADDIU SP, SP, -24
360:                     // to do
361:                    if (i==2){
9D008CC8  24020002   ADDIU V0, ZERO, 2
9D008CCC  14820007   BNE A0, V0, 0x9D008CEC
9D008CD0  AFBF0014   SW RA, 20(SP)
362:                        print_error_msg(ERR_NOT_DONE,NULL,0);
9D008CD4  24040001   ADDIU A0, ZERO, 1
9D008CD8  00002821   ADDU A1, ZERO, ZERO
9D008CDC  0F402155   JAL print_error_msg
9D008CE0  00003021   ADDU A2, ZERO, ZERO
9D008CE4  0B402340   J 0x9D008D00
9D008CE8  8FBF0014   LW RA, 20(SP)
363:                    }else{
364:                        print(comm_channel, "send file via serial, USAGE: send file_name\r");
9D008CEC  9784803C   LHU A0, -32708(GP)
9D008CF0  3C059D01   LUI A1, -25343
9D008CF4  0F402C18   JAL print
9D008CF8  24A5F668   ADDIU A1, A1, -2456
365:                    }
366:                 }//cmd_send()
9D008CFC  8FBF0014   LW RA, 20(SP)
9D008D00  03E00008   JR RA
9D008D04  27BD0018   ADDIU SP, SP, 24
367:                 
368:                 void receive(int i){ // reçois un fichier via uart
9D008D08  27BDFFE8   ADDIU SP, SP, -24
369:                     // to do
370:                    if (i==2){
9D008D0C  24020002   ADDIU V0, ZERO, 2
9D008D10  14820007   BNE A0, V0, 0x9D008D30
9D008D14  AFBF0014   SW RA, 20(SP)
371:                        print_error_msg(ERR_NOT_DONE,NULL,0);
9D008D18  24040001   ADDIU A0, ZERO, 1
9D008D1C  00002821   ADDU A1, ZERO, ZERO
9D008D20  0F402155   JAL print_error_msg
9D008D24  00003021   ADDU A2, ZERO, ZERO
9D008D28  0B402351   J 0x9D008D44
9D008D2C  8FBF0014   LW RA, 20(SP)
372:                    }else{
373:                        print(comm_channel, "receive file from serial, USAGE: receive file_name\r");
9D008D30  9784803C   LHU A0, -32708(GP)
9D008D34  3C059D01   LUI A1, -25343
9D008D38  0F402C18   JAL print
9D008D3C  24A5F698   ADDIU A1, A1, -2408
374:                    }
375:                 }//receive()
9D008D40  8FBF0014   LW RA, 20(SP)
9D008D44  03E00008   JR RA
9D008D48  27BD0018   ADDIU SP, SP, 24
376:                 
377:                 void cmd_hdump(int i){ // affiche un fichier en hexadécimal
9D008D4C  27BDFFA0   ADDIU SP, SP, -96
9D008D50  AFBF005C   SW RA, 92(SP)
9D008D54  AFBE0058   SW S8, 88(SP)
9D008D58  AFB70054   SW S7, 84(SP)
9D008D5C  AFB60050   SW S6, 80(SP)
9D008D60  AFB5004C   SW S5, 76(SP)
9D008D64  AFB40048   SW S4, 72(SP)
9D008D68  AFB30044   SW S3, 68(SP)
9D008D6C  AFB20040   SW S2, 64(SP)
9D008D70  AFB1003C   SW S1, 60(SP)
9D008D74  AFB00038   SW S0, 56(SP)
378:                     FIL *fh;
379:                     unsigned char *fmt, *buff, *rbuff, c,key,line[18];
380:                     int n,col=0,scr_line=0;
9D008E30  0000B821   ADDU S7, ZERO, ZERO
9D008E34  00008021   ADDU S0, ZERO, ZERO
381:                     unsigned addr=0;
9D008E2C  0000B021   ADDU S6, ZERO, ZERO
382:                     
383:                     if (!SDCardReady){
9D008D78  8F828068   LW V0, -32664(GP)
9D008D7C  1440000C   BNE V0, ZERO, 0x9D008DB0
9D008D80  00808021   ADDU S0, A0, ZERO
384:                         if (!mount(0)){
9D008D84  0F4042F9   JAL mount
9D008D88  00002021   ADDU A0, ZERO, ZERO
9D008D8C  14400007   BNE V0, ZERO, 0x9D008DAC
9D008D90  24020001   ADDIU V0, ZERO, 1
385:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D008D94  2404000A   ADDIU A0, ZERO, 10
9D008D98  00002821   ADDU A1, ZERO, ZERO
9D008D9C  0F402155   JAL print_error_msg
9D008DA0  00003021   ADDU A2, ZERO, ZERO
386:                             return;
387:                         }else{
388:                             SDCardReady=TRUE;
9D008DAC  AF828068   SW V0, -32664(GP)
389:                         }
390:                     }
391:                     FRESULT error=FR_OK;
9D00900C  00001021   ADDU V0, ZERO, ZERO
392:                     if (i==2){
9D008DB0  24020002   ADDIU V0, ZERO, 2
9D008DB4  1602009D   BNE S0, V0, 0x9D00902C
9D008DB8  24040003   ADDIU A0, ZERO, 3
393:                         fh=malloc(sizeof(FIL));
9D008DBC  0F404DAF   JAL malloc
9D008DC0  24040028   ADDIU A0, ZERO, 40
394:                         if (fh && ((error=f_open(fh,cmd_tokens[1],FA_READ))==FR_OK)){
9D008DC4  10400091   BEQ V0, ZERO, 0x9D00900C
9D008DC8  AFA2002C   SW V0, 44(SP)
9D008DCC  00402021   ADDU A0, V0, ZERO
9D008DD0  3C02A000   LUI V0, -24576
9D008DD4  8C454A4C   LW A1, 19020(V0)
9D008DD8  0F400664   JAL f_open
9D008DDC  24060001   ADDIU A2, ZERO, 1
9D008DE0  1440008C   BNE V0, ZERO, 0x9D009014
9D008DE4  24040009   ADDIU A0, ZERO, 9
395:                             if (comm_channel==LOCAL_CON) clear_screen();
9D008DE8  9782803C   LHU V0, -32708(GP)
9D008DEC  14400003   BNE V0, ZERO, 0x9D008DFC
9D008DF0  00000000   NOP
9D008DF4  0F402B6F   JAL clear_screen
9D008DF8  00000000   NOP
396:                             buff=malloc(512);
9D008DFC  0F404DAF   JAL malloc
9D008E00  24040200   ADDIU A0, ZERO, 512
9D008E04  AFA20028   SW V0, 40(SP)
397:                             fmt=malloc(CHAR_PER_LINE);
9D008E08  0F404DAF   JAL malloc
9D008E0C  24040050   ADDIU A0, ZERO, 80
398:                             if (fmt && buff){
9D008E10  10400077   BEQ V0, ZERO, 0x9D008FF0
9D008E14  00409821   ADDU S3, V0, ZERO
9D008E18  8FA20028   LW V0, 40(SP)
9D008E1C  10400074   BEQ V0, ZERO, 0x9D008FF0
9D008E20  2402000D   ADDIU V0, ZERO, 13
399:                                 key=0;
9D008E38  0000A021   ADDU S4, ZERO, ZERO
400:                                 line[16]=CR;
9D008E24  A3A20020   SB V0, 32(SP)
401:                                 line[17]=0;
9D008E28  A3A00021   SB ZERO, 33(SP)
402:                                 while (key!=ESC && f_read(fh,buff,512,&n)==FR_OK){
9D008F34  2402001B   ADDIU V0, ZERO, 27
9D008F38  16820009   BNE S4, V0, 0x9D008F60
9D008F3C  8FA4002C   LW A0, 44(SP)
9D008F40  0B4023DE   J 0x9D008F78
9D008F44  00000000   NOP
9D008F5C  8FA4002C   LW A0, 44(SP)
9D008F60  8FA50028   LW A1, 40(SP)
9D008F64  24060200   ADDIU A2, ZERO, 512
9D008F68  0F40070C   JAL f_read
9D008F6C  27A70024   ADDIU A3, SP, 36
9D008F70  1040FFB7   BEQ V0, ZERO, 0x9D008E50
9D008F74  8FA20024   LW V0, 36(SP)
403:                                     if (!n) break;
9D008E50  10400049   BEQ V0, ZERO, 0x9D008F78
9D008E54  2402001B   ADDIU V0, ZERO, 27
404:                                     rbuff=buff;
405:                                     for(;n && key!=ESC;n--){
9D008E58  12820047   BEQ S4, V0, 0x9D008F78
9D008E5C  8FB20028   LW S2, 40(SP)
9D008F24  8FA20024   LW V0, 36(SP)
9D008F28  2442FFFF   ADDIU V0, V0, -1
9D008F2C  14400006   BNE V0, ZERO, 0x9D008F48
9D008F30  AFA20024   SW V0, 36(SP)
9D008F48  2402001B   ADDIU V0, ZERO, 27
9D008F4C  1682FFC7   BNE S4, V0, 0x9D008E6C
9D008F50  00000000   NOP
9D008F54  0B4023DE   J 0x9D008F78
9D008F58  00000000   NOP
406:                                         if (!col){
9D008E6C  56000009   BNEL S0, ZERO, 0x9D008E94
9D008E70  26520001   ADDIU S2, S2, 1
407:                                             sprintf(fmt,"%08X  ",addr);
9D008E3C  3C1E9D01   LUI S8, -25343
9D008E40  27DEF6CC   ADDIU S8, S8, -2356
9D008E74  02602021   ADDU A0, S3, ZERO
9D008E78  03C02821   ADDU A1, S8, ZERO
9D008E7C  0F4062F0   JAL sprintf
9D008E80  02C03021   ADDU A2, S6, ZERO
408:                                             print(comm_channel,fmt);
9D008E84  9784803C   LHU A0, -32708(GP)
9D008E88  0F402C18   JAL print
9D008E8C  02602821   ADDU A1, S3, ZERO
409:                                         }
410:                                         c=*rbuff++;
9D008E90  26520001   ADDIU S2, S2, 1
9D008E94  9251FFFF   LBU S1, -1(S2)
411:                                         sprintf(fmt,"%02X ",c);
9D008E44  3C159D01   LUI S5, -25343
9D008E48  0B4023D7   J 0x9D008F5C
9D008E4C  26B5F6D4   ADDIU S5, S5, -2348
9D008E98  02602021   ADDU A0, S3, ZERO
9D008E9C  02A02821   ADDU A1, S5, ZERO
9D008EA0  0F4062F0   JAL sprintf
9D008EA4  02203021   ADDU A2, S1, ZERO
412:                                         //print_hex(comm_channel,c,2); put_char(comm_channel,32);
413:                                         if (c>=32) line[col]=c; else line[col]=32;
9D008EA8  2E220020   SLTIU V0, S1, 32
9D008EAC  14400004   BNE V0, ZERO, 0x9D008EC0
9D008EB0  24030020   ADDIU V1, ZERO, 32
9D008EB4  03B01021   ADDU V0, SP, S0
9D008EB8  0B4023B2   J 0x9D008EC8
9D008EBC  A0510010   SB S1, 16(V0)
9D008EC0  03B01021   ADDU V0, SP, S0
9D008EC4  A0430010   SB V1, 16(V0)
414:                                         print(comm_channel,fmt);
9D008EC8  9784803C   LHU A0, -32708(GP)
9D008ECC  0F402C18   JAL print
9D008ED0  02602821   ADDU A1, S3, ZERO
415:                                         col++;
9D008ED4  26100001   ADDIU S0, S0, 1
416:                                         if (col==16){
9D008ED8  24020010   ADDIU V0, ZERO, 16
9D008EDC  16020012   BNE S0, V0, 0x9D008F28
9D008EE0  8FA20024   LW V0, 36(SP)
417:                                             print(comm_channel,line);
9D008EE4  9784803C   LHU A0, -32708(GP)
9D008EE8  0F402C18   JAL print
9D008EEC  27A50010   ADDIU A1, SP, 16
418:                                             col=0;
419:                                             addr+=16;
9D008EF0  26D60010   ADDIU S6, S6, 16
420:                                             scr_line++;
9D008EF4  26F70001   ADDIU S7, S7, 1
421:                                             if (scr_line==(LINE_PER_SCREEN-1)){
9D008EF8  2402001D   ADDIU V0, ZERO, 29
9D008EFC  16E20009   BNE S7, V0, 0x9D008F24
9D008F00  00008021   ADDU S0, ZERO, ZERO
422:                                                 print(comm_channel,"more...");
9D008E60  3C029D01   LUI V0, -25343
9D008E64  2442F6DC   ADDIU V0, V0, -2340
9D008E68  AFA20030   SW V0, 48(SP)
9D008F04  9784803C   LHU A0, -32708(GP)
9D008F08  0F402C18   JAL print
9D008F0C  8FA50030   LW A1, 48(SP)
423:                                                 key=wait_key(comm_channel);
9D008F10  0F402D86   JAL wait_key
9D008F14  9784803C   LHU A0, -32708(GP)
424:                                                 clear_screen();
9D008F18  0F402B6F   JAL clear_screen
9D008F1C  0040A021   ADDU S4, V0, ZERO
425:                                                 scr_line=0;
9D008F20  0000B821   ADDU S7, ZERO, ZERO
426:                                             }
427:                                         }
428:                                     }
429:                                 }
430:                                 if (col){
9D008F78  12000013   BEQ S0, ZERO, 0x9D008FC8
9D008F7C  3C020020   LUI V0, 32
431:                                     strcpy(fmt,"   ");
9D008F80  24422020   ADDIU V0, V0, 8224
9D008F84  AE620000   SW V0, 0(S3)
432:                                     while (col<16){
9D008F88  2A020010   SLTI V0, S0, 16
9D008F8C  1040000B   BEQ V0, ZERO, 0x9D008FBC
9D008F90  27A20010   ADDIU V0, SP, 16
9D008F94  00508021   ADDU S0, V0, S0
9D008F98  27B20020   ADDIU S2, SP, 32
9D008FB4  5612FFFB   BNEL S0, S2, 0x9D008FA4
9D008FB8  9784803C   LHU A0, -32708(GP)
433:                                         print(comm_channel,fmt);
9D008FA0  9784803C   LHU A0, -32708(GP)
9D008FA4  0F402C18   JAL print
9D008FA8  02602821   ADDU A1, S3, ZERO
434:                                         line[col]=32;
9D008F9C  24110020   ADDIU S1, ZERO, 32
9D008FAC  A2110000   SB S1, 0(S0)
9D008FB0  26100001   ADDIU S0, S0, 1
435:                                         col++;
436:                                     }
437:                                     print(comm_channel,line);
9D008FBC  9784803C   LHU A0, -32708(GP)
9D008FC0  0F402C18   JAL print
9D008FC4  27A50010   ADDIU A1, SP, 16
438:                                 }
439:                                 f_close(fh);
9D008FC8  0F4008D2   JAL f_close
9D008FCC  8FA4002C   LW A0, 44(SP)
440:                                 free(fh);
9D008FD0  0F40656A   JAL free
9D008FD4  8FA4002C   LW A0, 44(SP)
441:                                 free(buff);
9D008FD8  0F40656A   JAL free
9D008FDC  8FA40028   LW A0, 40(SP)
442:                                 free(fmt);
9D008FE0  0F40656A   JAL free
9D008FE4  02602021   ADDU A0, S3, ZERO
9D008FE8  0B402410   J 0x9D009040
9D008FEC  8FBF005C   LW RA, 92(SP)
443:                             }else{
444:                                 print_error_msg(ERR_ALLOC,"Can't display file.\r",0);
9D008FF0  24040002   ADDIU A0, ZERO, 2
9D008FF4  3C059D01   LUI A1, -25343
9D008FF8  24A5F6E4   ADDIU A1, A1, -2332
9D008FFC  0F402155   JAL print_error_msg
9D009000  00003021   ADDU A2, ZERO, ZERO
445:                             }
446:                         }else{
447:                             print_error_msg(ERR_FIO,"File open failed.\r",error);
9D009010  24040009   ADDIU A0, ZERO, 9
9D009014  3C059D01   LUI A1, -25343
9D009018  24A5F6FC   ADDIU A1, A1, -2308
9D00901C  0F402155   JAL print_error_msg
9D009020  00403021   ADDU A2, V0, ZERO
448:                         }
449:                    }else{
450:                        print_error_msg(ERR_USAGE, "USAGE: more file_name\r",0);
9D00902C  3C059D01   LUI A1, -25343
9D009030  24A5F710   ADDIU A1, A1, -2288
9D009034  0F402155   JAL print_error_msg
9D009038  00003021   ADDU A2, ZERO, ZERO
451:                    }
452:                 }//f
9D008DA4  0B402410   J 0x9D009040
9D008DA8  8FBF005C   LW RA, 92(SP)
9D009004  0B402410   J 0x9D009040
9D009008  8FBF005C   LW RA, 92(SP)
9D009024  0B402410   J 0x9D009040
9D009028  8FBF005C   LW RA, 92(SP)
9D00903C  8FBF005C   LW RA, 92(SP)
9D009040  8FBE0058   LW S8, 88(SP)
9D009044  8FB70054   LW S7, 84(SP)
9D009048  8FB60050   LW S6, 80(SP)
9D00904C  8FB5004C   LW S5, 76(SP)
9D009050  8FB40048   LW S4, 72(SP)
9D009054  8FB30044   LW S3, 68(SP)
9D009058  8FB20040   LW S2, 64(SP)
9D00905C  8FB1003C   LW S1, 60(SP)
9D009060  8FB00038   LW S0, 56(SP)
9D009064  03E00008   JR RA
9D009068  27BD0060   ADDIU SP, SP, 96
453:                 
454:                 void cmd_mount(int i){// mount SDcard drive
9D00906C  27BDFFE8   ADDIU SP, SP, -24
9D009070  AFBF0014   SW RA, 20(SP)
455:                     if (!SDCardReady){
9D009074  8F828068   LW V0, -32664(GP)
9D009078  1440000D   BNE V0, ZERO, 0x9D0090B0
9D00907C  8FBF0014   LW RA, 20(SP)
456:                         if (!mount(0)){
9D009080  0F4042F9   JAL mount
9D009084  00002021   ADDU A0, ZERO, ZERO
9D009088  14400007   BNE V0, ZERO, 0x9D0090A8
9D00908C  24020001   ADDIU V0, ZERO, 1
457:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D009090  2404000A   ADDIU A0, ZERO, 10
9D009094  00002821   ADDU A1, ZERO, ZERO
9D009098  0F402155   JAL print_error_msg
9D00909C  00003021   ADDU A2, ZERO, ZERO
458:                             return;
9D0090A0  0B40242C   J 0x9D0090B0
9D0090A4  8FBF0014   LW RA, 20(SP)
459:                         }else{
460:                             SDCardReady=TRUE;
9D0090A8  AF828068   SW V0, -32664(GP)
461:                         }
462:                     }
463:                 }
9D0090AC  8FBF0014   LW RA, 20(SP)
9D0090B0  03E00008   JR RA
9D0090B4  27BD0018   ADDIU SP, SP, 24
464:                 
465:                 void cmd_umount(int i){
9D0090B8  27BDFFE8   ADDIU SP, SP, -24
9D0090BC  AFBF0014   SW RA, 20(SP)
466:                     unmountSD();
9D0090C0  0F402ED5   JAL unmountSD
9D0090C4  00000000   NOP
9D009AA8  0F402ED5   JAL unmountSD
9D009AAC  00000000   NOP
467:                     SDCardReady=FALSE;
9D0090C8  AF808068   SW ZERO, -32664(GP)
9D009AB0  0B4026CF   J 0x9D009B3C
9D009AB4  AF808068   SW ZERO, -32664(GP)
468:                 }
9D0090CC  8FBF0014   LW RA, 20(SP)
9D0090D0  03E00008   JR RA
9D0090D4  27BD0018   ADDIU SP, SP, 24
469:                 
470:                 void more(int i){ // affiche à l'écran le contenu d'un fichier texte
9D0090D8  27BDFFB8   ADDIU SP, SP, -72
9D0090DC  AFBF0044   SW RA, 68(SP)
9D0090E0  AFBE0040   SW S8, 64(SP)
9D0090E4  AFB7003C   SW S7, 60(SP)
9D0090E8  AFB60038   SW S6, 56(SP)
9D0090EC  AFB50034   SW S5, 52(SP)
9D0090F0  AFB40030   SW S4, 48(SP)
9D0090F4  AFB3002C   SW S3, 44(SP)
9D0090F8  AFB20028   SW S2, 40(SP)
9D0090FC  AFB10024   SW S1, 36(SP)
9D009100  AFB00020   SW S0, 32(SP)
471:                     FIL *fh;
472:                     char *fmt, *buff, *rbuff, c, prev,key;
473:                     int n,lcnt,colcnt=0;
9D0091C4  00009021   ADDU S2, ZERO, ZERO
474:                     text_coord_t cpos;
475:                     if (!SDCardReady){
9D009104  8F828068   LW V0, -32664(GP)
9D009108  1440000C   BNE V0, ZERO, 0x9D00913C
9D00910C  00808021   ADDU S0, A0, ZERO
476:                         if (!mount(0)){
9D009110  0F4042F9   JAL mount
9D009114  00002021   ADDU A0, ZERO, ZERO
9D009118  14400007   BNE V0, ZERO, 0x9D009138
9D00911C  24020001   ADDIU V0, ZERO, 1
477:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D009120  2404000A   ADDIU A0, ZERO, 10
9D009124  00002821   ADDU A1, ZERO, ZERO
9D009128  0F402155   JAL print_error_msg
9D00912C  00003021   ADDU A2, ZERO, ZERO
478:                             return;
479:                         }else{
480:                             SDCardReady=TRUE;
9D009138  AF828068   SW V0, -32664(GP)
481:                         }
482:                     }
483:                     FRESULT error=FR_OK;
9D009390  00001021   ADDU V0, ZERO, ZERO
484:                     if (i==2){
9D00913C  24020002   ADDIU V0, ZERO, 2
9D009140  1602009B   BNE S0, V0, 0x9D0093B0
9D009144  24040003   ADDIU A0, ZERO, 3
485:                         clear_screen();
9D009148  0F402B6F   JAL clear_screen
9D00914C  00000000   NOP
486:                         fh=malloc(sizeof(FIL));
9D009150  0F404DAF   JAL malloc
9D009154  24040028   ADDIU A0, ZERO, 40
487:                         if (fh && ((error=f_open(fh,cmd_tokens[1],FA_READ))==FR_OK)){
9D009158  1040008D   BEQ V0, ZERO, 0x9D009390
9D00915C  0040B821   ADDU S7, V0, ZERO
9D009160  00402021   ADDU A0, V0, ZERO
9D009164  3C02A000   LUI V0, -24576
9D009168  8C454A4C   LW A1, 19020(V0)
9D00916C  0F400664   JAL f_open
9D009170  24060001   ADDIU A2, ZERO, 1
9D009174  14400088   BNE V0, ZERO, 0x9D009398
9D009178  24040009   ADDIU A0, ZERO, 9
488:                             buff=malloc(512);
9D00917C  0F404DAF   JAL malloc
9D009180  24040200   ADDIU A0, ZERO, 512
9D009184  0040F021   ADDU S8, V0, ZERO
489:                             fmt=malloc(CHAR_PER_LINE);
9D009188  0F404DAF   JAL malloc
9D00918C  24040050   ADDIU A0, ZERO, 80
490:                             if (fmt && buff){
9D009190  10400078   BEQ V0, ZERO, 0x9D009374
9D009194  AFA2001C   SW V0, 28(SP)
9D009198  13C00076   BEQ S8, ZERO, 0x9D009374
9D00919C  00402021   ADDU A0, V0, ZERO
491:                                 sprintf(fmt,"File: %s, size %d bytes\r",cmd_tokens[1],fh->fsize);
9D0091A0  3C059D01   LUI A1, -25343
9D0091A4  24A5F728   ADDIU A1, A1, -2264
9D0091A8  3C02A000   LUI V0, -24576
9D0091AC  8C464A4C   LW A2, 19020(V0)
9D0091B0  0F4062F0   JAL sprintf
9D0091B4  8EE7000C   LW A3, 12(S7)
492:                                 print(comm_channel,fmt);
9D0091B8  9784803C   LHU A0, -32708(GP)
9D0091BC  0F402C18   JAL print
9D0091C0  8FA5001C   LW A1, 28(SP)
493:                                 key=0;
9D0091C8  0000B021   ADDU S6, ZERO, ZERO
494:                                 while (key!=ESC && f_read(fh,buff,512,&n)==FR_OK){
9D009324  2402001B   ADDIU V0, ZERO, 27
9D009328  12C20008   BEQ S6, V0, 0x9D00934C
9D00932C  00000000   NOP
9D009330  02E02021   ADDU A0, S7, ZERO
9D009334  03C02821   ADDU A1, S8, ZERO
9D009338  24060200   ADDIU A2, ZERO, 512
9D00933C  0F40070C   JAL f_read
9D009340  27A70010   ADDIU A3, SP, 16
9D009344  1040FFA6   BEQ V0, ZERO, 0x9D0091E0
9D009348  8FA20010   LW V0, 16(SP)
495:                                     if (!n) break;
9D0091E0  1040005A   BEQ V0, ZERO, 0x9D00934C
9D0091E4  03C08821   ADDU S1, S8, ZERO
496:                                     rbuff=buff;
497:                                     for(;n;n--){
9D0092C0  0B4024C6   J 0x9D009318
9D0092C4  8FA20010   LW V0, 16(SP)
9D009314  8FA20010   LW V0, 16(SP)
9D009318  2442FFFF   ADDIU V0, V0, -1
9D00931C  1440FFB3   BNE V0, ZERO, 0x9D0091EC
9D009320  AFA20010   SW V0, 16(SP)
498:                                         c=*rbuff++;
9D0091EC  26310001   ADDIU S1, S1, 1
9D0091F0  8230FFFF   LB S0, -1(S1)
499:                                         if ((c!=TAB && c!=CR && c!=LF) && (c<32 || c>126)) {c=32;}
9D0091CC  2413000D   ADDIU S3, ZERO, 13
9D0091E8  24150020   ADDIU S5, ZERO, 32
9D0091F4  320200FF   ANDI V0, S0, 255
9D0091F8  2443FFF7   ADDIU V1, V0, -9
9D0091FC  306300FF   ANDI V1, V1, 255
9D009200  2C630002   SLTIU V1, V1, 2
9D009204  14600007   BNE V1, ZERO, 0x9D009224
9D009208  9784803C   LHU A0, -32708(GP)
9D00920C  12130005   BEQ S0, S3, 0x9D009224
9D009210  2442FFE0   ADDIU V0, V0, -32
9D009214  304200FF   ANDI V0, V0, 255
9D009218  2C42005F   SLTIU V0, V0, 95
9D00921C  02A2800A   MOVZ S0, S5, V0
500:                                         put_char(comm_channel,c);
9D009220  9784803C   LHU A0, -32708(GP)
9D009224  0F402B85   JAL put_char
9D009228  02002821   ADDU A1, S0, ZERO
501:                                         if (comm_channel==LOCAL_CON){
9D00922C  9784803C   LHU A0, -32708(GP)
9D009230  54800025   BNEL A0, ZERO, 0x9D0092C8
9D009234  26520001   ADDIU S2, S2, 1
502:                                             cpos=get_curpos();
9D009238  0F402CC3   JAL get_curpos
9D00923C  27A40014   ADDIU A0, SP, 20
503:                                             if (cpos.x==0){
9D009240  97A20014   LHU V0, 20(SP)
9D009244  14400033   BNE V0, ZERO, 0x9D009314
9D009248  97A30016   LHU V1, 22(SP)
504:                                                 if (cpos.y>=(LINE_PER_SCREEN-1)){
9D00924C  2C63001D   SLTIU V1, V1, 29
9D009250  14600031   BNE V1, ZERO, 0x9D009318
9D009254  8FA20010   LW V0, 16(SP)
505:                                                     cpos.y=LINE_PER_SCREEN-1;
506:                                                     invert_video(TRUE);
9D009258  0F402DE2   JAL invert_video
9D00925C  24040001   ADDIU A0, ZERO, 1
507:                                                     print(comm_channel,"-- next --");
9D0091D0  3C029D01   LUI V0, -25343
9D0091D4  2442F744   ADDIU V0, V0, -2236
9D0091D8  0B4024CC   J 0x9D009330
9D0091DC  AFA20018   SW V0, 24(SP)
9D009260  9784803C   LHU A0, -32708(GP)
9D009264  0F402C18   JAL print
9D009268  8FA50018   LW A1, 24(SP)
508:                                                     invert_video(FALSE);
9D00926C  0F402DE2   JAL invert_video
9D009270  00002021   ADDU A0, ZERO, ZERO
509:                                                     key=wait_key(comm_channel);
9D009274  0F402D86   JAL wait_key
9D009278  9784803C   LHU A0, -32708(GP)
9D00927C  7C02B420   SEB S6, V0
510:                                                     if (key=='q' || key==ESC){key=ESC; break;}
9D009280  24020071   ADDIU V0, ZERO, 113
9D009284  12C20031   BEQ S6, V0, 0x9D00934C
9D009288  2402001B   ADDIU V0, ZERO, 27
9D00928C  12C2002F   BEQ S6, V0, 0x9D00934C
9D009290  00000000   NOP
511:                                                     if (key==CR){
9D009294  16D30008   BNE S6, S3, 0x9D0092B8
9D009298  00000000   NOP
512:                                                         set_curpos(cpos.x,cpos.y);
9D00929C  00002021   ADDU A0, ZERO, ZERO
9D0092A0  0F402CCF   JAL set_curpos
9D0092A4  2405001D   ADDIU A1, ZERO, 29
513:                                                         clear_eol();
9D0092A8  0F402C98   JAL clear_eol
9D0092AC  00000000   NOP
9D0092B0  0B4024C6   J 0x9D009318
9D0092B4  8FA20010   LW V0, 16(SP)
514:                                                     }else{
515:                                                         clear_screen();
9D0092B8  0F402B6F   JAL clear_screen
9D0092BC  00000000   NOP
516:                                                     }
517:                                                 }
518:                                             }
519:                                         }else{
520:                                             colcnt++;
521:                                             if ((colcnt==CHAR_PER_LINE)||(c=='\r')){
9D0092C8  24020050   ADDIU V0, ZERO, 80
9D0092CC  52420004   BEQL S2, V0, 0x9D0092E0
9D0092D0  26940001   ADDIU S4, S4, 1
9D0092D4  16130010   BNE S0, S3, 0x9D009318
9D0092D8  8FA20010   LW V0, 16(SP)
522:                                                 colcnt=0;
523:                                                 lcnt++;
9D0092DC  26940001   ADDIU S4, S4, 1
524:                                                 if (lcnt==22){
9D0092E0  24020016   ADDIU V0, ZERO, 22
9D0092E4  1682000B   BNE S4, V0, 0x9D009314
9D0092E8  00009021   ADDU S2, ZERO, ZERO
525:                                                     lcnt=0;
526:                                                    // print(comm_channel,"\r-- next --\r");
527:                                                     put_char(comm_channel,'\r');
9D0092EC  0F402B85   JAL put_char
9D0092F0  02602821   ADDU A1, S3, ZERO
528:                                                     key=wait_key(comm_channel);
9D0092F4  0F402D86   JAL wait_key
9D0092F8  9784803C   LHU A0, -32708(GP)
9D0092FC  7C02B420   SEB S6, V0
529:                                                     if (key=='q' || key==ESC){key=ESC;break;}
9D009300  24020071   ADDIU V0, ZERO, 113
9D009304  12C20011   BEQ S6, V0, 0x9D00934C
9D009308  2402001B   ADDIU V0, ZERO, 27
9D00930C  12C2000F   BEQ S6, V0, 0x9D00934C
9D009310  0000A021   ADDU S4, ZERO, ZERO
530:                                                 }
531:                                             }
532:                                         }
533:                                     }
534:                                 }
535:                                 f_close(fh);
9D00934C  0F4008D2   JAL f_close
9D009350  02E02021   ADDU A0, S7, ZERO
536:                                 free(fh);
9D009354  0F40656A   JAL free
9D009358  02E02021   ADDU A0, S7, ZERO
537:                                 free(buff);
9D00935C  0F40656A   JAL free
9D009360  03C02021   ADDU A0, S8, ZERO
538:                                 free(fmt);
9D009364  0F40656A   JAL free
9D009368  8FA4001C   LW A0, 28(SP)
9D00936C  0B4024F1   J 0x9D0093C4
9D009370  8FBF0044   LW RA, 68(SP)
539:                             }else{
540:                                 print_error_msg(ERR_ALLOC,"Can't display file.\r",0);
9D009374  24040002   ADDIU A0, ZERO, 2
9D009378  3C059D01   LUI A1, -25343
9D00937C  24A5F6E4   ADDIU A1, A1, -2332
9D009380  0F402155   JAL print_error_msg
9D009384  00003021   ADDU A2, ZERO, ZERO
541:                             }
542:                         }else{
543:                             print_error_msg(ERR_FIO,"File open failed.\r",error);
9D009394  24040009   ADDIU A0, ZERO, 9
9D009398  3C059D01   LUI A1, -25343
9D00939C  24A5F6FC   ADDIU A1, A1, -2308
9D0093A0  0F402155   JAL print_error_msg
9D0093A4  00403021   ADDU A2, V0, ZERO
544:                         }
545:                    }else{
546:                        print_error_msg(ERR_USAGE, "USAGE: more file_name\r",0);
9D0093B0  3C059D01   LUI A1, -25343
9D0093B4  24A5F710   ADDIU A1, A1, -2288
9D0093B8  0F402155   JAL print_error_msg
9D0093BC  00003021   ADDU A2, ZERO, ZERO
547:                    }
548:                 }//more
9D009130  0B4024F1   J 0x9D0093C4
9D009134  8FBF0044   LW RA, 68(SP)
9D009388  0B4024F1   J 0x9D0093C4
9D00938C  8FBF0044   LW RA, 68(SP)
9D0093A8  0B4024F1   J 0x9D0093C4
9D0093AC  8FBF0044   LW RA, 68(SP)
9D0093C0  8FBF0044   LW RA, 68(SP)
9D0093C4  8FBE0040   LW S8, 64(SP)
9D0093C8  8FB7003C   LW S7, 60(SP)
9D0093CC  8FB60038   LW S6, 56(SP)
9D0093D0  8FB50034   LW S5, 52(SP)
9D0093D4  8FB40030   LW S4, 48(SP)
9D0093D8  8FB3002C   LW S3, 44(SP)
9D0093DC  8FB20028   LW S2, 40(SP)
9D0093E0  8FB10024   LW S1, 36(SP)
9D0093E4  8FB00020   LW S0, 32(SP)
9D0093E8  03E00008   JR RA
9D0093EC  27BD0048   ADDIU SP, SP, 72
549:                 
550:                 void cmd_edit(int i){ // lance l'éditeur de texte
9D0093F0  27BDFFE8   ADDIU SP, SP, -24
551:                     if (i>1){
9D0093F4  28840002   SLTI A0, A0, 2
9D0093F8  14800006   BNE A0, ZERO, 0x9D009414
9D0093FC  AFBF0014   SW RA, 20(SP)
552:                         editor(cmd_tokens[1]);
9D009400  3C02A000   LUI V0, -24576
9D009404  0F4014E4   JAL editor
9D009408  8C444A4C   LW A0, 19020(V0)
9D00940C  0B402508   J 0x9D009420
9D009410  8FBF0014   LW RA, 20(SP)
553:                     }else{
554:                         editor(NULL);
9D009414  0F4014E4   JAL editor
9D009418  00002021   ADDU A0, ZERO, ZERO
555:                     }
556:                 }//f
9D00941C  8FBF0014   LW RA, 20(SP)
9D009420  03E00008   JR RA
9D009424  27BD0018   ADDIU SP, SP, 24
557:                 
558:                 void mkdir(int i){
9D009428  27BDFFE8   ADDIU SP, SP, -24
9D00942C  AFBF0014   SW RA, 20(SP)
9D009430  AFB00010   SW S0, 16(SP)
559:                     FRESULT error=FR_OK;
560:                     char *fmt;
561:                     if (!SDCardReady){
9D009434  8F828068   LW V0, -32664(GP)
9D009438  1440000C   BNE V0, ZERO, 0x9D00946C
9D00943C  00808021   ADDU S0, A0, ZERO
562:                         if (!mount(0)){
9D009440  0F4042F9   JAL mount
9D009444  00002021   ADDU A0, ZERO, ZERO
9D009448  14400007   BNE V0, ZERO, 0x9D009468
9D00944C  24020001   ADDIU V0, ZERO, 1
563:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D009450  2404000A   ADDIU A0, ZERO, 10
9D009454  00002821   ADDU A1, ZERO, ZERO
9D009458  0F402155   JAL print_error_msg
9D00945C  00003021   ADDU A2, ZERO, ZERO
564:                             return;
9D009460  0B402542   J 0x9D009508
9D009464  8FBF0014   LW RA, 20(SP)
565:                         }else{
566:                             SDCardReady=TRUE;
9D009468  AF828068   SW V0, -32664(GP)
567:                         }
568:                     }
569:                     if (i==2){
9D00946C  24020002   ADDIU V0, ZERO, 2
9D009470  16020015   BNE S0, V0, 0x9D0094C8
9D009474  24040003   ADDIU A0, ZERO, 3
570:                         fmt=malloc(CHAR_PER_LINE+1);
9D009478  0F404DAF   JAL malloc
9D00947C  24040051   ADDIU A0, ZERO, 81
571:                         if (fmt && (error=f_mkdir(cmd_tokens[1])==FR_OK)){
9D009480  10400017   BEQ V0, ZERO, 0x9D0094E0
9D009484  00408021   ADDU S0, V0, ZERO
9D009488  3C02A000   LUI V0, -24576
9D00948C  0F400C68   JAL f_mkdir
9D009490  8C444A4C   LW A0, 19020(V0)
9D009494  14400018   BNE V0, ZERO, 0x9D0094F8
9D009498  9784803C   LHU A0, -32708(GP)
572:                             sprintf(fmt,"directory %s created\r",cmd_tokens[1]);
9D00949C  02002021   ADDU A0, S0, ZERO
9D0094A0  3C059D01   LUI A1, -25343
9D0094A4  24A5F750   ADDIU A1, A1, -2224
9D0094A8  3C02A000   LUI V0, -24576
9D0094AC  0F4062F0   JAL sprintf
9D0094B0  8C464A4C   LW A2, 19020(V0)
573:                             print(comm_channel,fmt);
9D0094B4  9784803C   LHU A0, -32708(GP)
9D0094B8  0F402C18   JAL print
9D0094BC  02002821   ADDU A1, S0, ZERO
9D0094C0  0B402542   J 0x9D009508
9D0094C4  8FBF0014   LW RA, 20(SP)
574:                         }else{
575:                             if (!fmt){
576:                                 print(comm_channel,ERR_MSG[ERR_ALLOC]);
9D0094E0  9784803C   LHU A0, -32708(GP)
9D0094E4  3C02A000   LUI V0, -24576
9D0094E8  0F402C18   JAL print
9D0094EC  8C4548A0   LW A1, 18592(V0)
9D0094F0  0B402542   J 0x9D009508
9D0094F4  8FBF0014   LW RA, 20(SP)
577:                             }else{
578:                                 print(comm_channel,ERR_MSG[ERR_MKDIR]);
9D0094F8  3C02A000   LUI V0, -24576
9D0094FC  0F402C18   JAL print
9D009500  8C4548B0   LW A1, 18608(V0)
579:                             }
580:                         }
581:                     }else{
582:                         print_error_msg(ERR_USAGE,"mkdir create a directory, USAGE: mkdir dir_name\r",0);
9D0094C8  3C059D01   LUI A1, -25343
9D0094CC  24A5F768   ADDIU A1, A1, -2200
9D0094D0  0F402155   JAL print_error_msg
9D0094D4  00003021   ADDU A2, ZERO, ZERO
583:                     }
584:                 }// mkdir()
9D0094D8  0B402542   J 0x9D009508
9D0094DC  8FBF0014   LW RA, 20(SP)
9D009504  8FBF0014   LW RA, 20(SP)
9D009508  8FB00010   LW S0, 16(SP)
9D00950C  03E00008   JR RA
9D009510  27BD0018   ADDIU SP, SP, 24
585:                 
586:                 void list_directory(int i){
9D009514  27BDFFA8   ADDIU SP, SP, -88
9D009518  AFBF0054   SW RA, 84(SP)
9D00951C  AFB10050   SW S1, 80(SP)
9D009520  AFB0004C   SW S0, 76(SP)
587:                     FRESULT error;
588:                     FIL *fh;
589:                     char fmt[55];
590:                     if (!SDCardReady){
9D009524  8F828068   LW V0, -32664(GP)
9D009528  1440000C   BNE V0, ZERO, 0x9D00955C
9D00952C  00808021   ADDU S0, A0, ZERO
591:                         if (!mount(0)){
9D009530  0F4042F9   JAL mount
9D009534  00002021   ADDU A0, ZERO, ZERO
9D009538  14400007   BNE V0, ZERO, 0x9D009558
9D00953C  24020001   ADDIU V0, ZERO, 1
592:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D009540  2404000A   ADDIU A0, ZERO, 10
9D009544  00002821   ADDU A1, ZERO, ZERO
9D009548  0F402155   JAL print_error_msg
9D00954C  00003021   ADDU A2, ZERO, ZERO
593:                             return;
594:                         }else{
595:                             SDCardReady=TRUE;
9D009558  AF828068   SW V0, -32664(GP)
596:                         }
597:                     }
598:                     if (i>1){
9D00955C  2A100002   SLTI S0, S0, 2
9D009560  16000022   BNE S0, ZERO, 0x9D0095EC
9D009564  3C02A000   LUI V0, -24576
599:                         error=listDir(cmd_tokens[1]);
9D009568  0F404332   JAL listDir
9D00956C  8C444A4C   LW A0, 19020(V0)
9D009570  00408021   ADDU S0, V0, ZERO
600:                         if (error==FR_NO_PATH){// not a directory, try file
9D009574  24020005   ADDIU V0, ZERO, 5
9D009578  16020020   BNE S0, V0, 0x9D0095FC
9D00957C  00000000   NOP
601:                             fh=malloc(sizeof(FIL));
9D009580  0F404DAF   JAL malloc
9D009584  24040028   ADDIU A0, ZERO, 40
602:                             if (fh && ((error=f_open(fh,cmd_tokens[1],FA_READ))==FR_OK)){
9D009588  1040001E   BEQ V0, ZERO, 0x9D009604
9D00958C  00408821   ADDU S1, V0, ZERO
9D009590  00402021   ADDU A0, V0, ZERO
9D009594  3C02A000   LUI V0, -24576
9D009598  8C454A4C   LW A1, 19020(V0)
9D00959C  0F400664   JAL f_open
9D0095A0  24060001   ADDIU A2, ZERO, 1
9D0095A4  14400017   BNE V0, ZERO, 0x9D009604
9D0095A8  00408021   ADDU S0, V0, ZERO
603:                                 sprintf(fmt,"File: %s, size %d bytes\r",cmd_tokens[1],fh->fsize);
9D0095AC  27A40010   ADDIU A0, SP, 16
9D0095B0  3C059D01   LUI A1, -25343
9D0095B4  24A5F728   ADDIU A1, A1, -2264
9D0095B8  3C02A000   LUI V0, -24576
9D0095BC  8C464A4C   LW A2, 19020(V0)
9D0095C0  0F4062F0   JAL sprintf
9D0095C4  8E27000C   LW A3, 12(S1)
604:                                 print(comm_channel,fmt);
9D0095C8  9784803C   LHU A0, -32708(GP)
9D0095CC  0F402C18   JAL print
9D0095D0  27A50010   ADDIU A1, SP, 16
605:                                 f_close(fh);
9D0095D4  0F4008D2   JAL f_close
9D0095D8  02202021   ADDU A0, S1, ZERO
606:                                 free(fh);
9D0095DC  0F40656A   JAL free
9D0095E0  02202021   ADDU A0, S1, ZERO
607:                             }
608:                         }
609:                     }else{
610:                         error=listDir(".");
9D0095EC  3C049D01   LUI A0, -25343
9D0095F0  0F404332   JAL listDir
9D0095F4  2484F79C   ADDIU A0, A0, -2148
9D0095F8  00408021   ADDU S0, V0, ZERO
611:                     }
612:                     if (error) print_error_msg(ERR_FIO,"",error);
9D0095FC  12000007   BEQ S0, ZERO, 0x9D00961C
9D009600  8FBF0054   LW RA, 84(SP)
9D009604  24040009   ADDIU A0, ZERO, 9
9D009608  3C059D01   LUI A1, -25343
9D00960C  24A5F5C8   ADDIU A1, A1, -2616
9D009610  0F402155   JAL print_error_msg
9D009614  02003021   ADDU A2, S0, ZERO
613:                 }//list_directory()
9D009550  0B402587   J 0x9D00961C
9D009554  8FBF0054   LW RA, 84(SP)
9D0095E4  0B402587   J 0x9D00961C
9D0095E8  8FBF0054   LW RA, 84(SP)
9D009618  8FBF0054   LW RA, 84(SP)
9D00961C  8FB10050   LW S1, 80(SP)
9D009620  8FB0004C   LW S0, 76(SP)
9D009624  03E00008   JR RA
9D009628  27BD0058   ADDIU SP, SP, 88
614:                 
615:                 void cmd_puts(int i){
9D00962C  27BDFFE8   ADDIU SP, SP, -24
9D009630  AFBF0014   SW RA, 20(SP)
616:                     print(comm_channel, "puts, to be done.\r");
9D009634  9784803C   LHU A0, -32708(GP)
9D009638  3C059D01   LUI A1, -25343
9D00963C  0F402C18   JAL print
9D009640  24A5F7A0   ADDIU A1, A1, -2144
617:                 }//puts()
9D009644  8FBF0014   LW RA, 20(SP)
9D009648  03E00008   JR RA
9D00964C  27BD0018   ADDIU SP, SP, 24
618:                 
619:                 void expr(int i){
9D009650  27BDFFE8   ADDIU SP, SP, -24
9D009654  AFBF0014   SW RA, 20(SP)
620:                     print(comm_channel, "expr, to be done.\r");
9D009658  9784803C   LHU A0, -32708(GP)
9D00965C  3C059D01   LUI A1, -25343
9D009660  0F402C18   JAL print
9D009664  24A5F7B4   ADDIU A1, A1, -2124
621:                 }//expr()
9D009668  8FBF0014   LW RA, 20(SP)
9D00966C  03E00008   JR RA
9D009670  27BD0018   ADDIU SP, SP, 24
622:                 
623:                 //display heap status
624:                 void cmd_free(int i){
9D009674  27BDFFB0   ADDIU SP, SP, -80
9D009678  AFBF004C   SW RA, 76(SP)
625:                     char fmt[55];
626:                     sprintf(fmt,"free RAM %d/%d BYTES\r",free_heap(),heap_size);
9D00967C  0F40388E   JAL free_heap
9D009680  00000000   NOP
9D009684  27A40010   ADDIU A0, SP, 16
9D009688  3C059D01   LUI A1, -25343
9D00968C  24A5F7C8   ADDIU A1, A1, -2104
9D009690  00403021   ADDU A2, V0, ZERO
9D009694  0F4062F0   JAL sprintf
9D009698  8F878058   LW A3, -32680(GP)
627:                     print(comm_channel,fmt);
9D00969C  9784803C   LHU A0, -32708(GP)
9D0096A0  0F402C18   JAL print
9D0096A4  27A50010   ADDIU A1, SP, 16
628:                 }
9D0096A8  8FBF004C   LW RA, 76(SP)
9D0096AC  03E00008   JR RA
9D0096B0  27BD0050   ADDIU SP, SP, 80
629:                 
630:                 void cmd_date(int i){
9D0096B4  27BDFFC0   ADDIU SP, SP, -64
9D0096B8  AFBF003C   SW RA, 60(SP)
9D0096BC  AFB20038   SW S2, 56(SP)
9D0096C0  AFB10034   SW S1, 52(SP)
631:                     char fmt[20];
632:                     char *str;
633:                     sdate_t sdate;
634:                     unsigned y,m,d;
635:                     if (i>1){
9D0096C4  28840002   SLTI A0, A0, 2
9D0096C8  1480001E   BNE A0, ZERO, 0x9D009744
9D0096CC  AFB00030   SW S0, 48(SP)
636:                         y=atoi(cmd_tokens[1]);
9D0096D0  3C03A000   LUI V1, -24576
9D0096D4  0F406080   JAL atoi
9D0096D8  8C644A4C   LW A0, 19020(V1)
637:                         if (!y) y=2000;
9D0096DC  241207D0   ADDIU S2, ZERO, 2000
9D0096E0  0042900B   MOVN S2, V0, V0
638:                         str=strchr(cmd_tokens[1],'/');
9D0096E4  3C03A000   LUI V1, -24576
9D0096E8  8C644A4C   LW A0, 19020(V1)
9D0096EC  0F4065A2   JAL strchr
9D0096F0  2405002F   ADDIU A1, ZERO, 47
639:                         if (str){
9D0096F4  1040000D   BEQ V0, ZERO, 0x9D00972C
9D0096F8  24110001   ADDIU S1, ZERO, 1
640:                             m=atoi(++str);
9D0096FC  24500001   ADDIU S0, V0, 1
9D009700  0F406080   JAL atoi
9D009704  02002021   ADDU A0, S0, ZERO
9D009708  00408821   ADDU S1, V0, ZERO
641:                             str=strchr(str,'/');
9D00970C  02002021   ADDU A0, S0, ZERO
9D009710  0F4065A2   JAL strchr
9D009714  2405002F   ADDIU A1, ZERO, 47
642:                             if (str){
9D009718  50400004   BEQL V0, ZERO, 0x9D00972C
9D00971C  24100001   ADDIU S0, ZERO, 1
643:                                 d=atoi(++str);
9D009720  0F406080   JAL atoi
9D009724  24440001   ADDIU A0, V0, 1
9D009728  00408021   ADDU S0, V0, ZERO
644:                             }else{
645:                                 d=1;
646:                             }
647:                         }else{
648:                             m=1;
649:                         }
650:                         set_date(y,m,d);
9D00972C  02402021   ADDU A0, S2, ZERO
9D009730  02202821   ADDU A1, S1, ZERO
9D009734  0F40384A   JAL set_date
9D009738  02003021   ADDU A2, S0, ZERO
9D00973C  0B4025E0   J 0x9D009780
9D009740  8FBF003C   LW RA, 60(SP)
651:                     }else{
652:                         get_date(&sdate);
9D009744  0F403854   JAL get_date
9D009748  27A4002C   ADDIU A0, SP, 44
653:                         sprintf(fmt,"%4d/%02d/%02d\n",sdate.y,sdate.m,sdate.d);
9D00974C  97A6002C   LHU A2, 44(SP)
9D009750  8FA7002C   LW A3, 44(SP)
9D009754  7CE22500   EXT V0, A3, 20, 5
9D009758  AFA20010   SW V0, 16(SP)
9D00975C  27A40018   ADDIU A0, SP, 24
9D009760  3C059D01   LUI A1, -25343
9D009764  24A5F7E0   ADDIU A1, A1, -2080
9D009768  0F4062F0   JAL sprintf
9D00976C  7CE71C00   EXT A3, A3, 16, 4
654:                         print(comm_channel,fmt);
9D009770  9784803C   LHU A0, -32708(GP)
9D009774  0F402C18   JAL print
9D009778  27A50018   ADDIU A1, SP, 24
655:                     }
656:                 }
9D00977C  8FBF003C   LW RA, 60(SP)
9D009780  8FB20038   LW S2, 56(SP)
9D009784  8FB10034   LW S1, 52(SP)
9D009788  8FB00030   LW S0, 48(SP)
9D00978C  03E00008   JR RA
9D009790  27BD0040   ADDIU SP, SP, 64
657:                 
658:                 void display_time(){
9D009794  27BDFFC8   ADDIU SP, SP, -56
9D009798  AFBF0034   SW RA, 52(SP)
659:                     stime_t t;
660:                     text_coord_t cpos;
661:                     char fmt[15];
662:                     
663:                     get_time(&t);
9D00979C  0F40383D   JAL get_time
9D0097A0  27A40018   ADDIU A0, SP, 24
664:                     cpos=get_curpos();
9D0097A4  0F402CC3   JAL get_curpos
9D0097A8  27A4001C   ADDIU A0, SP, 28
665:                     set_curpos(CHAR_PER_LINE-9,0);
9D0097AC  24040047   ADDIU A0, ZERO, 71
9D0097B0  0F402CCF   JAL set_curpos
9D0097B4  00002821   ADDU A1, ZERO, ZERO
666:                     sprintf(fmt,"%02d:%02d:%02d",t.h,t.m,t.s);
9D0097B8  8FA70018   LW A3, 24(SP)
9D0097BC  30E2003F   ANDI V0, A3, 63
9D0097C0  AFA20010   SW V0, 16(SP)
9D0097C4  27A40020   ADDIU A0, SP, 32
9D0097C8  3C059D01   LUI A1, -25343
9D0097CC  24A5F7F0   ADDIU A1, A1, -2064
9D0097D0  7CE62300   EXT A2, A3, 12, 5
9D0097D4  0F4062F0   JAL sprintf
9D0097D8  7CE72980   EXT A3, A3, 6, 6
667:                     print(comm_channel,fmt);
9D0097DC  9784803C   LHU A0, -32708(GP)
9D0097E0  0F402C18   JAL print
9D0097E4  27A50020   ADDIU A1, SP, 32
668:                     set_curpos(cpos.x,cpos.y);
9D0097E8  97A4001C   LHU A0, 28(SP)
9D0097EC  0F402CCF   JAL set_curpos
9D0097F0  97A5001E   LHU A1, 30(SP)
669:                 }
9D0097F4  8FBF0034   LW RA, 52(SP)
9D0097F8  03E00008   JR RA
9D0097FC  27BD0038   ADDIU SP, SP, 56
670:                 
671:                 
672:                 void cmd_time(int i){
9D009800  27BDFFC0   ADDIU SP, SP, -64
9D009804  AFBF003C   SW RA, 60(SP)
9D009808  AFB20038   SW S2, 56(SP)
9D00980C  AFB10034   SW S1, 52(SP)
673:                     char fmt[16];
674:                     stime_t t;
675:                     char *str;
676:                     unsigned short hr,min,sec;
677:                     
678:                     hr=0;min=0;sec=0;
9D009880  00003021   ADDU A2, ZERO, ZERO
9D009884  00008821   ADDU S1, ZERO, ZERO
679:                     if ((i>1)&& cmd_tokens[1]){
9D009810  28840002   SLTI A0, A0, 2
9D009814  14800021   BNE A0, ZERO, 0x9D00989C
9D009818  AFB00030   SW S0, 48(SP)
9D00981C  3C02A000   LUI V0, -24576
9D009820  8C444A4C   LW A0, 19020(V0)
9D009824  1080001D   BEQ A0, ZERO, 0x9D00989C
9D009828  00000000   NOP
9D009894  0B402636   J 0x9D0098D8
9D009898  8FBF003C   LW RA, 60(SP)
680:                         hr=atoi(cmd_tokens[1]);
9D00982C  0F406080   JAL atoi
9D009830  00000000   NOP
9D009834  00409021   ADDU S2, V0, ZERO
681:                         str=strchr(cmd_tokens[1],':');
9D009838  3C02A000   LUI V0, -24576
9D00983C  8C444A4C   LW A0, 19020(V0)
9D009840  0F4065A2   JAL strchr
9D009844  2405003A   ADDIU A1, ZERO, 58
682:                         if (str){
9D009848  1040000D   BEQ V0, ZERO, 0x9D009880
9D00984C  24500001   ADDIU S0, V0, 1
683:                             min=atoi(++str);
9D009850  0F406080   JAL atoi
9D009854  02002021   ADDU A0, S0, ZERO
9D009858  3051FFFF   ANDI S1, V0, -1
684:                             str=strchr(str,':');
9D00985C  02002021   ADDU A0, S0, ZERO
9D009860  0F4065A2   JAL strchr
9D009864  2405003A   ADDIU A1, ZERO, 58
685:                             if (str) sec=atoi(++str);
9D009868  50400007   BEQL V0, ZERO, 0x9D009888
9D00986C  00003021   ADDU A2, ZERO, ZERO
9D009870  0F406080   JAL atoi
9D009874  24440001   ADDIU A0, V0, 1
9D009878  0B402622   J 0x9D009888
9D00987C  3046FFFF   ANDI A2, V0, -1
686:                         }
687:                         set_time(hr,min,sec);
9D009888  3244FFFF   ANDI A0, S2, -1
9D00988C  0F403832   JAL set_time
9D009890  02202821   ADDU A1, S1, ZERO
688:                     }else{
689:                         get_time(&t);
9D00989C  0F40383D   JAL get_time
9D0098A0  27A40028   ADDIU A0, SP, 40
690:                         sprintf(fmt,"%02d:%02d:%02d",t.h,t.m,t.s);
9D0098A4  8FA70028   LW A3, 40(SP)
9D0098A8  30E2003F   ANDI V0, A3, 63
9D0098AC  AFA20010   SW V0, 16(SP)
9D0098B0  27A40018   ADDIU A0, SP, 24
9D0098B4  3C059D01   LUI A1, -25343
9D0098B8  24A5F7F0   ADDIU A1, A1, -2064
9D0098BC  7CE62300   EXT A2, A3, 12, 5
9D0098C0  0F4062F0   JAL sprintf
9D0098C4  7CE72980   EXT A3, A3, 6, 6
691:                         print(comm_channel,fmt);
9D0098C8  9784803C   LHU A0, -32708(GP)
9D0098CC  0F402C18   JAL print
9D0098D0  27A50018   ADDIU A1, SP, 24
692:                     }
693:                 }
9D0098D4  8FBF003C   LW RA, 60(SP)
9D0098D8  8FB20038   LW S2, 56(SP)
9D0098DC  8FB10034   LW S1, 52(SP)
9D0098E0  8FB00030   LW S0, 48(SP)
9D0098E4  03E00008   JR RA
9D0098E8  27BD0040   ADDIU SP, SP, 64
694:                 
695:                 void execute_cmd(int i){
9D0098EC  27BDFFE8   ADDIU SP, SP, -24
9D0098F0  AFBF0014   SW RA, 20(SP)
9D0098F4  AFB00010   SW S0, 16(SP)
9D0098F8  00808021   ADDU S0, A0, ZERO
696:                         switch (cmd_search(cmd_tokens[0])){
9D0098FC  3C02A000   LUI V0, -24576
9D009900  0F40217F   JAL cmd_search
9D009904  8C444A48   LW A0, 19016(V0)
9D009908  2C430018   SLTIU V1, V0, 24
9D00990C  10600087   BEQ V1, ZERO, 0x9D009B2C
9D009910  00021080   SLL V0, V0, 2
9D009914  3C039D01   LUI V1, -25343
9D009918  2463992C   ADDIU V1, V1, -26324
9D00991C  00621021   ADDU V0, V1, V0
9D009920  8C420000   LW V0, 0(V0)
9D009924  00400008   JR V0
9D009928  00000000   NOP
697:                             case CMD_HELP:
698:                                 display_cmd_list(i);
9D00998C  0F40219A   JAL display_cmd_list
9D009990  02002021   ADDU A0, S0, ZERO
699:                                 break;
9D009994  0B4026D0   J 0x9D009B40
9D009998  8FBF0014   LW RA, 20(SP)
700:                             case CMD_CD:
701:                                 cd(i);
9D00999C  0F402220   JAL cd
9D0099A0  02002021   ADDU A0, S0, ZERO
702:                                 break;
9D0099A4  0B4026D0   J 0x9D009B40
9D0099A8  8FBF0014   LW RA, 20(SP)
703:                             case CMD_DIR: // liste des fichiers sur la carte SD
704:                                 list_directory(i);
9D0099AC  0F402545   JAL list_directory
9D0099B0  02002021   ADDU A0, S0, ZERO
705:                                 break;
9D0099B4  0B4026D0   J 0x9D009B40
9D0099B8  8FBF0014   LW RA, 20(SP)
706:                             case CMD_FORMAT:
707:                                 cmd_format(i);
9D0099BC  0F402208   JAL cmd_format
9D0099C0  02002021   ADDU A0, S0, ZERO
708:                                 break;
9D0099C4  0B4026D0   J 0x9D009B40
9D0099C8  8FBF0014   LW RA, 20(SP)
709:                             case CMD_FORTH:
710:                                 cmd_forth(i);
711:                                 break;
712:                             case CMD_FREE:
713:                                 cmd_free(i);
9D0099DC  0F40259D   JAL cmd_free
9D0099E0  02002021   ADDU A0, S0, ZERO
714:                                 break;
9D0099E4  0B4026D0   J 0x9D009B40
9D0099E8  8FBF0014   LW RA, 20(SP)
715:                             case CMD_MKDIR:
716:                                 mkdir(i);
9D0099EC  0F40250A   JAL mkdir
9D0099F0  02002021   ADDU A0, S0, ZERO
717:                                 break;
9D0099F4  0B4026D0   J 0x9D009B40
9D0099F8  8FBF0014   LW RA, 20(SP)
718:                             case CMD_DEL: // efface un fichier
719:                                 del(i);
9D0099FC  0F40224C   JAL del
9D009A00  02002021   ADDU A0, S0, ZERO
720:                                 break;
9D009A04  0B4026D0   J 0x9D009B40
9D009A08  8FBF0014   LW RA, 20(SP)
721:                             case CMD_REN: // renomme ou déplace un fichier
722:                                 ren(i);
9D009A0C  0F40229B   JAL ren
9D009A10  02002021   ADDU A0, S0, ZERO
723:                                 break;
9D009A14  0B4026D0   J 0x9D009B40
9D009A18  8FBF0014   LW RA, 20(SP)
724:                             case CMD_ED: // editeur
725:                                 cmd_edit(i);
9D009A1C  0F4024FC   JAL cmd_edit
9D009A20  02002021   ADDU A0, S0, ZERO
726:                                 break;
9D009A24  0B4026D0   J 0x9D009B40
9D009A28  8FBF0014   LW RA, 20(SP)
727:                             case CMD_SND:  // envoie un fichier vers la sortie uart
728:                                 cmd_send(i);
9D009A2C  0F402331   JAL cmd_send
9D009A30  02002021   ADDU A0, S0, ZERO
729:                                 break;
9D009A34  0B4026D0   J 0x9D009B40
9D009A38  8FBF0014   LW RA, 20(SP)
730:                             case CMD_RCV:  // reçoit un fichier du uart
731:                                 receive(i);
9D009A3C  0F402342   JAL receive
9D009A40  02002021   ADDU A0, S0, ZERO
732:                                 break;
9D009A44  0B4026D0   J 0x9D009B40
9D009A48  8FBF0014   LW RA, 20(SP)
733:                             case CMD_CPY:   // copie un fichier
734:                                 copy(i);
9D009A4C  0F4022BE   JAL copy
9D009A50  02002021   ADDU A0, S0, ZERO
735:                                 break;
9D009A54  0B4026D0   J 0x9D009B40
9D009A58  8FBF0014   LW RA, 20(SP)
736:                             case CMD_EXPR: // évalue une expression
737:                                 expr(i);
9D009A5C  0F402594   JAL expr
9D009A60  02002021   ADDU A0, S0, ZERO
738:                                 break;
9D009A64  0B4026D0   J 0x9D009B40
9D009A68  8FBF0014   LW RA, 20(SP)
739:                             case CMD_CLEAR: // efface l'écran
740:                                 if (comm_channel==LOCAL_CON){
9D009A6C  9784803C   LHU A0, -32708(GP)
9D009A70  54800005   BNEL A0, ZERO, 0x9D009A88
9D009A74  3C059D01   LUI A1, -25343
741:                                     clear_screen();
9D009A78  0F402B6F   JAL clear_screen
9D009A7C  00000000   NOP
9D009A80  0B4026D0   J 0x9D009B40
9D009A84  8FBF0014   LW RA, 20(SP)
742:                                 }else{
743:                                     print(comm_channel,"\E[2J\E[H"); // VT100 commands
9D009A88  0F402C18   JAL print
9D009A8C  24A5F800   ADDIU A1, A1, -2048
744:                                 }
745:                                 break;
746:                             case CMD_MOUNT:
747:                                 cmd_mount(i);
9D009A98  0F40241B   JAL cmd_mount
9D009A9C  02002021   ADDU A0, S0, ZERO
748:                                 break;
9D009AA0  0B4026D0   J 0x9D009B40
9D009AA4  8FBF0014   LW RA, 20(SP)
749:                             case CMD_UMOUNT:
750:                                 cmd_umount(i);
751:                                 break;
752:                             case CMD_MORE:
753:                                 more(i);
9D009AB8  0F402436   JAL more
9D009ABC  02002021   ADDU A0, S0, ZERO
754:                                 break;
9D009AC0  0B4026D0   J 0x9D009B40
9D009AC4  8FBF0014   LW RA, 20(SP)
755:                             case CMD_HDUMP:
756:                                 cmd_hdump(i);
9D009AC8  0F402353   JAL cmd_hdump
9D009ACC  02002021   ADDU A0, S0, ZERO
757:                                 break;
9D009AD0  0B4026D0   J 0x9D009B40
9D009AD4  8FBF0014   LW RA, 20(SP)
758:                             case CMD_PUTS: // affiche un texte à l'écran
759:                                 cmd_puts(i);
9D009AD8  0F40258B   JAL cmd_puts
9D009ADC  02002021   ADDU A0, S0, ZERO
760:                                 break;
9D009AE0  0B4026D0   J 0x9D009B40
9D009AE4  8FBF0014   LW RA, 20(SP)
761:                             case CMD_REBOOT: // redémarrage à froid.
762:                                 asm("lui $t0, 0xbfc0"); // _on_reset
9D009AE8  3C08BFC0   LUI T0, -16448
763:                                 asm("j  $t0");
9D009AEC  01000008   JR T0
9D009AF0  00000000   NOP
764:                                 break;
9D009AF4  0B4026D0   J 0x9D009B40
9D009AF8  8FBF0014   LW RA, 20(SP)
765:                             case CMD_TIME:
766:                                 cmd_time(i);
9D009AFC  0F402600   JAL cmd_time
9D009B00  02002021   ADDU A0, S0, ZERO
767:                                 break;
9D009B04  0B4026D0   J 0x9D009B40
9D009B08  8FBF0014   LW RA, 20(SP)
768:                             case CMD_DATE:
769:                                 cmd_date(i);
9D009B0C  0F4025AD   JAL cmd_date
9D009B10  02002021   ADDU A0, S0, ZERO
770:                                 break;
9D009B14  0B4026D0   J 0x9D009B40
9D009B18  8FBF0014   LW RA, 20(SP)
771:                             case CMD_UPTIME:
772:                                 cmd_uptime();
9D009B1C  0F4021CC   JAL cmd_uptime
9D009B20  00000000   NOP
773:                                 break;
9D009B24  0B4026D0   J 0x9D009B40
9D009B28  8FBF0014   LW RA, 20(SP)
774:                             default:
775:                                 print(comm_channel,"unknown command!\r");
9D009B2C  9784803C   LHU A0, -32708(GP)
9D009B30  3C059D01   LUI A1, -25343
9D009B34  0F402C18   JAL print
9D009B38  24A5F808   ADDIU A1, A1, -2040
776:                     }
777:                 }// execute_cmd()
9D0099D4  0B4026D0   J 0x9D009B40
9D0099D8  8FBF0014   LW RA, 20(SP)
9D009A90  0B4026D0   J 0x9D009B40
9D009A94  8FBF0014   LW RA, 20(SP)
9D009B3C  8FBF0014   LW RA, 20(SP)
9D009B40  8FB00010   LW S0, 16(SP)
9D009B44  03E00008   JR RA
9D009B48  27BD0018   ADDIU SP, SP, 24
778:                 
779:                 const char *prompt="\r#";
780:                 
781:                 void free_tokens(){
9D009B4C  27BDFFE0   ADDIU SP, SP, -32
9D009B50  AFBF001C   SW RA, 28(SP)
9D009B54  AFB10018   SW S1, 24(SP)
9D009B58  AFB00014   SW S0, 20(SP)
9D009B5C  3C10A000   LUI S0, -24576
9D009B60  26104A48   ADDIU S0, S0, 19016
9D009B64  2611FFEC   ADDIU S1, S0, -20
782:                     int i;
783:                     for (i=MAX_TOKEN-1;i>=0;i--){
9D009B84  5611FFF9   BNEL S0, S1, 0x9D009B6C
9D009B88  8E040010   LW A0, 16(S0)
784:                         if (cmd_tokens[i]){
9D009B68  8E040010   LW A0, 16(S0)
9D009B6C  50800005   BEQL A0, ZERO, 0x9D009B84
9D009B70  2610FFFC   ADDIU S0, S0, -4
785:                             free(cmd_tokens[i]);
9D009B74  0F40656A   JAL free
9D009B78  00000000   NOP
786:                             cmd_tokens[i]=NULL;
9D009B7C  AE000010   SW ZERO, 16(S0)
9D009B80  2610FFFC   ADDIU S0, S0, -4
787:                         }
788:                     }
789:                 }//free_tokens()
9D009B8C  8FBF001C   LW RA, 28(SP)
9D009B90  8FB10018   LW S1, 24(SP)
9D009B94  8FB00014   LW S0, 20(SP)
9D009B98  03E00008   JR RA
9D009B9C  27BD0020   ADDIU SP, SP, 32
790:                 
791:                 int tokenize(){ // découpe la ligne d'entrée en mots
9D009BA0  27BDFFC0   ADDIU SP, SP, -64
9D009BA4  AFBF003C   SW RA, 60(SP)
9D009BA8  AFBE0038   SW S8, 56(SP)
9D009BAC  AFB70034   SW S7, 52(SP)
9D009BB0  AFB60030   SW S6, 48(SP)
9D009BB4  AFB5002C   SW S5, 44(SP)
9D009BB8  AFB40028   SW S4, 40(SP)
9D009BBC  AFB30024   SW S3, 36(SP)
9D009BC0  AFB20020   SW S2, 32(SP)
9D009BC4  AFB1001C   SW S1, 28(SP)
9D009BC8  AFB00018   SW S0, 24(SP)
792:                     int i;
793:                     char *token;
794:                     i=0;
9D009BE0  0000F021   ADDU S8, ZERO, ZERO
795:                     cmd_line.first=0;
796:                     cmd_line.next=0;
9D009BCC  3C02A000   LUI V0, -24576
9D009BD0  A0404AAE   SB ZERO, 19118(V0)
9D009BD4  3C02A000   LUI V0, -24576
9D009BD8  24424A48   ADDIU V0, V0, 19016
9D009BDC  AFA20010   SW V0, 16(SP)
797:                     while ((i<MAX_TOKEN) && next_token()){
9D009C38  24020005   ADDIU V0, ZERO, 5
9D009C3C  13C2005A   BEQ S8, V0, 0x9D009DA8
9D009C40  03C01021   ADDU V0, S8, ZERO
9D009D6C  0217102B   SLTU V0, S0, S7
9D009D70  1440FFA2   BNE V0, ZERO, 0x9D009BFC
9D009D74  02F0B823   SUBU S7, S7, S0
9D009D78  0B40276A   J 0x9D009DA8
9D009D7C  03C01021   ADDU V0, S8, ZERO
798:                         token=malloc(sizeof(char)*(cmd_line.next-cmd_line.first+1));
9D009BFC  0F404DAF   JAL malloc
9D009C00  26E40001   ADDIU A0, S7, 1
9D009C04  0040B021   ADDU S6, V0, ZERO
799:                         memcpy(token,&cmd_line.buff[cmd_line.first],cmd_line.next-cmd_line.first);
9D009C08  26654A5C   ADDIU A1, S3, 19036
9D009C0C  00402021   ADDU A0, V0, ZERO
9D009C10  00B02821   ADDU A1, A1, S0
9D009C14  0F4056A7   JAL memcpy
9D009C18  02E03021   ADDU A2, S7, ZERO
800:                         *(token+cmd_line.next-cmd_line.first)=(char)0;
9D009C1C  02D7B821   ADDU S7, S6, S7
9D009C20  A2E00000   SB ZERO, 0(S7)
801:                         cmd_tokens[i]=token;
9D009C24  8FA20010   LW V0, 16(SP)
9D009C28  AC560000   SW S6, 0(V0)
802:                         i++;
9D009C2C  27DE0001   ADDIU S8, S8, 1
9D009C30  24420004   ADDIU V0, V0, 4
9D009C34  AFA20010   SW V0, 16(SP)
803:                     }//while
804:                     return i;
805:                 }//tokenize()
9D009DA4  03C01021   ADDU V0, S8, ZERO
9D009DA8  8FBF003C   LW RA, 60(SP)
9D009DAC  8FBE0038   LW S8, 56(SP)
9D009DB0  8FB70034   LW S7, 52(SP)
9D009DB4  8FB60030   LW S6, 48(SP)
9D009DB8  8FB5002C   LW S5, 44(SP)
9D009DBC  8FB40028   LW S4, 40(SP)
9D009DC0  8FB30024   LW S3, 36(SP)
9D009DC4  8FB20020   LW S2, 32(SP)
9D009DC8  8FB1001C   LW S1, 28(SP)
9D009DCC  8FB00018   LW S0, 24(SP)
9D009DD0  03E00008   JR RA
9D009DD4  27BD0040   ADDIU SP, SP, 64
806:                 
807:                 
808:                 void shell(void){
9D009DD8  27BDFFE8   ADDIU SP, SP, -24
9D009DDC  AFBF0014   SW RA, 20(SP)
9D009DE0  AFB00010   SW S0, 16(SP)
809:                     int i;
810:                     
811:                     print(comm_channel,"VPC-32 shell\rfree RAM (bytes): ");
9D009DE4  9784803C   LHU A0, -32708(GP)
9D009DE8  3C059D01   LUI A1, -25343
9D009DEC  0F402C18   JAL print
9D009DF0  24A5F81C   ADDIU A1, A1, -2020
812:                     print_int(comm_channel,free_heap(),0);
9D009DF4  0F40388E   JAL free_heap
9D009DF8  9790803C   LHU S0, -32708(GP)
9D009DFC  02002021   ADDU A0, S0, ZERO
9D009E00  00402821   ADDU A1, V0, ZERO
9D009E04  0F402C58   JAL print_int
9D009E08  00003021   ADDU A2, ZERO, ZERO
813:                     crlf();
9D009E0C  0F402B60   JAL crlf
9D009E10  3C10A000   LUI S0, -24576
814:                     free_tokens();
9D009E14  0F4026D3   JAL free_tokens
9D009E18  00000000   NOP
815:                     print(comm_channel,"date? (yyyy/mm/dd) ");
9D009E1C  9784803C   LHU A0, -32708(GP)
9D009E20  3C059D01   LUI A1, -25343
9D009E24  0F402C18   JAL print
9D009E28  24A5F83C   ADDIU A1, A1, -1988
816:                     cmd_line.len=readline(comm_channel,cmd_line.buff,12);
9D009E2C  9784803C   LHU A0, -32708(GP)
9D009E30  26054A5C   ADDIU A1, S0, 19036
9D009E34  0F402D9D   JAL readline
9D009E38  2406000C   ADDIU A2, ZERO, 12
9D009E3C  26104A5C   ADDIU S0, S0, 19036
817:                     if (cmd_line.len){
9D009E40  1040000D   BEQ V0, ZERO, 0x9D009E78
9D009E44  A2020050   SB V0, 80(S0)
818:                         i=tokenize();
9D009E48  0F4026E8   JAL tokenize
9D009E4C  00000000   NOP
819:                         cmd_tokens[1]=cmd_tokens[0];
9D009E50  3C02A000   LUI V0, -24576
9D009E54  24434A48   ADDIU V1, V0, 19016
9D009E58  8C424A48   LW V0, 19016(V0)
9D009E5C  AC620004   SW V0, 4(V1)
820:                         cmd_date(2);
9D009E60  0F4025AD   JAL cmd_date
9D009E64  24040002   ADDIU A0, ZERO, 2
821:                         free_tokens();
9D009E68  0F4026D3   JAL free_tokens
9D009E6C  00000000   NOP
9D009E70  0B4027A3   J 0x9D009E8C
9D009E74  9784803C   LHU A0, -32708(GP)
822:                     }else{
823:                         set_date(2000,1,1);
9D009E78  240407D0   ADDIU A0, ZERO, 2000
9D009E7C  24050001   ADDIU A1, ZERO, 1
9D009E80  0F40384A   JAL set_date
9D009E84  24060001   ADDIU A2, ZERO, 1
824:                     }
825:                     print(comm_channel,"time? (hh:mm:ss) ");
9D009E88  9784803C   LHU A0, -32708(GP)
9D009E8C  3C059D01   LUI A1, -25343
9D009E90  0F402C18   JAL print
9D009E94  24A5F850   ADDIU A1, A1, -1968
826:                     cmd_line.len=readline(comm_channel,cmd_line.buff,9);
9D009E98  9784803C   LHU A0, -32708(GP)
9D009E9C  3C10A000   LUI S0, -24576
9D009EA0  26054A5C   ADDIU A1, S0, 19036
9D009EA4  0F402D9D   JAL readline
9D009EA8  24060009   ADDIU A2, ZERO, 9
9D009EAC  26104A5C   ADDIU S0, S0, 19036
827:                     if (cmd_line.len){
9D009EB0  1040000D   BEQ V0, ZERO, 0x9D009EE8
9D009EB4  A2020050   SB V0, 80(S0)
828:                         i=tokenize();
9D009EB8  0F4026E8   JAL tokenize
9D009EBC  00000000   NOP
829:                         cmd_tokens[1]=cmd_tokens[0];
9D009EC0  3C02A000   LUI V0, -24576
9D009EC4  24434A48   ADDIU V1, V0, 19016
9D009EC8  8C424A48   LW V0, 19016(V0)
9D009ECC  AC620004   SW V0, 4(V1)
830:                         cmd_time(2);
9D009ED0  0F402600   JAL cmd_time
9D009ED4  24040002   ADDIU A0, ZERO, 2
831:                         free_tokens();
9D009ED8  0F4026D3   JAL free_tokens
9D009EDC  00000000   NOP
9D009EE0  0B4027BE   J 0x9D009EF8
9D009EE4  00000000   NOP
832:                     }else{
833:                         set_time(0,0,0);
9D009EE8  00002021   ADDU A0, ZERO, ZERO
9D009EEC  00002821   ADDU A1, ZERO, ZERO
9D009EF0  0F403832   JAL set_time
9D009EF4  00003021   ADDU A2, ZERO, ZERO
834:                     }
835:                     display_time();
9D009EF8  0F4025E5   JAL display_time
9D009EFC  3C10A000   LUI S0, -24576
836:                     while (1){
837:                         print(comm_channel,prompt);
9D009F04  9784803C   LHU A0, -32708(GP)
9D009F08  0F402C18   JAL print
9D009F0C  8F858014   LW A1, -32748(GP)
9D009F48  0B4027C2   J 0x9D009F08
838:                         cmd_line.len=readline(comm_channel,cmd_line.buff,CHAR_PER_LINE);
9D009F00  26104A5C   ADDIU S0, S0, 19036
9D009F10  9784803C   LHU A0, -32708(GP)
9D009F14  02002821   ADDU A1, S0, ZERO
9D009F18  0F402D9D   JAL readline
9D009F1C  24060050   ADDIU A2, ZERO, 80
839:                         if (cmd_line.len){
9D009F20  1040FFF8   BEQ V0, ZERO, 0x9D009F04
9D009F24  A2020050   SB V0, 80(S0)
840:                             i=tokenize();
9D009F28  0F4026E8   JAL tokenize
9D009F2C  00000000   NOP
841:                             if (i) {
9D009F30  5040FFF5   BEQL V0, ZERO, 0x9D009F08
9D009F34  9784803C   LHU A0, -32708(GP)
842:                                 execute_cmd(i);
9D009F38  0F40263B   JAL execute_cmd
9D009F3C  00402021   ADDU A0, V0, ZERO
843:                                 free_tokens();
9D009F40  0F4026D3   JAL free_tokens
9D009F44  00000000   NOP
9D009F48  0B4027C2   J 0x9D009F08
9D009F4C  9784803C   LHU A0, -32708(GP)
844:                             } // if
845:                         }// if
846:                     }//while(1)
847:                     asm("lui $t0, 0xbfc0"); // _on_reset
848:                     asm("j  $t0");
849:                 }//shell()
850:                 
---  /home/jacques/github/vpc-32vga/reader.c  -----------------------------------------------------------
1:                   /*
2:                    * Copyright 2015, 2016, Jacques Deschenes
3:                    * 
4:                    * This file is part of PV16SOG project.
5:                    * 
6:                    * ***  LICENCE ****
7:                    * This program is free software; you can redistribute it and/or modify
8:                    * it under the terms of the GNU General Public License as published by
9:                    * the Free Software Foundation; either version 3 of the License, or
10:                   * (at your option) any later version.
11:                   * 
12:                   * This program is distributed in the hope that it will be useful,
13:                   * but WITHOUT ANY WARRANTY; without even the implied warranty of
14:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
15:                   * GNU General Public License for more details.
16:                   * 
17:                   * You should have received a copy of the GNU General Public License
18:                   * along with this program; See 'copying.txt' in root directory of source.
19:                   * If not, write to the Free Software Foundation,
20:                   * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
21:                   *  
22:                   * to contact the author:  jd_temp@yahoo.fr
23:                   * 
24:                   */
25:                  
26:                  /*
27:                   * File: reader.c
28:                   * Description: lit une ligne à partir de la source spécifiée.
29:                   * Date: 2016-02-10 
30:                   */
31:                  
32:                  #include <stdlib.h>
33:                  //#include <stdint.h>
34:                  #include <stdbool.h>
35:                  #include <string.h>
36:                  #include <ctype.h>
37:                  
38:                  #include "hardware/HardwareProfile.h"
39:                  #include "hardware/spiram/spiram.h"
40:                  #include "hardware/Pinguino/fileio.h"
41:                  #include "hardware/Pinguino/ff.h"
42:                  #include "console.h"
43:                  #include "reader.h"
44:                  #include "font.h"
45:                  
46:                  
47:                  
48:                  
49:                  int complevel=0;
50:                  
51:                  static void display_prompt(){
52:                      int i;
53:                      crlf();
9D014AA8  0F402B60   JAL crlf
54:                      for(i=0;i<=complevel;i++) put_char(comm_channel,'>');
9D014AB0  8F828054   LW V0, -32684(GP)
9D014AB4  04400009   BLTZ V0, 0x9D014ADC
9D014AB8  00008821   ADDU S1, ZERO, ZERO
9D014ABC  9784803C   LHU A0, -32708(GP)
9D014AC0  0F402B85   JAL put_char
9D014AC4  2405003E   ADDIU A1, ZERO, 62
9D014AC8  26310001   ADDIU S1, S1, 1
9D014ACC  8F828054   LW V0, -32684(GP)
9D014AD0  0051102A   SLT V0, V0, S1
9D014AD4  1040FFFA   BEQ V0, ZERO, 0x9D014AC0
9D014AD8  9784803C   LHU A0, -32708(GP)
55:                  }//f
56:                  
57:                  //rempli le buffer
58:                  static bool read_sram(reader_t *reader){
59:                      if (sram_pos(reader->handle)==sram_fsize(reader->handle)){
9D014B08  8C440004   LW A0, 4(V0)
9D014B0C  8C460008   LW A2, 8(V0)
9D014B10  54860004   BNEL A0, A2, 0x9D014B24
9D014B14  00C43023   SUBU A2, A2, A0
60:                          reader->eof=true;
9D014B18  24020001   ADDIU V0, ZERO, 1
9D014B1C  0B4052E7   J 0x9D014B9C
9D014B20  A202010C   SB V0, 268(S0)
61:                          return false;
62:                      }
63:                      reader->count=min(READER_BUFFER_SIZE,sram_left(reader->handle));
9D014B24  2CC40101   SLTIU A0, A2, 257
9D014B28  24030100   ADDIU V1, ZERO, 256
9D014B2C  0064300A   MOVZ A2, V1, A0
9D014B30  AE060104   SW A2, 260(S0)
64:                      sram_read_block(sram_addr(reader->handle),(uint8_t*)reader->buffer,reader->count);
9D014B34  8C440004   LW A0, 4(V0)
9D014B38  8C420000   LW V0, 0(V0)
9D014B3C  00822021   ADDU A0, A0, V0
9D014B40  0F403F11   JAL sram_read_block
9D014B44  26050004   ADDIU A1, S0, 4
65:                      reader->inp=0;
9D014B48  AE000108   SW ZERO, 264(S0)
66:                      sram_pos(reader->handle)+=reader->count;
9D014B4C  8E020110   LW V0, 272(S0)
9D014B50  8C440004   LW A0, 4(V0)
9D014B54  8E030104   LW V1, 260(S0)
9D014B58  00831821   ADDU V1, A0, V1
9D014B5C  AC430004   SW V1, 4(V0)
67:                      return true;
9D014B60  0B4052E7   J 0x9D014B9C
9D014B64  24030001   ADDIU V1, ZERO, 1
68:                  }
69:                  
70:                  static bool fill_buffer(reader_t *reader){
71:                      FRESULT result;
72:                      switch (reader->device){
9D014A84  24040001   ADDIU A0, ZERO, 1
9D014A88  5044001F   BEQL V0, A0, 0x9D014B08
9D014A8C  8E020110   LW V0, 272(S0)
9D014A90  10400005   BEQ V0, ZERO, display_prompt
9D014A94  24040002   ADDIU A0, ZERO, 2
9D014A98  50440033   BEQL V0, A0, 0x9D014B68
9D014A9C  8E040110   LW A0, 272(S0)
73:                          case eDEV_KBD:
74:                              display_prompt();
75:                              reader->count=readline(comm_channel,reader->buffer,CHAR_PER_LINE);
9D014ADC  9784803C   LHU A0, -32708(GP)
9D014AE0  26050004   ADDIU A1, S0, 4
9D014AE4  0F402D9D   JAL readline
9D014AE8  24060050   ADDIU A2, ZERO, 80
76:                              reader->buffer[reader->count++]='\r';
9D014AEC  24430001   ADDIU V1, V0, 1
9D014AF0  AE030104   SW V1, 260(S0)
9D014AF4  02021021   ADDU V0, S0, V0
9D014AF8  2403000D   ADDIU V1, ZERO, 13
9D014AFC  A0430004   SB V1, 4(V0)
77:                              reader->inp=0;
9D014B00  0B4052EA   J 0x9D014BA8
9D014B04  AE000108   SW ZERO, 264(S0)
78:                              return true;
79:                              break;
80:                          case eDEV_SPIRAM:
81:                              return read_sram(reader);
82:                              break;
83:                          case eDEV_SDCARD:
84:                              result=f_read(reader->handle,(uint8_t*)reader->buffer,READER_BUFFER_SIZE,&reader->count);
9D014B68  26050004   ADDIU A1, S0, 4
9D014B6C  24060100   ADDIU A2, ZERO, 256
9D014B70  0F40070C   JAL f_read
9D014B74  26070104   ADDIU A3, S0, 260
85:                              reader->inp=0;
9D014B78  AE000108   SW ZERO, 264(S0)
86:                              if (reader->count<=0){
9D014B7C  8E020104   LW V0, 260(S0)
9D014B80  5C40000A   BGTZL V0, 0x9D014BAC
9D014B84  8E020108   LW V0, 264(S0)
87:                                  reader->count=0;
9D014B88  AE000104   SW ZERO, 260(S0)
88:                                  reader->eof=true;
9D014B8C  24020001   ADDIU V0, ZERO, 1
9D014B90  A202010C   SB V0, 268(S0)
89:                                  return false;
90:                              }
91:                              return true;
92:                              break;
93:                          case eDEV_FLASH:
94:                              break;
95:                      }
96:                      return false;
97:                  }//f()
98:                  
99:                  void reader_init(reader_t *reader, reader_src_t device, void *handle){
100:                     reader->inp=0;
9D014A28  AC800108   SW ZERO, 264(A0)
101:                     reader->count=0;
9D014A2C  AC800104   SW ZERO, 260(A0)
102:                     reader->eof=false;
9D014A30  A080010C   SB ZERO, 268(A0)
103:                     reader->device=device;
9D014A34  AC850000   SW A1, 0(A0)
104:                     reader->handle=handle;
9D014A38  03E00008   JR RA
9D014A3C  AC860110   SW A2, 272(A0)
105:                 }//f()
106:                 
107:                 char reader_getc(reader_t *reader){
9D014A40  27BDFFE0   ADDIU SP, SP, -32
9D014A44  AFBF001C   SW RA, 28(SP)
9D014A48  AFB10018   SW S1, 24(SP)
9D014A4C  AFB00014   SW S0, 20(SP)
108:                     char c=-1;
9D014AA0  0B4052E8   J 0x9D014BA0
9D014AA4  2402FFFF   ADDIU V0, ZERO, -1
9D014B94  0B4052F1   J 0x9D014BC4
9D014B98  2402FFFF   ADDIU V0, ZERO, -1
9D014B9C  2402FFFF   ADDIU V0, ZERO, -1
109:                     if (reader->eof) return c;
9D014A50  9083010C   LBU V1, 268(A0)
9D014A54  1460005A   BNE V1, ZERO, 0x9D014BC0
9D014A58  00808021   ADDU S0, A0, ZERO
9D014BC0  2402FFFF   ADDIU V0, ZERO, -1
110:                     if (reader->inp < reader->count){
9D014A5C  8C820108   LW V0, 264(A0)
9D014A60  8C840104   LW A0, 260(A0)
9D014A64  0044202A   SLT A0, V0, A0
9D014A68  50800006   BEQL A0, ZERO, 0x9D014A84
9D014A6C  8E020000   LW V0, 0(S0)
111:                         c=reader->buffer[reader->inp++];
9D014A70  24430001   ADDIU V1, V0, 1
9D014A74  AE030108   SW V1, 264(S0)
9D014A78  02028021   ADDU S0, S0, V0
9D014A7C  0B4052F1   J 0x9D014BC4
9D014A80  82020004   LB V0, 4(S0)
112:                     }else if (fill_buffer(reader)){
9D014BA0  10600009   BEQ V1, ZERO, 0x9D014BC8
9D014BA4  8FBF001C   LW RA, 28(SP)
113:                         c=reader->buffer[reader->inp++];
9D014BA8  8E020108   LW V0, 264(S0)
9D014BAC  24430001   ADDIU V1, V0, 1
9D014BB0  AE030108   SW V1, 264(S0)
9D014BB4  02028021   ADDU S0, S0, V0
9D014BB8  0B4052F1   J 0x9D014BC4
9D014BBC  82020004   LB V0, 4(S0)
114:                     }
115:                     return c;
116:                 }
9D014BC4  8FBF001C   LW RA, 28(SP)
9D014BC8  8FB10018   LW S1, 24(SP)
9D014BCC  8FB00014   LW S0, 20(SP)
9D014BD0  03E00008   JR RA
9D014BD4  27BD0020   ADDIU SP, SP, 32
117:                 
118:                 inline void reader_ungetc(reader_t *reader){
119:                     reader->inp--;
9D014BD8  8C820108   LW V0, 264(A0)
120:                 }
121:                 
122:                 // retourne la longueur de la chaîne ou -1 pour fin de fichier
123:                 // chaîne terminée par CR, LF, CRLF, \0
124:                 //int reader_gets(reader_t *reader, char *buffer, int len){
125:                 //    char c=-1;
126:                 //    int i=0;
127:                 //    
128:                 //    if (reader->eof) return -1;
129:                 //    while (!reader->eof && i<len && c){
130:                 //        c=reader_getc(reader);
131:                 //        switch(c){
132:                 //            case '\r':
133:                 //                c=reader_getc(reader);
134:                 //                if (c!='\n') reader_ungetc(reader);
135:                 //            case '\n':
136:                 //                c=0;
137:                 //                break;
138:                 //            default:
139:                 //                if (c<32) buffer[i++]=' '; else buffer[i++]=c;
140:                 //        }//switch
141:                 //    }//while
142:                 //    buffer[i]=0;
143:                 //    return i;
144:                 //}//f
145:                 
---  /home/jacques/github/vpc-32vga/hardware/tvout/vga.c  -----------------------------------------------
1:                   /*
2:                   * Copyright 2013,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /* 
19:                   * File:   vga.c
20:                   * Author: Jacques Deschênes
21:                   * Description: VGA video signal generator.
22:                   * Created on 20 août 2013, 08:48
23:                   * rev: 2017-07-31
24:                   */
25:                  
26:                  #include <stdio.h>
27:                  #include <stdlib.h>
28:                  #include <sys/attribs.h>
29:                  #include <plib.h>
30:                  #include "../HardwareProfile.h"
31:                  #include "vga.h"
32:                  
33:                  /*
34:                   * The generator use an output comapre to generate a regalar train of impulsion
35:                   * for HSync signal. The vertical VSync signal in generated in software inside
36:                   * the TIMER2 interrupt. TIMER2 is used as the horizontal period timer and as
37:                   * the output compare reference clock for HSync output compare.
38:                   * The video pixel are serialized using an SPI channel and DMA channel. This
39:                   * way the total time used by the MCU to generate the video signal is a small
40:                   * fraction of total MCU time.
41:                   */
42:                  /* USING DMA channel 0 and SPI1
43:                   *  The SPI is configured in frame mode with is SS line connected to a second
44:                   *  Output compare that generate the frame signal.
45:                   *  The SPI interrupt trigger the DMA channel which send video data to SPI transmit
46:                   *  buffer.
47:                   */
48:                  
49:                  #define PWM_PERIOD (SYSCLK/31469)-1
50:                  #define HSYNC  (3813/PBCLK_PER)-1  // 3,813µSec
51:                  #define FIRST_LINE (34)   //First video output line
52:                  #define LAST_LINE (FIRST_LINE+2*VRES+1)  // Disable video output for this frame.
53:                  #define BITCLK ((int)(HRES * 1000000L/25)) // 25µSec one horizontal line duration.
54:                  #define SPI_DLY 95 // video outpout delay after end of HSync pulse.
55:                  #define _enable_video_out()  PPSOutput(3,RPB6,SDO1);SPI1CONbits.ON=1;
56:                  #define _disable_video_out() PPSOutput(3,RPB6,NULL);SPI1CONbits.ON=0;
57:                  
58:                  unsigned int video_bmp[VRES][HRES/32]; // video bitmap buffer
59:                  volatile static int *DmaSrc; // pointer for DMA source.
60:                  
61:                  #define BLINK_DELAY (40) // 40/60 secondes
62:                  
63:                  typedef struct cursor_timer{
64:                      BOOL active;
65:                      unsigned int period;
66:                      cursor_tmr_callback_f  cb;
67:                  } cursor_timer_t;
68:                  
69:                  volatile static cursor_timer_t cursor_timer={FALSE,0,NULL};
70:                  
71:                  
72:                  // configure video generator.
73:                  // use TIMER2 as horizontal period timer.
74:                  void VideoInit(void){
9D00EBBC  27BDFFD8   ADDIU SP, SP, -40
9D00EBC0  AFBF0024   SW RA, 36(SP)
9D00EBC4  AFB10020   SW S1, 32(SP)
9D00EBC8  AFB0001C   SW S0, 28(SP)
75:                      T2CON = 0;
9D00EBCC  3C02BF80   LUI V0, -16512
9D00EBD0  AC400800   SW ZERO, 2048(V0)
76:                      PR2=PWM_PERIOD;
9D00EBD4  240304F6   ADDIU V1, ZERO, 1270
9D00EBD8  3C02BF80   LUI V0, -16512
9D00EBDC  AC430820   SW V1, 2080(V0)
77:                      OC2CONbits.OCM = 5; // pulse train mode (HSync)
9D00EBE0  3C02BF80   LUI V0, -16512
9D00EBE4  94433200   LHU V1, 12800(V0)
9D00EBE8  24110005   ADDIU S1, ZERO, 5
9D00EBEC  7E231004   INS V1, S1, 0, 3
9D00EBF0  A4433200   SH V1, 12800(V0)
78:                      OC2RS = 0; 
9D00EBF4  3C03BF80   LUI V1, -16512
9D00EBF8  AC603220   SW ZERO, 12832(V1)
79:                      OC2R = HSYNC;
9D00EBFC  24040097   ADDIU A0, ZERO, 151
9D00EC00  3C03BF80   LUI V1, -16512
9D00EC04  AC643210   SW A0, 12816(V1)
80:                      IFS0bits.T2IF=0;
9D00EC08  3C03BF88   LUI V1, -16504
9D00EC0C  8C641030   LW A0, 4144(V1)
9D00EC10  7C044A44   INS A0, ZERO, 9, 1
9D00EC14  AC641030   SW A0, 4144(V1)
81:                      IEC0bits.T2IE=1;
9D00EC18  3C03BF88   LUI V1, -16504
9D00EC1C  8C641060   LW A0, 4192(V1)
9D00EC20  24100001   ADDIU S0, ZERO, 1
9D00EC24  7E044A44   INS A0, S0, 9, 1
9D00EC28  AC641060   SW A0, 4192(V1)
82:                      IPC2bits.T2IP=7;
9D00EC2C  3C03BF88   LUI V1, -16504
9D00EC30  8C6410B0   LW A0, 4272(V1)
9D00EC34  24050007   ADDIU A1, ZERO, 7
9D00EC38  7CA42084   INS A0, A1, 2, 3
9D00EC3C  AC6410B0   SW A0, 4272(V1)
83:                      IPC2bits.T2IS=3;
9D00EC40  8C6410B0   LW A0, 4272(V1)
9D00EC44  24050003   ADDIU A1, ZERO, 3
9D00EC48  7CA40804   INS A0, A1, 0, 2
9D00EC4C  AC6410B0   SW A0, 4272(V1)
84:                      OC2CONbits.ON =1;  // enable output compare
9D00EC50  94433200   LHU V1, 12800(V0)
9D00EC54  7E037BC4   INS V1, S0, 15, 1
9D00EC58  A4433200   SH V1, 12800(V0)
85:                      T2CONbits.ON=1;  // enable TIMER2
9D00EC5C  3C02BF80   LUI V0, -16512
9D00EC60  94430800   LHU V1, 2048(V0)
9D00EC64  7E037BC4   INS V1, S0, 15, 1
9D00EC68  A4430800   SH V1, 2048(V0)
86:                      // using OC4 as frame trigger for SPI1
87:                      OC4CONbits.OCM = 5; //pulse train mode.
9D00EC6C  3C02BF80   LUI V0, -16512
9D00EC70  94433600   LHU V1, 13824(V0)
9D00EC74  7E231004   INS V1, S1, 0, 3
9D00EC78  A4433600   SH V1, 13824(V0)
88:                      OC4RS=0;
9D00EC7C  3C03BF80   LUI V1, -16512
9D00EC80  AC603620   SW ZERO, 13856(V1)
89:                      OC4R=HSYNC+SPI_DLY;
9D00EC84  240400F6   ADDIU A0, ZERO, 246
9D00EC88  3C03BF80   LUI V1, -16512
9D00EC8C  AC643610   SW A0, 13840(V1)
90:                      OC4CONbits.ON=1;
9D00EC90  94433600   LHU V1, 13824(V0)
9D00EC94  7E037BC4   INS V1, S0, 15, 1
9D00EC98  A4433600   SH V1, 13824(V0)
91:                      // configure  DMA channel 0.
92:                      // triggered by SPI1 TX interrupt.
93:                      DmaChnOpen(0,0,DMA_OPEN_DEFAULT);
9D00EC9C  00002021   ADDU A0, ZERO, ZERO
9D00ECA0  00002821   ADDU A1, ZERO, ZERO
9D00ECA4  0F405C24   JAL DmaChnOpen
9D00ECA8  00003021   ADDU A2, ZERO, ZERO
94:                      DmaChnSetEventControl(0,DMA_EV_START_IRQ_EN|
9D00ECAC  00002021   ADDU A0, ZERO, ZERO
9D00ECB0  0F406546   JAL DmaChnWriteEventControlFlags
9D00ECB4  24052610   ADDIU A1, ZERO, 9744
95:                                            DMA_EV_START_IRQ(_SPI1_TX_IRQ));
96:                      DmaChnSetTxfer(0,(void *)DmaSrc,(void *)&SPI1BUF,HRES/8,4,4);
9D00ECB8  24020004   ADDIU V0, ZERO, 4
9D00ECBC  AFA20010   SW V0, 16(SP)
9D00ECC0  AFA20014   SW V0, 20(SP)
9D00ECC4  00002021   ADDU A0, ZERO, ZERO
9D00ECC8  8F858030   LW A1, -32720(GP)
9D00ECCC  3C06BF80   LUI A2, -16512
9D00ECD0  24C65820   ADDIU A2, A2, 22560
9D00ECD4  0F4060FC   JAL DmaChnSetTxfer
9D00ECD8  2407003C   ADDIU A3, ZERO, 60
97:                      // configuredu SPI1 
98:                      SPI1CONbits.DISSDI=1; // SDI not used
9D00ECDC  3C02BF80   LUI V0, -16512
9D00ECE0  8C435800   LW V1, 22528(V0)
9D00ECE4  7E032104   INS V1, S0, 4, 1
9D00ECE8  AC435800   SW V1, 22528(V0)
99:                      SPI1CONbits.FRMEN=1; // frame mode
9D00ECEC  8C435800   LW V1, 22528(V0)
9D00ECF0  7E03FFC4   INS V1, S0, 31, 1
9D00ECF4  AC435800   SW V1, 22528(V0)
100:                     SPI1CONbits.FRMCNT=5; // 32 bytes per frame.
9D00ECF8  8C435800   LW V1, 22528(V0)
9D00ECFC  7E23D604   INS V1, S1, 24, 3
9D00ED00  AC435800   SW V1, 22528(V0)
101:                     SPI1CONbits.FRMPOL=1; // sync on rising edge
9D00ED04  8C435800   LW V1, 22528(V0)
9D00ED08  7E03EF44   INS V1, S0, 29, 1
9D00ED0C  AC435800   SW V1, 22528(V0)
102:                     SPI1CONbits.FRMSYNC=1; // slave synchronization
9D00ED10  8C435800   LW V1, 22528(V0)
9D00ED14  7E03F784   INS V1, S0, 30, 1
9D00ED18  AC435800   SW V1, 22528(V0)
103:                     SPI1CONbits.MSTEN=1; // SPI as master
9D00ED1C  8C435800   LW V1, 22528(V0)
9D00ED20  7E032944   INS V1, S0, 5, 1
9D00ED24  AC435800   SW V1, 22528(V0)
104:                     SPI1CONbits.MODE32=1; // 32 bits mode
9D00ED28  8C435800   LW V1, 22528(V0)
9D00ED2C  7E035AC4   INS V1, S0, 11, 1
9D00ED30  AC435800   SW V1, 22528(V0)
105:                     SPI1CONbits.STXISEL=1; // interrupt on TBE
9D00ED34  8C435800   LW V1, 22528(V0)
9D00ED38  7E031884   INS V1, S0, 2, 2
9D00ED3C  AC435800   SW V1, 22528(V0)
106:                     SpiChnSetBitRate(SPI_CHANNEL1, PBCLK, BITCLK); // bit rate
9D00ED40  24040001   ADDIU A0, ZERO, 1
9D00ED44  3C050262   LUI A1, 610
9D00ED48  24A55A00   ADDIU A1, A1, 23040
9D00ED4C  3C060124   LUI A2, 292
9D00ED50  0F406497   JAL SpiChnSetBitRate
9D00ED54  34C6F800   ORI A2, A2, -2048
107:                 }//init_video()
9D00ED58  8FBF0024   LW RA, 36(SP)
9D00ED5C  8FB10020   LW S1, 32(SP)
9D00ED60  8FB0001C   LW S0, 28(SP)
9D00ED64  03E00008   JR RA
9D00ED68  27BD0028   ADDIU SP, SP, 40
108:                 
109:                 
110:                 void enable_cursor_timer(BOOL enable, cursor_tmr_callback_f cb){
111:                     if (enable && cb){
9D00ED6C  1080000E   BEQ A0, ZERO, 0x9D00EDA8
9D00ED70  3C02A000   LUI V0, -24576
9D00ED74  10A0000C   BEQ A1, ZERO, 0x9D00EDA8
9D00ED78  00000000   NOP
112:                         if (!cursor_timer.active){
9D00ED7C  8C424C50   LW V0, 19536(V0)
9D00ED80  14400007   BNE V0, ZERO, 0x9D00EDA0
9D00ED84  3C02A000   LUI V0, -24576
113:                             cursor_timer.period=BLINK_DELAY;
9D00ED88  24434C50   ADDIU V1, V0, 19536
9D00ED8C  24040028   ADDIU A0, ZERO, 40
9D00ED90  AC640004   SW A0, 4(V1)
114:                             cursor_timer.cb=cb;
9D00ED94  AC650008   SW A1, 8(V1)
115:                             cursor_timer.active=TRUE;
9D00ED98  24030001   ADDIU V1, ZERO, 1
9D00ED9C  AC434C50   SW V1, 19536(V0)
9D00EDA0  03E00008   JR RA
9D00EDA4  00000000   NOP
116:                         }
117:                     }else{
118:                         cursor_timer.active=FALSE;
9D00EDA8  AC404C50   SW ZERO, 19536(V0)
9D00EDAC  03E00008   JR RA
9D00EDB0  00000000   NOP
119:                     }
120:                 }
121:                 
122:                 // interruption qui assure le fonctionnement du 
123:                 // générateur vidéo.
124:                 void __ISR(_TIMER_2_VECTOR,IPL7AUTO) tmr2_isr(void){
9D00EDB4  415DE800   RDPGPR SP, SP
9D00EDB8  401B7000   MFC0 K1, EPC
9D00EDBC  401A6002   MFC0 K0, SRSCtl
9D00EDC0  27BDFF88   ADDIU SP, SP, -120
9D00EDC4  401B6000   MFC0 K1, Status
9D00EDC8  AFBA0070   SW K0, 112(SP)
9D00EDCC  AFBB0074   SW K1, 116(SP)
9D00EDD0  7C1B7844   INS K1, ZERO, 1, 15
9D00EDD4  377B1C00   ORI K1, K1, 7168
9D00EDD8  409B6000   MTC0 K1, Status
9D00EDDC  AFA3001C   SW V1, 28(SP)
9D00EDE0  AFA20018   SW V0, 24(SP)
9D00EDE4  8FA30070   LW V1, 112(SP)
9D00EDE8  3063000F   ANDI V1, V1, 15
9D00EDEC  14600012   BNE V1, ZERO, 0x9D00EE38
9D00EDF0  00000000   NOP
9D00EDF4  AFBF005C   SW RA, 92(SP)
9D00EDF8  AFB90058   SW T9, 88(SP)
9D00EDFC  AFB80054   SW T8, 84(SP)
9D00EE00  AFB00050   SW S0, 80(SP)
9D00EE04  AFAF004C   SW T7, 76(SP)
9D00EE08  AFAE0048   SW T6, 72(SP)
9D00EE0C  AFAD0044   SW T5, 68(SP)
9D00EE10  AFAC0040   SW T4, 64(SP)
9D00EE14  AFAB003C   SW T3, 60(SP)
9D00EE18  AFAA0038   SW T2, 56(SP)
9D00EE1C  AFA90034   SW T1, 52(SP)
9D00EE20  AFA80030   SW T0, 48(SP)
9D00EE24  AFA7002C   SW A3, 44(SP)
9D00EE28  AFA60028   SW A2, 40(SP)
9D00EE2C  AFA50024   SW A1, 36(SP)
9D00EE30  AFA40020   SW A0, 32(SP)
9D00EE34  AFA10014   SW AT, 20(SP)
9D00EE38  00001012   MFLO V0
9D00EE3C  AFA20064   SW V0, 100(SP)
9D00EE40  00001810   MFHI V1
9D00EE44  AFA30060   SW V1, 96(SP)
125:                     _disable_video_out();
9D00EE48  3C02BF81   LUI V0, -16511
9D00EE4C  9043FB44   LBU V1, -1212(V0)
9D00EE50  7C031804   INS V1, ZERO, 0, 4
9D00EE54  A043FB44   SB V1, -1212(V0)
9D00EE58  3C02BF80   LUI V0, -16512
9D00EE5C  8C435800   LW V1, 22528(V0)
9D00EE60  7C037BC4   INS V1, ZERO, 15, 1
9D00EE64  AC435800   SW V1, 22528(V0)
126:                     static int ln_cnt=0;
127:                     static char video=0;
128:                     static char even=1;
129:                     
130:                     ln_cnt++;
9D00EE68  8F83802C   LW V1, -32724(GP)
9D00EE6C  24620001   ADDIU V0, V1, 1
131:                     switch (ln_cnt){
9D00EE70  24040004   ADDIU A0, ZERO, 4
9D00EE74  1044001C   BEQ V0, A0, 0x9D00EEE8
9D00EE78  AF82802C   SW V0, -32724(GP)
9D00EE7C  28440005   SLTI A0, V0, 5
9D00EE80  10800008   BEQ A0, ZERO, 0x9D00EEA4
9D00EE84  24040203   ADDIU A0, ZERO, 515
9D00EE88  24040001   ADDIU A0, ZERO, 1
9D00EE8C  1044000D   BEQ V0, A0, 0x9D00EEC4
9D00EE90  24040003   ADDIU A0, ZERO, 3
9D00EE94  50440010   BEQL V0, A0, 0x9D00EED8
9D00EE98  24030010   ADDIU V1, ZERO, 16
9D00EEA4  10440029   BEQ V0, A0, 0x9D00EF4C
9D00EEA8  2404020D   ADDIU A0, ZERO, 525
9D00EEAC  10440029   BEQ V0, A0, 0x9D00EF54
9D00EEB0  24040022   ADDIU A0, ZERO, 34
9D00EEB4  54440029   BNEL V0, A0, 0x9D00EF5C
9D00EEB8  83828028   LB V0, -32728(GP)
132:                         case 1:
133:                             PORTBCLR =VSYNC_OUT;
9D00EEC4  24030010   ADDIU V1, ZERO, 16
9D00EEC8  3C02BF88   LUI V0, -16504
9D00EECC  AC436124   SW V1, 24868(V0)
134:                             break;
9D00EED0  0B403C07   J 0x9D00F01C
9D00EED4  24030200   ADDIU V1, ZERO, 512
135:                         case 3:
136:                             PORTBSET=VSYNC_OUT;
9D00EED8  3C02BF88   LUI V0, -16504
9D00EEDC  AC436128   SW V1, 24872(V0)
137:                             break;
9D00EEE0  0B403C07   J 0x9D00F01C
9D00EEE4  24030200   ADDIU V1, ZERO, 512
138:                         case 4:
139:                             if (cursor_timer.active){
9D00EEE8  3C02A000   LUI V0, -24576
9D00EEEC  8C424C50   LW V0, 19536(V0)
9D00EEF0  10400049   BEQ V0, ZERO, 0x9D00F018
9D00EEF4  3C02A000   LUI V0, -24576
140:                                 cursor_timer.period--;
9D00EEF8  24424C50   ADDIU V0, V0, 19536
9D00EEFC  8C430004   LW V1, 4(V0)
9D00EF00  2463FFFF   ADDIU V1, V1, -1
9D00EF04  AC430004   SW V1, 4(V0)
141:                                 if (!cursor_timer.period){
9D00EF08  8C420004   LW V0, 4(V0)
9D00EF0C  54400043   BNEL V0, ZERO, 0x9D00F01C
9D00EF10  24030200   ADDIU V1, ZERO, 512
142:                                     cursor_timer.cb();
9D00EF14  3C10A000   LUI S0, -24576
9D00EF18  26104C50   ADDIU S0, S0, 19536
9D00EF1C  8E020008   LW V0, 8(S0)
9D00EF20  0040F809   JALR V0
9D00EF24  00000000   NOP
143:                                     cursor_timer.period=BLINK_DELAY;
9D00EF28  24020028   ADDIU V0, ZERO, 40
9D00EF2C  AE020004   SW V0, 4(S0)
144:                                 }
145:                             }
146:                             break;
147:                         case FIRST_LINE:
148:                             video=1;
9D00EEBC  0B403BCE   J 0x9D00EF38
9D00EEC0  24020001   ADDIU V0, ZERO, 1
9D00EF38  A3828028   SB V0, -32728(GP)
149:                             DmaSrc=(void*)&video_bmp[0];
9D00EF3C  3C02A000   LUI V0, -24576
9D00EF40  24420070   ADDIU V0, V0, 112
150:                             break;
9D00EF44  0B403C06   J 0x9D00F018
9D00EF48  AF828030   SW V0, -32720(GP)
151:                         case LAST_LINE:
152:                             video=0;
153:                             break;
9D00EF4C  0B403C06   J 0x9D00F018
9D00EF50  A3808028   SB ZERO, -32728(GP)
154:                         case FRAME_LINES:
155:                             ln_cnt=0;
156:                             break;
9D00EF54  0B403C06   J 0x9D00F018
9D00EF58  AF80802C   SW ZERO, -32724(GP)
157:                         default:
158:                             if (video){
9D00EE9C  0B403BD7   J 0x9D00EF5C
9D00EEA0  83828028   LB V0, -32728(GP)
9D00EF5C  5040002F   BEQL V0, ZERO, 0x9D00F01C
9D00EF60  24030200   ADDIU V1, ZERO, 512
159:                                 asm volatile(// jitter cancel code.
9D00EF64  3C02BF80   LUI V0, -16512
9D00EF68  24420810   ADDIU V0, V0, 2064
9D00EF6C  94440000   LHU A0, 0(V0)
9D00EF70  30840007   ANDI A0, A0, 7
9D00EF74  00042080   SLL A0, A0, 2
9D00EF78  3C029D01   LUI V0, -25343
9D00EF7C  2442EF8C   ADDIU V0, V0, -4212
9D00EF80  00822021   ADDU A0, A0, V0
9D00EF84  00800008   JR A0
9D00EF88  00000000   NOP
9D00EF8C  00000000   NOP
9D00EF90  00000000   NOP
9D00EF94  00000000   NOP
9D00EF98  00000000   NOP
9D00EF9C  00000000   NOP
9D00EFA0  00000000   NOP
9D00EFA4  00000000   NOP
9D00EFA8  00000000   NOP
160:                                 "la $v0,%0\n"
161:                                 "lhu $a0, 0($v0)\n"
162:                                 "andi $a0,$a0,7\n"
163:                                 "sll $a0,$a0,2\n"
164:                                 "la $v0, jit\n"
165:                                 "addu $a0,$v0\n"
166:                                 "jr $a0\n"
167:                                 "jit:\n"
168:                                 "nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"
169:                                 ::"i"(&TMR2)
170:                                 );
171:                                 _enable_video_out();
9D00EFAC  3C02BF81   LUI V0, -16511
9D00EFB0  9044FB44   LBU A0, -1212(V0)
9D00EFB4  24050003   ADDIU A1, ZERO, 3
9D00EFB8  7CA41804   INS A0, A1, 0, 4
9D00EFBC  A044FB44   SB A0, -1212(V0)
9D00EFC0  3C02BF80   LUI V0, -16512
9D00EFC4  8C445800   LW A0, 22528(V0)
9D00EFC8  24050001   ADDIU A1, ZERO, 1
9D00EFCC  7CA47BC4   INS A0, A1, 15, 1
9D00EFD0  AC445800   SW A0, 22528(V0)
172:                                 IFS1bits.SPI1TXIF=1;
9D00EFD4  3C02BF88   LUI V0, -16504
9D00EFD8  8C441040   LW A0, 4160(V0)
9D00EFDC  7CA43184   INS A0, A1, 6, 1
9D00EFE0  AC441040   SW A0, 4160(V0)
173:                                 DCH0SSA=KVA_TO_PA((void *)DmaSrc);
9D00EFE4  8F828030   LW V0, -32720(GP)
9D00EFE8  7C45E000   EXT A1, V0, 0, 29
9D00EFEC  3C04BF88   LUI A0, -16504
9D00EFF0  AC853090   SW A1, 12432(A0)
174:                                 if ((ln_cnt+1)&1) DmaSrc +=HRES/32;
9D00EFF4  30630001   ANDI V1, V1, 1
9D00EFF8  50600004   BEQL V1, ZERO, 0x9D00F00C
9D00EFFC  3C02BF88   LUI V0, -16504
9D00F000  2442003C   ADDIU V0, V0, 60
9D00F004  AF828030   SW V0, -32720(GP)
175:                                 DCH0CON |=128; // Enable DMA channel 0.
9D00F008  3C02BF88   LUI V0, -16504
9D00F00C  8C433060   LW V1, 12384(V0)
9D00F010  34630080   ORI V1, V1, 128
9D00F014  AC433060   SW V1, 12384(V0)
176:                             }
177:                     }//switch (ln_cnt)
178:                     mT2ClearIntFlag();
9D00EF30  0B403C07   J 0x9D00F01C
9D00EF34  24030200   ADDIU V1, ZERO, 512
9D00F018  24030200   ADDIU V1, ZERO, 512
9D00F01C  3C02BF88   LUI V0, -16504
9D00F020  AC431034   SW V1, 4148(V0)
179:                 }//tmr2_isr()
9D00F024  8FA20064   LW V0, 100(SP)
9D00F028  00400013   MTLO V0
9D00F02C  8FA30060   LW V1, 96(SP)
9D00F030  00600011   MTHI V1
9D00F034  8FA20070   LW V0, 112(SP)
9D00F038  3042000F   ANDI V0, V0, 15
9D00F03C  14400014   BNE V0, ZERO, 0x9D00F090
9D00F040  00000000   NOP
9D00F044  8FBF005C   LW RA, 92(SP)
9D00F048  8FB90058   LW T9, 88(SP)
9D00F04C  8FB80054   LW T8, 84(SP)
9D00F050  8FB00050   LW S0, 80(SP)
9D00F054  8FAF004C   LW T7, 76(SP)
9D00F058  8FAE0048   LW T6, 72(SP)
9D00F05C  8FAD0044   LW T5, 68(SP)
9D00F060  8FAC0040   LW T4, 64(SP)
9D00F064  8FAB003C   LW T3, 60(SP)
9D00F068  8FAA0038   LW T2, 56(SP)
9D00F06C  8FA90034   LW T1, 52(SP)
9D00F070  8FA80030   LW T0, 48(SP)
9D00F074  8FA7002C   LW A3, 44(SP)
9D00F078  8FA60028   LW A2, 40(SP)
9D00F07C  8FA50024   LW A1, 36(SP)
9D00F080  8FA40020   LW A0, 32(SP)
9D00F084  8FA3001C   LW V1, 28(SP)
9D00F088  8FA20018   LW V0, 24(SP)
9D00F08C  8FA10014   LW AT, 20(SP)
9D00F090  8FBB0074   LW K1, 116(SP)
9D00F094  8FBA0070   LW K0, 112(SP)
9D00F098  27BD0078   ADDIU SP, SP, 120
9D00F09C  409A6002   MTC0 K0, SRSCtl
9D00F0A0  41DDE800   WRPGPR SP, SP
9D00F0A4  409B6000   MTC0 K1, Status
9D00F0A8  42000018   ERET
---  /home/jacques/github/vpc-32vga/hardware/store/store_spi.c  -----------------------------------------
1:                   /*
2:                   * Copyright 2013,2014,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   store_spi.c
21:                   * Author: jacques Deschênes
22:                   * Description: shared SPI interface used by SDcard and SPIRAM
23:                   *
24:                   * Created on 25 novembre 2014, 15:40
25:                   * rev: 2017-07-31
26:                   */
27:                  
28:                  #include <peripheral/ports.h>
29:                  #include "store_spi.h"
30:                  
31:                  unsigned char store_initialized=0; // set to 1 by store_spi_init
32:                  
33:                  // set SPI interface clock frequency
34:                  // input:
35:                  //      freq  frequency Hertz
36:                  void spi_clock_freq(int freq){
37:                      STORE_SPICON &= ~BIT_15;
9D017B9C  3C02BF80   LUI V0, -16512
9D017BA0  8C435A00   LW V1, 23040(V0)
9D017BA4  7C037BC4   INS V1, ZERO, 15, 1
9D017BA8  AC435A00   SW V1, 23040(V0)
38:                      STORE_SPIBRG = (mGetPeripheralClock() / (freq<<1)) - 1;
9D017BAC  00042040   SLL A0, A0, 1
9D017BB0  3C030262   LUI V1, 610
9D017BB4  24635A00   ADDIU V1, V1, 23040
9D017BB8  0064001A   DIV V1, A0
9D017BBC  008001F4   TEQ A0, ZERO
9D017BC0  00002012   MFLO A0
9D017BC4  2484FFFF   ADDIU A0, A0, -1
9D017BC8  3C05BF80   LUI A1, -16512
9D017BCC  ACA45A30   SW A0, 23088(A1)
39:                      STORE_SPICON |= BIT_15;
9D017BD0  8C435A00   LW V1, 23040(V0)
9D017BD4  34638000   ORI V1, V1, -32768
9D017BD8  AC435A00   SW V1, 23040(V0)
9D017BDC  03E00008   JR RA
9D017BE0  00000000   NOP
40:                  }
41:                  
42:                  // configure SPI port
43:                  void store_spi_init(){
9D017BE4  27BDFFE8   ADDIU SP, SP, -24
9D017BE8  AFBF0014   SW RA, 20(SP)
9D017BEC  AFB00010   SW S0, 16(SP)
44:                      _sdc_deselect();
9D017BF0  24030008   ADDIU V1, ZERO, 8
9D017BF4  3C02BF88   LUI V0, -16504
9D017BF8  AC436128   SW V1, 24872(V0)
45:                      _sram_deselect();
9D017BFC  24100001   ADDIU S0, ZERO, 1
9D017C00  3C02BF88   LUI V0, -16504
9D017C04  AC506028   SW S0, 24616(V0)
46:                      STORE_SPICON = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
9D017C08  34038120   ORI V1, ZERO, -32480
9D017C0C  3C02BF80   LUI V0, -16512
9D017C10  AC435A00   SW V1, 23040(V0)
47:                      spi_clock_freq(FAST_CLOCK);
9D017C14  3C040131   LUI A0, 305
9D017C18  0F405EE7   JAL spi_clock_freq
9D017C1C  24842D00   ADDIU A0, A0, 11520
48:                      store_initialized=1;
9D017C20  A3908026   SB S0, -32730(GP)
49:                  }
9D017C24  8FBF0014   LW RA, 20(SP)
9D017C28  8FB00010   LW S0, 16(SP)
9D017C2C  03E00008   JR RA
9D017C30  27BD0018   ADDIU SP, SP, 24
50:                  
51:                  
52:                  // send one byte of data and receive one back at the same time
53:                  // input:
54:                  //      b  char to send
55:                  // output:
56:                  //      char reveived from interface
57:                  unsigned char writeSPI(unsigned char b)
58:                  {
59:                  	STORE_SPIBUF = b;
9D017C34  3C02BF80   LUI V0, -16512
9D017C38  AC445A20   SW A0, 23072(V0)
60:                  	while(!STORE_SPISTATbits.SPIRBF); // wait transfer complete
9D017C3C  3C03BF80   LUI V1, -16512
9D017C40  8C625A10   LW V0, 23056(V1)
9D017C44  30420001   ANDI V0, V0, 1
9D017C48  1040FFFD   BEQ V0, ZERO, 0x9D017C40
9D017C4C  3C02BF80   LUI V0, -16512
61:                  	return STORE_SPIBUF; // read the received value
9D017C50  8C425A20   LW V0, 23072(V0)
62:                  }// writeSPI
9D017C54  03E00008   JR RA
9D017C58  304200FF   ANDI V0, V0, 255
63:                  
---  /home/jacques/github/vpc-32vga/hardware/spiram/spiram.c  -------------------------------------------
1:                   /*
2:                   * Copyright 2013,2014,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  #include "../HardwareProfile.h"
20:                  #include "spiram.h"
21:                  #include "../Pinguino/sdmmc.h"
22:                  
23:                  /* File:   spiram.c
24:                   * Author: jacques Deschênes
25:                   * description: Low level SPI RAM interface
26:                   * rev: 2017-07-31
27:                  */
28:                  
29:                  // send command to SPI RAM
30:                  // input:
31:                  //      cmd  commmand code
32:                  //      addr address
33:                  static void sram_cmd(unsigned char cmd, unsigned addr){
9D00F9FC  27BDFFE8   ADDIU SP, SP, -24
9D00FA00  AFBF0014   SW RA, 20(SP)
9D00FA04  AFB00010   SW S0, 16(SP)
34:                      writeSPI(cmd);
9D00FA08  0F405F0D   JAL writeSPI
9D00FA0C  00A08021   ADDU S0, A1, ZERO
35:                  #if defined BIG_SRAM    
36:                      writeSPI(addr>>16);
37:                  #endif    
38:                      writeSPI(addr>>8);
9D00FA10  0F405F0D   JAL writeSPI
9D00FA14  7E043A00   EXT A0, S0, 8, 8
39:                      writeSPI(addr&0xff);
9D00FA18  0F405F0D   JAL writeSPI
9D00FA1C  320400FF   ANDI A0, S0, 255
40:                  }
9D00FA20  8FBF0014   LW RA, 20(SP)
9D00FA24  8FB00010   LW S0, 16(SP)
9D00FA28  03E00008   JR RA
9D00FA2C  27BD0018   ADDIU SP, SP, 24
41:                  
42:                  // sram_write_mode
43:                  //   select write operating mode {byte,page,sequential}
44:                  // input:
45:                  //   mode operating mode {SRAM_BTMOD,SRAM_PGMOD,SRAM_SQMOD}
46:                  // output:
47:                  //   none
48:                  void sram_write_mode(unsigned char mode){
9D00FA30  27BDFFE0   ADDIU SP, SP, -32
9D00FA34  AFBF001C   SW RA, 28(SP)
9D00FA38  AFB10018   SW S1, 24(SP)
9D00FA3C  AFB00014   SW S0, 20(SP)
9D00FA40  00808821   ADDU S1, A0, ZERO
49:                      _sram_select();
9D00FA44  24100001   ADDIU S0, ZERO, 1
9D00FA48  3C02BF88   LUI V0, -16504
9D00FA4C  AC506024   SW S0, 24612(V0)
50:                      writeSPI(SRAM_WRMR);
9D00FA50  0F405F0D   JAL writeSPI
9D00FA54  24040001   ADDIU A0, ZERO, 1
51:                      writeSPI(mode);
9D00FA58  0F405F0D   JAL writeSPI
9D00FA5C  02202021   ADDU A0, S1, ZERO
52:                      _sram_deselect();
9D00FA60  3C02BF88   LUI V0, -16504
9D00FA64  AC506028   SW S0, 24616(V0)
53:                  }
9D00FA68  8FBF001C   LW RA, 28(SP)
9D00FA6C  8FB10018   LW S1, 24(SP)
9D00FA70  8FB00014   LW S0, 20(SP)
9D00FA74  03E00008   JR RA
9D00FA78  27BD0020   ADDIU SP, SP, 32
54:                  
55:                  // sram_read_mode()
56:                  //      Read operation mode {byte,page,sequential}
57:                  // input:
58:                  //   none
59:                  // output:
60:                  //   char  Operating mode {SRAM_BTMOD,SRAM_PGMOD,SRAM_SQMOD}
61:                  unsigned char sram_read_mode(){
9D00FA7C  27BDFFE8   ADDIU SP, SP, -24
9D00FA80  AFBF0014   SW RA, 20(SP)
9D00FA84  AFB00010   SW S0, 16(SP)
62:                      unsigned char mode;
63:                      _sram_select();
9D00FA88  24100001   ADDIU S0, ZERO, 1
9D00FA8C  3C02BF88   LUI V0, -16504
9D00FA90  AC506024   SW S0, 24612(V0)
64:                      writeSPI(SRAM_RDMR);
9D00FA94  0F405F0D   JAL writeSPI
9D00FA98  24040005   ADDIU A0, ZERO, 5
65:                      mode=writeSPI(0);
9D00FA9C  0F405F0D   JAL writeSPI
9D00FAA0  00002021   ADDU A0, ZERO, ZERO
66:                      _sram_deselect();
9D00FAA4  3C03BF88   LUI V1, -16504
9D00FAA8  AC706028   SW S0, 24616(V1)
67:                      return mode;
68:                  }
9D00FAAC  8FBF0014   LW RA, 20(SP)
9D00FAB0  8FB00010   LW S0, 16(SP)
9D00FAB4  03E00008   JR RA
9D00FAB8  27BD0018   ADDIU SP, SP, 24
69:                  
70:                  // initialize SPI RAM operating mode
71:                  // use sequencial mode, SPI interface.
72:                  void sram_init(){
9D00FABC  27BDFFE8   ADDIU SP, SP, -24
9D00FAC0  AFBF0014   SW RA, 20(SP)
73:                      if (!store_initialized) store_spi_init();
9D00FAC4  93828026   LBU V0, -32730(GP)
9D00FAC8  14400003   BNE V0, ZERO, 0x9D00FAD8
9D00FACC  00000000   NOP
9D00FAD0  0F405EF9   JAL store_spi_init
9D00FAD4  00000000   NOP
74:                      sram_write_mode(SRAM_SQMD);
9D00FAD8  0F403E8C   JAL sram_write_mode
9D00FADC  24040040   ADDIU A0, ZERO, 64
75:                  }
9D00FAE0  8FBF0014   LW RA, 20(SP)
9D00FAE4  03E00008   JR RA
9D00FAE8  27BD0018   ADDIU SP, SP, 24
76:                  
77:                  // sram_clear()
78:                  //      Clear RAM to zero.
79:                  // input:
80:                  //      none
81:                  // output:
82:                  //      none
83:                  void sram_clear(){
9D00FAEC  27BDFFE8   ADDIU SP, SP, -24
9D00FAF0  AFBF0014   SW RA, 20(SP)
9D00FAF4  AFB00010   SW S0, 16(SP)
84:                      unsigned i;
85:                      _sram_select();
9D00FAF8  24030001   ADDIU V1, ZERO, 1
9D00FAFC  3C02BF88   LUI V0, -16504
9D00FB00  AC436024   SW V1, 24612(V0)
86:                      sram_cmd(SRAM_WRITE,0);
9D00FB04  24040002   ADDIU A0, ZERO, 2
9D00FB08  0F403E7F   JAL sram_cmd
9D00FB0C  00002821   ADDU A1, ZERO, ZERO
9D00FB10  3C100001   LUI S0, 1
87:                      for (i=0;i<SRAM_SIZE;i++) writeSPI(0);
9D00FB14  0F405F0D   JAL writeSPI
9D00FB18  00002021   ADDU A0, ZERO, ZERO
9D00FB1C  2610FFFF   ADDIU S0, S0, -1
9D00FB20  1600FFFC   BNE S0, ZERO, 0x9D00FB14
9D00FB24  24030001   ADDIU V1, ZERO, 1
88:                      _sram_deselect();
9D00FB28  3C02BF88   LUI V0, -16504
9D00FB2C  AC436028   SW V1, 24616(V0)
89:                  }
9D00FB30  8FBF0014   LW RA, 20(SP)
9D00FB34  8FB00010   LW S0, 16(SP)
9D00FB38  03E00008   JR RA
9D00FB3C  27BD0018   ADDIU SP, SP, 24
90:                  
91:                  // sram_clear_block()
92:                  //      Clear to zero a block in SPI RAM
93:                  // input:
94:                  //      addr  Start address
95:                  //      size  Size in byte to zeroes.
96:                  // output:
97:                  //      none
98:                  void sram_clear_block(unsigned addr, unsigned size){
9D00FB40  27BDFFE0   ADDIU SP, SP, -32
9D00FB44  AFBF001C   SW RA, 28(SP)
9D00FB48  AFB10018   SW S1, 24(SP)
9D00FB4C  AFB00014   SW S0, 20(SP)
9D00FB50  00801021   ADDU V0, A0, ZERO
9D00FB54  00A08821   ADDU S1, A1, ZERO
99:                      int i;
100:                     _sram_select();
9D00FB58  24040001   ADDIU A0, ZERO, 1
9D00FB5C  3C03BF88   LUI V1, -16504
9D00FB60  AC646024   SW A0, 24612(V1)
101:                     sram_cmd(SRAM_WRITE,addr);
9D00FB64  24040002   ADDIU A0, ZERO, 2
9D00FB68  0F403E7F   JAL sram_cmd
9D00FB6C  00402821   ADDU A1, V0, ZERO
102:                     for(i=0;i<size;i++)writeSPI(0);
9D00FB70  12200006   BEQ S1, ZERO, 0x9D00FB8C
9D00FB74  00008021   ADDU S0, ZERO, ZERO
9D00FB78  0F405F0D   JAL writeSPI
9D00FB7C  00002021   ADDU A0, ZERO, ZERO
9D00FB80  26100001   ADDIU S0, S0, 1
9D00FB84  1611FFFC   BNE S0, S1, 0x9D00FB78
9D00FB88  00000000   NOP
103:                     _sram_deselect();
9D00FB8C  24030001   ADDIU V1, ZERO, 1
9D00FB90  3C02BF88   LUI V0, -16504
9D00FB94  AC436028   SW V1, 24616(V0)
104:                 }
9D00FB98  8FBF001C   LW RA, 28(SP)
9D00FB9C  8FB10018   LW S1, 24(SP)
9D00FBA0  8FB00014   LW S0, 20(SP)
9D00FBA4  03E00008   JR RA
9D00FBA8  27BD0020   ADDIU SP, SP, 32
105:                 
106:                 // sram_read_byte()
107:                 //      Read a single byte from SPI RAM
108:                 // input:
109:                 //      addr  Adress to read.
110:                 // output:
111:                 //      char  byte read.
112:                 unsigned char sram_read_byte(unsigned addr){
9D00FBAC  27BDFFE8   ADDIU SP, SP, -24
9D00FBB0  AFBF0014   SW RA, 20(SP)
9D00FBB4  AFB00010   SW S0, 16(SP)
9D00FBB8  00802821   ADDU A1, A0, ZERO
113:                     unsigned char b;
114:                 
115:                     _sram_select();
9D00FBBC  24100001   ADDIU S0, ZERO, 1
9D00FBC0  3C02BF88   LUI V0, -16504
9D00FBC4  AC506024   SW S0, 24612(V0)
116:                     sram_cmd(SRAM_READ,addr);
9D00FBC8  0F403E7F   JAL sram_cmd
9D00FBCC  24040003   ADDIU A0, ZERO, 3
117:                     b=writeSPI(0);
9D00FBD0  0F405F0D   JAL writeSPI
9D00FBD4  00002021   ADDU A0, ZERO, ZERO
118:                     _sram_deselect();
9D00FBD8  3C03BF88   LUI V1, -16504
9D00FBDC  AC706028   SW S0, 24616(V1)
119:                     return b;
120:                 }
9D00FBE0  8FBF0014   LW RA, 20(SP)
9D00FBE4  8FB00010   LW S0, 16(SP)
9D00FBE8  03E00008   JR RA
9D00FBEC  27BD0018   ADDIU SP, SP, 24
121:                 
122:                 // sram_write_byte()
123:                 //      Write a byte to SPI RAM
124:                 // input:
125:                 //      addr  Adresse to write.
126:                 //      byte  Value to write
127:                 // ouput:
128:                 //      none    
129:                 void sram_write_byte(unsigned addr, unsigned char byte){
9D00FBF0  27BDFFE0   ADDIU SP, SP, -32
9D00FBF4  AFBF001C   SW RA, 28(SP)
9D00FBF8  AFB10018   SW S1, 24(SP)
9D00FBFC  AFB00014   SW S0, 20(SP)
9D00FC00  00801021   ADDU V0, A0, ZERO
9D00FC04  00A08821   ADDU S1, A1, ZERO
130:                     _sram_select();
9D00FC08  24100001   ADDIU S0, ZERO, 1
9D00FC0C  3C03BF88   LUI V1, -16504
9D00FC10  AC706024   SW S0, 24612(V1)
131:                     sram_cmd(SRAM_WRITE,addr);
9D00FC14  24040002   ADDIU A0, ZERO, 2
9D00FC18  0F403E7F   JAL sram_cmd
9D00FC1C  00402821   ADDU A1, V0, ZERO
132:                     writeSPI(byte);
9D00FC20  0F405F0D   JAL writeSPI
9D00FC24  02202021   ADDU A0, S1, ZERO
133:                     _sram_deselect();
9D00FC28  3C02BF88   LUI V0, -16504
9D00FC2C  AC506028   SW S0, 24616(V0)
134:                 }
9D00FC30  8FBF001C   LW RA, 28(SP)
9D00FC34  8FB10018   LW S1, 24(SP)
9D00FC38  8FB00014   LW S0, 20(SP)
9D00FC3C  03E00008   JR RA
9D00FC40  27BD0020   ADDIU SP, SP, 32
135:                 
136:                 // sram_read_block()
137:                 //      Read a range of adress in SPI RAM
138:                 // input:
139:                 //      addr  Adressse first byte.
140:                 //      buffer Buffer to store data.
141:                 //      count  Number of bytes to read.
142:                 // output:
143:                 //      none  Except for buffer[] content.
144:                 void sram_read_block(unsigned addr, unsigned char buffer[], unsigned count){
9D00FC44  27BDFFE0   ADDIU SP, SP, -32
9D00FC48  AFBF001C   SW RA, 28(SP)
9D00FC4C  AFB20018   SW S2, 24(SP)
9D00FC50  AFB10014   SW S1, 20(SP)
9D00FC54  AFB00010   SW S0, 16(SP)
9D00FC58  00801021   ADDU V0, A0, ZERO
9D00FC5C  00A09021   ADDU S2, A1, ZERO
9D00FC60  00C08821   ADDU S1, A2, ZERO
145:                     unsigned i;
146:                     _sram_select();
9D00FC64  24040001   ADDIU A0, ZERO, 1
9D00FC68  3C03BF88   LUI V1, -16504
9D00FC6C  AC646024   SW A0, 24612(V1)
147:                     sram_cmd(SRAM_READ,addr);
9D00FC70  24040003   ADDIU A0, ZERO, 3
9D00FC74  0F403E7F   JAL sram_cmd
9D00FC78  00402821   ADDU A1, V0, ZERO
148:                     for (i=0;i<count;i++) buffer[i]=writeSPI(0);
9D00FC7C  12200008   BEQ S1, ZERO, 0x9D00FCA0
9D00FC80  02408021   ADDU S0, S2, ZERO
9D00FC84  02518821   ADDU S1, S2, S1
9D00FC88  0F405F0D   JAL writeSPI
9D00FC8C  00002021   ADDU A0, ZERO, ZERO
9D00FC90  A2020000   SB V0, 0(S0)
9D00FC94  26100001   ADDIU S0, S0, 1
9D00FC98  1611FFFB   BNE S0, S1, 0x9D00FC88
9D00FC9C  00000000   NOP
149:                     _sram_deselect();
9D00FCA0  24030001   ADDIU V1, ZERO, 1
9D00FCA4  3C02BF88   LUI V0, -16504
9D00FCA8  AC436028   SW V1, 24616(V0)
150:                 }
9D00FCAC  8FBF001C   LW RA, 28(SP)
9D00FCB0  8FB20018   LW S2, 24(SP)
9D00FCB4  8FB10014   LW S1, 20(SP)
9D00FCB8  8FB00010   LW S0, 16(SP)
9D00FCBC  03E00008   JR RA
9D00FCC0  27BD0020   ADDIU SP, SP, 32
151:                 
152:                 // sram_write_block()
153:                 //      Write a range of byte to SPI RAM
154:                 // input:
155:                 //      addr Adresse of first byte location.
156:                 //      buffer  Buffer that contain data to write.
157:                 //      count  Number of bytes to write.
158:                 // output:
159:                 //      none
160:                 void sram_write_block(unsigned addr, const char buffer[],unsigned count){
9D00FCC4  27BDFFE0   ADDIU SP, SP, -32
9D00FCC8  AFBF001C   SW RA, 28(SP)
9D00FCCC  AFB20018   SW S2, 24(SP)
9D00FCD0  AFB10014   SW S1, 20(SP)
9D00FCD4  AFB00010   SW S0, 16(SP)
9D00FCD8  00801021   ADDU V0, A0, ZERO
9D00FCDC  00A09021   ADDU S2, A1, ZERO
9D00FCE0  00C08821   ADDU S1, A2, ZERO
161:                     unsigned i;
162:                     _sram_select();
9D00FCE4  24040001   ADDIU A0, ZERO, 1
9D00FCE8  3C03BF88   LUI V1, -16504
9D00FCEC  AC646024   SW A0, 24612(V1)
163:                     sram_cmd(SRAM_WRITE,addr);
9D00FCF0  24040002   ADDIU A0, ZERO, 2
9D00FCF4  0F403E7F   JAL sram_cmd
9D00FCF8  00402821   ADDU A1, V0, ZERO
164:                     for (i=0;i<count;i++) writeSPI(buffer[i]);
9D00FCFC  12200007   BEQ S1, ZERO, 0x9D00FD1C
9D00FD00  02408021   ADDU S0, S2, ZERO
9D00FD04  02518821   ADDU S1, S2, S1
9D00FD08  0F405F0D   JAL writeSPI
9D00FD0C  92040000   LBU A0, 0(S0)
9D00FD10  26100001   ADDIU S0, S0, 1
9D00FD14  1611FFFC   BNE S0, S1, 0x9D00FD08
9D00FD18  00000000   NOP
165:                     _sram_deselect();
9D00FD1C  24030001   ADDIU V1, ZERO, 1
9D00FD20  3C02BF88   LUI V0, -16504
9D00FD24  AC436028   SW V1, 24616(V0)
166:                 }
9D00FD28  8FBF001C   LW RA, 28(SP)
9D00FD2C  8FB20018   LW S2, 24(SP)
9D00FD30  8FB10014   LW S1, 20(SP)
9D00FD34  8FB00010   LW S0, 16(SP)
9D00FD38  03E00008   JR RA
9D00FD3C  27BD0020   ADDIU SP, SP, 32
167:                 
168:                 // sram_write_string()
169:                 //      Write a zero terminated string to SPI RAM
170:                 // input:
171:                 //      addr  Start adress in SPI RAM
172:                 //      *str  Pointer to asciiz string
173:                 // output:
174:                 //      none
175:                 void sram_write_string(unsigned addr, const char *str){
9D00FD40  27BDFFE8   ADDIU SP, SP, -24
9D00FD44  AFBF0014   SW RA, 20(SP)
9D00FD48  AFB00010   SW S0, 16(SP)
9D00FD4C  00801021   ADDU V0, A0, ZERO
9D00FD50  00A08021   ADDU S0, A1, ZERO
176:                     _sram_select();
9D00FD54  24040001   ADDIU A0, ZERO, 1
9D00FD58  3C03BF88   LUI V1, -16504
9D00FD5C  AC646024   SW A0, 24612(V1)
177:                     sram_cmd(SRAM_WRITE,addr);
9D00FD60  24040002   ADDIU A0, ZERO, 2
9D00FD64  0F403E7F   JAL sram_cmd
9D00FD68  00402821   ADDU A1, V0, ZERO
178:                     while (*str) writeSPI(*str++);
9D00FD6C  82040000   LB A0, 0(S0)
9D00FD70  10800006   BEQ A0, ZERO, 0x9D00FD8C
9D00FD74  26100001   ADDIU S0, S0, 1
9D00FD78  0F405F0D   JAL writeSPI
9D00FD7C  308400FF   ANDI A0, A0, 255
9D00FD80  82040000   LB A0, 0(S0)
9D00FD84  1480FFFC   BNE A0, ZERO, 0x9D00FD78
9D00FD88  26100001   ADDIU S0, S0, 1
179:                     writeSPI(0);
9D00FD8C  0F405F0D   JAL writeSPI
9D00FD90  00002021   ADDU A0, ZERO, ZERO
180:                     _sram_deselect();
9D00FD94  24030001   ADDIU V1, ZERO, 1
9D00FD98  3C02BF88   LUI V0, -16504
9D00FD9C  AC436028   SW V1, 24616(V0)
181:                 }
9D00FDA0  8FBF0014   LW RA, 20(SP)
9D00FDA4  8FB00010   LW S0, 16(SP)
9D00FDA8  03E00008   JR RA
9D00FDAC  27BD0018   ADDIU SP, SP, 24
182:                 
183:                 // sram_read_string()
184:                 //      Read a asciiz str from SPI RAM
185:                 // input:
186:                 //      addr Adresse to read from.
187:                 //      *buffer Buffer to receive str.
188:                 //      size  Maximum length to read.
189:                 // output:
190:                 //      len  Length of string read
191:                 int sram_read_string(unsigned addr, char *buffer,unsigned size){
9D00FDB0  27BDFFD0   ADDIU SP, SP, -48
9D00FDB4  AFBF002C   SW RA, 44(SP)
9D00FDB8  AFB50028   SW S5, 40(SP)
9D00FDBC  AFB40024   SW S4, 36(SP)
9D00FDC0  AFB30020   SW S3, 32(SP)
9D00FDC4  AFB2001C   SW S2, 28(SP)
9D00FDC8  AFB10018   SW S1, 24(SP)
9D00FDCC  AFB00014   SW S0, 20(SP)
9D00FDD0  00801021   ADDU V0, A0, ZERO
9D00FDD4  00A09821   ADDU S3, A1, ZERO
9D00FDD8  00C0A821   ADDU S5, A2, ZERO
192:                     int i=0;
9D00FE00  0B403F85   J 0x9D00FE14
9D00FE04  00008021   ADDU S0, ZERO, ZERO
9D00FE60  0B403F90   J 0x9D00FE40
9D00FE64  00008021   ADDU S0, ZERO, ZERO
193:                 
194:                     _sram_select();
9D00FDDC  24040001   ADDIU A0, ZERO, 1
9D00FDE0  3C03BF88   LUI V1, -16504
9D00FDE4  AC646024   SW A0, 24612(V1)
195:                     sram_cmd(SRAM_READ,addr);
9D00FDE8  24040003   ADDIU A0, ZERO, 3
9D00FDEC  0F403E7F   JAL sram_cmd
9D00FDF0  00402821   ADDU A1, V0, ZERO
196:                     while (i<size && (buffer[i]=writeSPI(0xff))) i++;
9D00FDF4  12A00017   BEQ S5, ZERO, 0x9D00FE54
9D00FDF8  02A0A021   ADDU S4, S5, ZERO
9D00FDFC  00008821   ADDU S1, ZERO, ZERO
9D00FE08  26100001   ADDIU S0, S0, 1
9D00FE0C  12140007   BEQ S0, S4, 0x9D00FE2C
9D00FE10  02008821   ADDU S1, S0, ZERO
9D00FE14  02719021   ADDU S2, S3, S1
9D00FE18  0F405F0D   JAL writeSPI
9D00FE1C  240400FF   ADDIU A0, ZERO, 255
9D00FE20  7C021420   SEB V0, V0
9D00FE24  1440FFF8   BNE V0, ZERO, 0x9D00FE08
9D00FE28  A2420000   SB V0, 0(S2)
197:                     _sram_deselect();
9D00FE2C  24030001   ADDIU V1, ZERO, 1
9D00FE30  3C02BF88   LUI V0, -16504
9D00FE34  AC436028   SW V1, 24616(V0)
9D00FE54  24030001   ADDIU V1, ZERO, 1
9D00FE58  3C02BF88   LUI V0, -16504
9D00FE5C  AC436028   SW V1, 24616(V0)
198:                     if (i==size)buffer[--i]=0;
9D00FE38  5635000B   BNEL S1, S5, 0x9D00FE68
9D00FE3C  2602FFFF   ADDIU V0, S0, -1
9D00FE40  2610FFFF   ADDIU S0, S0, -1
9D00FE44  02709821   ADDU S3, S3, S0
9D00FE48  A2600000   SB ZERO, 0(S3)
199:                     return --i;
9D00FE4C  0B403F9A   J 0x9D00FE68
9D00FE50  2602FFFF   ADDIU V0, S0, -1
200:                 }
9D00FE68  8FBF002C   LW RA, 44(SP)
9D00FE6C  8FB50028   LW S5, 40(SP)
9D00FE70  8FB40024   LW S4, 36(SP)
9D00FE74  8FB30020   LW S3, 32(SP)
9D00FE78  8FB2001C   LW S2, 28(SP)
9D00FE7C  8FB10018   LW S1, 24(SP)
9D00FE80  8FB00014   LW S0, 20(SP)
9D00FE84  03E00008   JR RA
9D00FE88  27BD0030   ADDIU SP, SP, 48
201:                 
202:                 
---  /home/jacques/github/vpc-32vga/hardware/sound/sound.c  ---------------------------------------------
1:                   /*
2:                   * Copyright 2013,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   sound.c
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 13 septembre 2013, 20:42
23:                   * rev: 2017-07-31
24:                   */
25:                  
26:                  #include <plib.h>
27:                  #include "../HardwareProfile.h"
28:                  #include "sound.h"
29:                  
30:                  
31:                  
32:                  volatile unsigned char fSound=0; // flags
33:                  volatile unsigned int duration;
34:                  volatile unsigned int *tones_list;
35:                  
36:                  
37:                  
38:                  void tone(unsigned int freq, // frequency hertz
39:                            unsigned int msec){ // duration  milliseconds
40:                      //config OC3 for tone generation
41:                      OC3CONbits.OCM = 5; // PWM mode
9D0125C4  3C02BF80   LUI V0, -16512
9D0125C8  94433400   LHU V1, 13312(V0)
9D0125CC  24060005   ADDIU A2, ZERO, 5
9D0125D0  7CC31004   INS V1, A2, 0, 3
9D0125D4  A4433400   SH V1, 13312(V0)
42:                      OC3CONbits.OCTSEL=1; // use TIMER3
9D0125D8  94433400   LHU V1, 13312(V0)
9D0125DC  24060001   ADDIU A2, ZERO, 1
9D0125E0  7CC318C4   INS V1, A2, 3, 1
9D0125E4  A4433400   SH V1, 13312(V0)
43:                      OC3RS=0;
9D0125E8  3C03BF80   LUI V1, -16512
9D0125EC  AC603420   SW ZERO, 13344(V1)
44:                      T3CON=0;
9D0125F0  3C03BF80   LUI V1, -16512
9D0125F4  AC600A00   SW ZERO, 2560(V1)
45:                      T3CONbits.TCKPS=3;
9D0125F8  3C03BF80   LUI V1, -16512
9D0125FC  94670A00   LHU A3, 2560(V1)
9D012600  24080003   ADDIU T0, ZERO, 3
9D012604  7D073104   INS A3, T0, 4, 3
9D012608  A4670A00   SH A3, 2560(V1)
46:                      PR3=(SYSCLK/8/freq)-1; // 50% duty cycle
9D01260C  3C07004C   LUI A3, 76
9D012610  24E74B40   ADDIU A3, A3, 19264
9D012614  00E4001B   DIVU A3, A0
9D012618  008001F4   TEQ A0, ZERO
9D01261C  00003812   MFLO A3
9D012620  24E7FFFF   ADDIU A3, A3, -1
9D012624  3C08BF80   LUI T0, -16512
9D012628  AD070A20   SW A3, 2592(T0)
47:                      OC3R=SYSCLK/16/freq;
9D01262C  3C070026   LUI A3, 38
9D012630  24E725A0   ADDIU A3, A3, 9632
9D012634  00E4001B   DIVU A3, A0
9D012638  008001F4   TEQ A0, ZERO
9D01263C  00002012   MFLO A0
9D012640  3C08BF80   LUI T0, -16512
9D012644  AD043410   SW A0, 13328(T0)
48:                      duration=msec;
9D012648  AF858060   SW A1, -32672(GP)
49:                      fSound |=TONE_ON;
9D01264C  93848025   LBU A0, -32731(GP)
9D012650  308400FF   ANDI A0, A0, 255
9D012654  34840001   ORI A0, A0, 1
9D012658  A3848025   SB A0, -32731(GP)
50:                      mTone_on();
9D01265C  94443400   LHU A0, 13312(V0)
9D012660  7CC47BC4   INS A0, A2, 15, 1
9D012664  A4443400   SH A0, 13312(V0)
51:                      T3CONbits.ON=1;
9D012668  94620A00   LHU V0, 2560(V1)
9D01266C  7CC27BC4   INS V0, A2, 15, 1
9D012670  A4620A00   SH V0, 2560(V1)
9D012674  03E00008   JR RA
9D012678  00000000   NOP
52:                  } //tone();
53:                  
54:                  // play a sequence of tones
55:                  void tune(const unsigned int *buffer){
9D01267C  27BDFFE8   ADDIU SP, SP, -24
9D012680  AFBF0014   SW RA, 20(SP)
56:                      tones_list=(unsigned *)buffer;
9D012684  AF84805C   SW A0, -32676(GP)
57:                      if (*tones_list && *(tones_list+1)){
9D012688  8C820000   LW V0, 0(A0)
9D01268C  10400023   BEQ V0, ZERO, 0x9D01271C
9D012690  8FBF0014   LW RA, 20(SP)
9D012694  8C820004   LW V0, 4(A0)
9D012698  10400020   BEQ V0, ZERO, 0x9D01271C
9D01269C  00000000   NOP
58:                          fSound |= PLAY_TUNE;
9D0126A0  93828025   LBU V0, -32731(GP)
9D0126A4  304200FF   ANDI V0, V0, 255
9D0126A8  34420002   ORI V0, V0, 2
9D0126AC  A3828025   SB V0, -32731(GP)
59:                          IPC3bits.T3IP=2;
9D0126B0  3C02BF88   LUI V0, -16504
9D0126B4  8C4310C0   LW V1, 4288(V0)
9D0126B8  24050002   ADDIU A1, ZERO, 2
9D0126BC  7CA32084   INS V1, A1, 2, 3
9D0126C0  AC4310C0   SW V1, 4288(V0)
60:                          IPC3bits.T3IS=3;
9D0126C4  8C4310C0   LW V1, 4288(V0)
9D0126C8  24050003   ADDIU A1, ZERO, 3
9D0126CC  7CA30804   INS V1, A1, 0, 2
9D0126D0  AC4310C0   SW V1, 4288(V0)
61:                          IFS0bits.T3IF=0;
9D0126D4  3C02BF88   LUI V0, -16504
9D0126D8  8C431030   LW V1, 4144(V0)
9D0126DC  7C037384   INS V1, ZERO, 14, 1
9D0126E0  AC431030   SW V1, 4144(V0)
62:                          IEC0bits.T3IE=1;
9D0126E4  3C02BF88   LUI V0, -16504
9D0126E8  8C431060   LW V1, 4192(V0)
9D0126EC  24050001   ADDIU A1, ZERO, 1
9D0126F0  7CA37384   INS V1, A1, 14, 1
9D0126F4  AC431060   SW V1, 4192(V0)
63:                          tone(*tones_list++,*tones_list++);
9D0126F8  24820004   ADDIU V0, A0, 4
9D0126FC  AF82805C   SW V0, -32676(GP)
9D012700  8C820000   LW V0, 0(A0)
9D012704  24830008   ADDIU V1, A0, 8
9D012708  AF83805C   SW V1, -32676(GP)
9D01270C  8C850004   LW A1, 4(A0)
9D012710  0F404971   JAL tone
9D012714  00402021   ADDU A0, V0, ZERO
64:                      }
65:                  }//tune()
9D012718  8FBF0014   LW RA, 20(SP)
9D01271C  03E00008   JR RA
9D012720  27BD0018   ADDIU SP, SP, 24
66:                  
67:                  
68:                  // TIMER3 interrupt service routine
69:                  // select next note to play
70:                  void __ISR(_TIMER_3_VECTOR, IPL2SOFT)  T3Handler(void){
9D012724  415DE800   RDPGPR SP, SP
9D012728  401A7000   MFC0 K0, EPC
9D01272C  401B6000   MFC0 K1, Status
9D012730  27BDFF90   ADDIU SP, SP, -112
9D012734  AFBA006C   SW K0, 108(SP)
9D012738  401A6002   MFC0 K0, SRSCtl
9D01273C  AFBB0068   SW K1, 104(SP)
9D012740  AFBA0064   SW K0, 100(SP)
9D012744  7C1B7844   INS K1, ZERO, 1, 15
9D012748  377B0800   ORI K1, K1, 2048
9D01274C  409B6000   MTC0 K1, Status
9D012750  AFBF0054   SW RA, 84(SP)
9D012754  AFB90050   SW T9, 80(SP)
9D012758  AFB8004C   SW T8, 76(SP)
9D01275C  AFAF0048   SW T7, 72(SP)
9D012760  AFAE0044   SW T6, 68(SP)
9D012764  AFAD0040   SW T5, 64(SP)
9D012768  AFAC003C   SW T4, 60(SP)
9D01276C  AFAB0038   SW T3, 56(SP)
9D012770  AFAA0034   SW T2, 52(SP)
9D012774  AFA90030   SW T1, 48(SP)
9D012778  AFA8002C   SW T0, 44(SP)
9D01277C  AFA70028   SW A3, 40(SP)
9D012780  AFA60024   SW A2, 36(SP)
9D012784  AFA50020   SW A1, 32(SP)
9D012788  AFA4001C   SW A0, 28(SP)
9D01278C  AFA30018   SW V1, 24(SP)
9D012790  AFA20014   SW V0, 20(SP)
9D012794  AFA10010   SW AT, 16(SP)
9D012798  00001012   MFLO V0
9D01279C  AFA2005C   SW V0, 92(SP)
9D0127A0  00001810   MFHI V1
9D0127A4  AFA30058   SW V1, 88(SP)
71:                      unsigned int f,d;
72:                         mT3ClearIntFlag();
9D0127A8  24034000   ADDIU V1, ZERO, 16384
9D0127AC  3C02BF88   LUI V0, -16504
9D0127B0  AC431034   SW V1, 4148(V0)
73:                         if (fSound==PLAY_TUNE){
9D0127B4  93838025   LBU V1, -32731(GP)
9D0127B8  306300FF   ANDI V1, V1, 255
9D0127BC  24020002   ADDIU V0, ZERO, 2
9D0127C0  14620020   BNE V1, V0, 0x9D012844
9D0127C4  8F82805C   LW V0, -32676(GP)
74:                             f=*tones_list++;
9D0127C8  24430004   ADDIU V1, V0, 4
9D0127CC  AF83805C   SW V1, -32676(GP)
9D0127D0  8C440000   LW A0, 0(V0)
75:                             d=*tones_list++;
9D0127D4  24430008   ADDIU V1, V0, 8
9D0127D8  AF83805C   SW V1, -32676(GP)
9D0127DC  8C450004   LW A1, 4(V0)
76:                             if (d){
9D0127E0  10A0000F   BEQ A1, ZERO, 0x9D012820
9D0127E4  00000000   NOP
77:                                  if (f){
9D0127E8  10800005   BEQ A0, ZERO, 0x9D012800
9D0127EC  00000000   NOP
78:                                      tone(f,d);
9D0127F0  0F404971   JAL tone
9D0127F4  00000000   NOP
9D0127F8  0B404A11   J 0x9D012844
9D0127FC  00000000   NOP
79:                                  }else{
80:                                      duration=(*tones_list);
9D012800  8C420008   LW V0, 8(V0)
9D012804  AF828060   SW V0, -32672(GP)
81:                                      fSound |= TONE_ON;
9D012808  93828025   LBU V0, -32731(GP)
9D01280C  304200FF   ANDI V0, V0, 255
9D012810  34420001   ORI V0, V0, 1
9D012814  A3828025   SB V0, -32731(GP)
9D012818  0B404A11   J 0x9D012844
9D01281C  00000000   NOP
82:                                  }
83:                              }else{
84:                                 fSound=0;
9D012820  A3808025   SB ZERO, -32731(GP)
85:                                 IEC0bits.T3IE=0;
9D012824  3C02BF88   LUI V0, -16504
9D012828  8C431060   LW V1, 4192(V0)
9D01282C  7C037384   INS V1, ZERO, 14, 1
9D012830  AC431060   SW V1, 4192(V0)
86:                                 T3CONbits.ON=0;
9D012834  3C02BF80   LUI V0, -16512
9D012838  94430A00   LHU V1, 2560(V0)
9D01283C  7C037BC4   INS V1, ZERO, 15, 1
9D012840  A4430A00   SH V1, 2560(V0)
87:                             } // if 
88:                         }//if 
89:                  }// T3Handler
9D012844  8FA2005C   LW V0, 92(SP)
9D012848  00400013   MTLO V0
9D01284C  8FA30058   LW V1, 88(SP)
9D012850  00600011   MTHI V1
9D012854  8FBF0054   LW RA, 84(SP)
9D012858  8FB90050   LW T9, 80(SP)
9D01285C  8FB8004C   LW T8, 76(SP)
9D012860  8FAF0048   LW T7, 72(SP)
9D012864  8FAE0044   LW T6, 68(SP)
9D012868  8FAD0040   LW T5, 64(SP)
9D01286C  8FAC003C   LW T4, 60(SP)
9D012870  8FAB0038   LW T3, 56(SP)
9D012874  8FAA0034   LW T2, 52(SP)
9D012878  8FA90030   LW T1, 48(SP)
9D01287C  8FA8002C   LW T0, 44(SP)
9D012880  8FA70028   LW A3, 40(SP)
9D012884  8FA60024   LW A2, 36(SP)
9D012888  8FA50020   LW A1, 32(SP)
9D01288C  8FA4001C   LW A0, 28(SP)
9D012890  8FA30018   LW V1, 24(SP)
9D012894  8FA20014   LW V0, 20(SP)
9D012898  8FA10010   LW AT, 16(SP)
9D01289C  41606000   DI ZERO
9D0128A0  000000C0   EHB
9D0128A4  8FBA006C   LW K0, 108(SP)
9D0128A8  8FBB0068   LW K1, 104(SP)
9D0128AC  409A7000   MTC0 K0, EPC
9D0128B0  8FBA0064   LW K0, 100(SP)
9D0128B4  27BD0070   ADDIU SP, SP, 112
9D0128B8  409A6002   MTC0 K0, SRSCtl
9D0128BC  41DDE800   WRPGPR SP, SP
9D0128C0  409B6000   MTC0 K1, Status
9D0128C4  42000018   ERET
---  /home/jacques/github/vpc-32vga/hardware/serial_comm/serial_comm.c  ---------------------------------
1:                   /*
2:                   * Copyright 2013,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   uart.h
20:                   * Author: Jacques Deschênes
21:                   * Description: fonctions de bas niveau pour communication UART avec le PC
22:                   * Created on 17 avril 2013, 14:48
23:                   * rev: 2017-07-321
24:                   */
25:                  
26:                  #include <plib.h>
27:                  #include "serial_comm.h"
28:                  #include "../HardwareProfile.h"
29:                  
30:                  static char unget;
31:                  
32:                  // serial port config
33:                  void UartInit(UART_MODULE channel, int baudrate, UART_LINE_CONTROL_MODE LineCtrl){
9D011894  27BDFFE0   ADDIU SP, SP, -32
9D011898  AFBF001C   SW RA, 28(SP)
9D01189C  AFB20018   SW S2, 24(SP)
9D0118A0  AFB10014   SW S1, 20(SP)
9D0118A4  AFB00010   SW S0, 16(SP)
9D0118A8  00808021   ADDU S0, A0, ZERO
9D0118AC  00A08821   ADDU S1, A1, ZERO
9D0118B0  00C09021   ADDU S2, A2, ZERO
34:                     UARTConfigure(channel, UART_ENABLE_PINS_TX_RX_ONLY); // no hardware control.
9D0118B4  0F4064A6   JAL UARTConfigure
9D0118B8  00002821   ADDU A1, ZERO, ZERO
35:                     UARTSetLineControl(channel, LineCtrl);
9D0118BC  02002021   ADDU A0, S0, ZERO
9D0118C0  0F4065C2   JAL UARTSetLineControl
9D0118C4  02402821   ADDU A1, S2, ZERO
36:                     UARTSetDataRate(channel, mGetPeripheralClock(), baudrate);
9D0118C8  02002021   ADDU A0, S0, ZERO
9D0118CC  3C050262   LUI A1, 610
9D0118D0  24A55A00   ADDIU A1, A1, 23040
9D0118D4  0F4063CF   JAL UARTSetDataRate
9D0118D8  02203021   ADDU A2, S1, ZERO
37:                     // enable peripheral
38:                     UARTEnable(channel, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D0118DC  02002021   ADDU A0, S0, ZERO
9D0118E0  0F406220   JAL UARTEnable
9D0118E4  24050087   ADDIU A1, ZERO, 135
39:                     unget=-1;
9D0118E8  2402FFFF   ADDIU V0, ZERO, -1
9D0118EC  A3828024   SB V0, -32732(GP)
40:                     UartPutch(STDOUT,12);
9D0118F0  24040001   ADDIU A0, ZERO, 1
9D0118F4  0F404618   JAL UartPutch
9D0118F8  2405000C   ADDIU A1, ZERO, 12
41:                  };
9D0118FC  8FBF001C   LW RA, 28(SP)
9D011900  8FB20018   LW S2, 24(SP)
9D011904  8FB10014   LW S1, 20(SP)
9D011908  8FB00010   LW S0, 16(SP)
9D01190C  03E00008   JR RA
9D011910  27BD0020   ADDIU SP, SP, 32
42:                  
43:                  // get character from serial port
44:                  // return 0 if none available
45:                  char UartGetch(UART_MODULE channel){
46:                      char ch;
47:                      if (!unget==-1) {
48:                          ch=unget;
49:                          unget=-1;
50:                          return ch;
51:                      }else{
52:                          if (UARTReceivedDataIsAvailable (channel)){
9D011848  10800003   BEQ A0, ZERO, 0x9D011858
9D01184C  00001021   ADDU V0, ZERO, ZERO
53:                                 return UARTGetDataByte(channel);
9D011854  7C021420   SEB V0, V0
54:                          }else{
55:                              return 0;
56:                          }
57:                      }
58:                  };
9D011858  03E00008   JR RA
9D01185C  00000000   NOP
59:                  
60:                  // send a character to serial port
61:                  void UartPutch(UART_MODULE channel, char c){
62:                      while(!UARTTransmitterIsReady(channel));
9D01187C  1440FFFD   BNE V0, ZERO, 0x9D011874
9D011880  00000000   NOP
63:                        UARTSendDataByte(channel, c);
64:                  };
65:                  
66:                  // wait for a character from serial port with expiration delay
67:                  char UartWaitch(UART_MODULE channel, int delay){
9D011914  27BDFFE0   ADDIU SP, SP, -32
9D011918  AFBF001C   SW RA, 28(SP)
9D01191C  AFB10018   SW S1, 24(SP)
9D011920  AFB00014   SW S0, 20(SP)
9D011924  00808821   ADDU S1, A0, ZERO
68:                      int t;
69:                      char ch;
70:                      if (!unget==-1){
71:                          ch=unget;
72:                          unget=-1;
73:                          return unget;
74:                      }
75:                      if (!delay) while (1) if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D011928  14A0000D   BNE A1, ZERO, 0x9D011960
9D01192C  00A08021   ADDU S0, A1, ZERO
9D01194C  1040FFFD   BEQ V0, ZERO, 0x9D011944
9D011950  00000000   NOP
9D011958  0B40466A   J 0x9D0119A8
9D01195C  7C021420   SEB V0, V0
76:                      t=ticks()+delay;
9D011960  0F40382F   JAL ticks
9D011964  00118880   SLL S1, S1, 2
77:                      while (ticks()<delay){
9D011970  0B404665   J 0x9D011994
9D011974  02228821   ADDU S1, S1, V0
9D011994  0F40382F   JAL ticks
9D011998  00000000   NOP
9D01199C  0050102B   SLTU V0, V0, S0
9D0119A0  5440FFF5   BNEL V0, ZERO, 0x9D011978
9D0119A4  8E220000   LW V0, 0(S1)
78:                         if (UARTReceivedDataIsAvailable(channel)) return UARTGetDataByte(channel);
9D011980  10600004   BEQ V1, ZERO, 0x9D011994
9D011984  00000000   NOP
9D01198C  0B40466A   J 0x9D0119A8
9D011990  7C021420   SEB V0, V0
79:                      }
80:                      return 0;
81:                  }
9D0119A8  8FBF001C   LW RA, 28(SP)
9D0119AC  8FB10018   LW S1, 24(SP)
9D0119B0  8FB00014   LW S0, 20(SP)
9D0119B4  03E00008   JR RA
9D0119B8  27BD0020   ADDIU SP, SP, 32
82:                  
83:                  // send a string to serial port.
84:                  void UartPrint(UART_MODULE channel, const char* str){
85:                     while(*str != (char)0)
9D0119BC  80A60000   LB A2, 0(A1)
9D0119C0  10C0000F   BEQ A2, ZERO, UartPrint::UARTTransmissionHasCompleted
9D0119C4  00041880   SLL V1, A0, 2
9D0119F4  80A60000   LB A2, 0(A1)
9D0119F8  14C0FFF7   BNE A2, ZERO, 0x9D0119D8
9D0119FC  00000000   NOP
86:                     {
87:                        while(!UARTTransmitterIsReady(channel));
9D0119E0  1440FFFD   BNE V0, ZERO, 0x9D0119D8
9D0119E4  00000000   NOP
88:                        UARTSendDataByte(channel, *str++);
9D0119E8  24A50001   ADDIU A1, A1, 1
89:                     }
90:                     while(!UARTTransmissionHasCompleted(channel));
9D011A1C  1040FFFD   BEQ V0, ZERO, 0x9D011A14
9D011A20  00000000   NOP
91:                  };
9D011A24  03E00008   JR RA
9D011A28  00000000   NOP
92:                  
93:                  // read a line from serial port
94:                  int UartReadln(UART_MODULE channel, char *buffer, int buff_len){
9D011A2C  27BDFFD0   ADDIU SP, SP, -48
9D011A30  AFBF002C   SW RA, 44(SP)
9D011A34  AFB60028   SW S6, 40(SP)
9D011A38  AFB50024   SW S5, 36(SP)
9D011A3C  AFB40020   SW S4, 32(SP)
9D011A40  AFB3001C   SW S3, 28(SP)
9D011A44  AFB20018   SW S2, 24(SP)
9D011A48  AFB10014   SW S1, 20(SP)
9D011A4C  AFB00010   SW S0, 16(SP)
9D011A50  00809021   ADDU S2, A0, ZERO
9D011A54  00A09821   ADDU S3, A1, ZERO
9D011A58  00C0A021   ADDU S4, A2, ZERO
95:                      int count=0;
9D011A5C  00008821   ADDU S1, ZERO, ZERO
96:                      char c;
97:                      if (!unget==-1){
98:                          c=unget;
99:                          unget=-1;
100:                         *buffer++=c;
101:                         if (c==CR) return;
102:                     }
103:                     while (count < (buff_len-1)){
9D011A70  0B4046BC   J 0x9D011AF0
9D011A74  3C159D01   LUI S5, -25343
9D011AD4  0B4046BD   J 0x9D011AF4
9D011AD8  2682FFFF   ADDIU V0, S4, -1
9D011AF0  2682FFFF   ADDIU V0, S4, -1
9D011AF4  0222102A   SLT V0, S1, V0
9D011AF8  5440FFDF   BNEL V0, ZERO, 0x9D011A78
9D011AFC  8E030000   LW V1, 0(S0)
104:                         if (UARTReceivedDataIsAvailable(channel)){
9D011A80  10E0001D   BEQ A3, ZERO, 0x9D011AF8
9D011A84  00000000   NOP
105:                             c = UARTGetDataByte(channel);
9D011A8C  7C052C20   SEB A1, A1
106:                             if (c==CR){UartPutch(channel,'\r'); break;}
9D011A90  2402000D   ADDIU V0, ZERO, 13
9D011A94  14A20006   BNE A1, V0, 0x9D011AB0
9D011A98  24020008   ADDIU V0, ZERO, 8
9D011A9C  02402021   ADDU A0, S2, ZERO
9D011AA0  0F404618   JAL UartPutch
9D011AA4  2405000D   ADDIU A1, ZERO, 13
9D011AA8  0B4046C0   J 0x9D011B00
9D011AAC  00000000   NOP
107:                             if (c==BS){
9D011AB0  14A2000A   BNE A1, V0, 0x9D011ADC
9D011AB4  26760001   ADDIU S6, S3, 1
108:                                 if (count){
9D011AB8  5220000E   BEQL S1, ZERO, 0x9D011AF4
9D011ABC  2682FFFF   ADDIU V0, S4, -1
109:                                     buffer--;
9D011AC0  2673FFFF   ADDIU S3, S3, -1
110:                                     count--;
9D011AC4  2631FFFF   ADDIU S1, S1, -1
111:                                     UartPrint(channel,"\b \b");
9D011AC8  02402021   ADDU A0, S2, ZERO
9D011ACC  0F40466F   JAL UartPrint
9D011AD0  26A55D6C   ADDIU A1, S5, 23916
112:                                 }
113:                             }else{
114:                                 *buffer++=c;
9D011ADC  A2650000   SB A1, 0(S3)
9D011AEC  02C09821   ADDU S3, S6, ZERO
115:                                 count++;
9D011AE0  26310001   ADDIU S1, S1, 1
116:                                 UartPutch(channel,c);
9D011AE4  0F404618   JAL UartPutch
9D011AE8  02402021   ADDU A0, S2, ZERO
117:                             }
118:                             
119:                         }
120:                     }
121:                     if (count) *buffer = (char)0;
9D011B00  56200001   BNEL S1, ZERO, 0x9D011B08
9D011B04  A2600000   SB ZERO, 0(S3)
122:                     UartPutch(channel,'\r');
9D011B08  02402021   ADDU A0, S2, ZERO
9D011B0C  0F404618   JAL UartPutch
9D011B10  2405000D   ADDIU A1, ZERO, 13
123:                     return count;
124:                 }
9D011B14  02201021   ADDU V0, S1, ZERO
9D011B18  8FBF002C   LW RA, 44(SP)
9D011B1C  8FB60028   LW S6, 40(SP)
9D011B20  8FB50024   LW S5, 36(SP)
9D011B24  8FB40020   LW S4, 32(SP)
9D011B28  8FB3001C   LW S3, 28(SP)
9D011B2C  8FB20018   LW S2, 24(SP)
9D011B30  8FB10014   LW S1, 20(SP)
9D011B34  8FB00010   LW S0, 16(SP)
9D011B38  03E00008   JR RA
9D011B3C  27BD0030   ADDIU SP, SP, 48
125:                 
126:                 // return TRUE if received an ESC character
127:                 int UartReceivedESC(UART_MODULE channel){
128:                    char ch;
129:                    if (unget==-1 && UARTReceivedDataIsAvailable(channel)) {
9D011B40  83858024   LB A1, -32732(GP)
9D011B44  2403FFFF   ADDIU V1, ZERO, -1
9D011B48  14A30012   BNE A1, V1, 0x9D011B94
9D011B4C  00001021   ADDU V0, ZERO, ZERO
9D011B6C  10800009   BEQ A0, ZERO, 0x9D011B94
9D011B70  00001021   ADDU V0, ZERO, ZERO
130:                        ch=UARTGetDataByte(channel);
9D011B78  7C021420   SEB V0, V0
131:                        if (ch==ESC) return 1; else unget=ch;
9D011B7C  2403001B   ADDIU V1, ZERO, 27
9D011B80  50430004   BEQL V0, V1, 0x9D011B94
9D011B84  24020001   ADDIU V0, ZERO, 1
9D011B88  A3828024   SB V0, -32732(GP)
132:                    }
133:                    return 0;
9D011B8C  03E00008   JR RA
9D011B90  00001021   ADDU V0, ZERO, ZERO
134:                 }
9D011B94  03E00008   JR RA
9D011B98  00000000   NOP
135:                 
136:                 // print debug message on remote terminal
137:                 void DebugPrint(const char* str){
9D011B9C  27BDFFE8   ADDIU SP, SP, -24
9D011BA0  AFBF0014   SW RA, 20(SP)
9D011BA4  00802821   ADDU A1, A0, ZERO
138:                         UartPrint(STDOUT,str); 
9D011BA8  0F40466F   JAL UartPrint
9D011BAC  24040001   ADDIU A0, ZERO, 1
139:                 }
9D011BB0  8FBF0014   LW RA, 20(SP)
9D011BB4  03E00008   JR RA
9D011BB8  27BD0018   ADDIU SP, SP, 24
140:                 
---  /home/jacques/github/vpc-32vga/hardware/ps2_kbd/keyboard.c  ----------------------------------------
1:                   /*
2:                   * Copyright 2013,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * Name: keyboard.c
20:                   * Author: Jacques Deschênes
21:                   * Description:  PS/2 keyboard low level interface
22:                   * REF: http://www.computer-engineering.org/ps2protocol/
23:                   * Date: 2013-08-26
24:                   * rev: 2017-07-30
25:                   */
26:                  #include <p32xxxx.h>
27:                  #include <plib.h>
28:                  #include <stdint.h>
29:                  #include <stdbool.h>
30:                  #include "../HardwareProfile.h"
31:                  #include "keyboard.h"
32:                  
33:                  
34:                  // using circular queues for received scan codes and translated codes.
35:                  #define KBD_QUEUE_SIZE (32)
36:                  static  uint8_t kbd_queue[KBD_QUEUE_SIZE]; // keyboard translated codes queue
37:                  volatile static unsigned char kbd_head=0, kbd_tail=0; // kbd_queue head and tail pointer
38:                  
39:                  // initialize UART1 keyboard receive character.
40:                  void KeyboardInit(){
41:                      U1BRG=PBCLK/16/9600-1;
9D0152B4  24030103   ADDIU V1, ZERO, 259
9D0152B8  3C02BF80   LUI V0, -16512
9D0152BC  AC436040   SW V1, 24640(V0)
42:                      U1RXR=KBD_RP_FN;
9D0152C0  24030004   ADDIU V1, ZERO, 4
9D0152C4  3C02BF81   LUI V0, -16511
9D0152C8  AC43FA50   SW V1, -1456(V0)
43:                      U1STA=(1<<12);
9D0152CC  24031000   ADDIU V1, ZERO, 4096
9D0152D0  3C02BF80   LUI V0, -16512
9D0152D4  AC436010   SW V1, 24592(V0)
44:                      IPC8bits.U1IP=3;
9D0152D8  3C02BF88   LUI V0, -16504
9D0152DC  8C431110   LW V1, 4368(V0)
9D0152E0  24040003   ADDIU A0, ZERO, 3
9D0152E4  7C832084   INS V1, A0, 2, 3
9D0152E8  AC431110   SW V1, 4368(V0)
45:                      IPC8bits.U1IS=0;
9D0152EC  8C431110   LW V1, 4368(V0)
9D0152F0  7C030804   INS V1, ZERO, 0, 2
9D0152F4  AC431110   SW V1, 4368(V0)
46:                      IFS1bits.U1EIF=0;
9D0152F8  3C02BF88   LUI V0, -16504
9D0152FC  8C431040   LW V1, 4160(V0)
9D015300  7C0339C4   INS V1, ZERO, 7, 1
9D015304  AC431040   SW V1, 4160(V0)
47:                      IFS1bits.U1RXIF=0;
9D015308  8C431040   LW V1, 4160(V0)
9D01530C  7C034204   INS V1, ZERO, 8, 1
9D015310  AC431040   SW V1, 4160(V0)
48:                      IEC1bits.U1EIE=1;
9D015314  3C02BF88   LUI V0, -16504
9D015318  8C431070   LW V1, 4208(V0)
9D01531C  24040001   ADDIU A0, ZERO, 1
9D015320  7C8339C4   INS V1, A0, 7, 1
9D015324  AC431070   SW V1, 4208(V0)
49:                      IEC1bits.U1RXIE=1;
9D015328  8C431070   LW V1, 4208(V0)
9D01532C  7C834204   INS V1, A0, 8, 1
9D015330  AC431070   SW V1, 4208(V0)
50:                      U1MODE=(1<<15);
9D015334  34038000   ORI V1, ZERO, -32768
9D015338  3C02BF80   LUI V0, -16512
9D01533C  AC436000   SW V1, 24576(V0)
9D015340  03E00008   JR RA
9D015344  00000000   NOP
51:                  } //KeyboardInit()
52:                  
53:                  
54:                  
55:                  // return translated key code.
56:                  // from kbd_queue.
57:                  unsigned char KbdKey(){
58:                      unsigned char key;
59:                      
60:                      if (kbd_head==kbd_tail) return 0;
9D015348  9383801D   LBU V1, -32739(GP)
9D01534C  306300FF   ANDI V1, V1, 255
9D015350  9382801C   LBU V0, -32740(GP)
9D015354  304200FF   ANDI V0, V0, 255
9D015358  1062000F   BEQ V1, V0, 0x9D015398
9D01535C  00000000   NOP
61:                      key=kbd_queue[kbd_head++];
9D015360  9382801D   LBU V0, -32739(GP)
9D015364  304200FF   ANDI V0, V0, 255
9D015368  24430001   ADDIU V1, V0, 1
9D01536C  306300FF   ANDI V1, V1, 255
9D015370  A383801D   SB V1, -32739(GP)
9D015374  3C03A000   LUI V1, -24576
9D015378  24634BBC   ADDIU V1, V1, 19388
9D01537C  00431021   ADDU V0, V0, V1
9D015380  90420000   LBU V0, 0(V0)
62:                      kbd_head&=KBD_QUEUE_SIZE-1;
9D015384  9383801D   LBU V1, -32739(GP)
9D015388  3063001F   ANDI V1, V1, 31
9D01538C  A383801D   SB V1, -32739(GP)
63:                      return key;
9D015390  03E00008   JR RA
9D015394  00000000   NOP
64:                  } // GetKey()
9D015398  03E00008   JR RA
9D01539C  00001021   ADDU V0, ZERO, ZERO
65:                  
66:                  // keyboard character receptionm
67:                  void __ISR(_UART_1_VECTOR,IPL6SOFT) kbd_rx_isr(void){
9D0153A0  415DE800   RDPGPR SP, SP
9D0153A4  401A7000   MFC0 K0, EPC
9D0153A8  401B6000   MFC0 K1, Status
9D0153AC  27BDFFE0   ADDIU SP, SP, -32
9D0153B0  AFBA001C   SW K0, 28(SP)
9D0153B4  401A6002   MFC0 K0, SRSCtl
9D0153B8  AFBB0018   SW K1, 24(SP)
9D0153BC  AFBA0014   SW K0, 20(SP)
9D0153C0  7C1B7844   INS K1, ZERO, 1, 15
9D0153C4  377B1800   ORI K1, K1, 6144
9D0153C8  409B6000   MTC0 K1, Status
9D0153CC  AFA4000C   SW A0, 12(SP)
9D0153D0  AFA30008   SW V1, 8(SP)
9D0153D4  AFA20004   SW V0, 4(SP)
68:                      kbd_queue[kbd_tail++]=U1RXREG;
9D0153D8  9382801C   LBU V0, -32740(GP)
9D0153DC  304200FF   ANDI V0, V0, 255
9D0153E0  24430001   ADDIU V1, V0, 1
9D0153E4  306300FF   ANDI V1, V1, 255
9D0153E8  A383801C   SB V1, -32740(GP)
9D0153EC  3C03BF80   LUI V1, -16512
9D0153F0  8C636030   LW V1, 24624(V1)
9D0153F4  3C04A000   LUI A0, -24576
9D0153F8  24844BBC   ADDIU A0, A0, 19388
9D0153FC  00441021   ADDU V0, V0, A0
9D015400  A0430000   SB V1, 0(V0)
69:                      kbd_tail&=KBD_QUEUE_SIZE-1;
9D015404  9382801C   LBU V0, -32740(GP)
9D015408  3042001F   ANDI V0, V0, 31
9D01540C  A382801C   SB V0, -32740(GP)
70:                      IFS1bits.U1RXIF=0;
9D015410  3C02BF88   LUI V0, -16504
9D015414  8C431040   LW V1, 4160(V0)
9D015418  7C034204   INS V1, ZERO, 8, 1
9D01541C  AC431040   SW V1, 4160(V0)
71:                  } // kbd_rx_isr()
9D015420  8FA4000C   LW A0, 12(SP)
9D015424  8FA30008   LW V1, 8(SP)
9D015428  8FA20004   LW V0, 4(SP)
9D01542C  41606000   DI ZERO
9D015430  000000C0   EHB
9D015434  8FBA001C   LW K0, 28(SP)
9D015438  8FBB0018   LW K1, 24(SP)
9D01543C  409A7000   MTC0 K0, EPC
9D015440  8FBA0014   LW K0, 20(SP)
9D015444  27BD0020   ADDIU SP, SP, 32
9D015448  409A6002   MTC0 K0, SRSCtl
9D01544C  41DDE800   WRPGPR SP, SP
9D015450  409B6000   MTC0 K1, Status
9D015454  42000018   ERET
72:                  
73:                  
---  /home/jacques/github/vpc-32vga/hardware/Pinguino/sdmmc.c  ------------------------------------------
1:                   /*
2:                   ** SDMMC.c SD card interface
3:                   **
4:                   ** 7/20/06 v1.4 LDJ
5:                   ** 7/14/07 v2.0 LDJ
6:                   **
7:                   [30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
8:                   ** 07 May 2012	Changes made to allow SD card library to support
9:                   **					PIC32 Pinguino and PIC32 Pinguino Micro that have neither
10:                  **					SD card presence nor WP switch detection switches.
11:                  **					see functions getCD() and getWP() below.
12:                  */
13:                  /*
14:                   *  adapted to VPC-32 project by Jacques Deschênes 2013,2014
15:                   */
16:                  
17:                  #ifndef __SDMMC_C__
18:                  #define __SDMMC_C__
19:                  
20:                  //#include <system.c>
21:                  //#include <digitalw.c>
22:                  //#include <spi.c>        // in order to use default SPI port
23:                  #include <plib.h>
24:                  #include "sdmmc.h"
25:                  //#include "diskio.h"
26:                  //#include "ff.h"
27:                  
28:                  
29:                  void initSD(void)
30:                  {
9D012EB0  27BDFFE8   ADDIU SP, SP, -24
9D012EB4  AFBF0014   SW RA, 20(SP)
31:                      if (!store_initialized) store_spi_init();
9D012EB8  93828026   LBU V0, -32730(GP)
9D012EBC  14400004   BNE V0, ZERO, 0x9D012ED0
9D012EC0  8FBF0014   LW RA, 20(SP)
9D012EC4  0F405EF9   JAL store_spi_init
9D012EC8  00000000   NOP
32:                  
33:                  //    PORTB |=SDCSEL; //digitalwrite(SDCSEL, HIGH);	// initially keep the SD card disabled
34:                  //	TRISB &=~SDCSEL; //pinmode(SDCSEL, OUTPUT);		// make Card select an output pin
35:                  //
36:                  //	// init the spi module for a slow (safe) clock speed first
37:                  //
38:                  //	SPI2CON = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
39:                  //	SPI2BRG = (mGetPeripheralClock() / (2 * 10000000)) - 1; // 10Mbits/sec
40:                  
41:                  }   // initSD
9D012ECC  8FBF0014   LW RA, 20(SP)
9D012ED0  03E00008   JR RA
9D012ED4  27BD0018   ADDIU SP, SP, 24
42:                  
43:                  
44:                  void disableSD(void)
45:                  {
9D012ED8  27BDFFE8   ADDIU SP, SP, -24
9D012EDC  AFBF0014   SW RA, 20(SP)
46:                  
47:                     _sdc_deselect(); 
9D012EE0  24030008   ADDIU V1, ZERO, 8
9D012EE4  3C02BF88   LUI V0, -16504
9D012EE8  AC436128   SW V1, 24872(V0)
48:                     clockSPI();
9D012EEC  0F405F0D   JAL writeSPI
9D012EF0  240400FF   ADDIU A0, ZERO, 255
49:                  }
9D012EF4  8FBF0014   LW RA, 20(SP)
9D012EF8  03E00008   JR RA
9D012EFC  27BD0018   ADDIU SP, SP, 24
50:                  
51:                  void enableSD(void)
52:                  {
53:                      _sdc_select();
9D012F00  24030008   ADDIU V1, ZERO, 8
9D012F04  3C02BF88   LUI V0, -16504
9D012F08  AC436124   SW V1, 24868(V0)
9D012F0C  03E00008   JR RA
9D012F10  00000000   NOP
9D012F24  24030008   ADDIU V1, ZERO, 8
9D012FB8  3C02BF88   LUI V0, -16504
9D012FBC  AC436124   SW V1, 24868(V0)
54:                  
55:                  }
56:                  
57:                  // c    command code
58:                  // a    byte address of data block
59:                  int sendSDCmd(unsigned char c, unsigned a)
60:                  {
9D012F14  27BDFFE8   ADDIU SP, SP, -24
9D012F18  AFBF0014   SW RA, 20(SP)
9D012F1C  AFB00010   SW S0, 16(SP)
9D012F20  00A08021   ADDU S0, A1, ZERO
61:                  	int i, r;
62:                  
63:                  	// enable SD card
64:                  	// CS low
65:                  	enableSD();
66:                  
67:                  	// send a comand packet (6 bytes)
68:                  	writeSPI(c | 0x40);    // send command
9D012F30  0F405F0D   JAL writeSPI
9D012F34  34840040   ORI A0, A0, 64
69:                  	writeSPI(a>>24);       // msb of the address
9D012F38  0F405F0D   JAL writeSPI
9D012F3C  00102602   SRL A0, S0, 24
70:                  	writeSPI(a>>16);
9D012F40  0F405F0D   JAL writeSPI
9D012F44  7E043C00   EXT A0, S0, 16, 8
71:                  	writeSPI(a>>8);
9D012F48  0F405F0D   JAL writeSPI
9D012F4C  7E043A00   EXT A0, S0, 8, 8
72:                  	writeSPI(a);           // lsb
9D012F50  0F405F0D   JAL writeSPI
9D012F54  320400FF   ANDI A0, S0, 255
73:                  
74:                  	writeSPI(0x95);        // send CMD0 CRC
9D012F58  0F405F0D   JAL writeSPI
9D012F5C  24040095   ADDIU A0, ZERO, 149
9D012F60  24100008   ADDIU S0, ZERO, 8
75:                  
76:                  	// now wait for a response, allow for up to 8 bytes delay
77:                  	for(i=0; i<8; i++)
9D012F78  1600FFFA   BNE S0, ZERO, 0x9D012F64
9D012F7C  00000000   NOP
78:                  	{
79:                  		r = readSPI();
9D012F64  0F405F0D   JAL writeSPI
9D012F68  240400FF   ADDIU A0, ZERO, 255
80:                  		if (r != 0xFF)
9D012F6C  240300FF   ADDIU V1, ZERO, 255
9D012F70  14430003   BNE V0, V1, 0x9D012F80
9D012F74  2610FFFF   ADDIU S0, S0, -1
81:                  			break;
82:                  	}
83:                  	return (r);
84:                  
85:                  	/* return response
86:                  	FF - timeout
87:                  	00 - command accepted
88:                  	01 - command received, card in idle state after RESET
89:                  
90:                  	other codes:
91:                  	bit 0 = Idle state
92:                  	bit 1 = Erase Reset
93:                  	bit 2 = Illegal command
94:                  	bit 3 = Communication CRC error
95:                  	bit 4 = Erase sequence error
96:                  	bit 5 = Address error
97:                  	bit 6 = Parameter error
98:                  	bit 7 = Always 0
99:                  	*/
100:                 	// NOTE CSCD is still low!
101:                 } // sendSDCmd
9D012F80  8FBF0014   LW RA, 20(SP)
9D012F84  8FB00010   LW S0, 16(SP)
9D012F88  03E00008   JR RA
9D012F8C  27BD0018   ADDIU SP, SP, 24
102:                 
103:                 
104:                 // returns 0 if successful
105:                 //          E_COMMAND_ACK   failed to acknowledge reset command
106:                 //          E_INIT_TIMEOUT  failed to initialize
107:                 int initMedia(void)
108:                 {
9D012F90  27BDFFE8   ADDIU SP, SP, -24
9D012F94  AFBF0014   SW RA, 20(SP)
109:                 	int i, r;
110:                 
111:                 	// 1. with the card NOT selected
112:                 	// Set DI and CS high
113:                 	disableSD();
9D012F98  0F404BB6   JAL disableSD
9D012F9C  AFB00010   SW S0, 16(SP)
9D012FA0  2410000A   ADDIU S0, ZERO, 10
114:                 
115:                 	// 2. send 74 or more clock cycles to start up
116:                 	// apply 74 or more clock pulses to SCLK.
117:                 	// The card will enter its native operating mode and go ready to accept native commands.
118:                 	for (i=0; i<10; i++)
9D012FB0  1600FFFC   BNE S0, ZERO, 0x9D012FA4
9D012FB4  24030008   ADDIU V1, ZERO, 8
119:                 		clockSPI();
9D012FA4  0F405F0D   JAL writeSPI
9D012FA8  240400FF   ADDIU A0, ZERO, 255
9D012FAC  2610FFFF   ADDIU S0, S0, -1
120:                 
121:                 	// 3. now select the card
122:                 	enableSD();
123:                 
124:                 	//card detection is now in disk_initialize()
125:                 
126:                 	return 0;
127:                 } // init media
9D012FC0  00001021   ADDU V0, ZERO, ZERO
9D012FC4  8FBF0014   LW RA, 20(SP)
9D012FC8  8FB00010   LW S0, 16(SP)
9D012FCC  03E00008   JR RA
9D012FD0  27BD0018   ADDIU SP, SP, 24
128:                 
129:                 
130:                 // a        LBA of sector requested
131:                 // p        pointer to sector buffer
132:                 // returns  TRUE if successful
133:                 int readSECTOR(LBA a, char *p)
134:                 {
9D012FD4  27BDFFD8   ADDIU SP, SP, -40
9D012FD8  AFBF0024   SW RA, 36(SP)
9D012FDC  AFB40020   SW S4, 32(SP)
9D012FE0  AFB3001C   SW S3, 28(SP)
9D012FE4  AFB20018   SW S2, 24(SP)
9D012FE8  AFB10014   SW S1, 20(SP)
9D012FEC  AFB00010   SW S0, 16(SP)
9D012FF0  00A08021   ADDU S0, A1, ZERO
135:                 	int r, i;
136:                 
137:                 	#ifdef READ_LED
138:                         _read_off();
139:                 	//digitalwrite(READ_LED, 0);
140:                 	#endif
141:                 
142:                 	// 1. send READ command
143:                 	r = sendSDCmd(READ_SINGLE, (a << 9));
9D012FF4  00042A40   SLL A1, A0, 9
9D012FF8  0F404BC5   JAL sendSDCmd
9D012FFC  24040011   ADDIU A0, ZERO, 17
144:                 	if (r == 0)    // check if command was accepted
9D013000  14400019   BNE V0, ZERO, 0x9D013068
9D013004  00409021   ADDU S2, V0, ZERO
9D013008  00008821   ADDU S1, ZERO, ZERO
145:                 	{
146:                 	// 2. wait for a response
147:                 	for(i=0; i<R_TIMEOUT; i++)
9D013010  241461A8   ADDIU S4, ZERO, 25000
9D013024  26310001   ADDIU S1, S1, 1
9D013028  1634FFFA   BNE S1, S4, 0x9D013014
9D01302C  00000000   NOP
9D013030  0B404C1A   J 0x9D013068
9D013034  00000000   NOP
148:                 	{
149:                 	r = readSPI();
9D013014  0F405F0D   JAL writeSPI
9D013018  240400FF   ADDIU A0, ZERO, 255
150:                 	if (r == DATA_START)
9D01300C  241300FE   ADDIU S3, ZERO, 254
9D01301C  10530006   BEQ V0, S3, 0x9D013038
9D013020  00409021   ADDU S2, V0, ZERO
151:                 	break;
152:                 	}
153:                 
154:                 	// 3. if it did not timeout, read 512 byte of data
155:                 	if (i != R_TIMEOUT)
9D013038  240261A8   ADDIU V0, ZERO, 25000
9D01303C  1222000A   BEQ S1, V0, 0x9D013068
9D013040  26110200   ADDIU S1, S0, 512
156:                 	{
157:                 		i = 512;
158:                 		do{
159:                 			*p++ = readSPI();
9D013044  26100001   ADDIU S0, S0, 1
9D013048  0F405F0D   JAL writeSPI
9D01304C  240400FF   ADDIU A0, ZERO, 255
160:                 		} while (--i>0);
9D013050  1611FFFC   BNE S0, S1, 0x9D013044
9D013054  A202FFFF   SB V0, -1(S0)
161:                 
162:                 		// 4. ignore CRC
163:                 		readSPI();
9D013058  0F405F0D   JAL writeSPI
9D01305C  240400FF   ADDIU A0, ZERO, 255
164:                 		readSPI();
9D013060  0F405F0D   JAL writeSPI
9D013064  240400FF   ADDIU A0, ZERO, 255
165:                 
166:                 	} // data arrived
167:                 
168:                 	} // command accepted
169:                 
170:                 	// 5. remember to disable the card
171:                 	disableSD();
9D013068  0F404BB6   JAL disableSD
9D01306C  00000000   NOP
172:                 
173:                 	#ifdef READ_LED
174:                         _read_on();
175:                 	//digital(READ_LED, 1);
176:                 	#endif
177:                 
178:                 	return (r == DATA_START);    // return TRUE if successful
9D013070  3A4200FE   XORI V0, S2, 254
179:                 } // readSECTOR
9D013074  2C420001   SLTIU V0, V0, 1
9D013078  8FBF0024   LW RA, 36(SP)
9D01307C  8FB40020   LW S4, 32(SP)
9D013080  8FB3001C   LW S3, 28(SP)
9D013084  8FB20018   LW S2, 24(SP)
9D013088  8FB10014   LW S1, 20(SP)
9D01308C  8FB00010   LW S0, 16(SP)
9D013090  03E00008   JR RA
9D013094  27BD0028   ADDIU SP, SP, 40
180:                 
181:                 
182:                 // a        LBA of sector requested
183:                 // p        pointer to sector buffer
184:                 // returns  TRUE if successful
185:                 int writeSECTOR(LBA a, char *p)
186:                 {
9D013098  27BDFFE0   ADDIU SP, SP, -32
9D01309C  AFBF001C   SW RA, 28(SP)
9D0130A0  AFB20018   SW S2, 24(SP)
9D0130A4  AFB10014   SW S1, 20(SP)
9D0130A8  AFB00010   SW S0, 16(SP)
9D0130AC  00A08021   ADDU S0, A1, ZERO
187:                 	unsigned r, i;
188:                 
189:                 	// 0. check Write Protect
190:                 //	if (getWP())
191:                 //		return FAIL;
192:                 
193:                 	// 1. send WRITE command
194:                 	r = sendSDCmd(WRITE_SINGLE, (a << 9));
9D0130B0  00042A40   SLL A1, A0, 9
9D0130B4  0F404BC5   JAL sendSDCmd
9D0130B8  24040018   ADDIU A0, ZERO, 24
195:                 	if (r == 0)    // check if command was accepted
9D0130BC  1440001B   BNE V0, ZERO, 0x9D01312C
9D0130C0  00409021   ADDU S2, V0, ZERO
196:                 	{
197:                 		// 2. send data
198:                 		writeSPI(DATA_START);
9D0130C4  0F405F0D   JAL writeSPI
9D0130C8  240400FE   ADDIU A0, ZERO, 254
9D0130CC  26110200   ADDIU S1, S0, 512
199:                 
200:                 		// send 512 bytes of data
201:                 		for(i=0; i<512; i++)
9D0130DC  1611FFFD   BNE S0, S1, 0x9D0130D4
9D0130E0  26100001   ADDIU S0, S0, 1
202:                 		writeSPI(*p++);
9D0130D0  26100001   ADDIU S0, S0, 1
9D0130D4  0F405F0D   JAL writeSPI
9D0130D8  9204FFFF   LBU A0, -1(S0)
203:                 
204:                 		// 3. send dummy CRC
205:                 		clockSPI();
9D0130E4  0F405F0D   JAL writeSPI
9D0130E8  240400FF   ADDIU A0, ZERO, 255
206:                 		clockSPI();
9D0130EC  0F405F0D   JAL writeSPI
9D0130F0  240400FF   ADDIU A0, ZERO, 255
207:                 
208:                 		// 4. check if data accepted
209:                 		r = readSPI();
9D0130F4  0F405F0D   JAL writeSPI
9D0130F8  240400FF   ADDIU A0, ZERO, 255
210:                 		if ((r & 0xf) == DATA_ACCEPT)
9D0130FC  3042000F   ANDI V0, V0, 15
9D013100  24030005   ADDIU V1, ZERO, 5
9D013104  14430009   BNE V0, V1, 0x9D01312C
9D013108  3C100003   LUI S0, 3
9D01310C  3610D090   ORI S0, S0, -12144
211:                 		{
212:                 			#ifdef WRITE_LED
213:                                         _write_off();
214:                 			//digitalwrite(WRITE_LED, 0);
215:                 			#endif
216:                 
217:                 			// 5. wait for write completion
218:                 			for(i=0; i<W_TIMEOUT; i++)
9D013124  1600FFFA   BNE S0, ZERO, 0x9D013110
9D013128  00000000   NOP
219:                 			{
220:                 				r = readSPI();
9D013110  0F405F0D   JAL writeSPI
9D013114  240400FF   ADDIU A0, ZERO, 255
221:                 				if (r != 0 )
9D013118  14400004   BNE V0, ZERO, 0x9D01312C
9D01311C  00409021   ADDU S2, V0, ZERO
9D013120  2610FFFF   ADDIU S0, S0, -1
222:                 					break;
223:                 			}
224:                 			#ifdef WRITE_LED
225:                                         _write_on();
226:                 			//digitalwrite(WRITE_LED, 1);
227:                 			#endif
228:                 		} // accepted
229:                 		else
230:                 		{
231:                 			r = FAIL;
232:                 		}
233:                 	} // command accepted
234:                 
235:                 	// 6. disable the card
236:                 	disableSD();
9D01312C  0F404BB6   JAL disableSD
9D013130  00000000   NOP
237:                 
238:                 	return (r);      // return TRUE if successful
239:                 } // writeSECTOR
9D013134  02401021   ADDU V0, S2, ZERO
9D013138  8FBF001C   LW RA, 28(SP)
9D01313C  8FB20018   LW S2, 24(SP)
9D013140  8FB10014   LW S1, 20(SP)
9D013144  8FB00010   LW S0, 16(SP)
9D013148  03E00008   JR RA
9D01314C  27BD0020   ADDIU SP, SP, 32
240:                 
241:                 
242:                 // SD card connector presence detection switch
243:                 // returns  TRUE card present
244:                 //          FALSE card not present
245:                 int getCD(void)
246:                 {
247:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
248:                 // 2013-09-05 ** added support for VPC_32
249:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined (EMPEROR460)
250:                 	return TRUE;
251:                 #elif defined VPC_32
252:                     return (PORTB&SDC_DET)==0;
9D013150  3C02BF88   LUI V0, -16504
9D013154  8C426120   LW V0, 24864(V0)
9D013158  38421000   XORI V0, V0, 4096
253:                 #else
254:                 	return (SDCD);
255:                 #endif
256:                 }
9D01315C  03E00008   JR RA
9D013160  7C420300   EXT V0, V0, 12, 1
257:                 
258:                 // card Write Protect tab detection switch
259:                 // returns  TRUE write protect tab on LOCK
260:                 //          FALSE write protection tab OPEN
261:                 int getWP(void)
262:                 {
263:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
264:                 // 2013-09-05 ** added support for VPC_32
265:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined(EMPEROR460) || defined (VPC_32)
266:                 	return FALSE;
267:                 #else
268:                 	return (SDWP);
269:                 #endif
270:                 }
9D013164  03E00008   JR RA
271:                 
272:                 #endif /* __SDMMC_C__ */
---  /home/jacques/github/vpc-32vga/hardware/Pinguino/fileio.c  -----------------------------------------
1:                   /*	----------------------------------------------------------------------------
2:                   	FILE:			fileio.c
3:                   	PROJECT:		pinguino32
4:                   	PURPOSE:		SD Card file system functions
5:                   	AUTHORS:		Alfred Broda <alfredbroda@gmail.com>
6:                   					Mark Harper <markfh@f2s.com>
7:                   					Regis Blanchot <rblanchot@gmail.com>
8:                   	FIRST RELEASE:	23 dec. 2011
9:                   	LAST RELEASE:	06 jan. 2012
10:                  	----------------------------------------------------------------------------
11:                  	based on original code by Regis Blanchot and FatFS example for PIC24
12:                  	----------------------------------------------------------------------------
13:                   	[30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
14:                  	07 May 2012	As part of providing support for PIC32 Pinguino Micro and
15:                  					potentially other cards removed #if defined (PIC32_Pinguino) etc
16:                  					and #endif in function mount() so that SDCS is set via mount 
17:                  					for all cards.
18:                  */
19:                  
20:                  #ifndef __FILEIO_C__
21:                  #define __FILEIO_C__
22:                  
23:                  // standard C libraries used
24:                  #include <stdio.h>
25:                  #include <ctype.h>      		// toupper...
26:                  #include <string.h>     		// memcpy...
27:                  //#include <malloc.h>				// malloc, free?
28:                  #include <GenericTypeDefs.h>
29:                  
30:                  #include "fileio.h"
31:                  #include "sdmmc.h"
32:                  #include "ff.h"					// Fat Filesystem
33:                  #include "diskio.h"				// card access functions
34:                  #include "../serial_comm/serial_comm.h"
35:                  #include "../../console.h"
36:                  
37:                  //#define SD_DEBUG
38:                  
39:                  //#ifdef SD_DEBUG
40:                  //    #include <__cdc.c>          // USB CDC functions
41:                  //#endif
42:                  
43:                  /*	----------------------------------------------------------------------------
44:                   mount
45:                   initializes a MEDIA structure for FILEIO access
46:                   will mount only the first partition on the disk/card
47:                   --------------------------------------------------------------------------*/
48:                  
49:                  BOOL SDCardReady;
50:                  
51:                  static FATFS _Fat;
52:                  
53:                  char mount(unsigned char pin) {
9D010BE4  27BDFFE0   ADDIU SP, SP, -32
9D010BE8  AFBF001C   SW RA, 28(SP)
54:                  	int flag, i;
55:                  	FRESULT r;
56:                  
57:                  	SDCS = pin;
58:                  
59:                  	// 0. init the I/Os
60:                  	initSD();
9D010BEC  0F404BAC   JAL initSD
9D010BF0  A384807C   SB A0, -32644(GP)
61:                  
62:                  
63:                  #ifdef SD_DEBUG
64:                  	DebugPrint("Looking for SD slot... ");
65:                  #endif
66:                  	// 1. check if the card is in the slot
67:                  	if (!getCD()) {
9D010BF4  0F404C54   JAL getCD
9D010BF8  00000000   NOP
9D010BFC  14400004   BNE V0, ZERO, 0x9D010C10
9D010C00  24020002   ADDIU V0, ZERO, 2
68:                  		FError = FE_NOT_PRESENT;
9D010C04  A3828070   SB V0, -32656(GP)
69:                  #ifdef SD_DEBUG
70:                  		DebugPrint( " getCD Failed!\r");
71:                  #endif
72:                  		return FALSE;
9D010C08  0B404320   J 0x9D010C80
9D010C0C  00001821   ADDU V1, ZERO, ZERO
73:                  	}
74:                  #ifdef SD_DEBUG
75:                  	DebugPrint("card in slot\r");
76:                  #endif
77:                  
78:                  	// 2. initialize the card
79:                  #ifdef SD_DEBUG
80:                  	DebugPrint("Initializing SD card... ");
81:                  #endif
82:                  	initMedia();
9D010C10  0F404BE4   JAL initMedia
9D010C14  00000000   NOP
83:                      if (disk_initialize(0)==STA_NOINIT){
9D010C18  0F402EDE   JAL disk_initialize
9D010C1C  00002021   ADDU A0, ZERO, ZERO
9D010C20  24040001   ADDIU A0, ZERO, 1
9D010C24  10440016   BEQ V0, A0, 0x9D010C80
9D010C28  00001821   ADDU V1, ZERO, ZERO
84:                  #ifdef SD_DEBUG
85:                              DebugPrint("disk_initialize() failed!\r");
86:                  #endif
87:                              return 0;
88:                          };
89:                  #ifdef SD_DEBUG
90:                          DebugPrint("disk_initialize() OK\r");
91:                  #endif
92:                  	// We're skipping the old step 3 because there's no need for malloc
93:                  	// This takes 6k off the code size if malloc is not used elsewhere.
94:                  	// Instead, just point it to our _Fat var.
95:                  	// The FATFS struct takes only 560 bytes of mem.
96:                  	Fat = &_Fat;
9D010C2C  3C05A000   LUI A1, -24576
9D010C30  24A54228   ADDIU A1, A1, 16936
9D010C34  AF858074   SW A1, -32652(GP)
97:                  
98:                  	// Mount media
99:                  #ifdef SD_DEBUG
100:                 	DebugPrint("Mounting FAT filesystem... ");
101:                 #endif
102:                 	r = f_mount(0, Fat);
9D010C38  0F400659   JAL f_mount
9D010C3C  00002021   ADDU A0, ZERO, ZERO
103:                 	if (r != FR_OK) {
9D010C40  10400003   BEQ V0, ZERO, 0x9D010C50
9D010C44  00001821   ADDU V1, ZERO, ZERO
104:                 		FError = r;
105:                 #ifdef SD_DEBUG
106:                 		DebugPrint("Failed!\r");
107:                 #endif
108:                 		//free(Fat);
109:                 		return FALSE;
9D010C48  0B404320   J 0x9D010C80
9D010C4C  A3828070   SB V0, -32656(GP)
110:                 	}
111:                 #ifdef SD_DEBUG
112:                 	DebugPrint( "OK\r");
113:                 #endif
114:                 
115:                 #ifdef SD_DEBUG
116:                 	DebugPrint("Checking FAT filesystem... ");
117:                 #endif
118:                 	const TCHAR * pth = "/";
9D010C50  3C029D01   LUI V0, -25343
9D010C54  24427948   ADDIU V0, V0, 31048
9D010C58  AFA20010   SW V0, 16(SP)
119:                 	r = chk_mounted(&pth, &Fat, 0);
9D010C5C  27A40010   ADDIU A0, SP, 16
9D010C60  27858074   ADDIU A1, GP, -32652
9D010C64  0F400521   JAL chk_mounted
9D010C68  00003021   ADDU A2, ZERO, ZERO
120:                 	if (r != FR_OK) {
9D010C6C  10400004   BEQ V0, ZERO, 0x9D010C80
9D010C70  24030001   ADDIU V1, ZERO, 1
121:                 		FError = r;
122:                 #ifdef SD_DEBUG
123:                 		DebugPrint( "Failed!\r");
124:                                  //put_rc(r);
125:                 #endif
126:                 		unmount();
9D010C74  0F4042EE   JAL unmount
9D010C78  A3828070   SB V0, -32656(GP)
127:                 		return FALSE;
9D010C7C  00001821   ADDU V1, ZERO, ZERO
128:                 	}
129:                 #ifdef SD_DEBUG
130:                 	DebugPrint( "OK\r");
131:                 #endif
132:                 
133:                 	return TRUE;
134:                 } // mount
9D010C80  00601021   ADDU V0, V1, ZERO
9D010C84  8FBF001C   LW RA, 28(SP)
9D010C88  03E00008   JR RA
9D010C8C  27BD0020   ADDIU SP, SP, 32
135:                 
136:                 /*	----------------------------------------------------------------------------
137:                  unmount    initializes a MEDIA structure for FILEIO access
138:                  --------------------------------------------------------------------------*/
139:                 
140:                 void unmount(void) {
9D010BB8  27BDFFE8   ADDIU SP, SP, -24
9D010BBC  AFBF0014   SW RA, 20(SP)
141:                 	f_mount(0, NULL);
9D010BC0  00002021   ADDU A0, ZERO, ZERO
9D010BC4  0F400659   JAL f_mount
9D010BC8  00002821   ADDU A1, ZERO, ZERO
142:                 	//free(Fat);
143:                 	SPI2CONCLR = 0x8000; // SPI2 OFF
9D010BCC  34038000   ORI V1, ZERO, -32768
9D010BD0  3C02BF80   LUI V0, -16512
9D010BD4  AC435A04   SW V1, 23044(V0)
144:                 } // unmount
9D010BD8  8FBF0014   LW RA, 20(SP)
9D010BDC  03E00008   JR RA
9D010BE0  27BD0018   ADDIU SP, SP, 24
145:                 
146:                 /*	----------------------------------------------------------------------------
147:                  present   test if a SD card is present
148:                  --------------------------------------------------------------------------*/
149:                 
150:                 char SD_present(unsigned char pin) {
9D010C90  27BDFFE8   ADDIU SP, SP, -24
9D010C94  AFBF0014   SW RA, 20(SP)
151:                 	if (mount(pin)) {
9D010C98  0F4042F9   JAL mount
9D010C9C  00000000   NOP
9D010CA0  10400005   BEQ V0, ZERO, 0x9D010CB8
9D010CA4  8FBF0014   LW RA, 20(SP)
152:                 		unmount();
9D010CA8  0F4042EE   JAL unmount
9D010CAC  00000000   NOP
153:                 		return TRUE;
9D010CB0  24020001   ADDIU V0, ZERO, 1
154:                 	} else {
155:                 		return FALSE;
156:                 	}
157:                 }
9D010CB4  8FBF0014   LW RA, 20(SP)
9D010CB8  03E00008   JR RA
9D010CBC  27BD0018   ADDIU SP, SP, 24
158:                 
159:                 /*	----------------------------------------------------------------------------
160:                  Scans the current disk and compiles a list of files with a given extension
161:                  list     array of file names max * 8
162:                  max      number of entries
163:                  ext      file extension we are searching for
164:                  return   number of files found
165:                  --------------------------------------------------------------------------*/
166:                 
167:                 //unsigned listTYPE(char *listname, long *listsize, int max, const char *ext )
168:                 unsigned listTYPE(DIRTABLE *list, int max, const char *ext)
169:                 //unsigned listTYPE(char *list, int max, const char *ext )
170:                 {
171:                 	//TODO: implement
172:                 
173:                 	return 0;
174:                 } // listTYPE
9D010CC0  03E00008   JR RA
9D010CC4  00001021   ADDU V0, ZERO, ZERO
175:                 
176:                 /* Prints the directory contents */
177:                 unsigned listDir(const char *path) {
9D010CC8  27BDFF90   ADDIU SP, SP, -112
9D010CCC  AFBF006C   SW RA, 108(SP)
9D010CD0  AFBE0068   SW S8, 104(SP)
9D010CD4  AFB70064   SW S7, 100(SP)
9D010CD8  AFB60060   SW S6, 96(SP)
9D010CDC  AFB5005C   SW S5, 92(SP)
9D010CE0  AFB40058   SW S4, 88(SP)
9D010CE4  AFB30054   SW S3, 84(SP)
9D010CE8  AFB20050   SW S2, 80(SP)
9D010CEC  AFB1004C   SW S1, 76(SP)
9D010CF0  AFB00048   SW S0, 72(SP)
9D010CF4  00808821   ADDU S1, A0, ZERO
178:                 	//TODO: remove all CDC references
179:                 	long p1;
180:                 	PF_BYTE res, b;
181:                 	UINT s1, s2;
182:                 	DIR dir; /* Directory object */
183:                         char * fmt;
184:                         dir.fs=Fat;
9D010CF8  8F828074   LW V0, -32652(GP)
9D010CFC  AFA20020   SW V0, 32(SP)
185:                 	res = f_opendir(&dir, path);
9D010D00  27A40020   ADDIU A0, SP, 32
9D010D04  0F400ABA   JAL f_opendir
9D010D08  02202821   ADDU A1, S1, ZERO
186:                         if (!res) {
9D010D0C  304300FF   ANDI V1, V0, 255
9D010D10  1460008E   BNE V1, ZERO, 0x9D010F4C
9D010D14  304200FF   ANDI V0, V0, 255
187:                             p1 = s1 = s2 = 0;
188:                             fmt=malloc(64);
9D010D18  0F404DAF   JAL malloc
9D010D1C  24040040   ADDIU A0, ZERO, 64
189:                             if (!fmt) {
9D010D20  10400084   BEQ V0, ZERO, 0x9D010F34
9D010D24  00408021   ADDU S0, V0, ZERO
190:                                 res=-1;
9D010F44  0B4043B5   J 0x9D010ED4
9D010F48  241200FF   ADDIU S2, ZERO, 255
191:                             }else{
192:                                 sprintf(fmt,"\rreading dirctory: ('%s')\r", path);
9D010D28  00402021   ADDU A0, V0, ZERO
9D010D2C  3C059D01   LUI A1, -25343
9D010D30  24A5794C   ADDIU A1, A1, 31052
9D010D34  0F4062D6   JAL _sprintf_cdnopsuxX
9D010D38  02203021   ADDU A2, S1, ZERO
193:                                 print(comm_channel,fmt);
9D010D3C  9784803C   LHU A0, -32708(GP)
9D010D40  0F402C18   JAL print
9D010D44  02002821   ADDU A1, S0, ZERO
9D010D48  0000A021   ADDU S4, ZERO, ZERO
9D010D4C  0000A821   ADDU S5, ZERO, ZERO
9D010D50  0000B021   ADDU S6, ZERO, ZERO
194:                             }
195:                         }else{
196:                             return res;
197:                         }
198:                         while (!res) {
199:                 		res = f_readdir(&dir, &Finfo);
9D010D54  3C13A000   LUI S3, -24576
9D010D58  267138B0   ADDIU S1, S3, 14512
9D010D78  27A40020   ADDIU A0, SP, 32
9D010D7C  0F400AEF   JAL f_readdir
9D010D80  02202821   ADDU A1, S1, ZERO
9D010D84  305200FF   ANDI S2, V0, 255
9D010ECC  0B40435F   J 0x9D010D7C
9D010ED0  27A40020   ADDIU A0, SP, 32
200:                 #ifdef SD_DEBUG
201:                 //		put_rc(res);
202:                 #endif
203:                 		if ((res != FR_OK) || !Finfo.fname[0]) {
9D010D88  16400061   BNE S2, ZERO, 0x9D010F10
9D010D8C  02002021   ADDU A0, S0, ZERO
9D010D90  82220009   LB V0, 9(S1)
9D010D94  50400053   BEQL V0, ZERO, 0x9D010EE4
9D010D98  AFB60010   SW S6, 16(SP)
204:                 			break;
205:                 		}
206:                 		if (Finfo.fattrib & AM_DIR) {
9D010D9C  92220008   LBU V0, 8(S1)
9D010DA0  30430010   ANDI V1, V0, 16
9D010DA4  306300FF   ANDI V1, V1, 255
9D010DA8  50600004   BEQL V1, ZERO, 0x9D010DBC
9D010DAC  26B50001   ADDIU S5, S5, 1
207:                 			s2++;
9D010DB0  26940001   ADDIU S4, S4, 1
208:                 		} else {
209:                 			s1++;
210:                 			p1 += Finfo.fsize;
9D010DBC  8E6338B0   LW V1, 14512(S3)
9D010DC0  02C3B021   ADDU S6, S6, V1
211:                 		}
212:                 // what about other outputs ?
213:                 		sprintf(fmt,"%c%c%c%c%c ",
9D010D5C  3C1E9D01   LUI S8, -25343
9D010D60  27DE7968   ADDIU S8, S8, 31080
9D010DB4  0B404372   J 0x9D010DC8
9D010DB8  24060044   ADDIU A2, ZERO, 68
9D010DC4  2406002D   ADDIU A2, ZERO, 45
9D010DC8  30470001   ANDI A3, V0, 1
9D010DD0  308400FF   ANDI A0, A0, 255
9D010DD4  24030048   ADDIU V1, ZERO, 72
9D010DD8  2405002D   ADDIU A1, ZERO, 45
9D010DDC  00A4180A   MOVZ V1, A1, A0
9D010DE0  00602021   ADDU A0, V1, ZERO
9D010DE8  306300FF   ANDI V1, V1, 255
9D010DEC  24050053   ADDIU A1, ZERO, 83
9D010DF0  2408002D   ADDIU T0, ZERO, 45
9D010DF4  0103280A   MOVZ A1, T0, V1
9D010DF8  00A01821   ADDU V1, A1, ZERO
9D010E00  304200FF   ANDI V0, V0, 255
9D010E04  24050041   ADDIU A1, ZERO, 65
9D010E08  0102280A   MOVZ A1, T0, V0
9D010E0C  AFA40010   SW A0, 16(SP)
9D010E10  AFA30014   SW V1, 20(SP)
9D010E14  AFA50018   SW A1, 24(SP)
9D010E18  02002021   ADDU A0, S0, ZERO
9D010E1C  03C02821   ADDU A1, S8, ZERO
9D010E20  24020052   ADDIU V0, ZERO, 82
9D010E24  2403002D   ADDIU V1, ZERO, 45
9D010E28  0067100A   MOVZ V0, V1, A3
9D010E2C  0F4062D6   JAL _sprintf_cdnopsuxX
9D010E30  00403821   ADDU A3, V0, ZERO
214:                                 (Finfo.fattrib & AM_DIR) ? 'D' : '-',
215:                 				(Finfo.fattrib & AM_RDO) ? 'R' : '-',
216:                 				(Finfo.fattrib & AM_HID) ? 'H' : '-',
9D010DCC  30440002   ANDI A0, V0, 2
217:                 				(Finfo.fattrib & AM_SYS) ? 'S' : '-',
9D010DE4  30430004   ANDI V1, V0, 4
218:                 				(Finfo.fattrib & AM_ARC) ? 'A' : '-');
9D010DFC  30420020   ANDI V0, V0, 32
219:                                 print(comm_channel, fmt);
9D010E34  9784803C   LHU A0, -32708(GP)
9D010E38  0F402C18   JAL print
9D010E3C  02002821   ADDU A1, S0, ZERO
220:                 		sprintf(fmt,"%u/%02u/%02u %02u:%02u ",
9D010D64  3C179D01   LUI S7, -25343
9D010D68  26F77974   ADDIU S7, S7, 31092
9D010E4C  30E3001F   ANDI V1, A3, 31
9D010E50  AFA30010   SW V1, 16(SP)
9D010E54  00021AC2   SRL V1, V0, 11
9D010E58  AFA30014   SW V1, 20(SP)
9D010E5C  7C422940   EXT V0, V0, 5, 6
9D010E60  AFA20018   SW V0, 24(SP)
9D010E64  02002021   ADDU A0, S0, ZERO
9D010E68  02E02821   ADDU A1, S7, ZERO
9D010E6C  24C607BC   ADDIU A2, A2, 1980
9D010E70  0F4062D6   JAL _sprintf_cdnopsuxX
9D010E74  7CE71940   EXT A3, A3, 5, 4
221:                                 (Finfo.fdate >> 9) + 1980,
9D010E40  96270004   LHU A3, 4(S1)
9D010E48  00073242   SRL A2, A3, 9
222:                 				(Finfo.fdate >> 5) & 15, Finfo.fdate & 31, (Finfo.ftime >> 11),
9D010E44  96220006   LHU V0, 6(S1)
223:                 				(Finfo.ftime >> 5) & 63);
224:                                 print(comm_channel, fmt);
9D010E78  9784803C   LHU A0, -32708(GP)
9D010E7C  0F402C18   JAL print
9D010E80  02002821   ADDU A1, S0, ZERO
225:                                 sprintf(fmt," %9u ", Finfo.fsize);
9D010D6C  3C029D01   LUI V0, -25343
9D010D70  2442798C   ADDIU V0, V0, 31116
9D010D74  AFA20040   SW V0, 64(SP)
9D010E84  02002021   ADDU A0, S0, ZERO
9D010E88  8FA50040   LW A1, 64(SP)
9D010E8C  0F4062D6   JAL _sprintf_cdnopsuxX
9D010E90  8E6638B0   LW A2, 14512(S3)
226:                                 print(comm_channel, fmt);
9D010E94  9784803C   LHU A0, -32708(GP)
9D010E98  0F402C18   JAL print
9D010E9C  02002821   ADDU A1, S0, ZERO
227:                 		sprintf(fmt, " %-12s %s\r", Finfo.fname,
9D010EA0  02002021   ADDU A0, S0, ZERO
9D010EA4  3C029D01   LUI V0, -25343
9D010EA8  24457994   ADDIU A1, V0, 31124
9D010EAC  3C06A000   LUI A2, -24576
9D010EB0  24C638B9   ADDIU A2, A2, 14521
9D010EB4  3C079D01   LUI A3, -25343
9D010EB8  0F4062D6   JAL _sprintf_cdnopsuxX
9D010EBC  24E779A0   ADDIU A3, A3, 31136
228:                 #if _USE_LFN
229:                 				Lfname);
230:                 #else
231:                 				"");
232:                 #endif
233:                                 print(comm_channel,fmt);
9D010EC0  9784803C   LHU A0, -32708(GP)
9D010EC4  0F402C18   JAL print
9D010EC8  02002821   ADDU A1, S0, ZERO
234:                 	}
235:                         if (!res){
236:                             sprintf(fmt, "\rfile count %d\rdirectory count %d\rtotal size %d\r",s1,s2,p1);
9D010EE4  02002021   ADDU A0, S0, ZERO
9D010EE8  3C059D01   LUI A1, -25343
9D010EEC  24A579A4   ADDIU A1, A1, 31140
9D010EF0  02A03021   ADDU A2, S5, ZERO
9D010EF4  0F4062D6   JAL _sprintf_cdnopsuxX
9D010EF8  02803821   ADDU A3, S4, ZERO
237:                             print(comm_channel, fmt);
9D010EFC  9784803C   LHU A0, -32708(GP)
9D010F00  0F402C18   JAL print
9D010F04  02002821   ADDU A1, S0, ZERO
9D010F08  0B4043B5   J 0x9D010ED4
9D010F0C  00000000   NOP
238:                         }else{
239:                             if (fmt){
240:                                     sprintf(fmt,"file i/o error code: %d\r", res);
9D010F10  3C059D01   LUI A1, -25343
9D010F14  24A579D8   ADDIU A1, A1, 31192
9D010F18  0F4062D6   JAL _sprintf_cdnopsuxX
9D010F1C  02403021   ADDU A2, S2, ZERO
241:                                     print(comm_channel, fmt);
9D010F20  9784803C   LHU A0, -32708(GP)
9D010F24  0F402C18   JAL print
9D010F28  02002821   ADDU A1, S0, ZERO
9D010F2C  0B4043B5   J 0x9D010ED4
9D010F30  00000000   NOP
242:                             }else{
243:                                 print(comm_channel,"Memory allocation error.\r");
9D010F34  9784803C   LHU A0, -32708(GP)
9D010F38  3C059D01   LUI A1, -25343
9D010F3C  0F402C18   JAL print
9D010F40  24A579F4   ADDIU A1, A1, 31220
244:                             }
245:                         }
246:                         free(fmt);
9D010ED4  0F40656A   JAL free
9D010ED8  02002021   ADDU A0, S0, ZERO
247:                 	return res;
9D010EDC  0B4043D3   J 0x9D010F4C
9D010EE0  02401021   ADDU V0, S2, ZERO
248:                 } // listDir
9D010F4C  8FBF006C   LW RA, 108(SP)
9D010F50  8FBE0068   LW S8, 104(SP)
9D010F54  8FB70064   LW S7, 100(SP)
9D010F58  8FB60060   LW S6, 96(SP)
9D010F5C  8FB5005C   LW S5, 92(SP)
9D010F60  8FB40058   LW S4, 88(SP)
9D010F64  8FB30054   LW S3, 84(SP)
9D010F68  8FB20050   LW S2, 80(SP)
9D010F6C  8FB1004C   LW S1, 76(SP)
9D010F70  8FB00048   LW S0, 72(SP)
9D010F74  03E00008   JR RA
9D010F78  27BD0070   ADDIU SP, SP, 112
249:                 
250:                 char isDirectory(FILINFO file) {
9D010F7C  AFA40000   SW A0, 0(SP)
9D010F80  AFA50004   SW A1, 4(SP)
9D010F84  AFA60008   SW A2, 8(SP)
9D010F88  AFA7000C   SW A3, 12(SP)
251:                 	if (file.fattrib & AM_DIR) {
252:                 		return TRUE;
253:                 	} else {
254:                 		return FALSE;
255:                 	}
256:                 }
9D010F8C  03E00008   JR RA
9D010F90  7CC20100   EXT V0, A2, 4, 1
257:                 
258:                 char isReadOnly(FILINFO file) {
9D010F94  AFA40000   SW A0, 0(SP)
9D010F98  AFA50004   SW A1, 4(SP)
9D010F9C  AFA60008   SW A2, 8(SP)
9D010FA0  AFA7000C   SW A3, 12(SP)
259:                 	if (file.fattrib & AM_RDO) {
260:                 		return TRUE;
261:                 	} else {
262:                 		return FALSE;
263:                 	}
264:                 }
9D010FA4  03E00008   JR RA
9D010FA8  30C20001   ANDI V0, A2, 1
265:                 
266:                 char isHidden(FILINFO file) {
9D010FAC  AFA40000   SW A0, 0(SP)
9D010FB0  AFA50004   SW A1, 4(SP)
9D010FB4  AFA60008   SW A2, 8(SP)
9D010FB8  AFA7000C   SW A3, 12(SP)
267:                 	if (file.fattrib & AM_HID) {
268:                 		return TRUE;
269:                 	} else {
270:                 		return FALSE;
271:                 	}
272:                 }
9D010FBC  03E00008   JR RA
9D010FC0  7CC20040   EXT V0, A2, 1, 1
273:                 
274:                 char isSystem(FILINFO file) {
9D010FC4  AFA40000   SW A0, 0(SP)
9D010FC8  AFA50004   SW A1, 4(SP)
9D010FCC  AFA60008   SW A2, 8(SP)
9D010FD0  AFA7000C   SW A3, 12(SP)
275:                 	if (file.fattrib & AM_SYS) {
276:                 		return TRUE;
277:                 	} else {
278:                 		return FALSE;
279:                 	}
280:                 }
9D010FD4  03E00008   JR RA
9D010FD8  7CC20080   EXT V0, A2, 2, 1
281:                 
282:                 char isArchive(FILINFO file) {
9D010FDC  AFA40000   SW A0, 0(SP)
9D010FE0  AFA50004   SW A1, 4(SP)
9D010FE4  AFA60008   SW A2, 8(SP)
9D010FE8  AFA7000C   SW A3, 12(SP)
283:                 	if (file.fattrib & AM_ARC) {
284:                 		return TRUE;
285:                 	} else {
286:                 		return FALSE;
287:                 	}
288:                 }
9D010FEC  03E00008   JR RA
9D010FF0  7CC20140   EXT V0, A2, 5, 1
289:                 #endif /* __FILEIO_C__ */
290:                 
---  /home/jacques/github/vpc-32vga/hardware/Pinguino/ff.c  ---------------------------------------------
1:                   /*----------------------------------------------------------------------------/
2:                    /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
3:                    /-----------------------------------------------------------------------------/
4:                    / FatFs module is a generic FAT file system module for small embedded systems.
5:                    / This is a free software that opened for education, research and commercial
6:                    / developments under license policy of following terms.
7:                    /
8:                    /  Copyright (C) 2011, ChaN, all right reserved.
9:                    /
10:                   / * The FatFs module is a free software and there is NO WARRANTY.
11:                   / * No restriction on use. You can use, modify and redistribute it for
12:                   /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
13:                   / * Redistributions of source code must retain the above copyright notice.
14:                   /
15:                   /-----------------------------------------------------------------------------/
16:                   / Feb 26,'06 R0.00  Prototype.
17:                   /
18:                   / Apr 29,'06 R0.01  First stable version.
19:                   /
20:                   / Jun 01,'06 R0.02  Added FAT12 support.
21:                   /                   Removed unbuffered mode.
22:                   /                   Fixed a problem on small (<32M) partition.
23:                   / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
24:                   /
25:                   / Sep 22,'06 R0.03  Added f_rename().
26:                   /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
27:                   / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
28:                   /                   Fixed f_mkdir() creates incorrect directory on FAT32.
29:                   /
30:                   / Feb 04,'07 R0.04  Supported multiple drive system.
31:                   /                   Changed some interfaces for multiple drive system.
32:                   /                   Changed f_mountdrv() to f_mount().
33:                   /                   Added f_mkfs().
34:                   / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
35:                   /                   Added a capability of extending file size to f_lseek().
36:                   /                   Added minimization level 3.
37:                   /                   Fixed an endian sensitive code in f_mkfs().
38:                   / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
39:                   /                   Added FSInfo support.
40:                   /                   Fixed DBCS name can result FR_INVALID_NAME.
41:                   /                   Fixed short seek (<= csize) collapses the file object.
42:                   /
43:                   / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
44:                   /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
45:                   /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
46:                   / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
47:                   /                   Fixed off by one error at FAT sub-type determination.
48:                   /                   Fixed btr in f_read() can be mistruncated.
49:                   /                   Fixed cached sector is not flushed when create and close without write.
50:                   /
51:                   / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
52:                   /                   Improved performance of f_lseek() on moving to the same or following cluster.
53:                   /
54:                   / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
55:                   /                   Added long file name feature.
56:                   /                   Added multiple code page feature.
57:                   /                   Added re-entrancy for multitask operation.
58:                   /                   Added auto cluster size selection to f_mkfs().
59:                   /                   Added rewind option to f_readdir().
60:                   /                   Changed result code of critical errors.
61:                   /                   Renamed string functions to avoid name collision.
62:                   / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
63:                   /                   Added multiple sector size feature.
64:                   / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
65:                   /                   Fixed wrong cache control in f_lseek().
66:                   /                   Added relative path feature.
67:                   /                   Added f_chdir() and f_chdrive().
68:                   /                   Added proper case conversion to extended char.
69:                   / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
70:                   /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
71:                   /                   Fixed name matching error on the 13 char boundary.
72:                   /                   Added a configuration option, _LFN_UNICODE.
73:                   /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
74:                   /
75:                   / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
76:                   /                   Added file lock feature. (_FS_SHARE)
77:                   /                   Added fast seek feature. (_USE_FASTSEEK)
78:                   /                   Changed some types on the API, XCHAR->TCHAR.
79:                   /                   Changed fname member in the FILINFO structure on Unicode cfg.
80:                   /                   String functions support UTF-8 encoding files on Unicode cfg.
81:                   / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
82:                   /                   Added sector erase feature. (_USE_ERASE)
83:                   /                   Moved file lock semaphore table from fs object to the bss.
84:                   /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
85:                   /                   Fixed f_mkfs() creates wrong FAT32 volume.
86:                   / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
87:                   /                   f_lseek() reports required table size on creating CLMP.
88:                   /                   Extended format syntax of f_printf function.
89:                   /                   Ignores duplicated directory separators in given path names.
90:                   /
91:                   / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
92:                   /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
93:                   /---------------------------------------------------------------------------
94:                   / 2011-12 Alfred Broda <alfredbroda@gmail.com> adapted for Pinguno Project
95:                   / BYTE and WORD were changed to PF_BYTE and PF_WORD because of a conflict.
96:                   ---------------------------------------------------------------------------*/
97:                  
98:                  #include "ff.h"			/* FatFs configurations and declarations */
99:                  #include "diskio.h"		/* Declarations of low level disk I/O functions */
100:                 
101:                 #if defined _DEBUG_
102:                 #include "../serial_comm/serial_comm.h"
103:                 #include"../../console.h"
104:                 #endif
105:                 /*--------------------------------------------------------------------------
106:                 
107:                  Module Private Definitions
108:                 
109:                  ---------------------------------------------------------------------------*/
110:                 
111:                 #if _FATFS != 6502	/* Revision ID */
112:                 #error Wrong include file (ff.h).
113:                 #endif
114:                 
115:                 /* Definitions on sector size */
116:                 #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
117:                 #error Wrong sector size.
118:                 #endif
119:                 #if _MAX_SS != 512
120:                 #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
121:                 #else
122:                 #define	SS(fs)	512U			/* Fixed sector size */
123:                 #endif
124:                 
125:                 /* Reentrancy related */
126:                 #if _FS_REENTRANT
127:                 #if _USE_LFN == 1
128:                 #error Static LFN work area must not be used in re-entrant configuration.
129:                 #endif
130:                 #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
131:                 #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
132:                 #else
133:                 #define	ENTER_FF(fs)
134:                 #define LEAVE_FF(fs, res)	return res
135:                 #endif
136:                 
137:                 #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
138:                 
139:                 /* File shareing feature */
140:                 #if _FS_SHARE
141:                 #if _FS_READONLY
142:                 #error _FS_SHARE must be 0 on read-only cfg.
143:                 #endif
144:                 typedef struct {
145:                 	FATFS *fs; /* File ID 1, volume (NULL:blank entry) */
146:                 	DWORD clu; /* File ID 2, directory */
147:                 	PF_WORD idx; /* File ID 3, directory index */
148:                 	PF_WORD ctr; /* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
149:                 }FILESEM;
150:                 #endif
151:                 
152:                 /* Misc definitions */
153:                 #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
154:                 #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
155:                 
156:                 /* DBCS code ranges and SBCS extend char conversion table */
157:                 
158:                 #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
159:                 #define _DF1S	0x81	/* DBC 1st byte range 1 start */
160:                 #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
161:                 #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
162:                 #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
163:                 #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
164:                 #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
165:                 #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
166:                 #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
167:                 
168:                 #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
169:                 #define _DF1S	0x81
170:                 #define _DF1E	0xFE
171:                 #define _DS1S	0x40
172:                 #define _DS1E	0x7E
173:                 #define _DS2S	0x80
174:                 #define _DS2E	0xFE
175:                 
176:                 #elif _CODE_PAGE == 949	/* Korean */
177:                 #define _DF1S	0x81
178:                 #define _DF1E	0xFE
179:                 #define _DS1S	0x41
180:                 #define _DS1E	0x5A
181:                 #define _DS2S	0x61
182:                 #define _DS2E	0x7A
183:                 #define _DS3S	0x81
184:                 #define _DS3E	0xFE
185:                 
186:                 #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
187:                 #define _DF1S	0x81
188:                 #define _DF1E	0xFE
189:                 #define _DS1S	0x40
190:                 #define _DS1E	0x7E
191:                 #define _DS2S	0xA1
192:                 #define _DS2E	0xFE
193:                 
194:                 #elif _CODE_PAGE == 437	/* U.S. (OEM) */
195:                 #define _DF1S	0
196:                 #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
197:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
198:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
199:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
200:                 
201:                 #elif _CODE_PAGE == 720	/* Arabic (OEM) */
202:                 #define _DF1S	0
203:                 #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
204:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
205:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
206:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
207:                 
208:                 #elif _CODE_PAGE == 737	/* Greek (OEM) */
209:                 #define _DF1S	0
210:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
211:                 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
212:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
213:                 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
214:                 
215:                 #elif _CODE_PAGE == 775	/* Baltic (OEM) */
216:                 #define _DF1S	0
217:                 #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
218:                 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
219:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
220:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
221:                 
222:                 #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
223:                 #define _DF1S	0
224:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
225:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
226:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
227:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
228:                 
229:                 #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
230:                 #define _DF1S	0
231:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
232:                 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
233:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
234:                 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
235:                 
236:                 #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
237:                 #define _DF1S	0
238:                 #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
239:                 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
240:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
241:                 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
242:                 
243:                 #elif _CODE_PAGE == 857	/* Turkish (OEM) */
244:                 #define _DF1S	0
245:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
246:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
247:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
248:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
249:                 
250:                 #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
251:                 #define _DF1S	0
252:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
253:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
254:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
255:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
256:                 
257:                 #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
258:                 #define _DF1S	0
259:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
260:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
261:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
262:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
263:                 
264:                 #elif _CODE_PAGE == 866	/* Russian (OEM) */
265:                 #define _DF1S	0
266:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
267:                 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
268:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
269:                 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
270:                 
271:                 #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
272:                 #define _DF1S	0
273:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
274:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
275:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
276:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
277:                 
278:                 #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
279:                 #define _DF1S	0
280:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
281:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
282:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
283:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
284:                 
285:                 #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
286:                 #define _DF1S	0
287:                 #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
288:                 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
289:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
290:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
291:                 
292:                 #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
293:                 #define _DF1S	0
294:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
295:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
296:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
297:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
298:                 
299:                 #elif _CODE_PAGE == 1253 /* Greek (Windows) */
300:                 #define _DF1S	0
301:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
302:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
303:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
304:                 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
305:                 
306:                 #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
307:                 #define _DF1S	0
308:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
309:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
310:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
311:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
312:                 
313:                 #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
314:                 #define _DF1S	0
315:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
316:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
317:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
318:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
319:                 
320:                 #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
321:                 #define _DF1S	0
322:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
323:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
324:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
325:                 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
326:                 
327:                 #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
328:                 #define _DF1S	0
329:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
330:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
331:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
332:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
333:                 
334:                 #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
335:                 #define _DF1S	0
336:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
337:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
338:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
339:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
340:                 
341:                 #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
342:                 #if _USE_LFN
343:                 #error Cannot use LFN feature without valid code page.
344:                 #endif
345:                 #define _DF1S	0
346:                 
347:                 #else
348:                 #error Unknown code page
349:                 
350:                 #endif
351:                 
352:                 /* Character code support macros */
353:                 #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
354:                 #define IsLower(c)	(((c)>='a')&&((c)<='z'))
355:                 #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
356:                 
357:                 #if _DF1S		/* Code page is DBCS */
358:                 
359:                 #ifdef _DF2S	/* Two 1st byte areas */
360:                 #define IsDBCS1(c)	(((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E) || ((PF_BYTE)(c) >= _DF2S && (PF_BYTE)(c) <= _DF2E))
361:                 #else			/* One 1st byte area */
362:                 #define IsDBCS1(c)	((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E)
363:                 #endif
364:                 
365:                 #ifdef _DS3S	/* Three 2nd byte areas */
366:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E) || ((PF_BYTE)(c) >= _DS3S && (PF_BYTE)(c) <= _DS3E))
367:                 #else			/* Two 2nd byte areas */
368:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E))
369:                 #endif
370:                 
371:                 #else			/* Code page is SBCS */
372:                 
373:                 #define IsDBCS1(c)	0
374:                 #define IsDBCS2(c)	0
375:                 
376:                 #endif /* _DF1S */
377:                 
378:                 /* Name status flags */
379:                 #define NS			11		/* Index of name status byte in fn[] */
380:                 #define NS_LOSS		0x01	/* Out of 8.3 format */
381:                 #define NS_LFN		0x02	/* Force to create LFN entry */
382:                 #define NS_LAST		0x04	/* Last segment */
383:                 #define NS_BODY		0x08	/* Lower case flag (body) */
384:                 #define NS_EXT		0x10	/* Lower case flag (ext) */
385:                 #define NS_DOT		0x20	/* Dot entry */
386:                 
387:                 /* FAT sub-type boundaries */
388:                 /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
389:                 #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
390:                 #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
391:                 
392:                 /* FatFs refers the members in the FAT structures as byte array instead of
393:                  / structure member because the structure is not binary compatible between
394:                  / different platforms */
395:                 
396:                 #define BS_jmpBoot			0	/* Jump instruction (3) */
397:                 #define BS_OEMName			3	/* OEM name (8) */
398:                 #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
399:                 #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
400:                 #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
401:                 #define BPB_NumFATs			16	/* Number of FAT copies (1) */
402:                 #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
403:                 #define BPB_TotSec16		19	/* Volume size [sector] (2) */
404:                 #define BPB_Media			21	/* Media descriptor (1) */
405:                 #define BPB_FATSz16			22	/* FAT size [sector] (2) */
406:                 #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
407:                 #define BPB_NumHeads		26	/* Number of heads (2) */
408:                 #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
409:                 #define BPB_TotSec32		32	/* Volume size [sector] (4) */
410:                 #define BS_DrvNum			36	/* Physical drive number (2) */
411:                 #define BS_BootSig			38	/* Extended boot signature (1) */
412:                 #define BS_VolID			39	/* Volume serial number (4) */
413:                 #define BS_VolLab			43	/* Volume label (8) */
414:                 #define BS_FilSysType		54	/* File system type (1) */
415:                 #define BPB_FATSz32			36	/* FAT size [sector] (4) */
416:                 #define BPB_ExtFlags		40	/* Extended flags (2) */
417:                 #define BPB_FSVer			42	/* File system version (2) */
418:                 #define BPB_RootClus		44	/* Root dir first cluster (4) */
419:                 #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
420:                 #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
421:                 #define BS_DrvNum32			64	/* Physical drive number (2) */
422:                 #define BS_BootSig32		66	/* Extended boot signature (1) */
423:                 #define BS_VolID32			67	/* Volume serial number (4) */
424:                 #define BS_VolLab32			71	/* Volume label (8) */
425:                 #define BS_FilSysType32		82	/* File system type (1) */
426:                 #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
427:                 #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
428:                 #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
429:                 #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
430:                 #define MBR_Table			446	/* MBR: Partition table offset (2) */
431:                 #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
432:                 #define BS_55AA				510	/* Boot sector signature (2) */
433:                 
434:                 #define	DIR_Name			0	/* Short file name (11) */
435:                 #define	DIR_Attr			11	/* Attribute (1) */
436:                 #define	DIR_NTres			12	/* NT flag (1) */
437:                 #define	DIR_CrtTime			14	/* Created time (2) */
438:                 #define	DIR_CrtDate			16	/* Created date (2) */
439:                 #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
440:                 #define	DIR_WrtTime			22	/* Modified time (2) */
441:                 #define	DIR_WrtDate			24	/* Modified date (2) */
442:                 #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
443:                 #define	DIR_FileSize		28	/* File size (4) */
444:                 #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
445:                 #define	LDIR_Attr			11	/* LFN attribute (1) */
446:                 #define	LDIR_Type			12	/* LFN type (1) */
447:                 #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
448:                 #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
449:                 #define	SZ_DIR				32		/* Size of a directory entry */
450:                 #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
451:                 #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
452:                 #define	NDDE				0x05	/* Replacement of a character collides with DDE */
453:                 
454:                 /*------------------------------------------------------------*/
455:                 /* Module private work area                                   */
456:                 /*------------------------------------------------------------*/
457:                 /* Note that uninitialized variables with static duration are
458:                  /  zeroed/nulled at start-up. If not, the compiler or start-up
459:                  /  routine is out of ANSI-C standard.
460:                  */
461:                 
462:                 #if _VOLUMES
463:                 static FATFS *FatFs[_VOLUMES]; /* Pointer to the file system objects (logical drives) */
464:                 #else
465:                 #error Number of volumes must not be 0.
466:                 #endif
467:                 
468:                 static PF_WORD Fsid; /* File system mount ID */
469:                 
470:                 #if _FS_RPATH
471:                 static
472:                 PF_BYTE CurrVol; /* Current drive */
473:                 #endif
474:                 
475:                 #if _FS_SHARE
476:                 static
477:                 FILESEM Files[_FS_SHARE]; /* File lock semaphores */
478:                 #endif
479:                 
480:                 #if _USE_LFN == 0			/* No LFN feature */
481:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
482:                 #define INIT_BUF(dobj)		(dobj).fn = sfn
483:                 #define	FREE_BUF()
484:                 
485:                 #elif _USE_LFN == 1			/* LFN feature with static working buffer */
486:                 static WCHAR LfnBuf[_MAX_LFN+1];
487:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
488:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
489:                 #define	FREE_BUF()
490:                 
491:                 #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
492:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
493:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
494:                 #define	FREE_BUF()
495:                 
496:                 #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
497:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR *lfn
498:                 #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
499:                 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
500:                 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
501:                 #define	FREE_BUF()			ff_memfree(lfn)
502:                 
503:                 #else
504:                 #error Wrong LFN configuration.
505:                 #endif
506:                 
507:                 /*--------------------------------------------------------------------------
508:                 
509:                  Module Private Functions
510:                 
511:                  ---------------------------------------------------------------------------*/
512:                 
513:                 /*-----------------------------------------------------------------------*/
514:                 /* String functions                                                      */
515:                 /*-----------------------------------------------------------------------*/
516:                 
517:                 /* Copy memory to memory */
518:                 static
519:                 void mem_cpy(void* dst, const void* src, UINT cnt) {
520:                 	PF_BYTE *d = (PF_BYTE*) dst;
521:                 	const PF_BYTE *s = (const PF_BYTE*) src;
522:                 
523:                 #if _WORD_ACCESS == 1
524:                 	while (cnt >= sizeof(int)) {
525:                 		*(int*) d = *(int*) s;
526:                 		d += sizeof(int);
527:                 		s += sizeof(int);
528:                 		cnt -= sizeof(int);
529:                 	}
530:                 #endif
531:                 	while (cnt--)
9D000000  10C00006   BEQ A2, ZERO, 0x9D00001C
9D000004  00863021   ADDU A2, A0, A2
9D000014  1486FFFC   BNE A0, A2, 0x9D000008
9D000018  A082FFFF   SB V0, -1(A0)
9D00001C  03E00008   JR RA
9D000020  00000000   NOP
532:                 		*d++ = *s++;
9D000008  24840001   ADDIU A0, A0, 1
9D00000C  24A50001   ADDIU A1, A1, 1
9D000010  90A2FFFF   LBU V0, -1(A1)
9D000014  1486FFFC   BNE A0, A2, 0x9D000008
9D000018  A082FFFF   SB V0, -1(A0)
9D00001C  03E00008   JR RA
9D000020  00000000   NOP
533:                 }
534:                 
535:                 /* Fill memory */
536:                 static
537:                 void mem_set(void* dst, int val, UINT cnt) {
538:                 	PF_BYTE *d = (PF_BYTE*) dst;
9D000440  00A01021   ADDU V0, A1, ZERO
9D000E48  00801021   ADDU V0, A0, ZERO
9D0012AC  00801021   ADDU V0, A0, ZERO
9D00328C  02601021   ADDU V0, S3, ZERO
539:                 
540:                 	while (cnt--)
9D000448  1443FFFE   BNE V0, V1, 0x9D000444
9D000CCC  1443FFFE   BNE V0, V1, mem_set
9D000E50  1443FFFE   BNE V0, V1, 0x9D000E4C
9D000E54  A054FFFF   SB S4, -1(V0)
9D0012B4  1443FFFE   BNE V0, V1, 0x9D0012B0
9D003294  1451FFFE   BNE V0, S1, 0x9D003290
9D0032AC  1444FFFE   BNE V0, A0, 0x9D0032A8
9D0033B4  1622FFFE   BNE S1, V0, f_mkdir::mem_set
541:                 		*d++ = (PF_BYTE) val;
9D000444  24420001   ADDIU V0, V0, 1
9D000CC8  24420001   ADDIU V0, V0, 1
9D000E08  24140020   ADDIU S4, ZERO, 32
9D000E4C  24420001   ADDIU V0, V0, 1
9D0012B0  24420001   ADDIU V0, V0, 1
9D003290  24420001   ADDIU V0, V0, 1
9D0032A4  24030020   ADDIU V1, ZERO, 32
9D0033B0  24420001   ADDIU V0, V0, 1
9D0033B4  1622FFFE   BNE S1, V0, f_mkdir::mem_set
9D0033B8  A040FFFF   SB ZERO, -1(V0)
542:                 }
543:                 
544:                 /* Compare memory to memory */
545:                 static
546:                 int mem_cmp(const void* dst, const void* src, UINT cnt) {
547:                 	const PF_BYTE *d = (const PF_BYTE *) dst, *s = (const PF_BYTE *) src;
9D001098  01203021   ADDU A2, T1, ZERO
9D00109C  0B40042B   J 0x9D0010AC
9D0010A0  01001821   ADDU V1, T0, ZERO
548:                 	int r = 0;
549:                 
550:                 	while (cnt-- && (r = *d++ - *s++) == 0)
9D0010A4  5067004C   BEQL V1, A3, 0x9D0011D8
9D0010A8  9123000B   LBU V1, 11(T1)
9D0010AC  24630001   ADDIU V1, V1, 1
9D0010B0  24C60001   ADDIU A2, A2, 1
9D0010B4  9065FFFF   LBU A1, -1(V1)
9D0010B8  90C4FFFF   LBU A0, -1(A2)
9D0010BC  10A4FFF9   BEQ A1, A0, follow_path::dir_find
9D0010C0  00000000   NOP
551:                 		;
552:                 	return r;
553:                 }
554:                 
555:                 /* Check if chr is contained in the string */
556:                 static
557:                 int chk_chr(const char* str, int chr) {
558:                 	while (*str && *str != chr)
9D000E74  0B4003B5   J follow_path::create_name
9D000E78  240C0022   ADDIU T4, ZERO, 34
9D000FAC  104C0081   BEQ V0, T4, 0x9D0011B4
559:                 		str++;
560:                 	return *str;
561:                 }
562:                 
563:                 /*-----------------------------------------------------------------------*/
564:                 /* Request/Release grant to access the volume                            */
565:                 /*-----------------------------------------------------------------------*/
566:                 #if _FS_REENTRANT
567:                 
568:                 static
569:                 int lock_fs (
570:                 		FATFS *fs /* File system object */
571:                 )
572:                 {
573:                 	return ff_req_grant(fs->sobj);
574:                 }
575:                 
576:                 static
577:                 void unlock_fs (
578:                 		FATFS *fs, /* File system object */
579:                 		FRESULT res /* Result code to be returned */
580:                 )
581:                 {
582:                 	if (res != FR_NOT_ENABLED &&
583:                 			res != FR_INVALID_DRIVE &&
584:                 			res != FR_INVALID_OBJECT &&
585:                 			res != FR_TIMEOUT) {
586:                 		ff_rel_grant(fs->sobj);
587:                 	}
588:                 }
589:                 #endif
590:                 
591:                 /*-----------------------------------------------------------------------*/
592:                 /* File shareing control functions                                       */
593:                 /*-----------------------------------------------------------------------*/
594:                 #if _FS_SHARE
595:                 
596:                 static
597:                 FRESULT chk_lock ( /* Check if the file can be accessed */
598:                 		DIR* dj, /* Directory object pointing the file to be checked */
599:                 		int acc /* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
600:                 )
601:                 {
602:                 	UINT i, be;
603:                 
604:                 	/* Search file semaphore table */
605:                 	for (i = be = 0; i < _FS_SHARE; i++) {
606:                 		if (Files[i].fs) { /* Existing entry */
607:                 			if (Files[i].fs == dj->fs && /* Check if the file matched with an open file */
608:                 					Files[i].clu == dj->sclust &&
609:                 					Files[i].idx == dj->index) break;
610:                 		} else { /* Blank entry */
611:                 			be++;
612:                 		}
613:                 	}
614:                 	if (i == _FS_SHARE) /* The file is not opened */
615:                 	return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES; /* Is there a blank entry for new file? */
616:                 
617:                 	/* The file has been opened. Reject any open against writing file and all write mode open */
618:                 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
619:                 }
620:                 
621:                 static
622:                 int enq_lock (void) /* Check if an entry is available for a new file */
623:                 {
624:                 	UINT i;
625:                 
626:                 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
627:                 	return (i == _FS_SHARE) ? 0 : 1;
628:                 }
629:                 
630:                 static
631:                 UINT inc_lock ( /* Increment file open counter and returns its index (0:int error) */
632:                 		DIR* dj, /* Directory object pointing the file to register or increment */
633:                 		int acc /* Desired access mode (0:Read, !0:Write) */
634:                 )
635:                 {
636:                 	UINT i;
637:                 
638:                 	for (i = 0; i < _FS_SHARE; i++) { /* Find the file */
639:                 		if (Files[i].fs == dj->fs &&
640:                 				Files[i].clu == dj->sclust &&
641:                 				Files[i].idx == dj->index) break;
642:                 	}
643:                 
644:                 	if (i == _FS_SHARE) { /* Not opened. Register it as new. */
645:                 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
646:                 		if (i == _FS_SHARE) return 0; /* No space to register (int err) */
647:                 		Files[i].fs = dj->fs;
648:                 		Files[i].clu = dj->sclust;
649:                 		Files[i].idx = dj->index;
650:                 		Files[i].ctr = 0;
651:                 	}
652:                 
653:                 	if (acc && Files[i].ctr) return 0; /* Access violation (int err) */
654:                 
655:                 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1; /* Set semaphore value */
656:                 
657:                 	return i + 1;
658:                 }
659:                 
660:                 static
661:                 FRESULT dec_lock ( /* Decrement file open counter */
662:                 		UINT i /* Semaphore index */
663:                 )
664:                 {
665:                 	PF_WORD n;
666:                 	FRESULT res;
667:                 
668:                 	if (--i < _FS_SHARE) {
669:                 		n = Files[i].ctr;
670:                 		if (n == 0x100) n = 0;
671:                 		if (n) n--;
672:                 		Files[i].ctr = n;
673:                 		if (!n) Files[i].fs = 0;
674:                 		res = FR_OK;
675:                 	} else {
676:                 		res = FR_INT_ERR;
677:                 	}
678:                 	return res;
679:                 }
680:                 
681:                 static
682:                 void clear_lock ( /* Clear lock entries of the volume */
683:                 		FATFS *fs
684:                 )
685:                 {
686:                 	UINT i;
687:                 
688:                 	for (i = 0; i < _FS_SHARE; i++) {
689:                 		if (Files[i].fs == fs) Files[i].fs = 0;
690:                 	}
691:                 }
692:                 #endif
693:                 
694:                 /*-----------------------------------------------------------------------*/
695:                 /* Change window offset                                                  */
696:                 /*-----------------------------------------------------------------------*/
697:                 
698:                 static FRESULT move_window(FATFS *fs, /* File system object */
699:                 DWORD sector /* Sector number to make appearance in the fs->win[] */
700:                 ) /* Move to zero only writes back dirty window */
701:                 {
9D0001BC  27BDFFD8   ADDIU SP, SP, -40
9D0001C0  AFBF0024   SW RA, 36(SP)
9D0001C4  AFB40020   SW S4, 32(SP)
9D0001C8  AFB3001C   SW S3, 28(SP)
9D0001CC  AFB20018   SW S2, 24(SP)
9D0001D0  AFB10014   SW S1, 20(SP)
9D0001D4  AFB00010   SW S0, 16(SP)
9D0001D8  00808021   ADDU S0, A0, ZERO
702:                 	DWORD wsect;
703:                 
704:                 	wsect = fs->winsect;
9D0001DC  8C910030   LW S1, 48(A0)
705:                 	if (wsect != sector) { /* Changed current window */
9D0001E0  1225002E   BEQ S1, A1, 0x9D00029C
9D0001E4  00A09021   ADDU S2, A1, ZERO
706:                 #if !_FS_READONLY
707:                 		if (fs->wflag) { /* Write back dirty window if needed */
9D0001E8  90820004   LBU V0, 4(A0)
9D0001EC  1040001F   BEQ V0, ZERO, 0x9D00026C
9D0001F0  02203021   ADDU A2, S1, ZERO
708:                 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
9D0001F4  24940034   ADDIU S4, A0, 52
9D0001F8  90840001   LBU A0, 1(A0)
9D0001FC  02802821   ADDU A1, S4, ZERO
9D000200  0F402FA8   JAL disk_write
9D000204  24070001   ADDIU A3, ZERO, 1
9D000208  14400025   BNE V0, ZERO, 0x9D0002A0
9D00020C  24030001   ADDIU V1, ZERO, 1
709:                 				return FR_DISK_ERR;
710:                 			fs->wflag = 0;
9D000210  A2000004   SB ZERO, 4(S0)
711:                 			if (wsect < (fs->fatbase + fs->fsize)) { /* In FAT area */
9D000214  8E030020   LW V1, 32(S0)
9D000218  8E020024   LW V0, 36(S0)
9D00021C  00621021   ADDU V0, V1, V0
9D000220  0222102B   SLTU V0, S1, V0
9D000224  10400011   BEQ V0, ZERO, 0x9D00026C
9D000228  00000000   NOP
712:                 				PF_BYTE nf;
713:                 				for (nf = fs->n_fats; nf > 1; nf--) { /* Reflect the change to all FAT copies */
9D00022C  92130003   LBU S3, 3(S0)
9D000230  2E620002   SLTIU V0, S3, 2
9D000234  1440000D   BNE V0, ZERO, 0x9D00026C
9D000238  00000000   NOP
9D000258  2673FFFF   ADDIU S3, S3, -1
9D00025C  327300FF   ANDI S3, S3, 255
9D000260  24020001   ADDIU V0, ZERO, 1
9D000264  5662FFF6   BNEL S3, V0, 0x9D000240
9D000268  8E020020   LW V0, 32(S0)
714:                 					wsect += fs->fsize;
9D00023C  8E020020   LW V0, 32(S0)
9D000240  02228821   ADDU S1, S1, V0
715:                 					disk_write(fs->drv, fs->win, wsect, 1);
9D000244  92040001   LBU A0, 1(S0)
9D000248  02802821   ADDU A1, S4, ZERO
9D00024C  02203021   ADDU A2, S1, ZERO
9D000250  0F402FA8   JAL disk_write
9D000254  24070001   ADDIU A3, ZERO, 1
716:                 				}
717:                 			}
718:                 		}
719:                 #endif
720:                 		if (sector) {
9D00026C  1240000C   BEQ S2, ZERO, 0x9D0002A0
9D000270  00001821   ADDU V1, ZERO, ZERO
721:                 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
9D000274  92040001   LBU A0, 1(S0)
9D000278  26050034   ADDIU A1, S0, 52
9D00027C  02403021   ADDU A2, S2, ZERO
9D000280  0F402F71   JAL disk_read
9D000284  24070001   ADDIU A3, ZERO, 1
9D000288  14400005   BNE V0, ZERO, 0x9D0002A0
9D00028C  24030001   ADDIU V1, ZERO, 1
722:                 				return FR_DISK_ERR;
723:                 			fs->winsect = sector;
9D000290  AE120030   SW S2, 48(S0)
724:                 		}
725:                 	}
726:                 
727:                 	return FR_OK;
9D000294  0B4000A8   J 0x9D0002A0
9D000298  00001821   ADDU V1, ZERO, ZERO
9D00029C  00001821   ADDU V1, ZERO, ZERO
728:                 }
9D0002A0  00601021   ADDU V0, V1, ZERO
9D0002A4  8FBF0024   LW RA, 36(SP)
9D0002A8  8FB40020   LW S4, 32(SP)
9D0002AC  8FB3001C   LW S3, 28(SP)
9D0002B0  8FB20018   LW S2, 24(SP)
9D0002B4  8FB10014   LW S1, 20(SP)
9D0002B8  8FB00010   LW S0, 16(SP)
9D0002BC  03E00008   JR RA
9D0002C0  27BD0028   ADDIU SP, SP, 40
729:                 
730:                 /*-----------------------------------------------------------------------*/
731:                 /* Clean-up cached data                                                  */
732:                 /*-----------------------------------------------------------------------*/
733:                 #if !_FS_READONLY
734:                 static FRESULT sync( /* FR_OK: successful, FR_DISK_ERR: failed */
735:                 FATFS *fs /* File system object */
736:                 ) {
9D0003F8  27BDFFE8   ADDIU SP, SP, -24
9D0003FC  AFBF0014   SW RA, 20(SP)
9D000400  AFB00010   SW S0, 16(SP)
9D000404  00808021   ADDU S0, A0, ZERO
737:                 	FRESULT res;
738:                 
739:                 	res = move_window(fs, 0);
9D000408  0F40006F   JAL move_window
9D00040C  00002821   ADDU A1, ZERO, ZERO
740:                 	if (res == FR_OK) {
9D000410  1440003A   BNE V0, ZERO, 0x9D0004FC
9D000414  8FBF0014   LW RA, 20(SP)
741:                 		/* Update FSInfo sector if needed */
742:                 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
9D000418  92030000   LBU V1, 0(S0)
9D00041C  24020003   ADDIU V0, ZERO, 3
9D000420  54620031   BNEL V1, V0, 0x9D0004E8
9D000424  92040001   LBU A0, 1(S0)
9D000428  92020005   LBU V0, 5(S0)
9D00042C  5040002E   BEQL V0, ZERO, 0x9D0004E8
9D000430  92040001   LBU A0, 1(S0)
743:                 			fs->winsect = 0;
9D000434  AE000030   SW ZERO, 48(S0)
744:                 			/* Create FSInfo structure */
745:                 			mem_set(fs->win, 0, 512);
9D000438  26050034   ADDIU A1, S0, 52
9D00043C  26030234   ADDIU V1, S0, 564
746:                 			ST_WORD(fs->win+BS_55AA, 0xAA55);
9D000450  24020055   ADDIU V0, ZERO, 85
9D000454  A2020232   SB V0, 562(S0)
9D000458  2402FFAA   ADDIU V0, ZERO, -86
9D00045C  A2020233   SB V0, 563(S0)
747:                 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
9D000460  24020052   ADDIU V0, ZERO, 82
9D000464  A2020034   SB V0, 52(S0)
9D000468  A2020035   SB V0, 53(S0)
9D00046C  24020061   ADDIU V0, ZERO, 97
9D000470  A2020036   SB V0, 54(S0)
9D000474  24030041   ADDIU V1, ZERO, 65
9D000478  A2030037   SB V1, 55(S0)
748:                 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
9D00047C  24040072   ADDIU A0, ZERO, 114
9D000480  A2040218   SB A0, 536(S0)
9D000484  A2040219   SB A0, 537(S0)
9D000488  A203021A   SB V1, 538(S0)
9D00048C  A202021B   SB V0, 539(S0)
749:                 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
9D000490  8E020010   LW V0, 16(S0)
9D000494  A202021C   SB V0, 540(S0)
9D000498  7C433A00   EXT V1, V0, 8, 8
9D00049C  A203021D   SB V1, 541(S0)
9D0004A0  00021C02   SRL V1, V0, 16
9D0004A4  A203021E   SB V1, 542(S0)
9D0004A8  00021602   SRL V0, V0, 24
9D0004AC  A202021F   SB V0, 543(S0)
750:                 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
9D0004B0  8E02000C   LW V0, 12(S0)
9D0004B4  A2020220   SB V0, 544(S0)
9D0004B8  7C433A00   EXT V1, V0, 8, 8
9D0004BC  A2030221   SB V1, 545(S0)
9D0004C0  00021C02   SRL V1, V0, 16
9D0004C4  A2030222   SB V1, 546(S0)
9D0004C8  00021602   SRL V0, V0, 24
9D0004CC  A2020223   SB V0, 547(S0)
751:                 			/* Write it into the FSInfo sector */
752:                 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
9D0004D0  92040001   LBU A0, 1(S0)
9D0004D4  8E060014   LW A2, 20(S0)
9D0004D8  0F402FA8   JAL disk_write
9D0004DC  24070001   ADDIU A3, ZERO, 1
753:                 			fs->fsi_flag = 0;
9D0004E0  A2000005   SB ZERO, 5(S0)
754:                 		}
755:                 		/* Make sure that no pending write process in the physical drive */
756:                 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
9D0004E4  92040001   LBU A0, 1(S0)
9D0004E8  00002821   ADDU A1, ZERO, ZERO
9D0004EC  0F402FEF   JAL disk_ioctl
9D0004F0  00003021   ADDU A2, ZERO, ZERO
9D0004F4  0002102B   SLTU V0, ZERO, V0
757:                 			res = FR_DISK_ERR;
758:                 	}
759:                 
760:                 	return res;
761:                 }
9D0004F8  8FBF0014   LW RA, 20(SP)
9D0004FC  8FB00010   LW S0, 16(SP)
9D000500  03E00008   JR RA
9D000504  27BD0018   ADDIU SP, SP, 24
762:                 #endif
763:                 
764:                 /*-----------------------------------------------------------------------*/
765:                 /* Get sector# from cluster#                                             */
766:                 /*-----------------------------------------------------------------------*/
767:                 
768:                 DWORD clust2sect( /* !=0: Sector number, 0: Failed - invalid cluster# */
769:                 FATFS *fs, /* File system object */
770:                 DWORD clst /* Cluster# to be converted */
771:                 ) {
772:                 	clst -= 2;
9D000508  24A5FFFE   ADDIU A1, A1, -2
773:                 	if (clst >= (fs->n_fatent - 2))
9D00050C  8C83001C   LW V1, 28(A0)
9D000510  2463FFFE   ADDIU V1, V1, -2
9D000514  00A3182B   SLTU V1, A1, V1
9D000518  10600005   BEQ V1, ZERO, 0x9D000530
9D00051C  00001021   ADDU V0, ZERO, ZERO
774:                 		return 0; /* Invalid cluster# */
775:                 	return clst * fs->csize + fs->database;
9D000520  90830002   LBU V1, 2(A0)
9D000524  8C82002C   LW V0, 44(A0)
9D000528  70A32002   MUL A0, A1, V1
9D00052C  00821021   ADDU V0, A0, V0
776:                 }
9D000530  03E00008   JR RA
9D000534  00000000   NOP
777:                 
778:                 /*-----------------------------------------------------------------------*/
779:                 /* FAT access - Read value of a FAT entry                                */
780:                 /*-----------------------------------------------------------------------*/
781:                 
782:                 DWORD get_fat( /* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
783:                 FATFS *fs, /* File system object */
784:                 DWORD clst /* Cluster# to get the link information */
785:                 ) {
9D000538  27BDFFD8   ADDIU SP, SP, -40
9D00053C  AFBF0024   SW RA, 36(SP)
9D000540  AFB30020   SW S3, 32(SP)
9D000544  AFB2001C   SW S2, 28(SP)
9D000548  AFB10018   SW S1, 24(SP)
9D00054C  AFB00014   SW S0, 20(SP)
786:                 	UINT wc, bc;
787:                 	PF_BYTE *p;
788:                 
789:                 	if (clst < 2 || clst >= fs->n_fatent) /* Chack range */
9D000550  2CA20002   SLTIU V0, A1, 2
9D000554  14400051   BNE V0, ZERO, 0x9D00069C
9D000558  00A08021   ADDU S0, A1, ZERO
9D00055C  00808821   ADDU S1, A0, ZERO
9D000560  8C82001C   LW V0, 28(A0)
9D000564  00A2102B   SLTU V0, A1, V0
9D000568  1040004D   BEQ V0, ZERO, 0x9D0006A0
9D00056C  24030001   ADDIU V1, ZERO, 1
790:                 		return 1;
791:                 
792:                 	switch (fs->fs_type) {
9D000570  90820000   LBU V0, 0(A0)
9D000574  24030002   ADDIU V1, ZERO, 2
9D000578  50430025   BEQL V0, V1, 0x9D000610
9D00057C  00052A02   SRL A1, A1, 8
9D000580  24030003   ADDIU V1, ZERO, 3
9D000584  5043002F   BEQL V0, V1, 0x9D000644
9D000588  000529C2   SRL A1, A1, 7
9D00058C  24030001   ADDIU V1, ZERO, 1
9D000590  54430043   BNEL V0, V1, 0x9D0006A0
9D000594  2403FFFF   ADDIU V1, ZERO, -1
793:                 	case FS_FAT12:
794:                 		bc = (UINT) clst;
795:                 		bc += bc / 2;
9D000598  00059042   SRL S2, A1, 1
9D00059C  02459021   ADDU S2, S2, A1
796:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D0005A0  00122A42   SRL A1, S2, 9
9D0005A4  8C820024   LW V0, 36(A0)
9D0005A8  0F40006F   JAL move_window
9D0005AC  00A22821   ADDU A1, A1, V0
9D0005B0  1440003B   BNE V0, ZERO, 0x9D0006A0
9D0005B4  2403FFFF   ADDIU V1, ZERO, -1
797:                 			break;
798:                 		wc = fs->win[bc % SS(fs)];
9D0005B8  324201FF   ANDI V0, S2, 511
9D0005BC  02221021   ADDU V0, S1, V0
9D0005C0  90530034   LBU S3, 52(V0)
799:                 		bc++;
9D0005C4  26520001   ADDIU S2, S2, 1
800:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D0005C8  00122A42   SRL A1, S2, 9
9D0005CC  8E220024   LW V0, 36(S1)
9D0005D0  02202021   ADDU A0, S1, ZERO
9D0005D4  0F40006F   JAL move_window
9D0005D8  00A22821   ADDU A1, A1, V0
9D0005DC  14400030   BNE V0, ZERO, 0x9D0006A0
9D0005E0  2403FFFF   ADDIU V1, ZERO, -1
801:                 			break;
802:                 		wc |= fs->win[bc % SS(fs)] << 8;
9D0005E4  325201FF   ANDI S2, S2, 511
9D0005E8  02328821   ADDU S1, S1, S2
9D0005EC  92220034   LBU V0, 52(S1)
9D0005F0  00021200   SLL V0, V0, 8
9D0005F4  00539825   OR S3, V0, S3
803:                 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
9D0005F8  32030001   ANDI V1, S0, 1
9D0005FC  00131102   SRL V0, S3, 4
9D000600  32730FFF   ANDI S3, S3, 4095
9D000604  0263100A   MOVZ V0, S3, V1
9D000608  0B4001A8   J 0x9D0006A0
9D00060C  00401821   ADDU V1, V0, ZERO
804:                 
805:                 	case FS_FAT16:
806:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))))
9D000610  8C820024   LW V0, 36(A0)
9D000614  0F40006F   JAL move_window
9D000618  00A22821   ADDU A1, A1, V0
9D00061C  14400020   BNE V0, ZERO, 0x9D0006A0
9D000620  2403FFFF   ADDIU V1, ZERO, -1
807:                 			break;
808:                 		p = &fs->win[clst * 2 % SS(fs)];
9D000624  00108040   SLL S0, S0, 1
9D000628  321001FE   ANDI S0, S0, 510
809:                 		return LD_WORD(p);
9D00062C  02301021   ADDU V0, S1, S0
9D000630  90430035   LBU V1, 53(V0)
9D000634  00031A00   SLL V1, V1, 8
9D000638  90420034   LBU V0, 52(V0)
9D00063C  0B4001A8   J 0x9D0006A0
9D000640  00621825   OR V1, V1, V0
810:                 
811:                 	case FS_FAT32:
812:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))))
9D000644  8C820024   LW V0, 36(A0)
9D000648  0F40006F   JAL move_window
9D00064C  00A22821   ADDU A1, A1, V0
9D000650  14400013   BNE V0, ZERO, 0x9D0006A0
9D000654  2403FFFF   ADDIU V1, ZERO, -1
813:                 			break;
814:                 		p = &fs->win[clst * 4 % SS(fs)];
9D000658  00108080   SLL S0, S0, 2
9D00065C  321001FC   ANDI S0, S0, 508
9D000660  02301021   ADDU V0, S1, S0
9D000670  24420034   ADDIU V0, V0, 52
815:                 		return LD_DWORD(p) & 0x0FFFFFFF;
9D000664  90440036   LBU A0, 54(V0)
9D000668  00042400   SLL A0, A0, 16
9D00066C  90430037   LBU V1, 55(V0)
9D000674  00031E00   SLL V1, V1, 24
9D000678  00831825   OR V1, A0, V1
9D00067C  90420001   LBU V0, 1(V0)
9D000680  00021200   SLL V0, V0, 8
9D000684  00621825   OR V1, V1, V0
9D000688  02308021   ADDU S0, S1, S0
9D00068C  92020034   LBU V0, 52(S0)
9D000690  00621825   OR V1, V1, V0
9D000694  0B4001A8   J 0x9D0006A0
9D000698  7C63D800   EXT V1, V1, 0, 28
9D00069C  24030001   ADDIU V1, ZERO, 1
816:                 	}
817:                 
818:                 	return 0xFFFFFFFF; /* An error occurred at the disk I/O layer */
819:                 }
9D0006A0  00601021   ADDU V0, V1, ZERO
9D0006A4  8FBF0024   LW RA, 36(SP)
9D0006A8  8FB30020   LW S3, 32(SP)
9D0006AC  8FB2001C   LW S2, 28(SP)
9D0006B0  8FB10018   LW S1, 24(SP)
9D0006B4  8FB00014   LW S0, 20(SP)
9D0006B8  03E00008   JR RA
9D0006BC  27BD0028   ADDIU SP, SP, 40
820:                 
821:                 /*-----------------------------------------------------------------------*/
822:                 /* FAT access - Change value of a FAT entry                              */
823:                 /*-----------------------------------------------------------------------*/
824:                 #if !_FS_READONLY
825:                 
826:                 FRESULT put_fat(FATFS *fs, /* File system object */
827:                 DWORD clst, /* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
828:                 DWORD val /* New value to mark the cluster */
829:                 ) {
9D00085C  27BDFFD8   ADDIU SP, SP, -40
9D000860  AFBF0024   SW RA, 36(SP)
9D000864  AFB30020   SW S3, 32(SP)
9D000868  AFB2001C   SW S2, 28(SP)
9D00086C  AFB10018   SW S1, 24(SP)
9D000870  AFB00014   SW S0, 20(SP)
9D000874  00A08021   ADDU S0, A1, ZERO
830:                 	UINT bc;
831:                 	PF_BYTE *p;
832:                 	FRESULT res;
833:                 
834:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D000878  2CA30002   SLTIU V1, A1, 2
9D00087C  1460005D   BNE V1, ZERO, 0x9D0009F4
9D000880  24020002   ADDIU V0, ZERO, 2
9D000884  8C83001C   LW V1, 28(A0)
9D000888  00A3182B   SLTU V1, A1, V1
9D00088C  10600059   BEQ V1, ZERO, 0x9D0009F4
9D000890  00808821   ADDU S1, A0, ZERO
835:                 		res = FR_INT_ERR;
836:                 
837:                 	} else {
838:                 		switch (fs->fs_type) {
9D000894  90820000   LBU V0, 0(A0)
9D000898  24030002   ADDIU V1, ZERO, 2
9D00089C  10430031   BEQ V0, V1, 0x9D000964
9D0008A0  00C09021   ADDU S2, A2, ZERO
9D0008A4  24030003   ADDIU V1, ZERO, 3
9D0008A8  1043003B   BEQ V0, V1, 0x9D000998
9D0008AC  24030001   ADDIU V1, ZERO, 1
9D0008B0  1443004E   BNE V0, V1, 0x9D0009EC
9D0008B4  24020002   ADDIU V0, ZERO, 2
839:                 		case FS_FAT12:
840:                 			bc = clst;
841:                 			bc += bc / 2;
9D0008B8  00059842   SRL S3, A1, 1
9D0008BC  02659821   ADDU S3, S3, A1
842:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D0008C0  00132A42   SRL A1, S3, 9
9D0008C4  8C820024   LW V0, 36(A0)
9D0008C8  0F40006F   JAL move_window
9D0008CC  00A22821   ADDU A1, A1, V0
843:                 			if (res != FR_OK)
9D0008D0  14400047   BNE V0, ZERO, 0x9D0009F0
9D0008D4  24030001   ADDIU V1, ZERO, 1
844:                 				break;
845:                 			p = &fs->win[bc % SS(fs)];
9D0008D8  326301FF   ANDI V1, S3, 511
846:                 			*p = (clst & 1) ? ((*p & 0x0F) | ((PF_BYTE) val << 4))
9D0008DC  32100001   ANDI S0, S0, 1
9D0008E0  12000008   BEQ S0, ZERO, 0x9D000904
9D0008E4  324200FF   ANDI V0, S2, 255
9D0008E8  02231021   ADDU V0, S1, V1
9D0008EC  90440034   LBU A0, 52(V0)
9D0008F0  3084000F   ANDI A0, A0, 15
9D0008F4  324200FF   ANDI V0, S2, 255
9D0008F8  00021100   SLL V0, V0, 4
9D0008FC  00821025   OR V0, A0, V0
9D000900  304200FF   ANDI V0, V0, 255
9D000904  02231821   ADDU V1, S1, V1
9D000908  A0620034   SB V0, 52(V1)
847:                 					: (PF_BYTE) val;
848:                 			bc++;
9D00090C  26730001   ADDIU S3, S3, 1
849:                 			fs->wflag = 1;
9D000910  24020001   ADDIU V0, ZERO, 1
9D000914  A2220004   SB V0, 4(S1)
850:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D000918  00132A42   SRL A1, S3, 9
9D00091C  8E220024   LW V0, 36(S1)
9D000920  02202021   ADDU A0, S1, ZERO
9D000924  0F40006F   JAL move_window
9D000928  00A22821   ADDU A1, A1, V0
851:                 			if (res != FR_OK)
9D00092C  14400030   BNE V0, ZERO, 0x9D0009F0
9D000930  24030001   ADDIU V1, ZERO, 1
852:                 				break;
853:                 			p = &fs->win[bc % SS(fs)];
854:                 			*p = (clst & 1) ? (PF_BYTE) (val >> 4) : ((*p & 0xF0)
9D000934  12000003   BEQ S0, ZERO, 0x9D000944
9D000938  327301FF   ANDI S3, S3, 511
9D00093C  0B400256   J 0x9D000958
9D000940  7E523900   EXT S2, S2, 4, 8
9D000944  02331821   ADDU V1, S1, S3
9D000948  90630034   LBU V1, 52(V1)
9D00094C  7E521A00   EXT S2, S2, 8, 4
9D000950  306300F0   ANDI V1, V1, 240
9D000954  00729025   OR S2, V1, S2
9D000958  02339821   ADDU S3, S1, S3
855:                 					| ((PF_BYTE) (val >> 8) & 0x0F));
856:                 			break;
9D00095C  0B40027B   J 0x9D0009EC
9D000960  A2720034   SB S2, 52(S3)
857:                 
858:                 		case FS_FAT16:
859:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
9D000964  00052A02   SRL A1, A1, 8
9D000968  8C820024   LW V0, 36(A0)
9D00096C  0F40006F   JAL move_window
9D000970  00A22821   ADDU A1, A1, V0
860:                 			if (res != FR_OK)
9D000974  1440001E   BNE V0, ZERO, 0x9D0009F0
9D000978  24030001   ADDIU V1, ZERO, 1
861:                 				break;
862:                 			p = &fs->win[clst * 2 % SS(fs)];
9D00097C  00108040   SLL S0, S0, 1
9D000980  321001FE   ANDI S0, S0, 510
863:                 			ST_WORD(p, (PF_WORD)val)
9D000984  02301821   ADDU V1, S1, S0
9D000988  A0720034   SB S2, 52(V1)
9D00098C  7E523A00   EXT S2, S2, 8, 8
864:                 			;
865:                 			break;
9D000990  0B40027B   J 0x9D0009EC
9D000994  A0720035   SB S2, 53(V1)
866:                 
867:                 		case FS_FAT32:
868:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
9D000998  000529C2   SRL A1, A1, 7
9D00099C  8C820024   LW V0, 36(A0)
9D0009A0  0F40006F   JAL move_window
9D0009A4  00A22821   ADDU A1, A1, V0
869:                 			if (res != FR_OK)
9D0009A8  14400011   BNE V0, ZERO, 0x9D0009F0
9D0009AC  24030001   ADDIU V1, ZERO, 1
870:                 				break;
871:                 			p = &fs->win[clst * 4 % SS(fs)];
9D0009B0  00108080   SLL S0, S0, 2
9D0009B4  321001FC   ANDI S0, S0, 508
9D0009B8  02301821   ADDU V1, S1, S0
872:                 			val |= LD_DWORD(p) & 0xF0000000;
9D0009BC  90640037   LBU A0, 55(V1)
9D0009C0  00042600   SLL A0, A0, 24
9D0009C4  02308021   ADDU S0, S1, S0
9D0009C8  7C04D804   INS A0, ZERO, 0, 28
9D0009CC  00929025   OR S2, A0, S2
873:                 			ST_DWORD(p, val)
9D0009D0  A2120034   SB S2, 52(S0)
9D0009D4  7E443A00   EXT A0, S2, 8, 8
9D0009D8  A0640035   SB A0, 53(V1)
9D0009DC  00122402   SRL A0, S2, 16
9D0009E0  A0640036   SB A0, 54(V1)
9D0009E4  00129602   SRL S2, S2, 24
9D0009E8  A0720037   SB S2, 55(V1)
874:                 			;
875:                 			break;
876:                 
877:                 		default:
878:                 			res = FR_INT_ERR;
879:                 		}
880:                 		fs->wflag = 1;
9D0009EC  24030001   ADDIU V1, ZERO, 1
9D0009F0  A2230004   SB V1, 4(S1)
881:                 	}
882:                 
883:                 	return res;
884:                 }
9D0009F4  8FBF0024   LW RA, 36(SP)
9D0009F8  8FB30020   LW S3, 32(SP)
9D0009FC  8FB2001C   LW S2, 28(SP)
9D000A00  8FB10018   LW S1, 24(SP)
9D000A04  8FB00014   LW S0, 20(SP)
9D000A08  03E00008   JR RA
9D000A0C  27BD0028   ADDIU SP, SP, 40
885:                 #endif /* !_FS_READONLY */
886:                 
887:                 /*-----------------------------------------------------------------------*/
888:                 /* FAT handling - Remove a cluster chain                                 */
889:                 /*-----------------------------------------------------------------------*/
890:                 #if !_FS_READONLY
891:                 static FRESULT remove_chain(FATFS *fs, /* File system object */
892:                 DWORD clst /* Cluster# to remove a chain from */
893:                 ) {
9D0013A4  27BDFFD0   ADDIU SP, SP, -48
9D0013A8  AFBF002C   SW RA, 44(SP)
9D0013AC  AFB50028   SW S5, 40(SP)
9D0013B0  AFB40024   SW S4, 36(SP)
9D0013B4  AFB30020   SW S3, 32(SP)
9D0013B8  AFB2001C   SW S2, 28(SP)
9D0013BC  AFB10018   SW S1, 24(SP)
9D0013C0  AFB00014   SW S0, 20(SP)
9D0013C4  00A09021   ADDU S2, A1, ZERO
894:                 	FRESULT res;
895:                 	DWORD nxt;
896:                 #if _USE_ERASE
897:                 	DWORD scl = clst, ecl = clst, resion[2];
898:                 #endif
899:                 
900:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D0013C8  2CA30002   SLTIU V1, A1, 2
9D0013CC  14600024   BNE V1, ZERO, 0x9D001460
9D0013D0  24020002   ADDIU V0, ZERO, 2
9D0013D4  8C83001C   LW V1, 28(A0)
9D0013D8  00A3182B   SLTU V1, A1, V1
9D0013DC  10600020   BEQ V1, ZERO, 0x9D001460
9D0013E0  00808021   ADDU S0, A0, ZERO
901:                 		res = FR_INT_ERR;
902:                 
903:                 	} else {
904:                 		res = FR_OK;
905:                 		while (clst < fs->n_fatent) { /* Not a last link? */
9D00143C  8E03001C   LW V1, 28(S0)
9D001440  0223182B   SLTU V1, S1, V1
9D001444  10600006   BEQ V1, ZERO, 0x9D001460
9D001448  02209021   ADDU S2, S1, ZERO
906:                 			nxt = get_fat(fs, clst); /* Get cluster status */
9D0013F0  02002021   ADDU A0, S0, ZERO
9D0013F4  0F40014E   JAL get_fat
9D0013F8  02402821   ADDU A1, S2, ZERO
9D00144C  0B4004FD   J 0x9D0013F4
9D001450  02002021   ADDU A0, S0, ZERO
9D001454  0B400518   J 0x9D001460
9D001458  00001021   ADDU V0, ZERO, ZERO
907:                 			if (nxt == 0)
9D0013FC  10400015   BEQ V0, ZERO, 0x9D001454
9D001400  00408821   ADDU S1, V0, ZERO
908:                 				break; /* Empty cluster? */
909:                 			if (nxt == 1) {
9D0013E4  24140001   ADDIU S4, ZERO, 1
9D001404  50540016   BEQL V0, S4, 0x9D001460
9D001408  24020002   ADDIU V0, ZERO, 2
910:                 				res = FR_INT_ERR;
911:                 				break;
912:                 			} /* Internal error? */
913:                 			if (nxt == 0xFFFFFFFF) {
9D0013E8  2413FFFF   ADDIU S3, ZERO, -1
9D00140C  10530013   BEQ V0, S3, 0x9D00145C
9D001410  02002021   ADDU A0, S0, ZERO
914:                 				res = FR_DISK_ERR;
9D00145C  24020001   ADDIU V0, ZERO, 1
915:                 				break;
916:                 			} /* Disk error? */
917:                 			res = put_fat(fs, clst, 0); /* Mark the cluster "empty" */
9D001414  02402821   ADDU A1, S2, ZERO
9D001418  0F400217   JAL put_fat
9D00141C  00003021   ADDU A2, ZERO, ZERO
918:                 			if (res != FR_OK)
9D001420  14400010   BNE V0, ZERO, 0x9D001464
9D001424  8FBF002C   LW RA, 44(SP)
919:                 				break;
920:                 			if (fs->free_clust != 0xFFFFFFFF) { /* Update FSInfo */
9D001428  8E030010   LW V1, 16(S0)
9D00142C  10730003   BEQ V1, S3, 0x9D00143C
9D001430  24630001   ADDIU V1, V1, 1
921:                 				fs->free_clust++;
9D001434  AE030010   SW V1, 16(S0)
922:                 				fs->fsi_flag = 1;
9D0013EC  24150001   ADDIU S5, ZERO, 1
9D001438  A2150005   SB S5, 5(S0)
923:                 			}
924:                 #if _USE_ERASE
925:                 			if (ecl + 1 == nxt) { /* Next cluster is contiguous */
926:                 				ecl = nxt;
927:                 			} else { /* End of contiguous clusters */
928:                 				resion[0] = clust2sect(fs, scl); /* Start sector */
929:                 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1; /* End sector */
930:                 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion); /* Erase the block */
931:                 				scl = ecl = nxt;
932:                 			}
933:                 #endif
934:                 			clst = nxt; /* Next cluster */
935:                 		}
936:                 	}
937:                 
938:                 	return res;
939:                 }
9D001460  8FBF002C   LW RA, 44(SP)
9D001464  8FB50028   LW S5, 40(SP)
9D001468  8FB40024   LW S4, 36(SP)
9D00146C  8FB30020   LW S3, 32(SP)
9D001470  8FB2001C   LW S2, 28(SP)
9D001474  8FB10018   LW S1, 24(SP)
9D001478  8FB00014   LW S0, 20(SP)
9D00147C  03E00008   JR RA
9D001480  27BD0030   ADDIU SP, SP, 48
940:                 #endif
941:                 
942:                 /*-----------------------------------------------------------------------*/
943:                 /* FAT handling - Stretch or Create a cluster chain                      */
944:                 /*-----------------------------------------------------------------------*/
945:                 #if !_FS_READONLY
946:                 static DWORD create_chain( /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
947:                 FATFS *fs, /* File system object */
948:                 DWORD clst /* Cluster# to stretch. 0 means create a new chain. */
949:                 ) {
9D000A10  27BDFFD0   ADDIU SP, SP, -48
9D000A14  AFBF002C   SW RA, 44(SP)
9D000A18  AFB60028   SW S6, 40(SP)
9D000A1C  AFB50024   SW S5, 36(SP)
9D000A20  AFB40020   SW S4, 32(SP)
9D000A24  AFB3001C   SW S3, 28(SP)
9D000A28  AFB20018   SW S2, 24(SP)
9D000A2C  AFB10014   SW S1, 20(SP)
9D000A30  AFB00010   SW S0, 16(SP)
9D000A34  00808821   ADDU S1, A0, ZERO
950:                 	DWORD cs, ncl, scl;
951:                 	FRESULT res;
952:                 
953:                 	if (clst == 0) { /* Create a new chain */
9D000A38  14A00009   BNE A1, ZERO, 0x9D000A60
9D000A3C  00A0B021   ADDU S6, A1, ZERO
954:                 		scl = fs->last_clust; /* Get suggested start point */
9D000A40  8C92000C   LW S2, 12(A0)
955:                 		if (!scl || scl >= fs->n_fatent)
9D000A44  52400011   BEQL S2, ZERO, 0x9D000A8C
9D000A48  24120001   ADDIU S2, ZERO, 1
9D000A4C  8C83001C   LW V1, 28(A0)
9D000A50  0243182B   SLTU V1, S2, V1
956:                 			scl = 1;
9D000A54  24020001   ADDIU V0, ZERO, 1
9D000A58  0B4002A3   J 0x9D000A8C
9D000A5C  0043900A   MOVZ S2, V0, V1
957:                 	} else { /* Stretch the current chain */
958:                 		cs = get_fat(fs, clst); /* Check the cluster status */
9D000A60  0F40014E   JAL get_fat
9D000A64  00000000   NOP
959:                 		if (cs < 2)
9D000A68  2C430002   SLTIU V1, V0, 2
9D000A6C  54600042   BNEL V1, ZERO, 0x9D000B78
9D000A70  24020001   ADDIU V0, ZERO, 1
960:                 			return 1; /* It is an invalid cluster */
961:                 		if (cs < fs->n_fatent)
9D000A74  8E23001C   LW V1, 28(S1)
9D000A78  0043182B   SLTU V1, V0, V1
9D000A7C  10600003   BEQ V1, ZERO, 0x9D000A8C
9D000A80  02C09021   ADDU S2, S6, ZERO
962:                 			return cs; /* It is already followed by next cluster */
963:                 		scl = clst;
964:                 	}
965:                 
966:                 	ncl = scl; /* Start cluster */
9D000A8C  02408021   ADDU S0, S2, ZERO
967:                 	for (;;) {
968:                 		ncl++; /* Next cluster */
9D000A9C  26100001   ADDIU S0, S0, 1
969:                 		if (ncl >= fs->n_fatent) { /* Wrap around */
9D000AA0  8E22001C   LW V0, 28(S1)
9D000AA4  0202102B   SLTU V0, S0, V0
9D000AA8  14400004   BNE V0, ZERO, 0x9D000ABC
9D000AAC  02202021   ADDU A0, S1, ZERO
970:                 			ncl = 2;
971:                 			if (ncl > scl)
9D000A90  2E550002   SLTIU S5, S2, 2
9D000AB0  16A0002C   BNE S5, ZERO, 0x9D000B64
9D000AB4  24100002   ADDIU S0, ZERO, 2
972:                 				return 0; /* No free cluster */
9D000B64  0B4002DE   J 0x9D000B78
9D000B68  00001021   ADDU V0, ZERO, ZERO
973:                 		}
974:                 		cs = get_fat(fs, ncl); /* Get the cluster status */
9D000AB8  02202021   ADDU A0, S1, ZERO
9D000ABC  0F40014E   JAL get_fat
9D000AC0  02002821   ADDU A1, S0, ZERO
975:                 		if (cs == 0)
9D000AC4  50400009   BEQL V0, ZERO, 0x9D000AEC
9D000AC8  02009021   ADDU S2, S0, ZERO
976:                 			break; /* Found a free cluster */
977:                 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
9D000A94  2413FFFF   ADDIU S3, ZERO, -1
9D000A98  24140001   ADDIU S4, ZERO, 1
9D000ACC  1053002B   BEQ V0, S3, 0x9D000B7C
9D000AD0  8FBF002C   LW RA, 44(SP)
9D000AD4  5054002A   BEQL V0, S4, 0x9D000B80
9D000AD8  8FB60028   LW S6, 40(SP)
978:                 			return cs;
979:                 		if (ncl == scl)
9D000ADC  1612FFF0   BNE S0, S2, 0x9D000AA0
9D000AE0  26100001   ADDIU S0, S0, 1
9D000AE4  0B4002DB   J 0x9D000B6C
9D000AE8  00001021   ADDU V0, ZERO, ZERO
980:                 			return 0; /* No free cluster */
981:                 	}
982:                 
983:                 	res = put_fat(fs, ncl, 0x0FFFFFFF); /* Mark the new cluster "last link" */
9D000AEC  02202021   ADDU A0, S1, ZERO
9D000AF0  02002821   ADDU A1, S0, ZERO
9D000AF4  3C060FFF   LUI A2, 4095
9D000AF8  0F400217   JAL put_fat
9D000AFC  34C6FFFF   ORI A2, A2, -1
984:                 	if (res == FR_OK && clst != 0) {
9D000B00  14400013   BNE V0, ZERO, 0x9D000B50
9D000B04  38420001   XORI V0, V0, 1
9D000B08  52C00008   BEQL S6, ZERO, 0x9D000B2C
9D000B0C  AE32000C   SW S2, 12(S1)
985:                 		res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
9D000B10  02202021   ADDU A0, S1, ZERO
9D000B14  02C02821   ADDU A1, S6, ZERO
9D000B18  0F400217   JAL put_fat
9D000B1C  02003021   ADDU A2, S0, ZERO
986:                 	}
987:                 	if (res == FR_OK) {
9D000B20  1440000B   BNE V0, ZERO, 0x9D000B50
9D000B24  38420001   XORI V0, V0, 1
988:                 		fs->last_clust = ncl; /* Update FSINFO */
9D000B28  AE32000C   SW S2, 12(S1)
989:                 		if (fs->free_clust != 0xFFFFFFFF) {
9D000B2C  8E220010   LW V0, 16(S1)
9D000B30  2403FFFF   ADDIU V1, ZERO, -1
9D000B34  1043000F   BEQ V0, V1, 0x9D000B74
9D000B38  2442FFFF   ADDIU V0, V0, -1
990:                 			fs->free_clust--;
9D000B3C  AE220010   SW V0, 16(S1)
991:                 			fs->fsi_flag = 1;
9D000B40  24020001   ADDIU V0, ZERO, 1
9D000B44  A2220005   SB V0, 5(S1)
9D000B48  0B4002DE   J 0x9D000B78
9D000B4C  02001021   ADDU V0, S0, ZERO
992:                 		}
993:                 	} else {
994:                 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
9D000B50  2403FFFF   ADDIU V1, ZERO, -1
9D000B54  24040001   ADDIU A0, ZERO, 1
9D000B58  0082180B   MOVN V1, A0, V0
9D000B5C  0B4002DE   J 0x9D000B78
9D000B60  00601021   ADDU V0, V1, ZERO
995:                 	}
996:                 
997:                 	return ncl; /* Return new cluster number or error code */
998:                 }
9D000A84  0B4002DF   J 0x9D000B7C
9D000A88  8FBF002C   LW RA, 44(SP)
9D000B6C  0B4002DF   J 0x9D000B7C
9D000B70  8FBF002C   LW RA, 44(SP)
9D000B74  02001021   ADDU V0, S0, ZERO
9D000B78  8FBF002C   LW RA, 44(SP)
9D000B7C  8FB60028   LW S6, 40(SP)
9D000B80  8FB50024   LW S5, 36(SP)
9D000B84  8FB40020   LW S4, 32(SP)
9D000B88  8FB3001C   LW S3, 28(SP)
9D000B8C  8FB20018   LW S2, 24(SP)
9D000B90  8FB10014   LW S1, 20(SP)
9D000B94  8FB00010   LW S0, 16(SP)
9D000B98  03E00008   JR RA
9D000B9C  27BD0030   ADDIU SP, SP, 48
999:                 #endif /* !_FS_READONLY */
1000:                
1001:                /*-----------------------------------------------------------------------*/
1002:                /* FAT handling - Convert offset into cluster with link map table        */
1003:                /*-----------------------------------------------------------------------*/
1004:                
1005:                #if _USE_FASTSEEK
1006:                static DWORD clmt_clust( /* <2:Error, >=2:Cluster number */
1007:                FIL* fp, /* Pointer to the file object */
1008:                DWORD ofs /* File offset to be converted to cluster# */
1009:                ) {
1010:                	DWORD cl, ncl, *tbl;
1011:                
1012:                	tbl = fp->cltbl + 1; /* Top of CLMT */
9D000024  8C830024   LW V1, 36(A0)
9D000028  24660004   ADDIU A2, V1, 4
1013:                	cl = ofs / SS(fp->fs) / fp->fs->csize; /* Cluster order from top of the file */
9D00002C  00052A42   SRL A1, A1, 9
9D000030  8C820000   LW V0, 0(A0)
9D000034  90420002   LBU V0, 2(V0)
9D000038  00A2001B   DIVU A1, V0
9D00003C  004001F4   TEQ V0, ZERO
9D000040  00002812   MFLO A1
1014:                	for (;;) {
1015:                		ncl = *tbl++; /* Number of cluters in the fragment */
9D000044  8C630004   LW V1, 4(V1)
9D000074  8CC30000   LW V1, 0(A2)
1016:                		if (!ncl)
9D000048  10600011   BEQ V1, ZERO, 0x9D000090
9D00004C  00001012   MFLO V0
9D000078  1460FFFA   BNE V1, ZERO, 0x9D000064
9D00007C  0043202B   SLTU A0, V0, V1
9D000080  03E00008   JR RA
9D000084  00001021   ADDU V0, ZERO, ZERO
1017:                			return 0; /* End of table? (error) */
9D000090  03E00008   JR RA
9D000094  00001021   ADDU V0, ZERO, ZERO
1018:                		if (cl < ncl)
9D000050  00A3282B   SLTU A1, A1, V1
9D000054  50A00006   BEQL A1, ZERO, 0x9D000070
9D000058  00431023   SUBU V0, V0, V1
9D000064  54800008   BNEL A0, ZERO, 0x9D000088
9D000068  8CC30004   LW V1, 4(A2)
1019:                			break; /* In this fragment? */
1020:                		cl -= ncl;
9D00006C  00431023   SUBU V0, V0, V1
9D000070  24C60008   ADDIU A2, A2, 8
1021:                		tbl++; /* Next fragment */
1022:                	}
1023:                	return cl + *tbl; /* Return the cluster number */
9D00005C  0B400022   J 0x9D000088
9D000060  8CC30004   LW V1, 4(A2)
9D000088  03E00008   JR RA
9D00008C  00431021   ADDU V0, V0, V1
9D000090  03E00008   JR RA
9D000094  00001021   ADDU V0, ZERO, ZERO
1024:                }
1025:                #endif	/* _USE_FASTSEEK */
1026:                
1027:                /*-----------------------------------------------------------------------*/
1028:                /* Directory handling - Set directory index                              */
1029:                /*-----------------------------------------------------------------------*/
1030:                
1031:                static FRESULT dir_sdi(DIR *dj, /* Pointer to directory object */
1032:                PF_WORD idx /* Directory index number */
1033:                ) {
9D0006C0  27BDFFD8   ADDIU SP, SP, -40
9D0006C4  AFBF0024   SW RA, 36(SP)
9D0006C8  AFB30020   SW S3, 32(SP)
9D0006CC  AFB2001C   SW S2, 28(SP)
9D0006D0  AFB10018   SW S1, 24(SP)
9D0006D4  AFB00014   SW S0, 20(SP)
9D0006D8  00808021   ADDU S0, A0, ZERO
9D0006DC  00A08821   ADDU S1, A1, ZERO
1034:                	DWORD clst;
1035:                	PF_WORD ic;
1036:                
1037:                	dj->index = idx;
9D0006E0  A6050006   SH A1, 6(S0)
1038:                	clst = dj->sclust;
9D0006E4  8C850008   LW A1, 8(A0)
1039:                	if (clst == 1 || clst >= dj->fs->n_fatent) /* Check start cluster range */
9D0006E8  24030001   ADDIU V1, ZERO, 1
9D0006EC  10A3003E   BEQ A1, V1, 0x9D0007E8
9D0006F0  24020002   ADDIU V0, ZERO, 2
9D0006F4  8C830000   LW V1, 0(A0)
9D0006F8  8C64001C   LW A0, 28(V1)
9D0006FC  00A4202B   SLTU A0, A1, A0
9D000700  5080003A   BEQL A0, ZERO, 0x9D0007EC
9D000704  8FBF0024   LW RA, 36(SP)
1040:                		return FR_INT_ERR;
1041:                	if (!clst && dj->fs->fs_type == FS_FAT32) /* Replace cluster# 0 with root cluster# if in FAT32 */
9D000708  54A00012   BNEL A1, ZERO, 0x9D000754
9D00070C  90720002   LBU S2, 2(V1)
9D000710  90640000   LBU A0, 0(V1)
9D000714  24020003   ADDIU V0, ZERO, 3
9D000718  54820005   BNEL A0, V0, 0x9D000730
9D00071C  AE00000C   SW ZERO, 12(S0)
1042:                		clst = dj->fs->dirbase;
9D000720  8C650028   LW A1, 40(V1)
1043:                
1044:                	if (clst == 0) { /* Static table (root-dir in FAT12/16) */
9D000724  54A0000B   BNEL A1, ZERO, 0x9D000754
9D000728  90720002   LBU S2, 2(V1)
1045:                		dj->clust = clst;
9D00072C  AE00000C   SW ZERO, 12(S0)
1046:                		if (idx >= dj->fs->n_rootdir) /* Index is out of range */
9D000730  94640008   LHU A0, 8(V1)
9D000734  0224202B   SLTU A0, S1, A0
9D000738  1080002B   BEQ A0, ZERO, 0x9D0007E8
9D00073C  24020002   ADDIU V0, ZERO, 2
1047:                			return FR_INT_ERR;
1048:                		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D000740  00111102   SRL V0, S1, 4
9D000744  8C630028   LW V1, 40(V1)
9D000748  00431021   ADDU V0, V0, V1
9D00074C  0B4001EF   J 0x9D0007BC
9D000750  AE020010   SW V0, 16(S0)
1049:                	} else { /* Dynamic table (sub-dirs or root-dir in FAT32) */
1050:                		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize; /* Entries per cluster */
9D000754  00129100   SLL S2, S2, 4
1051:                		while (idx >= ic) { /* Follow cluster chain */
9D000758  0232102B   SLTU V0, S1, S2
9D00075C  14400011   BNE V0, ZERO, 0x9D0007A4
9D000760  2413FFFF   ADDIU S3, ZERO, -1
9D000798  0232102B   SLTU V0, S1, S2
9D00079C  1040FFF1   BEQ V0, ZERO, 0x9D000764
9D0007A0  00000000   NOP
1052:                			clst = get_fat(dj->fs, clst); /* Get next cluster */
9D000764  0F40014E   JAL get_fat
9D000768  8E040000   LW A0, 0(S0)
1053:                			if (clst == 0xFFFFFFFF)
9D00076C  1053001B   BEQ V0, S3, 0x9D0007DC
9D000770  00402821   ADDU A1, V0, ZERO
1054:                				return FR_DISK_ERR; /* Disk error */
9D0007DC  0B4001FA   J 0x9D0007E8
9D0007E0  24020001   ADDIU V0, ZERO, 1
1055:                			if (clst < 2 || clst >= dj->fs->n_fatent) /* Reached to end of table or int error */
9D000774  2C420002   SLTIU V0, V0, 2
9D000778  1440001B   BNE V0, ZERO, 0x9D0007E8
9D00077C  24020002   ADDIU V0, ZERO, 2
9D000780  8E020000   LW V0, 0(S0)
9D000784  8C42001C   LW V0, 28(V0)
9D000788  00A2102B   SLTU V0, A1, V0
9D00078C  10400015   BEQ V0, ZERO, 0x9D0007E4
9D000790  02328823   SUBU S1, S1, S2
1056:                				return FR_INT_ERR;
9D0007E4  24020002   ADDIU V0, ZERO, 2
1057:                			idx -= ic;
9D000794  3231FFFF   ANDI S1, S1, -1
1058:                		}
1059:                		dj->clust = clst;
9D0007A4  AE05000C   SW A1, 12(S0)
1060:                		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D0007A8  0F400142   JAL clust2sect
9D0007AC  8E040000   LW A0, 0(S0)
9D0007B0  00111902   SRL V1, S1, 4
9D0007B4  00621021   ADDU V0, V1, V0
9D0007B8  AE020010   SW V0, 16(S0)
1061:                	}
1062:                
1063:                	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR; /* Ptr to the entry in the sector */
9D0007BC  3231000F   ANDI S1, S1, 15
9D0007C0  00118940   SLL S1, S1, 5
9D0007C4  8E020000   LW V0, 0(S0)
9D0007C8  00511021   ADDU V0, V0, S1
9D0007CC  24420034   ADDIU V0, V0, 52
9D0007D0  AE020014   SW V0, 20(S0)
1064:                
1065:                	return FR_OK; /* Seek succeeded */
9D0007D4  0B4001FA   J 0x9D0007E8
9D0007D8  00001021   ADDU V0, ZERO, ZERO
1066:                }
9D0007E8  8FBF0024   LW RA, 36(SP)
9D0007EC  8FB30020   LW S3, 32(SP)
9D0007F0  8FB2001C   LW S2, 28(SP)
9D0007F4  8FB10018   LW S1, 24(SP)
9D0007F8  8FB00014   LW S0, 20(SP)
9D0007FC  03E00008   JR RA
9D000800  27BD0028   ADDIU SP, SP, 40
1067:                
1068:                /*-----------------------------------------------------------------------*/
1069:                /* Directory handling - Move directory index next                        */
1070:                /*-----------------------------------------------------------------------*/
1071:                
1072:                static FRESULT dir_next( /* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
1073:                DIR *dj, /* Pointer to directory object */
1074:                int stretch /* 0: Do not stretch table, 1: Stretch table if needed */
1075:                ) {
9D000BA0  27BDFFD0   ADDIU SP, SP, -48
9D000BA4  AFBF002C   SW RA, 44(SP)
9D000BA8  AFB50028   SW S5, 40(SP)
9D000BAC  AFB40024   SW S4, 36(SP)
9D000BB0  AFB30020   SW S3, 32(SP)
9D000BB4  AFB2001C   SW S2, 28(SP)
9D000BB8  AFB10018   SW S1, 24(SP)
9D000BBC  AFB00014   SW S0, 20(SP)
9D000BC0  00808021   ADDU S0, A0, ZERO
1076:                	DWORD clst;
1077:                	PF_WORD i;
1078:                
1079:                	stretch = stretch; /* To suppress warning on read-only cfg. */
1080:                	i = dj->index + 1;
9D000BC4  94910006   LHU S1, 6(A0)
9D000BC8  26310001   ADDIU S1, S1, 1
9D000BCC  3231FFFF   ANDI S1, S1, -1
1081:                	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
9D000BD0  12200068   BEQ S1, ZERO, 0x9D000D74
9D000BD4  24030004   ADDIU V1, ZERO, 4
9D000BD8  8C820010   LW V0, 16(A0)
9D000BDC  50400066   BEQL V0, ZERO, 0x9D000D78
9D000BE0  00601021   ADDU V0, V1, ZERO
1082:                		return FR_NO_FILE;
1083:                
1084:                	if (!(i % (SS(dj->fs) / SZ_DIR))) { /* Sector changed? */
9D000BE4  3233000F   ANDI S3, S1, 15
9D000BE8  5660005A   BNEL S3, ZERO, 0x9D000D54
9D000BEC  A6110006   SH S1, 6(S0)
9D000BF0  00A09021   ADDU S2, A1, ZERO
1085:                		dj->sect++; /* Next sector */
9D000BF4  24420001   ADDIU V0, V0, 1
9D000BF8  AC820010   SW V0, 16(A0)
1086:                
1087:                		if (dj->clust == 0) { /* Static table */
9D000BFC  8C85000C   LW A1, 12(A0)
9D000C00  54A00008   BNEL A1, ZERO, 0x9D000C24
9D000C04  8C840000   LW A0, 0(A0)
1088:                			if (i >= dj->fs->n_rootdir) /* Report EOT when end of table */
9D000C08  8C820000   LW V0, 0(A0)
9D000C0C  94420008   LHU V0, 8(V0)
9D000C10  0222102B   SLTU V0, S1, V0
9D000C14  10400058   BEQ V0, ZERO, 0x9D000D78
9D000C18  00601021   ADDU V0, V1, ZERO
9D000C1C  0B400355   J 0x9D000D54
9D000C20  A6110006   SH S1, 6(S0)
1089:                				return FR_NO_FILE;
1090:                		} else { /* Dynamic table */
1091:                			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) { /* Cluster changed? */
9D000C24  90830002   LBU V1, 2(A0)
9D000C28  2463FFFF   ADDIU V1, V1, -1
9D000C2C  00111102   SRL V0, S1, 4
9D000C30  00621024   AND V0, V1, V0
9D000C34  54400047   BNEL V0, ZERO, 0x9D000D54
9D000C38  A6110006   SH S1, 6(S0)
1092:                				clst = get_fat(dj->fs, dj->clust); /* Get next cluster */
9D000C3C  0F40014E   JAL get_fat
9D000C40  00000000   NOP
9D000C44  0040A021   ADDU S4, V0, ZERO
1093:                				if (clst <= 1)
9D000C48  2C420002   SLTIU V0, V0, 2
9D000C4C  14400049   BNE V0, ZERO, 0x9D000D74
9D000C50  24030002   ADDIU V1, ZERO, 2
1094:                					return FR_INT_ERR;
1095:                				if (clst == 0xFFFFFFFF)
9D000C54  2402FFFF   ADDIU V0, ZERO, -1
9D000C58  52820046   BEQL S4, V0, 0x9D000D74
9D000C5C  24030001   ADDIU V1, ZERO, 1
1096:                					return FR_DISK_ERR;
1097:                				if (clst >= dj->fs->n_fatent) { /* When it reached end of dynamic table */
9D000C60  8E040000   LW A0, 0(S0)
9D000C64  8C82001C   LW V0, 28(A0)
9D000C68  0282102B   SLTU V0, S4, V0
9D000C6C  54400034   BNEL V0, ZERO, 0x9D000D40
9D000C70  AE14000C   SW S4, 12(S0)
1098:                #if !_FS_READONLY
1099:                					PF_BYTE c;
1100:                					if (!stretch)
9D000C74  1240003F   BEQ S2, ZERO, 0x9D000D74
9D000C78  24030004   ADDIU V1, ZERO, 4
1101:                						return FR_NO_FILE; /* When do not stretch, report EOT */
1102:                					clst = create_chain(dj->fs, dj->clust); /* Stretch cluster chain */
9D000C7C  0F400284   JAL create_chain
9D000C80  8E05000C   LW A1, 12(S0)
9D000C84  0040A021   ADDU S4, V0, ZERO
1103:                					if (clst == 0)
9D000C88  1040003A   BEQ V0, ZERO, 0x9D000D74
9D000C8C  24030007   ADDIU V1, ZERO, 7
1104:                						return FR_DENIED; /* No free cluster */
1105:                					if (clst == 1)
9D000C90  24020001   ADDIU V0, ZERO, 1
9D000C94  12820037   BEQ S4, V0, 0x9D000D74
9D000C98  24030002   ADDIU V1, ZERO, 2
1106:                						return FR_INT_ERR;
1107:                					if (clst == 0xFFFFFFFF)
9D000C9C  2402FFFF   ADDIU V0, ZERO, -1
9D000CA0  12820034   BEQ S4, V0, 0x9D000D74
9D000CA4  24030001   ADDIU V1, ZERO, 1
1108:                						return FR_DISK_ERR;
1109:                					/* Clean-up stretched table */
1110:                					if (move_window(dj->fs, 0))
9D000CA8  8E040000   LW A0, 0(S0)
9D000CAC  0F40006F   JAL move_window
9D000CB0  00002821   ADDU A1, ZERO, ZERO
9D000CB4  1440002F   BNE V0, ZERO, 0x9D000D74
9D000CB8  24030001   ADDIU V1, ZERO, 1
1111:                						return FR_DISK_ERR; /* Flush active window */
1112:                					mem_set(dj->fs->win, 0, SS(dj->fs)); /* Clear window buffer */
9D000CBC  8E030000   LW V1, 0(S0)
9D000CC0  24620034   ADDIU V0, V1, 52
9D000CC4  24630234   ADDIU V1, V1, 564
1113:                					dj->fs->winsect = clust2sect(dj->fs, clst); /* Cluster start sector */
9D000CD4  8E120000   LW S2, 0(S0)
9D000CD8  02402021   ADDU A0, S2, ZERO
9D000CDC  0F400142   JAL clust2sect
9D000CE0  02802821   ADDU A1, S4, ZERO
9D000CE4  AE420030   SW V0, 48(S2)
1114:                					for (c = 0; c < dj->fs->csize; c++) { /* Fill the new cluster with 0 */
9D000CE8  00009021   ADDU S2, ZERO, ZERO
9D000CEC  0B400347   J 0x9D000D1C
9D000CF0  24150001   ADDIU S5, ZERO, 1
9D000D18  325200FF   ANDI S2, S2, 255
9D000D1C  8E020000   LW V0, 0(S0)
9D000D20  90430002   LBU V1, 2(V0)
9D000D24  0243182B   SLTU V1, S2, V1
9D000D28  5460FFF2   BNEL V1, ZERO, 0x9D000CF4
9D000D2C  A0550004   SB S5, 4(V0)
1115:                						dj->fs->wflag = 1;
1116:                						if (move_window(dj->fs, 0))
9D000CF4  8E040000   LW A0, 0(S0)
9D000CF8  0F40006F   JAL move_window
9D000CFC  00002821   ADDU A1, ZERO, ZERO
9D000D00  1440001B   BNE V0, ZERO, 0x9D000D70
9D000D04  26520001   ADDIU S2, S2, 1
1117:                							return FR_DISK_ERR;
9D000D70  24030001   ADDIU V1, ZERO, 1
1118:                						dj->fs->winsect++;
9D000D08  8E020000   LW V0, 0(S0)
9D000D0C  8C430030   LW V1, 48(V0)
9D000D10  24630001   ADDIU V1, V1, 1
9D000D14  AC430030   SW V1, 48(V0)
1119:                					}
1120:                					dj->fs->winsect -= c; /* Rewind window address */
9D000D30  8C430030   LW V1, 48(V0)
9D000D34  00729023   SUBU S2, V1, S2
9D000D38  AC520030   SW S2, 48(V0)
1121:                #else
1122:                					return FR_NO_FILE; /* Report EOT */
1123:                #endif
1124:                				}
1125:                				dj->clust = clst; /* Initialize data for new cluster */
9D000D3C  AE14000C   SW S4, 12(S0)
1126:                				dj->sect = clust2sect(dj->fs, clst);
9D000D40  8E040000   LW A0, 0(S0)
9D000D44  0F400142   JAL clust2sect
9D000D48  02802821   ADDU A1, S4, ZERO
9D000D4C  AE020010   SW V0, 16(S0)
1127:                			}
1128:                		}
1129:                	}
1130:                
1131:                	dj->index = i;
9D000D50  A6110006   SH S1, 6(S0)
1132:                	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
9D000D54  00139940   SLL S3, S3, 5
9D000D58  8E020000   LW V0, 0(S0)
9D000D5C  00539821   ADDU S3, V0, S3
9D000D60  26730034   ADDIU S3, S3, 52
9D000D64  AE130014   SW S3, 20(S0)
1133:                
1134:                	return FR_OK;
9D000D68  0B40035D   J 0x9D000D74
9D000D6C  00001821   ADDU V1, ZERO, ZERO
1135:                }
9D000D74  00601021   ADDU V0, V1, ZERO
9D000D78  8FBF002C   LW RA, 44(SP)
9D000D7C  8FB50028   LW S5, 40(SP)
9D000D80  8FB40024   LW S4, 36(SP)
9D000D84  8FB30020   LW S3, 32(SP)
9D000D88  8FB2001C   LW S2, 28(SP)
9D000D8C  8FB10018   LW S1, 24(SP)
9D000D90  8FB00014   LW S0, 20(SP)
9D000D94  03E00008   JR RA
9D000D98  27BD0030   ADDIU SP, SP, 48
1136:                
1137:                /*-----------------------------------------------------------------------*/
1138:                /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1139:                /*-----------------------------------------------------------------------*/
1140:                #if _USE_LFN
1141:                static
1142:                const PF_BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30}; /* Offset of LFN chars in the directory entry */
1143:                
1144:                static
1145:                int cmp_lfn ( /* 1:Matched, 0:Not matched */
1146:                		WCHAR *lfnbuf, /* Pointer to the LFN to be compared */
1147:                		PF_BYTE *dir /* Pointer to the directory entry containing a part of LFN */
1148:                )
1149:                {
1150:                	UINT i, s;
1151:                	WCHAR wc, uc;
1152:                
1153:                	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13; /* Get offset in the LFN buffer */
1154:                	s = 0; wc = 1;
1155:                	do {
1156:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1157:                		if (wc) { /* Last char has not been processed */
1158:                			wc = ff_wtoupper(uc); /* Convert it to upper case */
1159:                			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++])) /* Compare it */
1160:                			return 0; /* Not matched */
1161:                		} else {
1162:                			if (uc != 0xFFFF) return 0; /* Check filler */
1163:                		}
1164:                	}while (++s < 13); /* Repeat until all chars in the entry are checked */
1165:                
1166:                	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i]) /* Last segment matched but different length */
1167:                	return 0;
1168:                
1169:                	return 1; /* The part of LFN matched */
1170:                }
1171:                
1172:                static
1173:                int pick_lfn ( /* 1:Succeeded, 0:Buffer overflow */
1174:                		WCHAR *lfnbuf, /* Pointer to the Unicode-LFN buffer */
1175:                		PF_BYTE *dir /* Pointer to the directory entry */
1176:                )
1177:                {
1178:                	UINT i, s;
1179:                	WCHAR wc, uc;
1180:                
1181:                	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13; /* Offset in the LFN buffer */
1182:                
1183:                	s = 0; wc = 1;
1184:                	do {
1185:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1186:                		if (wc) { /* Last char has not been processed */
1187:                			if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1188:                			lfnbuf[i++] = wc = uc; /* Store it */
1189:                		} else {
1190:                			if (uc != 0xFFFF) return 0; /* Check filler */
1191:                		}
1192:                	}while (++s < 13); /* Read all character in the entry */
1193:                
1194:                	if (dir[LDIR_Ord] & LLE) { /* Put terminator if it is the last LFN part */
1195:                		if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1196:                		lfnbuf[i] = 0;
1197:                	}
1198:                
1199:                	return 1;
1200:                }
1201:                
1202:                #if !_FS_READONLY
1203:                static
1204:                void fit_lfn (
1205:                		const WCHAR *lfnbuf, /* Pointer to the LFN buffer */
1206:                		PF_BYTE *dir, /* Pointer to the directory entry */
1207:                		PF_BYTE ord, /* LFN order (1-20) */
1208:                		PF_BYTE sum /* SFN sum */
1209:                )
1210:                {
1211:                	UINT i, s;
1212:                	WCHAR wc;
1213:                
1214:                	dir[LDIR_Chksum] = sum; /* Set check sum */
1215:                	dir[LDIR_Attr] = AM_LFN; /* Set attribute. LFN entry */
1216:                	dir[LDIR_Type] = 0;
1217:                	ST_WORD(dir+LDIR_FstClusLO, 0);
1218:                
1219:                	i = (ord - 1) * 13; /* Get offset in the LFN buffer */
1220:                	s = wc = 0;
1221:                	do {
1222:                		if (wc != 0xFFFF) wc = lfnbuf[i++]; /* Get an effective char */
1223:                		ST_WORD(dir+LfnOfs[s], wc); /* Put it */
1224:                		if (!wc) wc = 0xFFFF; /* Padding chars following last char */
1225:                	}while (++s < 13);
1226:                	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE; /* Bottom LFN part is the start of LFN sequence */
1227:                	dir[LDIR_Ord] = ord; /* Set the LFN order */
1228:                }
1229:                
1230:                #endif
1231:                #endif
1232:                
1233:                /*-----------------------------------------------------------------------*/
1234:                /* Create numbered name                                                  */
1235:                /*-----------------------------------------------------------------------*/
1236:                #if _USE_LFN
1237:                void gen_numname (
1238:                		PF_BYTE *dst, /* Pointer to generated SFN */
1239:                		const PF_BYTE *src, /* Pointer to source SFN to be modified */
1240:                		const WCHAR *lfn, /* Pointer to LFN */
1241:                		PF_WORD seq /* Sequence number */
1242:                )
1243:                {
1244:                	PF_BYTE ns[8], c;
1245:                	UINT i, j;
1246:                
1247:                	mem_cpy(dst, src, 11);
1248:                
1249:                	if (seq > 5) { /* On many collisions, generate a hash number instead of sequential number */
1250:                		do seq = (seq >> 1) + (seq << 15) + (PF_WORD)*lfn++; while (*lfn);
1251:                	}
1252:                
1253:                	/* itoa (hexdecimal) */
1254:                	i = 7;
1255:                	do {
1256:                		c = (seq % 16) + '0';
1257:                		if (c > '9') c += 7;
1258:                		ns[i--] = c;
1259:                		seq /= 16;
1260:                	}while (seq);
1261:                	ns[i] = '~';
1262:                
1263:                	/* Append the number */
1264:                	for (j = 0; j < i && dst[j] != ' '; j++) {
1265:                		if (IsDBCS1(dst[j])) {
1266:                			if (j == i - 1) break;
1267:                			j++;
1268:                		}
1269:                	}
1270:                	do {
1271:                		dst[j++] = (i < 8) ? ns[i++] : ' ';
1272:                	}while (j < 8);
1273:                }
1274:                #endif
1275:                
1276:                /*-----------------------------------------------------------------------*/
1277:                /* Calculate sum of an SFN                                               */
1278:                /*-----------------------------------------------------------------------*/
1279:                #if _USE_LFN
1280:                static
1281:                PF_BYTE sum_sfn (
1282:                		const PF_BYTE *dir /* Ptr to directory entry */
1283:                )
1284:                {
1285:                	PF_BYTE sum = 0;
1286:                	UINT n = 11;
1287:                
1288:                	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
1289:                	return sum;
1290:                }
1291:                #endif
1292:                
1293:                /*-----------------------------------------------------------------------*/
1294:                /* Directory handling - Find an object in the directory                  */
1295:                /*-----------------------------------------------------------------------*/
1296:                
1297:                static FRESULT dir_find(DIR *dj /* Pointer to the directory object linked to the file name */
1298:                ) {
1299:                	FRESULT res;
1300:                	PF_BYTE c, *dir;
1301:                #if _USE_LFN
1302:                	PF_BYTE a, ord, sum;
1303:                #endif
1304:                
1305:                	res = dir_sdi(dj, 0); /* Rewind directory object */
9D0011BC  02202021   ADDU A0, S1, ZERO
9D0011C0  0F4001B0   JAL dir_sdi
9D0011C4  00002821   ADDU A1, ZERO, ZERO
1306:                	if (res != FR_OK)
9D0011C8  5040FFA5   BEQL V0, ZERO, follow_path::dir_find
9D0011CC  8E240000   LW A0, 0(S1)
1307:                		return res;
1308:                
1309:                #if _USE_LFN
1310:                	ord = sum = 0xFF;
1311:                #endif
1312:                	do {
1313:                		res = move_window(dj->fs, dj->sect);
9D001060  0F40006F   JAL move_window
9D001064  8E250010   LW A1, 16(S1)
1314:                		if (res != FR_OK)
9D001068  54400061   BNEL V0, ZERO, 0x9D0011F0
9D00106C  8E230018   LW V1, 24(S1)
1315:                			break;
1316:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D001070  8E280014   LW T0, 20(S1)
1317:                		c = dir[DIR_Name];
1318:                		if (c == 0) {
9D001074  91030000   LBU V1, 0(T0)
9D001078  50600062   BEQL V1, ZERO, 0x9D001204
9D00107C  8E220018   LW V0, 24(S1)
1319:                			res = FR_NO_FILE;
1320:                			break;
1321:                		} /* Reached to end of table */
1322:                #if _USE_LFN	/* LFN configuration */
1323:                		a = dir[DIR_Attr] & AM_MASK;
1324:                		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1325:                			ord = 0xFF;
1326:                		} else {
1327:                			if (a == AM_LFN) { /* An LFN entry is found */
1328:                				if (dj->lfn) {
1329:                					if (c & LLE) { /* Is it start of LFN sequence? */
1330:                						sum = dir[LDIR_Chksum];
1331:                						c &= ~LLE; ord = c; /* LFN start order */
1332:                						dj->lfn_idx = dj->index;
1333:                					}
1334:                					/* Check validity of the LFN entry and compare it with given name */
1335:                					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1336:                				}
1337:                			} else { /* An SFN entry is found */
1338:                				if (!ord && sum == sum_sfn(dir)) break; /* LFN matched? */
1339:                				ord = 0xFF; dj->lfn_idx = 0xFFFF; /* Reset LFN sequence */
1340:                				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break; /* SFN matched? */
1341:                			}
1342:                		}
1343:                #else		/* Non LFN configuration */
1344:                		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
9D001080  9103000B   LBU V1, 11(T0)
9D001084  30630008   ANDI V1, V1, 8
9D001088  306300FF   ANDI V1, V1, 255
9D00108C  1460000D   BNE V1, ZERO, 0x9D0010C4
9D001090  2507000B   ADDIU A3, T0, 11
9D001094  8E290018   LW T1, 24(S1)
1345:                			break;
1346:                #endif
1347:                		res = dir_next(dj, 0); /* Next entry */
9D0010C4  02202021   ADDU A0, S1, ZERO
9D0010C8  0F4002E8   JAL dir_next
9D0010CC  00002821   ADDU A1, ZERO, ZERO
1348:                	} while (res == FR_OK);
9D0010D0  5040FFE3   BEQL V0, ZERO, follow_path::dir_find
9D0010D4  8E240000   LW A0, 0(S1)
1349:                
1350:                	return res;
1351:                }
1352:                
1353:                /*-----------------------------------------------------------------------*/
1354:                /* Read an object from the directory                                     */
1355:                /*-----------------------------------------------------------------------*/
1356:                #if _FS_MINIMIZE <= 1
1357:                static FRESULT dir_read(DIR *dj /* Pointer to the directory object that pointing the entry to be read */
1358:                ) {
9D001308  27BDFFE0   ADDIU SP, SP, -32
9D00130C  AFBF001C   SW RA, 28(SP)
9D001310  AFB10018   SW S1, 24(SP)
9D001314  AFB00014   SW S0, 20(SP)
9D001318  00808021   ADDU S0, A0, ZERO
1359:                	FRESULT res;
1360:                	PF_BYTE c, *dir;
1361:                #if _USE_LFN
1362:                	PF_BYTE a, ord = 0xFF, sum = 0xFF;
1363:                #endif
1364:                
1365:                	res = FR_NO_FILE;
9D00131C  24020004   ADDIU V0, ZERO, 4
1366:                	while (dj->sect) {
9D001320  0B4004DD   J 0x9D001374
9D001324  241100E5   ADDIU S1, ZERO, 229
9D001374  8E050010   LW A1, 16(S0)
9D001378  14A0FFEB   BNE A1, ZERO, 0x9D001328
9D00137C  00000000   NOP
1367:                		res = move_window(dj->fs, dj->sect);
9D001328  0F40006F   JAL move_window
9D00132C  8E040000   LW A0, 0(S0)
1368:                		if (res != FR_OK)
9D001330  54400017   BNEL V0, ZERO, 0x9D001390
9D001334  AE000010   SW ZERO, 16(S0)
1369:                			break;
1370:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D001338  8E040014   LW A0, 20(S0)
1371:                		c = dir[DIR_Name];
9D00133C  90830000   LBU V1, 0(A0)
1372:                		if (c == 0) {
9D001340  50600011   BEQL V1, ZERO, 0x9D001388
9D001344  24020004   ADDIU V0, ZERO, 4
1373:                			res = FR_NO_FILE;
1374:                			break;
1375:                		} /* Reached to end of table */
1376:                #if _USE_LFN	/* LFN configuration */
1377:                		a = dir[DIR_Attr] & AM_MASK;
1378:                		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1379:                			ord = 0xFF;
1380:                		} else {
1381:                			if (a == AM_LFN) { /* An LFN entry is found */
1382:                				if (c & LLE) { /* Is it start of LFN sequence? */
1383:                					sum = dir[LDIR_Chksum];
1384:                					c &= ~LLE; ord = c;
1385:                					dj->lfn_idx = dj->index;
1386:                				}
1387:                				/* Check LFN validity and capture it */
1388:                				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1389:                			} else { /* An SFN entry is found */
1390:                				if (ord || sum != sum_sfn(dir)) /* Is there a valid LFN? */
1391:                				dj->lfn_idx = 0xFFFF; /* It has no LFN. */
1392:                				break;
1393:                			}
1394:                		}
1395:                #else		/* Non LFN configuration */
1396:                		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL)) /* Is it a valid entry? */
9D001348  50710006   BEQL V1, S1, 0x9D001364
9D00134C  02002021   ADDU A0, S0, ZERO
9D001350  9083000B   LBU V1, 11(A0)
9D001354  30630008   ANDI V1, V1, 8
9D001358  306300FF   ANDI V1, V1, 255
9D00135C  1060000C   BEQ V1, ZERO, 0x9D001390
9D001360  02002021   ADDU A0, S0, ZERO
1397:                			break;
1398:                #endif
1399:                		res = dir_next(dj, 0); /* Next entry */
9D001364  0F4002E8   JAL dir_next
9D001368  00002821   ADDU A1, ZERO, ZERO
1400:                		if (res != FR_OK)
9D00136C  54400008   BNEL V0, ZERO, 0x9D001390
9D001370  AE000010   SW ZERO, 16(S0)
1401:                			break;
1402:                	}
1403:                
1404:                	if (res != FR_OK)
9D001380  10400004   BEQ V0, ZERO, 0x9D001394
9D001384  8FBF001C   LW RA, 28(SP)
1405:                		dj->sect = 0;
9D001388  0B4004E4   J 0x9D001390
9D00138C  AE000010   SW ZERO, 16(S0)
1406:                
1407:                	return res;
1408:                }
9D001390  8FBF001C   LW RA, 28(SP)
9D001394  8FB10018   LW S1, 24(SP)
9D001398  8FB00014   LW S0, 20(SP)
9D00139C  03E00008   JR RA
9D0013A0  27BD0020   ADDIU SP, SP, 32
1409:                #endif
1410:                
1411:                /*-----------------------------------------------------------------------*/
1412:                /* Register an object to the directory                                   */
1413:                /*-----------------------------------------------------------------------*/
1414:                #if !_FS_READONLY
1415:                static FRESULT dir_register( /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
1416:                DIR *dj /* Target directory with object name to be created */
1417:                ) {
9D001234  27BDFFE0   ADDIU SP, SP, -32
9D001238  AFBF001C   SW RA, 28(SP)
9D00123C  AFB20018   SW S2, 24(SP)
9D001240  AFB10014   SW S1, 20(SP)
9D001244  AFB00010   SW S0, 16(SP)
9D001248  00808821   ADDU S1, A0, ZERO
1418:                	FRESULT res;
1419:                	PF_BYTE c, *dir;
1420:                #if _USE_LFN	/* LFN configuration */
1421:                	PF_WORD n, ne, is;
1422:                	PF_BYTE sn[12], *fn, sum;
1423:                	WCHAR *lfn;
1424:                
1425:                	fn = dj->fn; lfn = dj->lfn;
1426:                	mem_cpy(sn, fn, 12);
1427:                
1428:                	if (_FS_RPATH && (sn[NS] & NS_DOT)) /* Cannot create dot entry */
1429:                	return FR_INVALID_NAME;
1430:                
1431:                	if (sn[NS] & NS_LOSS) { /* When LFN is out of 8.3 format, generate a numbered name */
1432:                		fn[NS] = 0; dj->lfn = 0; /* Find only SFN */
1433:                		for (n = 1; n < 100; n++) {
1434:                			gen_numname(fn, sn, lfn, n); /* Generate a numbered name */
1435:                			res = dir_find(dj); /* Check if the name collides with existing SFN */
1436:                			if (res != FR_OK) break;
1437:                		}
1438:                		if (n == 100) return FR_DENIED; /* Abort if too many collisions */
1439:                		if (res != FR_NO_FILE) return res; /* Abort if the result is other than 'not collided' */
1440:                		fn[NS] = sn[NS]; dj->lfn = lfn;
1441:                	}
1442:                
1443:                	if (sn[NS] & NS_LFN) { /* When LFN is to be created, reserve an SFN + LFN entries. */
1444:                		for (ne = 0; lfn[ne]; ne++);
1445:                		ne = (ne + 25) / 13;
1446:                	} else { /* Otherwise reserve only an SFN entry. */
1447:                		ne = 1;
1448:                	}
1449:                
1450:                	/* Reserve contiguous entries */
1451:                	res = dir_sdi(dj, 0);
1452:                	if (res != FR_OK) return res;
1453:                	n = is = 0;
1454:                	do {
1455:                		res = move_window(dj->fs, dj->sect);
1456:                		if (res != FR_OK) break;
1457:                		c = *dj->dir; /* Check the entry status */
1458:                		if (c == DDE || c == 0) { /* Is it a blank entry? */
1459:                			if (n == 0) is = dj->index; /* First index of the contiguous entry */
1460:                			if (++n == ne) break; /* A contiguous entry that required count is found */
1461:                		} else {
1462:                			n = 0; /* Not a blank entry. Restart to search */
1463:                		}
1464:                		res = dir_next(dj, 1); /* Next entry with table stretch */
1465:                	}while (res == FR_OK);
1466:                
1467:                	if (res == FR_OK && ne > 1) { /* Initialize LFN entry if needed */
1468:                		res = dir_sdi(dj, is);
1469:                		if (res == FR_OK) {
1470:                			sum = sum_sfn(dj->fn); /* Sum of the SFN tied to the LFN */
1471:                			ne--;
1472:                			do { /* Store LFN entries in bottom first */
1473:                				res = move_window(dj->fs, dj->sect);
1474:                				if (res != FR_OK) break;
1475:                				fit_lfn(dj->lfn, dj->dir, (PF_BYTE)ne, sum);
1476:                				dj->fs->wflag = 1;
1477:                				res = dir_next(dj, 0); /* Next entry */
1478:                			}while (res == FR_OK && --ne);
1479:                		}
1480:                	}
1481:                
1482:                #else	/* Non LFN configuration */
1483:                	res = dir_sdi(dj, 0);
9D00124C  0F4001B0   JAL dir_sdi
9D001250  00002821   ADDU A1, ZERO, ZERO
1484:                	if (res == FR_OK) {
9D001254  14400025   BNE V0, ZERO, 0x9D0012EC
9D001258  00408021   ADDU S0, V0, ZERO
1485:                		do { /* Find a blank entry for the SFN */
1486:                			res = move_window(dj->fs, dj->sect);
9D001260  8E240000   LW A0, 0(S1)
9D001264  0F40006F   JAL move_window
9D001268  8E250010   LW A1, 16(S1)
1487:                			if (res != FR_OK)
9D00126C  1440001F   BNE V0, ZERO, 0x9D0012EC
9D001270  00408021   ADDU S0, V0, ZERO
1488:                				break;
1489:                			c = *dj->dir;
9D001274  8E220014   LW V0, 20(S1)
9D001278  90420000   LBU V0, 0(V0)
1490:                			if (c == DDE || c == 0)
9D00125C  241200E5   ADDIU S2, ZERO, 229
9D00127C  50520017   BEQL V0, S2, 0x9D0012DC
9D001280  8E240000   LW A0, 0(S1)
9D001284  10400014   BEQ V0, ZERO, 0x9D0012D8
9D001288  02202021   ADDU A0, S1, ZERO
1491:                				break; /* Is it a blank entry? */
1492:                			res = dir_next(dj, 1); /* Next entry with table stretch */
9D00128C  0F4002E8   JAL dir_next
9D001290  24050001   ADDIU A1, ZERO, 1
1493:                		} while (res == FR_OK);
9D001294  1040FFF2   BEQ V0, ZERO, 0x9D001260
9D001298  00408021   ADDU S0, V0, ZERO
9D00129C  0B4004BC   J 0x9D0012F0
9D0012A0  02001021   ADDU V0, S0, ZERO
1494:                	}
1495:                #endif
1496:                
1497:                	if (res == FR_OK) { /* Initialize the SFN entry */
1498:                		res = move_window(dj->fs, dj->sect);
9D0012D8  8E240000   LW A0, 0(S1)
9D0012DC  0F40006F   JAL move_window
9D0012E0  8E250010   LW A1, 16(S1)
1499:                		if (res == FR_OK) {
9D0012E4  1040FFEF   BEQ V0, ZERO, 0x9D0012A4
9D0012E8  00408021   ADDU S0, V0, ZERO
1500:                			dir = dj->dir;
9D0012A4  8E240014   LW A0, 20(S1)
9D0012A8  24830020   ADDIU V1, A0, 32
1501:                			mem_set(dir, 0, SZ_DIR); /* Clean the entry */
1502:                			mem_cpy(dir, dj->fn, 11); /* Put SFN */
9D0012BC  8E250018   LW A1, 24(S1)
9D0012C0  0F400000   JAL mem_cpy
9D0012C4  2406000B   ADDIU A2, ZERO, 11
1503:                #if _USE_LFN
1504:                			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT); /* Put NT flag */
1505:                #endif
1506:                			dj->fs->wflag = 1;
9D0012C8  8E220000   LW V0, 0(S1)
9D0012CC  24030001   ADDIU V1, ZERO, 1
9D0012D0  0B4004BB   J 0x9D0012EC
9D0012D4  A0430004   SB V1, 4(V0)
1507:                		}
1508:                	}
1509:                
1510:                	return res;
1511:                }
9D0012EC  02001021   ADDU V0, S0, ZERO
9D0012F0  8FBF001C   LW RA, 28(SP)
9D0012F4  8FB20018   LW S2, 24(SP)
9D0012F8  8FB10014   LW S1, 20(SP)
9D0012FC  8FB00010   LW S0, 16(SP)
9D001300  03E00008   JR RA
9D001304  27BD0020   ADDIU SP, SP, 32
1512:                #endif /* !_FS_READONLY */
1513:                
1514:                /*-----------------------------------------------------------------------*/
1515:                /* Remove an object from the directory                                   */
1516:                /*-----------------------------------------------------------------------*/
1517:                #if !_FS_READONLY && !_FS_MINIMIZE
1518:                static FRESULT dir_remove( /* FR_OK: Successful, FR_DISK_ERR: A disk error */
1519:                DIR *dj /* Directory object pointing the entry to be removed */
1520:                ) {
9D000804  27BDFFE8   ADDIU SP, SP, -24
9D000808  AFBF0014   SW RA, 20(SP)
9D00080C  AFB00010   SW S0, 16(SP)
9D000810  00808021   ADDU S0, A0, ZERO
1521:                	FRESULT res;
1522:                #if _USE_LFN	/* LFN configuration */
1523:                	PF_WORD i;
1524:                
1525:                	i = dj->index; /* SFN index */
1526:                	res = dir_sdi(dj, (PF_WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx)); /* Goto the SFN or top of the LFN entries */
1527:                	if (res == FR_OK) {
1528:                		do {
1529:                			res = move_window(dj->fs, dj->sect);
1530:                			if (res != FR_OK) break;
1531:                			*dj->dir = DDE; /* Mark the entry "deleted" */
1532:                			dj->fs->wflag = 1;
1533:                			if (dj->index >= i) break; /* When reached SFN, all entries of the object has been deleted. */
1534:                			res = dir_next(dj, 0); /* Next entry */
1535:                		}while (res == FR_OK);
1536:                		if (res == FR_NO_FILE) res = FR_INT_ERR;
1537:                	}
1538:                
1539:                #else			/* Non LFN configuration */
1540:                	res = dir_sdi(dj, dj->index);
9D000814  0F4001B0   JAL dir_sdi
9D000818  94850006   LHU A1, 6(A0)
1541:                	if (res == FR_OK) {
9D00081C  1440000C   BNE V0, ZERO, 0x9D000850
9D000820  8FBF0014   LW RA, 20(SP)
1542:                		res = move_window(dj->fs, dj->sect);
9D000824  8E040000   LW A0, 0(S0)
9D000828  0F40006F   JAL move_window
9D00082C  8E050010   LW A1, 16(S0)
1543:                		if (res == FR_OK) {
9D000830  14400006   BNE V0, ZERO, 0x9D00084C
9D000834  2404FFE5   ADDIU A0, ZERO, -27
1544:                			*dj->dir = DDE; /* Mark the entry "deleted" */
9D000838  8E030014   LW V1, 20(S0)
9D00083C  A0640000   SB A0, 0(V1)
1545:                			dj->fs->wflag = 1;
9D000840  8E030000   LW V1, 0(S0)
9D000844  24040001   ADDIU A0, ZERO, 1
9D000848  A0640004   SB A0, 4(V1)
1546:                		}
1547:                	}
1548:                #endif
1549:                
1550:                	return res;
1551:                }
9D00084C  8FBF0014   LW RA, 20(SP)
9D000850  8FB00010   LW S0, 16(SP)
9D000854  03E00008   JR RA
9D000858  27BD0018   ADDIU SP, SP, 24
1552:                #endif /* !_FS_READONLY */
1553:                
1554:                /*-----------------------------------------------------------------------*/
1555:                /* Pick a segment and create the object name in directory form           */
1556:                /*-----------------------------------------------------------------------*/
1557:                
1558:                static FRESULT create_name(DIR *dj, /* Pointer to the directory object */
1559:                const TCHAR **path /* Pointer to pointer to the segment in the path string */
1560:                ) {
1561:                #ifdef _EXCVT
1562:                	static const PF_BYTE excvt[] = _EXCVT; /* Upper conversion table for extended chars */
1563:                #endif
1564:                
1565:                #if _USE_LFN	/* LFN configuration */
1566:                	PF_BYTE b, cf;
1567:                	WCHAR w, *lfn;
1568:                	UINT i, ni, si, di;
1569:                	const TCHAR *p;
1570:                
1571:                	/* Create LFN in Unicode */
1572:                	for (p = *path; *p == '/' || *p == '\\'; p++); /* Strip duplicated separator */
1573:                	lfn = dj->lfn;
1574:                	si = di = 0;
1575:                	for (;;) {
1576:                		w = p[si++]; /* Get a character */
1577:                		if (w < ' ' || w == '/' || w == '\\') break; /* Break on end of segment */
1578:                		if (di >= _MAX_LFN) /* Reject too long name */
1579:                		return FR_INVALID_NAME;
1580:                #if !_LFN_UNICODE
1581:                		w &= 0xFF;
1582:                		if (IsDBCS1(w)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1583:                			b = (PF_BYTE)p[si++]; /* Get 2nd byte */
1584:                			if (!IsDBCS2(b))
1585:                			return FR_INVALID_NAME; /* Reject invalid sequence */
1586:                			w = (w << 8) + b; /* Create a DBC */
1587:                		}
1588:                		w = ff_convert(w, 1); /* Convert ANSI/OEM to Unicode */
1589:                		if (!w) return FR_INVALID_NAME; /* Reject invalid code */
1590:                #endif
1591:                		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
1592:                		return FR_INVALID_NAME;
1593:                		lfn[di++] = w; /* Store the Unicode char */
1594:                	}
1595:                	*path = &p[si]; /* Return pointer to the next segment */
1596:                	cf = (w < ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
1597:                #if _FS_RPATH
1598:                	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
1599:                			(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
1600:                		lfn[di] = 0;
1601:                		for (i = 0; i < 11; i++)
1602:                		dj->fn[i] = (i < di) ? '.' : ' ';
1603:                		dj->fn[i] = cf | NS_DOT; /* This is a dot entry */
1604:                		return FR_OK;
1605:                	}
1606:                #endif
1607:                	while (di) { /* Strip trailing spaces and dots */
1608:                		w = lfn[di-1];
1609:                		if (w != ' ' && w != '.') break;
1610:                		di--;
1611:                	}
1612:                	if (!di) return FR_INVALID_NAME; /* Reject nul string */
1613:                
1614:                	lfn[di] = 0; /* LFN is created */
1615:                
1616:                	/* Create SFN in directory form */
1617:                	mem_set(dj->fn, ' ', 11);
1618:                	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++); /* Strip leading spaces and dots */
1619:                	if (si) cf |= NS_LOSS | NS_LFN;
1620:                	while (di && lfn[di - 1] != '.') di--; /* Find extension (di<=si: no extension) */
1621:                
1622:                	b = i = 0; ni = 8;
1623:                	for (;;) {
1624:                		w = lfn[si++]; /* Get an LFN char */
1625:                		if (!w) break; /* Break on end of the LFN */
1626:                		if (w == ' ' || (w == '.' && si != di)) { /* Remove spaces and dots */
1627:                			cf |= NS_LOSS | NS_LFN; continue;
1628:                		}
1629:                
1630:                		if (i >= ni || si == di) { /* Extension or end of SFN */
1631:                			if (ni == 11) { /* Long extension */
1632:                				cf |= NS_LOSS | NS_LFN; break;
1633:                			}
1634:                			if (si != di) cf |= NS_LOSS | NS_LFN; /* Out of 8.3 format */
1635:                			if (si > di) break; /* No extension */
1636:                			si = di; i = 8; ni = 11; /* Enter extension section */
1637:                			b <<= 2; continue;
1638:                		}
1639:                
1640:                		if (w >= 0x80) { /* Non ASCII char */
1641:                #ifdef _EXCVT
1642:                			w = ff_convert(w, 0); /* Unicode -> OEM code */
1643:                			if (w) w = excvt[w - 0x80]; /* Convert extended char to upper (SBCS) */
1644:                #else
1645:                			w = ff_convert(ff_wtoupper(w), 0); /* Upper converted Unicode -> OEM code */
1646:                #endif
1647:                			cf |= NS_LFN; /* Force create LFN entry */
1648:                		}
1649:                
1650:                		if (_DF1S && w >= 0x100) { /* Double byte char (always false on SBCS cfg) */
1651:                			if (i >= ni - 1) {
1652:                				cf |= NS_LOSS | NS_LFN; i = ni; continue;
1653:                			}
1654:                			dj->fn[i++] = (PF_BYTE)(w >> 8);
1655:                		} else { /* Single byte char */
1656:                			if (!w || chk_chr("+,;=[]", w)) { /* Replace illegal chars for SFN */
1657:                				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
1658:                			} else {
1659:                				if (IsUpper(w)) { /* ASCII large capital */
1660:                					b |= 2;
1661:                				} else {
1662:                					if (IsLower(w)) { /* ASCII small capital */
1663:                						b |= 1; w -= 0x20;
1664:                					}
1665:                				}
1666:                			}
1667:                		}
1668:                		dj->fn[i++] = (PF_BYTE)w;
1669:                	}
1670:                
1671:                	if (dj->fn[0] == DDE) dj->fn[0] = NDDE; /* If the first char collides with deleted mark, replace it with 0x05 */
1672:                
1673:                	if (ni == 8) b <<= 2;
1674:                	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) /* Create LFN entry when there are composite capitals */
1675:                	cf |= NS_LFN;
1676:                	if (!(cf & NS_LFN)) { /* When LFN is in 8.3 format without extended char, NT flags are created */
1677:                		if ((b & 0x03) == 0x01) cf |= NS_EXT; /* NT flag (Extension has only small capital) */
1678:                		if ((b & 0x0C) == 0x04) cf |= NS_BODY; /* NT flag (Filename has only small capital) */
1679:                	}
1680:                
1681:                	dj->fn[NS] = cf; /* SFN is created */
1682:                
1683:                	return FR_OK;
1684:                
1685:                #else	/* Non-LFN configuration */
1686:                	PF_BYTE b, c, d, *sfn;
1687:                	UINT ni, si, i;
1688:                	const char *p;
1689:                
1690:                	/* Create file name in directory form */
1691:                	for (p = *path; *p == '/' || *p == '\\'; p++)
9D000E04  2413005C   ADDIU S3, ZERO, 92
9D000E2C  82020000   LB V0, 0(S0)
9D000E30  5052FFFE   BEQL V0, S2, follow_path::create_name
9D000E34  26100001   ADDIU S0, S0, 1
9D000E38  5053FFFC   BEQL V0, S3, follow_path::create_name
9D000E3C  26100001   ADDIU S0, S0, 1
1692:                		; /* Strip duplicated separator */
1693:                	sfn = dj->fn;
9D000E40  8E240018   LW A0, 24(S1)
9D000E44  2483000B   ADDIU V1, A0, 11
1694:                	mem_set(sfn, ' ', 11);
1695:                	si = i = b = 0;
1696:                	ni = 8;
1697:                #if _FS_RPATH
1698:                	if (p[si] == '.') { /* Is this a dot entry? */
9D000E0C  2415002E   ADDIU S5, ZERO, 46
9D000E10  0B40038B   J follow_path::create_name
9D000E14  3C169D02   LUI S6, -25342
9D000E58  82020000   LB V0, 0(S0)
9D000E5C  10550007   BEQ V0, S5, follow_path::create_name
9D000E60  00002821   ADDU A1, ZERO, ZERO
9D000E64  00001821   ADDU V1, ZERO, ZERO
9D000E68  24090008   ADDIU T1, ZERO, 8
9D000E6C  00003821   ADDU A3, ZERO, ZERO
1699:                		for (;;) {
1700:                			c = (PF_BYTE)p[si++];
9D000E84  92020001   LBU V0, 1(S0)
9D000E98  92020002   LBU V0, 2(S0)
1701:                			if (c != '.' || si >= 3) break;
9D000E88  14550007   BNE V0, S5, 0x9D000EA8
9D000E8C  24030002   ADDIU V1, ZERO, 2
9D000E9C  505500DB   BEQL V0, S5, 0x9D00120C
9D000EA0  24020006   ADDIU V0, ZERO, 6
9D000EA4  24030003   ADDIU V1, ZERO, 3
1702:                			sfn[i++] = c;
9D000E7C  2402002E   ADDIU V0, ZERO, 46
9D000E80  A0820000   SB V0, 0(A0)
9D000E90  2402002E   ADDIU V0, ZERO, 46
9D000E94  A0820001   SB V0, 1(A0)
1703:                		}
1704:                		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
9D000EA8  505200AD   BEQL V0, S2, 0x9D001160
9D000EAC  02038021   ADDU S0, S0, V1
9D000EB0  505300AB   BEQL V0, S3, 0x9D001160
9D000EB4  02038021   ADDU S0, S0, V1
9D000EB8  2C420021   SLTIU V0, V0, 33
9D000EBC  504000D3   BEQL V0, ZERO, 0x9D00120C
9D000EC0  24020006   ADDIU V0, ZERO, 6
1705:                		*path = &p[si]; /* Return pointer to the next segment */
9D000EC4  0B40045A   J 0x9D001168
9D000EC8  02038021   ADDU S0, S0, V1
1706:                		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
9D000ECC  0B40046F   J follow_path::dir_find
9D000ED0  A082000B   SB V0, 11(A0)
9D001160  0B4003B3   J 0x9D000ECC
9D001164  24020020   ADDIU V0, ZERO, 32
9D001168  0B4003B3   J 0x9D000ECC
9D00116C  24020024   ADDIU V0, ZERO, 36
1707:                		return FR_OK;
1708:                	}
1709:                #endif
1710:                	for (;;) {
1711:                		c = (PF_BYTE) p[si++];
9D000ED4  02031021   ADDU V0, S0, V1
9D000ED8  80460000   LB A2, 0(V0)
9D000EDC  30C200FF   ANDI V0, A2, 255
9D000F18  01401821   ADDU V1, T2, ZERO
9D000FFC  0B4003B5   J follow_path::create_name
9D001000  01401821   ADDU V1, T2, ZERO
1712:                		if (c <= ' ' || c == '/' || c == '\\')
9D000EE0  2C480021   SLTIU T0, V0, 33
9D000EE4  150000AF   BNE T0, ZERO, follow_path::create_name
9D000EE8  246A0001   ADDIU T2, V1, 1
9D000EEC  505200AA   BEQL V0, S2, follow_path::create_name
9D000EF0  020A8021   ADDU S0, S0, T2
9D000EF4  505300A8   BEQL V0, S3, follow_path::create_name
9D000EF8  020A8021   ADDU S0, S0, T2
1713:                			break; /* Break on end of segment */
1714:                		if (c == '.' || i >= ni) {
9D000EFC  1055009C   BEQ V0, S5, follow_path::create_name
9D000F00  00A9402B   SLTU T0, A1, T1
9D000F04  510000C1   BEQL T0, ZERO, 0x9D00120C
9D000F08  24020006   ADDIU V0, ZERO, 6
1715:                			if (ni != 8 || c != '.')
9D000E70  240B0008   ADDIU T3, ZERO, 8
9D001170  512BFF68   BEQL T1, T3, follow_path::create_name
9D001174  00073880   SLL A3, A3, 2
9D001178  0B400483   J 0x9D00120C
9D00117C  24020006   ADDIU V0, ZERO, 6
1716:                				return FR_INVALID_NAME;
1717:                			i = 8;
9D000F1C  01602821   ADDU A1, T3, ZERO
1718:                			ni = 11;
9D000F20  0B4003B5   J follow_path::create_name
9D000F24  2409000B   ADDIU T1, ZERO, 11
1719:                			b <<= 2;
9D000F14  30E700FF   ANDI A3, A3, 255
1720:                			continue;
1721:                		}
1722:                		if (c >= 0x80) { /* Extended char? */
1723:                			b |= 3; /* Eliminate NT flag */
9D000F0C  0B4003CA   J follow_path::create_name
9D000F10  34E80003   ORI T0, A3, 3
9D000F28  28C60000   SLTI A2, A2, 0
9D000F2C  0106380B   MOVN A3, T0, A2
1724:                #ifdef _EXCVT
1725:                			c = excvt[c-0x80]; /* Upper conversion (SBCS) */
1726:                #else
1727:                #if !_DF1S	/* ASCII only cfg */
1728:                			return FR_INVALID_NAME;
1729:                #endif
1730:                #endif
1731:                		}
1732:                		if (IsDBCS1(c)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
9D000F30  2446007F   ADDIU A2, V0, 127
9D000F34  30C600FF   ANDI A2, A2, 255
9D000F38  2CC6001F   SLTIU A2, A2, 31
9D000F3C  54C00007   BNEL A2, ZERO, 0x9D000F5C
9D000F40  020A5021   ADDU T2, S0, T2
9D000F44  24460020   ADDIU A2, V0, 32
9D000F48  30C600FF   ANDI A2, A2, 255
9D000F4C  2CC6001D   SLTIU A2, A2, 29
9D000F50  10C00016   BEQ A2, ZERO, follow_path::create_name
9D000F54  00000000   NOP
1733:                			d = (PF_BYTE) p[si++]; /* Get 2nd byte */
9D000F58  020A5021   ADDU T2, S0, T2
9D000F5C  91460000   LBU A2, 0(T2)
1734:                			if (!IsDBCS2(d) || i >= ni - 1) /* Reject invalid DBC */
9D000F60  24C8FFC0   ADDIU T0, A2, -64
9D000F64  310800FF   ANDI T0, T0, 255
9D000F68  2D08003F   SLTIU T0, T0, 63
9D000F6C  15000005   BNE T0, ZERO, 0x9D000F84
9D000F70  24630002   ADDIU V1, V1, 2
9D000F74  38C80080   XORI T0, A2, 128
9D000F78  2D08007D   SLTIU T0, T0, 125
9D000F7C  510000A3   BEQL T0, ZERO, 0x9D00120C
9D000F80  24020006   ADDIU V0, ZERO, 6
9D000F84  2528FFFF   ADDIU T0, T1, -1
9D000F88  00A8402B   SLTU T0, A1, T0
9D000F8C  11000089   BEQ T0, ZERO, 0x9D0011B4
9D000F90  24A80001   ADDIU T0, A1, 1
1735:                				return FR_INVALID_NAME;
1736:                			sfn[i++] = c;
9D000F94  00855021   ADDU T2, A0, A1
9D000F98  A1420000   SB V0, 0(T2)
1737:                			sfn[i++] = d;
9D000F9C  00881021   ADDU V0, A0, T0
9D000FA0  24A50002   ADDIU A1, A1, 2
9D000FA4  0B4003B5   J follow_path::create_name
9D000FA8  A0460000   SB A2, 0(V0)
1738:                		} else { /* Single byte code */
1739:                			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) /* Reject illegal chrs for SFN */
1740:                				return FR_INVALID_NAME;
1741:                			if (IsUpper(c)) { /* ASCII large capital? */
9D001180  306300FF   ANDI V1, V1, 255
9D001184  2C63001A   SLTIU V1, V1, 26
9D001188  5460FF99   BNEL V1, ZERO, 0x9D000FF0
9D00118C  34E70002   ORI A3, A3, 2
1742:                				b |= 2;
1743:                			} else {
1744:                				if (IsLower(c)) { /* ASCII small capital? */
9D000FD4  306300FF   ANDI V1, V1, 255
9D000FD8  2C63001A   SLTIU V1, V1, 26
9D000FDC  50600005   BEQL V1, ZERO, 0x9D000FF4
9D000FE0  00851821   ADDU V1, A0, A1
9D001190  0B4003F5   J follow_path::create_name
9D001194  2443FF9F   ADDIU V1, V0, -97
1745:                					b |= 1;
9D000FE4  34E70001   ORI A3, A3, 1
1746:                					c -= 0x20;
9D000FE8  2442FFE0   ADDIU V0, V0, -32
9D000FEC  304200FF   ANDI V0, V0, 255
1747:                				}
1748:                			}
1749:                			sfn[i++] = c;
9D000FF0  00851821   ADDU V1, A0, A1
9D000FF4  A0620000   SB V0, 0(V1)
9D000FF8  24A50001   ADDIU A1, A1, 1
1750:                		}
1751:                	}
1752:                	*path = &p[si]; /* Return pointer to the next segment */
9D001198  00E01821   ADDU V1, A3, ZERO
9D0011A4  020A8021   ADDU S0, S0, T2
9D0011A8  00E01821   ADDU V1, A3, ZERO
1753:                	c = (c <= ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
9D00119C  0B400401   J follow_path::create_name
9D0011A0  00001021   ADDU V0, ZERO, ZERO
9D0011AC  0B400401   J follow_path::create_name
9D0011B0  24020004   ADDIU V0, ZERO, 4
1754:                
1755:                	if (!i)
9D001004  50A00081   BEQL A1, ZERO, 0x9D00120C
9D001008  24020006   ADDIU V0, ZERO, 6
1756:                		return FR_INVALID_NAME; /* Reject nul string */
1757:                	if (sfn[0] == DDE)
9D00100C  90860000   LBU A2, 0(A0)
9D001010  240500E5   ADDIU A1, ZERO, 229
9D001014  14C50004   BNE A2, A1, 0x9D001028
9D001018  24050008   ADDIU A1, ZERO, 8
1758:                		sfn[0] = NDDE; /* When first char collides with DDE, replace it with 0x05 */
9D00101C  24050005   ADDIU A1, ZERO, 5
9D001020  A0850000   SB A1, 0(A0)
1759:                
1760:                	if (ni == 8)
9D001024  24050008   ADDIU A1, ZERO, 8
9D001028  55250004   BNEL T1, A1, 0x9D00103C
9D00102C  30E50003   ANDI A1, A3, 3
1761:                		b <<= 2;
9D001030  00031880   SLL V1, V1, 2
9D001034  306700FF   ANDI A3, V1, 255
1762:                	if ((b & 0x03) == 0x01)
9D001038  30E50003   ANDI A1, A3, 3
1763:                		c |= NS_EXT; /* NT flag (Name extension has only small capital) */
9D00103C  34430010   ORI V1, V0, 16
9D001040  38A50001   XORI A1, A1, 1
9D001044  0065100A   MOVZ V0, V1, A1
1764:                	if ((b & 0x0C) == 0x04)
9D001048  30E5000C   ANDI A1, A3, 12
1765:                		c |= NS_BODY; /* NT flag (Name body has only small capital) */
9D00104C  34430008   ORI V1, V0, 8
9D001050  38A50004   XORI A1, A1, 4
9D001054  0065100A   MOVZ V0, V1, A1
1766:                
1767:                	sfn[NS] = c; /* Store NT flag, File name is created */
9D001058  0B40046F   J follow_path::dir_find
9D00105C  A082000B   SB V0, 11(A0)
1768:                
1769:                	return FR_OK;
1770:                #endif
1771:                }
1772:                
1773:                /*-----------------------------------------------------------------------*/
1774:                /* Get file information from directory entry                             */
1775:                /*-----------------------------------------------------------------------*/
1776:                #if _FS_MINIMIZE <= 1
1777:                static
1778:                void get_fileinfo( /* No return code */
1779:                DIR *dj, /* Pointer to the directory object */
1780:                FILINFO *fno /* Pointer to the file information to be filled */
1781:                ) {
1782:                	UINT i;
1783:                	PF_BYTE nt, *dir;
1784:                	TCHAR *p, c;
1785:                
1786:                	p = fno->fname;
1787:                	if (dj->sect) {
9D000098  8C820010   LW V0, 16(A0)
9D00009C  1040003B   BEQ V0, ZERO, 0x9D00018C
9D0000A0  24A30009   ADDIU V1, A1, 9
1788:                		dir = dj->dir;
9D0000A4  8C860014   LW A2, 20(A0)
1789:                		nt = dir[DIR_NTres]; /* NT flag */
1790:                		for (i = 0; i < 8; i++) { /* Copy name body */
9D0000C0  24080008   ADDIU T0, ZERO, 8
9D0000E8  24840001   ADDIU A0, A0, 1
9D0000EC  1488FFF7   BNE A0, T0, 0x9D0000CC
9D0000F0  A062FFFF   SB V0, -1(V1)
1791:                			c = dir[i];
9D0000A8  80C20000   LB V0, 0(A2)
9D0000D0  80420000   LB V0, 0(V0)
1792:                			if (c == ' ')
9D0000AC  24040020   ADDIU A0, ZERO, 32
9D0000B0  10440010   BEQ V0, A0, 0x9D0000F4
9D0000B4  00002021   ADDU A0, ZERO, ZERO
9D0000C4  0B400037   J 0x9D0000DC
9D0000C8  240B0020   ADDIU T3, ZERO, 32
9D0000CC  00C41021   ADDU V0, A2, A0
9D0000D4  504B0008   BEQL V0, T3, 0x9D0000F8
9D0000D8  90C40008   LBU A0, 8(A2)
1793:                				break;
1794:                			if (c == NDDE)
9D0000B8  240A0005   ADDIU T2, ZERO, 5
1795:                				c = (TCHAR) DDE;
9D0000BC  2409FFE5   ADDIU T1, ZERO, -27
9D0000DC  004A3826   XOR A3, V0, T2
9D0000E0  0127100A   MOVZ V0, T1, A3
9D000120  0B40004C   J 0x9D000130
9D000124  00E01821   ADDU V1, A3, ZERO
1796:                			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c))
1797:                				c += 0x20;
1798:                #if _LFN_UNICODE
1799:                			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
1800:                			c = (c << 8) | dir[++i];
1801:                			c = ff_convert(c, 1);
1802:                			if (!c) c = '?';
1803:                #endif
1804:                			*p++ = c;
9D0000E4  24630001   ADDIU V1, V1, 1
1805:                		}
1806:                		if (dir[8] != ' ') { /* Copy name extension */
9D0000F4  90C40008   LBU A0, 8(A2)
9D0000F8  24020020   ADDIU V0, ZERO, 32
9D0000FC  1082000C   BEQ A0, V0, 0x9D000130
9D000100  2402002E   ADDIU V0, ZERO, 46
1807:                			*p++ = '.';
9D000104  A0620000   SB V0, 0(V1)
9D000118  0B40004C   J 0x9D000130
9D00011C  24630001   ADDIU V1, V1, 1
1808:                			for (i = 8; i < 11; i++) {
1809:                				c = dir[i];
9D000108  80C20008   LB V0, 8(A2)
9D000194  80C20009   LB V0, 9(A2)
9D0001A8  80C2000A   LB V0, 10(A2)
1810:                				if (c == ' ')
9D00010C  24040020   ADDIU A0, ZERO, 32
9D000110  54440020   BNEL V0, A0, 0x9D000194
9D000114  A0620001   SB V0, 1(V1)
9D000198  24040020   ADDIU A0, ZERO, 32
9D00019C  1044FFE0   BEQ V0, A0, 0x9D000120
9D0001A0  24670002   ADDIU A3, V1, 2
9D0001AC  1444FFDE   BNE V0, A0, 0x9D000128
9D0001B0  24670003   ADDIU A3, V1, 3
9D0001B4  0B40004C   J 0x9D000130
9D0001B8  00E01821   ADDU V1, A3, ZERO
1811:                					break;
1812:                				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c))
1813:                					c += 0x20;
1814:                #if _LFN_UNICODE
1815:                				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
1816:                				c = (c << 8) | dir[++i];
1817:                				c = ff_convert(c, 1);
1818:                				if (!c) c = '?';
1819:                #endif
1820:                				*p++ = c;
9D000128  A0620003   SB V0, 3(V1)
9D00012C  24630004   ADDIU V1, V1, 4
9D0001A4  A0620002   SB V0, 2(V1)
1821:                			}
1822:                		}
1823:                		fno->fattrib = dir[DIR_Attr]; /* Attribute */
9D000130  90C2000B   LBU V0, 11(A2)
9D000134  A0A20008   SB V0, 8(A1)
1824:                		fno->fsize = LD_DWORD(dir+DIR_FileSize); /* Size */
9D000138  90C4001F   LBU A0, 31(A2)
9D00013C  00042600   SLL A0, A0, 24
9D000140  90C2001E   LBU V0, 30(A2)
9D000144  00021400   SLL V0, V0, 16
9D000148  00821025   OR V0, A0, V0
9D00014C  90C4001C   LBU A0, 28(A2)
9D000150  00441025   OR V0, V0, A0
9D000154  90C4001D   LBU A0, 29(A2)
9D000158  00042200   SLL A0, A0, 8
9D00015C  00441025   OR V0, V0, A0
9D000160  ACA20000   SW V0, 0(A1)
1825:                		fno->fdate = LD_WORD(dir+DIR_WrtDate); /* Date */
9D000164  90C20019   LBU V0, 25(A2)
9D000168  00021200   SLL V0, V0, 8
9D00016C  90C40018   LBU A0, 24(A2)
9D000170  00441025   OR V0, V0, A0
9D000174  A4A20004   SH V0, 4(A1)
1826:                		fno->ftime = LD_WORD(dir+DIR_WrtTime); /* Time */
9D000178  90C20017   LBU V0, 23(A2)
9D00017C  00021200   SLL V0, V0, 8
9D000180  90C40016   LBU A0, 22(A2)
9D000184  00441025   OR V0, V0, A0
9D000188  A4A20006   SH V0, 6(A1)
1827:                	}
1828:                	*p = 0; /* Terminate SFN str by a \0 */
9D00018C  03E00008   JR RA
9D000190  A0600000   SB ZERO, 0(V1)
9D000194  80C20009   LB V0, 9(A2)
9D000198  24040020   ADDIU A0, ZERO, 32
9D00019C  1044FFE0   BEQ V0, A0, 0x9D000120
9D0001A0  24670002   ADDIU A3, V1, 2
9D0001A4  A0620002   SB V0, 2(V1)
9D0001A8  80C2000A   LB V0, 10(A2)
9D0001AC  1444FFDE   BNE V0, A0, 0x9D000128
9D0001B0  24670003   ADDIU A3, V1, 3
9D0001B4  0B40004C   J 0x9D000130
9D0001B8  00E01821   ADDU V1, A3, ZERO
1829:                
1830:                #if _USE_LFN
1831:                	if (fno->lfname && fno->lfsize) {
1832:                		TCHAR *tp = fno->lfname;
1833:                		WCHAR w, *lfn;
1834:                
1835:                		i = 0;
1836:                		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1837:                			lfn = dj->lfn;
1838:                			while ((w = *lfn++) != 0) { /* Get an LFN char */
1839:                #if !_LFN_UNICODE
1840:                				w = ff_convert(w, 0); /* Unicode -> OEM conversion */
1841:                				if (!w) {i = 0; break;} /* Could not convert, no LFN */
1842:                				if (_DF1S && w >= 0x100) /* Put 1st byte if it is a DBC (always false on SBCS cfg) */
1843:                				tp[i++] = (TCHAR)(w >> 8);
1844:                #endif
1845:                				if (i >= fno->lfsize - 1) {i = 0; break;} /* Buffer overflow, no LFN */
1846:                				tp[i++] = (TCHAR)w;
1847:                			}
1848:                		}
1849:                		tp[i] = 0; /* Terminate the LFN str by a \0 */
1850:                	}
1851:                #endif
1852:                }
1853:                #endif /* _FS_MINIMIZE <= 1 */
1854:                
1855:                /*-----------------------------------------------------------------------*/
1856:                /* Follow a file path                                                    */
1857:                /*-----------------------------------------------------------------------*/
1858:                
1859:                static FRESULT follow_path( /* FR_OK(0): successful, !=0: error code */
1860:                DIR *dj, /* Directory object to return last directory and found object */
1861:                const TCHAR *path /* Full-path string to find a file or directory */
1862:                ) {
9D000D9C  27BDFFD0   ADDIU SP, SP, -48
9D000DA0  AFBF002C   SW RA, 44(SP)
9D000DA4  AFB60028   SW S6, 40(SP)
9D000DA8  AFB50024   SW S5, 36(SP)
9D000DAC  AFB40020   SW S4, 32(SP)
9D000DB0  AFB3001C   SW S3, 28(SP)
9D000DB4  AFB20018   SW S2, 24(SP)
9D000DB8  AFB10014   SW S1, 20(SP)
9D000DBC  AFB00010   SW S0, 16(SP)
9D000DC0  00808821   ADDU S1, A0, ZERO
1863:                	FRESULT res;
1864:                	PF_BYTE *dir, ns;
1865:                
1866:                #if _FS_RPATH
1867:                	if (*path == '/' || *path == '\\') { /* There is a heading separator */
9D000DC4  80A20000   LB V0, 0(A1)
9D000DC8  2403002F   ADDIU V1, ZERO, 47
9D000DCC  10430004   BEQ V0, V1, 0x9D000DE0
9D000DD0  00A08021   ADDU S0, A1, ZERO
9D000DD4  2403005C   ADDIU V1, ZERO, 92
9D000DD8  54430004   BNEL V0, V1, 0x9D000DEC
9D000DDC  8C820000   LW V0, 0(A0)
1868:                		path++; dj->sclust = 0; /* Strip it and start from the root dir */
9D000DE0  26100001   ADDIU S0, S0, 1
9D000DE4  0B40037D   J 0x9D000DF4
9D000DE8  AE200008   SW ZERO, 8(S1)
1869:                	} else { /* No heading separator */
1870:                		dj->sclust = dj->fs->cdir; /* Start from the current dir */
9D000DEC  8C420018   LW V0, 24(V0)
9D000DF0  AC820008   SW V0, 8(A0)
1871:                	}
1872:                #else
1873:                	if (*path == '/' || *path == '\\') /* Strip heading separator if exist */
1874:                		path++;
1875:                	dj->sclust = 0; /* Start from the root dir */
1876:                #endif
1877:                
1878:                	if ((UINT) *path < ' ') { /* Nul path means the start directory itself */
9D000DF4  92020000   LBU V0, 0(S0)
9D000DF8  2C420020   SLTIU V0, V0, 32
9D000DFC  14400006   BNE V0, ZERO, 0x9D000E18
9D000E00  2412002F   ADDIU S2, ZERO, 47
1879:                		res = dir_sdi(dj, 0);
9D000E18  02202021   ADDU A0, S1, ZERO
9D000E1C  0F4001B0   JAL dir_sdi
9D000E20  00002821   ADDU A1, ZERO, ZERO
9D000E24  0B400483   J 0x9D00120C
9D000E28  AE200014   SW ZERO, 20(S1)
1880:                		dj->dir = 0;
1881:                
1882:                	} else { /* Follow path */
1883:                		for (;;) {
1884:                			res = create_name(dj, &path); /* Get a segment */
1885:                			if (res != FR_OK)
1886:                				break;
1887:                			res = dir_find(dj); /* Find it */
9D001110  24030004   ADDIU V1, ZERO, 4
9D001114  24020005   ADDIU V0, ZERO, 5
9D001118  0B400483   J 0x9D00120C
9D00111C  0064100B   MOVN V0, V1, A0
1888:                			ns = *(dj->fn + NS);
9D0010D8  0B40047C   J 0x9D0011F0
9D0010DC  8E230018   LW V1, 24(S1)
9D0011D0  0B40047C   J 0x9D0011F0
9D0011D4  8E230018   LW V1, 24(S1)
9D001204  0B400438   J 0x9D0010E0
9D001208  9043000B   LBU V1, 11(V0)
1889:                			if (res != FR_OK) { /* Failed to find the object */
1890:                				if (res != FR_NO_FILE)
9D0011F0  24040004   ADDIU A0, ZERO, 4
9D0011F4  1044FFBA   BEQ V0, A0, 0x9D0010E0
9D0011F8  9063000B   LBU V1, 11(V1)
9D0011FC  0B400484   J 0x9D001210
9D001200  8FBF002C   LW RA, 44(SP)
1891:                					break; /* Abort if any hard error occured */
1892:                				/* Object not found */
1893:                				if (_FS_RPATH && (ns & NS_DOT)) { /* If dot entry is not exit */
9D0010E0  30620020   ANDI V0, V1, 32
9D0010E4  304200FF   ANDI V0, V0, 255
9D0010E8  50400008   BEQL V0, ZERO, 0x9D00110C
9D0010EC  30630004   ANDI V1, V1, 4
1894:                					dj->sclust = 0;
9D0010F0  AE200008   SW ZERO, 8(S1)
1895:                					dj->dir = 0; /* It is the root dir */
1896:                					res = FR_OK;
9D001104  0B400483   J 0x9D00120C
9D001108  00001021   ADDU V0, ZERO, ZERO
1897:                					if (!(ns & NS_LAST))
9D0010F4  30620004   ANDI V0, V1, 4
9D0010F8  304200FF   ANDI V0, V0, 255
9D0010FC  1040FF4B   BEQ V0, ZERO, follow_path::create_name
9D001100  AE200014   SW ZERO, 20(S1)
1898:                						continue;
1899:                				} else { /* Could not find the object */
1900:                					if (!(ns & NS_LAST))
9D00110C  306400FF   ANDI A0, V1, 255
1901:                						res = FR_NO_PATH;
9D000FCC  0B400483   J 0x9D00120C
9D000FD0  24020006   ADDIU V0, ZERO, 6
9D0011B4  0B400483   J 0x9D00120C
9D0011B8  24020006   ADDIU V0, ZERO, 6
1902:                				}
1903:                				break;
1904:                			}
1905:                			if (ns & NS_LAST)
9D0011D8  30630004   ANDI V1, V1, 4
9D0011DC  306300FF   ANDI V1, V1, 255
9D0011E0  5060FFCF   BEQL V1, ZERO, 0x9D001120
9D0011E4  9102000B   LBU V0, 11(T0)
9D0011E8  0B400484   J 0x9D001210
9D0011EC  8FBF002C   LW RA, 44(SP)
1906:                				break; /* Last segment match. Function completed. */
1907:                			dir = dj->dir; /* There is next segment. Follow the sub directory */
1908:                			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
9D001120  30420010   ANDI V0, V0, 16
9D001124  304200FF   ANDI V0, V0, 255
9D001128  10400038   BEQ V0, ZERO, 0x9D00120C
9D00112C  24020005   ADDIU V0, ZERO, 5
1909:                				res = FR_NO_PATH;
1910:                				break;
1911:                			}
1912:                			dj->sclust = LD_CLUST(dir);
9D001130  91030015   LBU V1, 21(T0)
9D001134  00031A00   SLL V1, V1, 8
9D001138  91020014   LBU V0, 20(T0)
9D00113C  00621825   OR V1, V1, V0
9D001140  00031C00   SLL V1, V1, 16
9D001144  9104001B   LBU A0, 27(T0)
9D001148  00042200   SLL A0, A0, 8
9D00114C  9102001A   LBU V0, 26(T0)
9D001150  00821025   OR V0, A0, V0
9D001154  00621025   OR V0, V1, V0
9D001158  0B40038B   J follow_path::create_name
9D00115C  AE220008   SW V0, 8(S1)
1913:                		}
1914:                	}
1915:                
1916:                	return res;
1917:                }
9D00120C  8FBF002C   LW RA, 44(SP)
9D001210  8FB60028   LW S6, 40(SP)
9D001214  8FB50024   LW S5, 36(SP)
9D001218  8FB40020   LW S4, 32(SP)
9D00121C  8FB3001C   LW S3, 28(SP)
9D001220  8FB20018   LW S2, 24(SP)
9D001224  8FB10014   LW S1, 20(SP)
9D001228  8FB00010   LW S0, 16(SP)
9D00122C  03E00008   JR RA
9D001230  27BD0030   ADDIU SP, SP, 48
1918:                
1919:                /*-----------------------------------------------------------------------*/
1920:                /* Load a sector and check if it is an FAT Volume Boot Record            */
1921:                /*-----------------------------------------------------------------------*/
1922:                
1923:                static PF_BYTE check_fs( /* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
1924:                FATFS *fs, /* File system object */
1925:                DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
1926:                ) {
9D0002C4  27BDFFE8   ADDIU SP, SP, -24
9D0002C8  AFBF0014   SW RA, 20(SP)
9D0002CC  AFB00010   SW S0, 16(SP)
9D0002D0  00808021   ADDU S0, A0, ZERO
9D0002D4  00A03021   ADDU A2, A1, ZERO
1927:                	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK) /* Load boot record */
9D0002D8  90840001   LBU A0, 1(A0)
9D0002DC  26050034   ADDIU A1, S0, 52
9D0002E0  0F402F71   JAL disk_read
9D0002E4  24070001   ADDIU A3, ZERO, 1
9D0002E8  14400027   BNE V0, ZERO, 0x9D000388
9D0002EC  24030003   ADDIU V1, ZERO, 3
1928:                		return 3;
1929:                	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55) /* Check record signature (always placed at offset 510 even if the sector size is >512) */
9D0002F0  92040233   LBU A0, 563(S0)
9D0002F4  00042200   SLL A0, A0, 8
9D0002F8  92020232   LBU V0, 562(S0)
9D0002FC  00822025   OR A0, A0, V0
9D000300  7C042620   SEH A0, A0
9D000304  2402AA55   ADDIU V0, ZERO, -21931
9D000308  1482001F   BNE A0, V0, 0x9D000388
9D00030C  24030002   ADDIU V1, ZERO, 2
1930:                		return 2;
1931:                
1932:                	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
9D000310  9203006D   LBU V1, 109(S0)
9D000314  00031E00   SLL V1, V1, 24
9D000318  9202006C   LBU V0, 108(S0)
9D00031C  00021400   SLL V0, V0, 16
9D000320  00621825   OR V1, V1, V0
9D000324  9202006A   LBU V0, 106(S0)
9D000328  00621825   OR V1, V1, V0
9D00032C  9202006B   LBU V0, 107(S0)
9D000330  00021200   SLL V0, V0, 8
9D000334  00621825   OR V1, V1, V0
9D000338  7C63B800   EXT V1, V1, 0, 24
9D00033C  3C020054   LUI V0, 84
9D000340  24424146   ADDIU V0, V0, 16710
9D000344  50620010   BEQL V1, V0, 0x9D000388
9D000348  00001821   ADDU V1, ZERO, ZERO
1933:                		return 0;
1934:                	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
9D00034C  92030089   LBU V1, 137(S0)
9D000350  00031E00   SLL V1, V1, 24
9D000354  92020088   LBU V0, 136(S0)
9D000358  00021400   SLL V0, V0, 16
9D00035C  00621825   OR V1, V1, V0
9D000360  92020086   LBU V0, 134(S0)
9D000364  00621825   OR V1, V1, V0
9D000368  92020087   LBU V0, 135(S0)
9D00036C  00021200   SLL V0, V0, 8
9D000370  00621825   OR V1, V1, V0
9D000374  7C63B800   EXT V1, V1, 0, 24
9D000378  3C02FFAB   LUI V0, -85
9D00037C  3442BEBA   ORI V0, V0, -16710
9D000380  00621821   ADDU V1, V1, V0
9D000384  0003182B   SLTU V1, ZERO, V1
1935:                		return 0;
1936:                
1937:                	return 1;
1938:                }
9D000388  00601021   ADDU V0, V1, ZERO
9D00038C  8FBF0014   LW RA, 20(SP)
9D000390  8FB00010   LW S0, 16(SP)
9D000394  03E00008   JR RA
9D000398  27BD0018   ADDIU SP, SP, 24
1939:                
1940:                /*-----------------------------------------------------------------------*/
1941:                /* Check if the file system object is valid or not                       */
1942:                /*-----------------------------------------------------------------------*/
1943:                
1944:                FRESULT chk_mounted( /* FR_OK(0): successful, !=0: any error occurred */
1945:                                            const TCHAR **path, /* Pointer to pointer to the path name (drive number) */
1946:                                            FATFS **rfs, /* Pointer to pointer to the found file system object */
1947:                                            PF_BYTE chk_wp /* !=0: Check media write protection for write access */
1948:                                            ) {
9D001484  27BDFFE0   ADDIU SP, SP, -32
9D001488  AFBF001C   SW RA, 28(SP)
9D00148C  AFB20018   SW S2, 24(SP)
9D001490  AFB10014   SW S1, 20(SP)
9D001494  AFB00010   SW S0, 16(SP)
1949:                	PF_BYTE fmt, b, pi, *tbl;
1950:                	UINT vol;
1951:                	DSTATUS stat;
1952:                	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
1953:                	PF_WORD nrsv;
1954:                	const TCHAR *p = *path;
9D001498  8C820000   LW V0, 0(A0)
1955:                	FATFS *fs;
1956:                
1957:                	/* Get logical drive number from the path name */
1958:                	vol = p[0] - '0'; /* Is there a drive number? */
9D00149C  80430000   LB V1, 0(V0)
9D0014A0  2463FFD0   ADDIU V1, V1, -48
1959:                	if (vol <= 9 && p[1] == ':') { /* Found a drive number, get and strip it */
9D0014A4  2C67000A   SLTIU A3, V1, 10
9D0014A8  10E00008   BEQ A3, ZERO, 0x9D0014CC
9D0014AC  00C08821   ADDU S1, A2, ZERO
9D0014B0  80470001   LB A3, 1(V0)
9D0014B4  2406003A   ADDIU A2, ZERO, 58
9D0014B8  54E60005   BNEL A3, A2, 0x9D0014D0
9D0014BC  93838048   LBU V1, -32696(GP)
1960:                		p += 2;
9D0014C0  24420002   ADDIU V0, V0, 2
1961:                		*path = p; /* Return pointer to the path name */
9D0014C4  0B400534   J 0x9D0014D0
9D0014C8  AC820000   SW V0, 0(A0)
1962:                	} else { /* No drive number is given */
1963:                #if _FS_RPATH
1964:                		vol = CurrVol; /* Use current drive */
9D0014CC  93838048   LBU V1, -32696(GP)
1965:                #else
1966:                		vol = 0; /* Use drive 0 */
1967:                #endif
1968:                	}
1969:                
1970:                	/* Check if the file system object is valid or not */
1971:                	if (vol >= _VOLUMES) /* Is the drive number valid? */
9D0014D0  1460011E   BNE V1, ZERO, 0x9D00194C
9D0014D4  2402000B   ADDIU V0, ZERO, 11
1972:                		return FR_INVALID_DRIVE;
1973:                	*rfs = fs = FatFs[vol]; /* Return pointer to the corresponding file system object */
9D0014D8  8F90804C   LW S0, -32692(GP)
1974:                	if (!fs)
9D0014DC  12000112   BEQ S0, ZERO, 0x9D001928
9D0014E0  ACB00000   SW S0, 0(A1)
1975:                		return FR_NOT_ENABLED; /* Is the file system object available? */
9D001928  0B400653   J 0x9D00194C
9D00192C  2402000C   ADDIU V0, ZERO, 12
1976:                
1977:                	ENTER_FF(fs); /* Lock file system */
1978:                
1979:                	if (fs->fs_type) { /* If the logical drive has been mounted */
9D0014E4  92020000   LBU V0, 0(S0)
9D0014E8  5040000D   BEQL V0, ZERO, 0x9D001520
9D0014EC  A2000000   SB ZERO, 0(S0)
1980:                		stat = disk_status(fs->drv);
9D0014F0  0F402F6B   JAL disk_status
9D0014F4  92040001   LBU A0, 1(S0)
9D0014F8  00401821   ADDU V1, V0, ZERO
1981:                		if (!(stat & STA_NOINIT)) { /* and the physical drive is kept initialized (has not been changed), */
9D0014FC  30420001   ANDI V0, V0, 1
9D001500  54400007   BNEL V0, ZERO, 0x9D001520
9D001504  A2000000   SB ZERO, 0(S0)
1982:                			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check write protection if needed */
9D001508  12200110   BEQ S1, ZERO, 0x9D00194C
9D00150C  30630004   ANDI V1, V1, 4
9D001510  306300FF   ANDI V1, V1, 255
1983:                				return FR_WRITE_PROTECTED;
1984:                			return FR_OK; /* The file system object is valid */
9D001514  2402000A   ADDIU V0, ZERO, 10
9D001518  0B400653   J 0x9D00194C
9D00151C  0003100A   MOVZ V0, ZERO, V1
1985:                		}
1986:                	}
1987:                
1988:                	/* The file system object is not valid. */
1989:                	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
1990:                
1991:                	fs->fs_type = 0; /* Clear the file system object */
1992:                	fs->drv = LD2PD(vol); /* Bind the logical drive and a physical drive */
9D001520  A2000001   SB ZERO, 1(S0)
1993:                	stat = disk_initialize(fs->drv); /* Initialize low level disk I/O layer */
9D001524  0F402EDE   JAL disk_initialize
9D001528  00002021   ADDU A0, ZERO, ZERO
9D00152C  00401821   ADDU V1, V0, ZERO
1994:                	if (stat & STA_NOINIT) /* Check if the initialization succeeded */
9D001530  30440001   ANDI A0, V0, 1
9D001534  14800105   BNE A0, ZERO, 0x9D00194C
9D001538  24020003   ADDIU V0, ZERO, 3
1995:                		return FR_NOT_READY; /* Failed to initialize due to no media or hard error */
1996:                	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check disk write protection if needed */
9D00153C  12200004   BEQ S1, ZERO, 0x9D001550
9D001540  30630004   ANDI V1, V1, 4
9D001544  306300FF   ANDI V1, V1, 255
9D001548  14600100   BNE V1, ZERO, 0x9D00194C
9D00154C  2402000A   ADDIU V0, ZERO, 10
1997:                		return FR_WRITE_PROTECTED;
1998:                #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
1999:                	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
2000:                	return FR_DISK_ERR;
2001:                #endif
2002:                	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
2003:                	fmt = check_fs(fs, bsect = 0); /* Load sector 0 and check if it is an FAT-VBR (in SFD) */
9D001550  02002021   ADDU A0, S0, ZERO
9D001554  0F4000B1   JAL check_fs
9D001558  00002821   ADDU A1, ZERO, ZERO
9D00155C  00401821   ADDU V1, V0, ZERO
2004:                	if (LD2PT(vol) && !fmt)
2005:                		fmt = 1; /* Force non-SFD if the volume is forced partition */
2006:                	if (fmt == 1) { /* Not an FAT-VBR, the physical drive can be partitioned */
9D001560  24020001   ADDIU V0, ZERO, 1
9D001564  14620012   BNE V1, V0, 0x9D0015B0
9D001568  00008821   ADDU S1, ZERO, ZERO
2007:                		/* Check the partition listed in the partition table */
2008:                		pi = LD2PT(vol);
2009:                		if (pi)
2010:                			pi--;
2011:                		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
2012:                		if (tbl[4]) { /* Is the partition existing? */
9D00156C  920301F6   LBU V1, 502(S0)
9D001570  106000F6   BEQ V1, ZERO, 0x9D00194C
9D001574  2402000D   ADDIU V0, ZERO, 13
2013:                			bsect = LD_DWORD(&tbl[8]); /* Partition offset in LBA */
9D001578  921101FD   LBU S1, 509(S0)
9D00157C  00118E00   SLL S1, S1, 24
9D001580  920201FC   LBU V0, 508(S0)
9D001584  00021400   SLL V0, V0, 16
9D001588  02228825   OR S1, S1, V0
9D00158C  920201FA   LBU V0, 506(S0)
9D001590  02228825   OR S1, S1, V0
9D001594  920201FB   LBU V0, 507(S0)
9D001598  00021200   SLL V0, V0, 8
9D00159C  02228825   OR S1, S1, V0
2014:                			fmt = check_fs(fs, bsect); /* Check the partition */
9D0015A0  02002021   ADDU A0, S0, ZERO
9D0015A4  0F4000B1   JAL check_fs
9D0015A8  02202821   ADDU A1, S1, ZERO
9D0015AC  00401821   ADDU V1, V0, ZERO
2015:                		}
2016:                	}
2017:                	if (fmt == 3)
9D0015B0  24020003   ADDIU V0, ZERO, 3
9D0015B4  506200E5   BEQL V1, V0, 0x9D00194C
9D0015B8  24020001   ADDIU V0, ZERO, 1
2018:                		return FR_DISK_ERR;
2019:                	if (fmt)
9D0015BC  146000E3   BNE V1, ZERO, 0x9D00194C
9D0015C0  2402000D   ADDIU V0, ZERO, 13
2020:                		return FR_NO_FILESYSTEM; /* No FAT volume is found */
2021:                
2022:                	/* An FAT volume is found. Following code initializes the file system object */
2023:                
2024:                	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs)) /* (BPB_BytsPerSec must be equal to the physical sector size) */
9D0015C4  92040040   LBU A0, 64(S0)
9D0015C8  00042200   SLL A0, A0, 8
9D0015CC  9202003F   LBU V0, 63(S0)
9D0015D0  00822025   OR A0, A0, V0
9D0015D4  7C042620   SEH A0, A0
9D0015D8  24030200   ADDIU V1, ZERO, 512
9D0015DC  148300DB   BNE A0, V1, 0x9D00194C
9D0015E0  2402000D   ADDIU V0, ZERO, 13
2025:                		return FR_NO_FILESYSTEM;
2026:                
2027:                	fasize = LD_WORD(fs->win+BPB_FATSz16); /* Number of sectors per FAT */
9D0015E4  9204004B   LBU A0, 75(S0)
9D0015E8  00042200   SLL A0, A0, 8
9D0015EC  9202004A   LBU V0, 74(S0)
9D0015F0  00822025   OR A0, A0, V0
2028:                	if (!fasize)
9D0015F4  5480000C   BNEL A0, ZERO, 0x9D001628
9D0015F8  AE040020   SW A0, 32(S0)
2029:                		fasize = LD_DWORD(fs->win+BPB_FATSz32);
9D0015FC  9204005B   LBU A0, 91(S0)
9D001600  00042600   SLL A0, A0, 24
9D001604  9202005A   LBU V0, 90(S0)
9D001608  00021400   SLL V0, V0, 16
9D00160C  00822025   OR A0, A0, V0
9D001610  92020058   LBU V0, 88(S0)
9D001614  00822025   OR A0, A0, V0
9D001618  92020059   LBU V0, 89(S0)
9D00161C  00021200   SLL V0, V0, 8
9D001620  00822025   OR A0, A0, V0
2030:                	fs->fsize = fasize;
9D001624  AE040020   SW A0, 32(S0)
2031:                
2032:                	fs->n_fats = b = fs->win[BPB_NumFATs]; /* Number of FAT copies */
9D001628  92070044   LBU A3, 68(S0)
9D00162C  A2070003   SB A3, 3(S0)
2033:                	if (b != 1 && b != 2)
9D001630  24E3FFFF   ADDIU V1, A3, -1
9D001634  306300FF   ANDI V1, V1, 255
9D001638  2C630002   SLTIU V1, V1, 2
9D00163C  106000C3   BEQ V1, ZERO, 0x9D00194C
9D001640  2402000D   ADDIU V0, ZERO, 13
2034:                		return FR_NO_FILESYSTEM; /* (Must be 1 or 2) */
2035:                	fasize *= b; /* Number of sectors for FAT area */
9D0016D4  70874802   MUL T1, A0, A3
2036:                
2037:                	fs->csize = b = fs->win[BPB_SecPerClus]; /* Number of sectors per cluster */
9D001644  92030041   LBU V1, 65(S0)
2038:                	if (!b || (b & (b - 1)))
9D001648  106000C0   BEQ V1, ZERO, 0x9D00194C
9D00164C  A2030002   SB V1, 2(S0)
9D001650  2465FFFF   ADDIU A1, V1, -1
9D001654  00A32824   AND A1, A1, V1
9D001658  14A000BD   BNE A1, ZERO, 0x9D001950
9D00165C  8FBF001C   LW RA, 28(SP)
2039:                		return FR_NO_FILESYSTEM; /* (Must be power of 2) */
2040:                
2041:                	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt); /* Number of root directory entries */
9D001660  92050046   LBU A1, 70(S0)
9D001664  00052A00   SLL A1, A1, 8
9D001668  92020045   LBU V0, 69(S0)
9D00166C  00A22825   OR A1, A1, V0
9D001670  A6050008   SH A1, 8(S0)
2042:                	if (fs->n_rootdir % (SS(fs) / SZ_DIR))
9D001674  30A6000F   ANDI A2, A1, 15
9D001678  14C000B4   BNE A2, ZERO, 0x9D00194C
9D00167C  2402000D   ADDIU V0, ZERO, 13
2043:                		return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be sector aligned) */
2044:                
2045:                	tsect = LD_WORD(fs->win+BPB_TotSec16); /* Number of sectors on the volume */
9D001680  92080048   LBU T0, 72(S0)
9D001684  00084200   SLL T0, T0, 8
9D001688  92020047   LBU V0, 71(S0)
9D00168C  01024025   OR T0, T0, V0
2046:                	if (!tsect)
9D001690  1500000B   BNE T0, ZERO, 0x9D0016C0
9D001694  92060043   LBU A2, 67(S0)
2047:                		tsect = LD_DWORD(fs->win+BPB_TotSec32);
9D001698  92080057   LBU T0, 87(S0)
9D00169C  00084600   SLL T0, T0, 24
9D0016A0  92020056   LBU V0, 86(S0)
9D0016A4  00021400   SLL V0, V0, 16
9D0016A8  01024025   OR T0, T0, V0
9D0016AC  92020054   LBU V0, 84(S0)
9D0016B0  01024025   OR T0, T0, V0
9D0016B4  92020055   LBU V0, 85(S0)
9D0016B8  00021200   SLL V0, V0, 8
9D0016BC  01024025   OR T0, T0, V0
2048:                
2049:                	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt); /* Number of reserved sectors */
9D0016C0  00063200   SLL A2, A2, 8
9D0016C4  92020042   LBU V0, 66(S0)
9D0016C8  00C23025   OR A2, A2, V0
2050:                	if (!nrsv)
9D0016CC  10C0009F   BEQ A2, ZERO, 0x9D00194C
9D0016D0  2402000D   ADDIU V0, ZERO, 13
2051:                		return FR_NO_FILESYSTEM; /* (BPB_RsvdSecCnt must not be 0) */
2052:                
2053:                	/* Determine the FAT sub type */
2054:                	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR); /* RSV+FAT+DIR */
9D0016D8  00053902   SRL A3, A1, 4
9D0016DC  00E63821   ADDU A3, A3, A2
9D0016E0  00E93821   ADDU A3, A3, T1
2055:                	if (tsect < sysect)
9D0016E4  0107502B   SLTU T2, T0, A3
9D0016E8  15400099   BNE T2, ZERO, 0x9D001950
9D0016EC  8FBF001C   LW RA, 28(SP)
2056:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2057:                	nclst = (tsect - sysect) / fs->csize; /* Number of clusters */
9D0016F0  01074023   SUBU T0, T0, A3
9D0016F4  0103001B   DIVU T0, V1
9D0016F8  006001F4   TEQ V1, ZERO
9D0016FC  00001812   MFLO V1
2058:                	if (!nclst)
9D001700  10600094   BEQ V1, ZERO, 0x9D001954
9D001704  8FB20018   LW S2, 24(SP)
2059:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2060:                	fmt = FS_FAT12;
9D00170C  24020001   ADDIU V0, ZERO, 1
9D001710  24080002   ADDIU T0, ZERO, 2
9D001714  0112100A   MOVZ V0, T0, S2
9D001718  00409021   ADDU S2, V0, ZERO
2061:                	if (nclst >= MIN_FAT16)
9D001708  2C720FF6   SLTIU S2, V1, 4086
2062:                		fmt = FS_FAT16;
2063:                	if (nclst >= MIN_FAT32)
9D00171C  3402FFF6   ORI V0, ZERO, -10
9D001720  0062102B   SLTU V0, V1, V0
9D001724  10400082   BEQ V0, ZERO, 0x9D001930
9D001728  24630002   ADDIU V1, V1, 2
2064:                		fmt = FS_FAT32;
9D001944  0B4005D2   J 0x9D001748
9D001948  24120003   ADDIU S2, ZERO, 3
2065:                
2066:                	/* Boundaries and Limits */
2067:                	fs->n_fatent = nclst + 2; /* Number of FAT entries */
9D00172C  AE03001C   SW V1, 28(S0)
9D001930  AE03001C   SW V1, 28(S0)
2068:                	fs->database = bsect + sysect; /* Data start sector */
9D001730  00F13821   ADDU A3, A3, S1
9D001734  AE07002C   SW A3, 44(S0)
9D001934  00F13821   ADDU A3, A3, S1
9D001938  AE07002C   SW A3, 44(S0)
2069:                	fs->fatbase = bsect + nrsv; /* FAT start sector */
9D001738  02263021   ADDU A2, S1, A2
9D00193C  02263021   ADDU A2, S1, A2
9D001940  AE060024   SW A2, 36(S0)
2070:                	if (fmt == FS_FAT32) {
9D00173C  24020003   ADDIU V0, ZERO, 3
9D001740  16420010   BNE S2, V0, 0x9D001784
9D001744  AE060024   SW A2, 36(S0)
2071:                		if (fs->n_rootdir)
9D001748  14A00080   BNE A1, ZERO, 0x9D00194C
9D00174C  2402000D   ADDIU V0, ZERO, 13
2072:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be 0) */
2073:                		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
9D001750  92050063   LBU A1, 99(S0)
9D001754  00052E00   SLL A1, A1, 24
9D001758  92020062   LBU V0, 98(S0)
9D00175C  00021400   SLL V0, V0, 16
9D001760  00A22825   OR A1, A1, V0
9D001764  92020060   LBU V0, 96(S0)
9D001768  00A22825   OR A1, A1, V0
9D00176C  92020061   LBU V0, 97(S0)
9D001770  00021200   SLL V0, V0, 8
9D001774  00A21025   OR V0, A1, V0
9D001778  AE020028   SW V0, 40(S0)
9D00177C  0B4005EE   J 0x9D0017B8
9D001780  00031880   SLL V1, V1, 2
2074:                		szbfat = fs->n_fatent * 4; /* (Required FAT size) */
2075:                	} else {
2076:                		if (!fs->n_rootdir)
9D001784  10A00071   BEQ A1, ZERO, 0x9D00194C
9D001788  2402000D   ADDIU V0, ZERO, 13
2077:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must not be 0) */
2078:                		fs->dirbase = fs->fatbase + fasize; /* Root directory start sector */
9D00178C  01263021   ADDU A2, T1, A2
2079:                		szbfat = (fmt == FS_FAT16) ? /* (Required FAT size) */
2080:                		fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
9D001790  24020002   ADDIU V0, ZERO, 2
9D001794  16420003   BNE S2, V0, 0x9D0017A4
9D001798  AE060028   SW A2, 40(S0)
9D00179C  0B4005EE   J 0x9D0017B8
9D0017A0  00031840   SLL V1, V1, 1
9D0017A4  24020003   ADDIU V0, ZERO, 3
9D0017A8  70621002   MUL V0, V1, V0
9D0017AC  00021042   SRL V0, V0, 1
9D0017B0  30630001   ANDI V1, V1, 1
9D0017B4  00431821   ADDU V1, V0, V1
2081:                	}
2082:                	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) /* (BPB_FATSz must not be less than required) */
9D0017B8  246201FF   ADDIU V0, V1, 511
9D0017BC  00021242   SRL V0, V0, 9
9D0017C0  0082202B   SLTU A0, A0, V0
9D0017C4  14800061   BNE A0, ZERO, 0x9D00194C
9D0017C8  2402000D   ADDIU V0, ZERO, 13
2083:                		return FR_NO_FILESYSTEM;
2084:                
2085:                #if !_FS_READONLY
2086:                	/* Initialize cluster allocation information */
2087:                	fs->free_clust = 0xFFFFFFFF;
9D0017CC  2402FFFF   ADDIU V0, ZERO, -1
9D0017D0  AE020010   SW V0, 16(S0)
2088:                	fs->last_clust = 0;
2089:                
2090:                	/* Get fsinfo if available */
2091:                	if (fmt == FS_FAT32) {
9D0017D4  24020003   ADDIU V0, ZERO, 3
9D0017D8  16420048   BNE S2, V0, 0x9D0018FC
9D0017DC  AE00000C   SW ZERO, 12(S0)
2092:                		fs->fsi_flag = 0;
9D0017E0  A2000005   SB ZERO, 5(S0)
2093:                		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
9D0017E4  92060065   LBU A2, 101(S0)
9D0017E8  00063200   SLL A2, A2, 8
9D0017EC  92020064   LBU V0, 100(S0)
9D0017F0  00C23025   OR A2, A2, V0
9D0017F4  02263021   ADDU A2, S1, A2
9D0017F8  AE060014   SW A2, 20(S0)
2094:                		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK
9D0017FC  92040001   LBU A0, 1(S0)
9D001800  26050034   ADDIU A1, S0, 52
9D001804  0F402F71   JAL disk_read
9D001808  24070001   ADDIU A3, ZERO, 1
9D00180C  5440003C   BNEL V0, ZERO, 0x9D001900
9D001810  A2120000   SB S2, 0(S0)
2095:                				&& LD_WORD(fs->win+BS_55AA) == 0xAA55
9D001814  92030233   LBU V1, 563(S0)
9D001818  00031A00   SLL V1, V1, 8
9D00181C  92020232   LBU V0, 562(S0)
9D001820  00621825   OR V1, V1, V0
9D001824  7C031E20   SEH V1, V1
9D001828  2402AA55   ADDIU V0, ZERO, -21931
9D00182C  54620034   BNEL V1, V0, 0x9D001900
9D001830  A2120000   SB S2, 0(S0)
2096:                				&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
9D001834  92030037   LBU V1, 55(S0)
9D001838  00031E00   SLL V1, V1, 24
9D00183C  92020036   LBU V0, 54(S0)
9D001840  00021400   SLL V0, V0, 16
9D001844  00621825   OR V1, V1, V0
9D001848  92020034   LBU V0, 52(S0)
9D00184C  00621825   OR V1, V1, V0
9D001850  92020035   LBU V0, 53(S0)
9D001854  00021200   SLL V0, V0, 8
9D001858  00621825   OR V1, V1, V0
9D00185C  3C024161   LUI V0, 16737
9D001860  24425252   ADDIU V0, V0, 21074
9D001864  54620026   BNEL V1, V0, 0x9D001900
9D001868  A2120000   SB S2, 0(S0)
2097:                				&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
9D00186C  9203021B   LBU V1, 539(S0)
9D001870  00031E00   SLL V1, V1, 24
9D001874  9202021A   LBU V0, 538(S0)
9D001878  00021400   SLL V0, V0, 16
9D00187C  00621825   OR V1, V1, V0
9D001880  92020218   LBU V0, 536(S0)
9D001884  00621825   OR V1, V1, V0
9D001888  92020219   LBU V0, 537(S0)
9D00188C  00021200   SLL V0, V0, 8
9D001890  00621825   OR V1, V1, V0
9D001894  3C026141   LUI V0, 24897
9D001898  24427272   ADDIU V0, V0, 29298
9D00189C  54620018   BNEL V1, V0, 0x9D001900
9D0018A0  A2120000   SB S2, 0(S0)
2098:                			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
9D0018A4  92030223   LBU V1, 547(S0)
9D0018A8  00031E00   SLL V1, V1, 24
9D0018AC  92020222   LBU V0, 546(S0)
9D0018B0  00021400   SLL V0, V0, 16
9D0018B4  00621825   OR V1, V1, V0
9D0018B8  92020220   LBU V0, 544(S0)
9D0018BC  00621825   OR V1, V1, V0
9D0018C0  92020221   LBU V0, 545(S0)
9D0018C4  00021200   SLL V0, V0, 8
9D0018C8  00621025   OR V0, V1, V0
9D0018CC  AE02000C   SW V0, 12(S0)
2099:                			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
9D0018D0  9203021F   LBU V1, 543(S0)
9D0018D4  00031E00   SLL V1, V1, 24
9D0018D8  9202021E   LBU V0, 542(S0)
9D0018DC  00021400   SLL V0, V0, 16
9D0018E0  00621825   OR V1, V1, V0
9D0018E4  9202021C   LBU V0, 540(S0)
9D0018E8  00621825   OR V1, V1, V0
9D0018EC  9202021D   LBU V0, 541(S0)
9D0018F0  00021200   SLL V0, V0, 8
9D0018F4  00621025   OR V0, V1, V0
9D0018F8  AE020010   SW V0, 16(S0)
2100:                		}
2101:                	}
2102:                #endif
2103:                	fs->fs_type = fmt; /* FAT sub-type */
9D0018FC  A2120000   SB S2, 0(S0)
2104:                	fs->id = ++Fsid; /* File system mount ID */
9D001900  9782804A   LHU V0, -32694(GP)
9D001904  24420001   ADDIU V0, V0, 1
9D001908  3042FFFF   ANDI V0, V0, -1
9D00190C  A782804A   SH V0, -32694(GP)
9D001910  A6020006   SH V0, 6(S0)
2105:                	fs->winsect = 0; /* Invalidate sector cache */
9D001914  AE000030   SW ZERO, 48(S0)
2106:                	fs->wflag = 0;
9D001918  A2000004   SB ZERO, 4(S0)
2107:                #if _FS_RPATH
2108:                	fs->cdir = 0; /* Current directory (root dir) */
9D00191C  AE000018   SW ZERO, 24(S0)
2109:                #endif
2110:                #if _FS_SHARE				/* Clear file lock semaphores */
2111:                	clear_lock(fs);
2112:                #endif
2113:                
2114:                	return FR_OK;
9D001920  0B400653   J 0x9D00194C
9D001924  00001021   ADDU V0, ZERO, ZERO
2115:                }
9D00194C  8FBF001C   LW RA, 28(SP)
9D001950  8FB20018   LW S2, 24(SP)
9D001954  8FB10014   LW S1, 20(SP)
9D001958  8FB00010   LW S0, 16(SP)
9D00195C  03E00008   JR RA
9D001960  27BD0020   ADDIU SP, SP, 32
2116:                
2117:                /*-----------------------------------------------------------------------*/
2118:                /* Check if the file/dir object is valid or not                          */
2119:                /*-----------------------------------------------------------------------*/
2120:                
2121:                static FRESULT validate( /* FR_OK(0): The object is valid, !=0: Invalid */
2122:                FATFS *fs, /* Pointer to the file system object */
2123:                PF_WORD id /* Member id of the target object to be checked */
2124:                ) {
9D0003BC  27BDFFE8   ADDIU SP, SP, -24
9D0003C0  AFBF0014   SW RA, 20(SP)
2125:                	if (!fs || !fs->fs_type || fs->id != id)
9D00039C  10800010   BEQ A0, ZERO, 0x9D0003E0
9D0003A0  00000000   NOP
9D0003A4  90830000   LBU V1, 0(A0)
9D0003A8  10600011   BEQ V1, ZERO, 0x9D0003F0
9D0003AC  24020009   ADDIU V0, ZERO, 9
9D0003B0  94830006   LHU V1, 6(A0)
9D0003B4  1465000E   BNE V1, A1, 0x9D0003F0
9D0003B8  00000000   NOP
2126:                		return FR_INVALID_OBJECT;
9D0003E0  03E00008   JR RA
9D0003E4  24020009   ADDIU V0, ZERO, 9
2127:                
2128:                	ENTER_FF(fs); /* Lock file system */
2129:                
2130:                	if (disk_status(fs->drv) & STA_NOINIT)
9D0003C4  0F402F6B   JAL disk_status
9D0003C8  90840001   LBU A0, 1(A0)
9D0003CC  30420001   ANDI V0, V0, 1
2131:                		return FR_NOT_READY;
9D0003D0  24030003   ADDIU V1, ZERO, 3
9D0003D4  0002180A   MOVZ V1, ZERO, V0
9D0003D8  0B4000FA   J 0x9D0003E8
9D0003DC  00601021   ADDU V0, V1, ZERO
2132:                
2133:                	return FR_OK;
2134:                }
9D0003E8  8FBF0014   LW RA, 20(SP)
9D0003EC  27BD0018   ADDIU SP, SP, 24
9D0003F0  03E00008   JR RA
9D0003F4  00000000   NOP
2135:                
2136:                /*--------------------------------------------------------------------------
2137:                
2138:                 Public Functions
2139:                
2140:                 --------------------------------------------------------------------------*/
2141:                
2142:                /*-----------------------------------------------------------------------*/
2143:                /* Mount/Unmount a Logical Drive                                         */
2144:                /*-----------------------------------------------------------------------*/
2145:                
2146:                FRESULT f_mount(PF_BYTE vol, /* Logical drive number to be mounted/unmounted */
2147:                                FATFS *fs /* Pointer to new file system object (NULL for unmount)*/
2148:                                ) {
2149:                	FATFS *rfs;
2150:                
2151:                	if (vol >= _VOLUMES) {/* Check if the drive number is valid */
9D001964  14800008   BNE A0, ZERO, 0x9D001988
9D001968  2402000B   ADDIU V0, ZERO, 11
2152:                		return FR_INVALID_DRIVE;
2153:                	}
2154:                	rfs = FatFs[vol]; /* Get current fs object */
9D00196C  8F82804C   LW V0, -32692(GP)
2155:                
2156:                	if (rfs) {
9D001970  54400001   BNEL V0, ZERO, 0x9D001978
9D001974  A0400000   SB ZERO, 0(V0)
2157:                #if _FS_SHARE
2158:                		clear_lock(rfs);
2159:                #endif
2160:                #if _FS_REENTRANT				/* Discard sync object of the current volume */
2161:                		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2162:                #endif
2163:                		rfs->fs_type = 0; /* Clear old fs object */
2164:                	}
2165:                
2166:                	if (fs) {
9D001978  54A00001   BNEL A1, ZERO, 0x9D001980
9D00197C  A0A00000   SB ZERO, 0(A1)
2167:                		fs->fs_type = 0; /* Clear new fs object */
2168:                #if _FS_REENTRANT				/* Create sync object for the new volume */
2169:                		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2170:                #endif
2171:                	}
2172:                	FatFs[vol] = fs; /* Register new fs object */
9D001980  AF85804C   SW A1, -32692(GP)
2173:                
2174:                	return FR_OK;
9D001984  00001021   ADDU V0, ZERO, ZERO
2175:                }
9D001988  03E00008   JR RA
9D00198C  00000000   NOP
2176:                
2177:                /*-----------------------------------------------------------------------*/
2178:                /* Open or Create a File                                                 */
2179:                /*-----------------------------------------------------------------------*/
2180:                
2181:                FRESULT f_open(FIL *fp, /* Pointer to the blank file object */
2182:                                const TCHAR *path, /* Pointer to the file name */
2183:                                PF_BYTE mode /* Access mode and file open mode flags */
2184:                                ) {
9D001990  27BDFFB0   ADDIU SP, SP, -80
9D001994  AFBF004C   SW RA, 76(SP)
9D001998  AFB40048   SW S4, 72(SP)
9D00199C  AFB30044   SW S3, 68(SP)
9D0019A0  AFB20040   SW S2, 64(SP)
9D0019A4  AFB1003C   SW S1, 60(SP)
9D0019A8  AFB00038   SW S0, 56(SP)
9D0019AC  00808821   ADDU S1, A0, ZERO
9D0019B0  AFA50054   SW A1, 84(SP)
9D0019B4  00C09821   ADDU S3, A2, ZERO
9D001C08  0B4006D1   J 0x9D001B44
9D001C0C  00001021   ADDU V0, ZERO, ZERO
2185:                	FRESULT res;
2186:                	DIR dj;
2187:                	PF_BYTE *dir;
2188:                	DEF_NAMEBUF;
2189:                
2190:                	fp->fs = 0; /* Clear file object */
9D0019B8  AC800000   SW ZERO, 0(A0)
2191:                
2192:                #if !_FS_READONLY
2193:                	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS
9D0019BC  30D2001F   ANDI S2, A2, 31
2194:                			| FA_CREATE_NEW;
2195:                	res = chk_mounted(&path, &dj.fs, (PF_BYTE) (mode & ~FA_READ));
9D0019C0  27A40054   ADDIU A0, SP, 84
9D0019C4  27A50010   ADDIU A1, SP, 16
9D0019C8  0F400521   JAL chk_mounted
9D0019CC  30C6001E   ANDI A2, A2, 30
2196:                #else
2197:                	mode &= FA_READ;
2198:                	res = chk_mounted(&path, &dj.fs, 0);
2199:                #endif
2200:                	INIT_BUF(dj);
9D0019D0  27A3002C   ADDIU V1, SP, 44
2201:                	if (res == FR_OK)
9D0019D4  14400081   BNE V0, ZERO, 0x9D001BDC
9D0019D8  AFA30028   SW V1, 40(SP)
2202:                		res = follow_path(&dj, path); /* Follow the file path */
9D0019DC  27A40010   ADDIU A0, SP, 16
9D0019E0  0F400367   JAL follow_path
9D0019E4  8FA50054   LW A1, 84(SP)
2203:                	dir = dj.dir;
9D001BDC  0B4006FD   J 0x9D001BF4
9D001BE0  8FB00024   LW S0, 36(SP)
2204:                
2205:                #if !_FS_READONLY	/* R/W configuration */
2206:                	if (res == FR_OK) {
9D0019E8  14400082   BNE V0, ZERO, 0x9D001BF4
9D0019EC  8FB00024   LW S0, 36(SP)
2207:                		if (!dir) /* Current dir itself */
9D0019F0  5600007C   BNEL S0, ZERO, 0x9D001BE4
9D0019F4  3262001C   ANDI V0, S3, 28
9D0019F8  0B4006FD   J 0x9D001BF4
9D0019FC  24020006   ADDIU V0, ZERO, 6
2208:                			res = FR_INVALID_NAME;
2209:                #if _FS_SHARE
2210:                		else
2211:                		res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2212:                #endif
2213:                	}
2214:                	/* Create or Open a file */
2215:                	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
9D001BE4  1440FF92   BNE V0, ZERO, 0x9D001A30
9D001BE8  9203000B   LBU V1, 11(S0)
9D001BF4  3263001C   ANDI V1, S3, 28
9D001BF8  1460FF81   BNE V1, ZERO, 0x9D001A00
9D001BFC  00000000   NOP
9D001C00  0B4006CF   J 0x9D001B3C
9D001C04  00000000   NOP
2216:                		DWORD dw, cl;
2217:                
2218:                		if (res != FR_OK) { /* No file, create new */
9D001A00  5040000B   BEQL V0, ZERO, 0x9D001A30
9D001A04  9203000B   LBU V1, 11(S0)
2219:                			if (res == FR_NO_FILE) /* There is no file to open, create a new entry */
9D001A08  24030004   ADDIU V1, ZERO, 4
9D001A0C  14430081   BNE V0, V1, 0x9D001C14
9D001A10  8FBF004C   LW RA, 76(SP)
2220:                #if _FS_SHARE
2221:                				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
2222:                #else
2223:                				res = dir_register(&dj);
9D001A14  0F40048D   JAL dir_register
9D001A18  27A40010   ADDIU A0, SP, 16
2224:                #endif
2225:                			mode |= FA_CREATE_ALWAYS; /* File is created */
9D001A1C  36520008   ORI S2, S2, 8
2226:                			dir = dj.dir; /* New entry */
2227:                		} else { /* Any object is already existing */
2228:                			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) { /* Cannot overwrite it (R/O or DIR) */
9D001A30  30630011   ANDI V1, V1, 17
9D001A34  14600076   BNE V1, ZERO, 0x9D001C10
9D001A38  24020007   ADDIU V0, ZERO, 7
2229:                				res = FR_DENIED;
2230:                			} else {
2231:                				if (mode & FA_CREATE_NEW) /* Cannot create as new file */
9D001A3C  32730004   ANDI S3, S3, 4
9D001A40  327300FF   ANDI S3, S3, 255
9D001A44  16600072   BNE S3, ZERO, 0x9D001C10
9D001A48  24020008   ADDIU V0, ZERO, 8
2232:                					res = FR_EXIST;
2233:                			}
2234:                		}
2235:                		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) { /* Truncate it if overwrite mode */
9D001A20  1040000A   BEQ V0, ZERO, 0x9D001A4C
9D001A24  8FB00024   LW S0, 36(SP)
9D001A28  0B400705   J 0x9D001C14
9D001A2C  8FBF004C   LW RA, 76(SP)
9D001A4C  32420008   ANDI V0, S2, 8
9D001A50  304200FF   ANDI V0, V0, 255
9D001A54  1040003B   BEQ V0, ZERO, 0x9D001B44
9D001A58  00001021   ADDU V0, ZERO, ZERO
2236:                			dw = get_fattime(); /* Created time */
9D001A5C  0F4030CD   JAL get_fattime
9D001A60  00000000   NOP
2237:                			ST_DWORD(dir+DIR_CrtTime, dw);
9D001A64  A202000E   SB V0, 14(S0)
9D001A68  7C433A00   EXT V1, V0, 8, 8
9D001A6C  A203000F   SB V1, 15(S0)
9D001A70  00021C02   SRL V1, V0, 16
9D001A74  A2030010   SB V1, 16(S0)
9D001A78  00021602   SRL V0, V0, 24
9D001A7C  A2020011   SB V0, 17(S0)
2238:                			dir[DIR_Attr] = 0; /* Reset attribute */
9D001A80  A200000B   SB ZERO, 11(S0)
2239:                			ST_DWORD(dir+DIR_FileSize, 0); /* size = 0 */
9D001A84  A200001C   SB ZERO, 28(S0)
9D001A88  A200001D   SB ZERO, 29(S0)
9D001A8C  A200001E   SB ZERO, 30(S0)
9D001A90  A200001F   SB ZERO, 31(S0)
2240:                			cl = LD_CLUST(dir); /* Get start cluster */
9D001A94  92020015   LBU V0, 21(S0)
9D001A98  00021200   SLL V0, V0, 8
9D001A9C  92030014   LBU V1, 20(S0)
9D001AA0  00431025   OR V0, V0, V1
9D001AA4  00021400   SLL V0, V0, 16
9D001AA8  9213001B   LBU S3, 27(S0)
9D001AAC  00139A00   SLL S3, S3, 8
9D001AB0  9203001A   LBU V1, 26(S0)
9D001AB4  02639825   OR S3, S3, V1
9D001AB8  00539825   OR S3, V0, S3
2241:                			ST_CLUST(dir, 0); /* cluster = 0 */
9D001ABC  A200001A   SB ZERO, 26(S0)
9D001AC0  A200001B   SB ZERO, 27(S0)
9D001AC4  A2000014   SB ZERO, 20(S0)
9D001AC8  A2000015   SB ZERO, 21(S0)
2242:                			dj.fs->wflag = 1;
9D001ACC  8FA40010   LW A0, 16(SP)
9D001AD0  24020001   ADDIU V0, ZERO, 1
2243:                			if (cl) { /* Remove the cluster chain if exist */
9D001AD4  1260004C   BEQ S3, ZERO, 0x9D001C08
9D001AD8  A0820004   SB V0, 4(A0)
2244:                				dw = dj.fs->winsect;
9D001ADC  8C940030   LW S4, 48(A0)
2245:                				res = remove_chain(dj.fs, cl);
9D001AE0  0F4004E9   JAL remove_chain
9D001AE4  02602821   ADDU A1, S3, ZERO
2246:                				if (res == FR_OK) {
9D001AE8  1440004A   BNE V0, ZERO, 0x9D001C14
9D001AEC  8FBF004C   LW RA, 76(SP)
2247:                					dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
9D001AF0  8FA40010   LW A0, 16(SP)
9D001AF4  2673FFFF   ADDIU S3, S3, -1
9D001AF8  AC93000C   SW S3, 12(A0)
2248:                					res = move_window(dj.fs, dw);
9D001AFC  0F40006F   JAL move_window
9D001B00  02802821   ADDU A1, S4, ZERO
9D001B04  0B4006CF   J 0x9D001B3C
9D001B08  00000000   NOP
2249:                				}
2250:                			}
2251:                		}
2252:                	} else { /* Open an existing file */
2253:                		if (res == FR_OK) { /* Follow succeeded */
2254:                			if (dir[DIR_Attr] & AM_DIR) { /* It is a directory */
9D001B0C  308400FF   ANDI A0, A0, 255
9D001B10  1480003F   BNE A0, ZERO, 0x9D001C10
9D001B14  24020004   ADDIU V0, ZERO, 4
9D001BEC  0B4006C3   J 0x9D001B0C
9D001BF0  30640010   ANDI A0, V1, 16
2255:                				res = FR_NO_FILE;
2256:                			} else {
2257:                				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
9D001B18  32730002   ANDI S3, S3, 2
9D001B1C  327300FF   ANDI S3, S3, 255
9D001B20  52600008   BEQL S3, ZERO, 0x9D001B44
9D001B24  00001021   ADDU V0, ZERO, ZERO
9D001B28  30630001   ANDI V1, V1, 1
9D001B2C  14600038   BNE V1, ZERO, 0x9D001C10
9D001B30  24020007   ADDIU V0, ZERO, 7
9D001B34  0B4006D1   J 0x9D001B44
9D001B38  00001021   ADDU V0, ZERO, ZERO
2258:                					res = FR_DENIED;
2259:                			}
2260:                		}
2261:                	}
2262:                	if (res == FR_OK) {
9D001B3C  14400035   BNE V0, ZERO, 0x9D001C14
9D001B40  8FBF004C   LW RA, 76(SP)
2263:                		if (mode & FA_CREATE_ALWAYS) /* Set file change flag if created or overwritten */
9D001B44  32440008   ANDI A0, S2, 8
9D001B48  308400FF   ANDI A0, A0, 255
2264:                			mode |= FA__WRITTEN;
9D001B4C  36430020   ORI V1, S2, 32
9D001B50  0064900B   MOVN S2, V1, A0
2265:                		fp->dir_sect = dj.fs->winsect; /* Pointer to the directory entry */
9D001B54  8FA30010   LW V1, 16(SP)
9D001B58  8C640030   LW A0, 48(V1)
9D001B5C  AE24001C   SW A0, 28(S1)
2266:                		fp->dir_ptr = dir;
9D001B60  AE300020   SW S0, 32(S1)
2267:                #if _FS_SHARE
2268:                		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
2269:                		if (!fp->lockid) res = FR_INT_ERR;
2270:                #endif
2271:                	}
2272:                
2273:                #else				/* R/O configuration */
2274:                	if (res == FR_OK) { /* Follow succeeded */
2275:                		if (!dir) { /* Current dir itself */
2276:                			res = FR_INVALID_NAME;
2277:                		} else {
2278:                			if (dir[DIR_Attr] & AM_DIR) /* It is a directory */
2279:                			res = FR_NO_FILE;
2280:                		}
2281:                	}
2282:                #endif
2283:                	FREE_BUF();
2284:                
2285:                	if (res == FR_OK) {
2286:                		fp->flag = mode; /* File access mode */
9D001B64  A2320006   SB S2, 6(S1)
2287:                		fp->sclust = LD_CLUST(dir); /* File start cluster */
9D001B68  92050015   LBU A1, 21(S0)
9D001B6C  00052A00   SLL A1, A1, 8
9D001B70  92040014   LBU A0, 20(S0)
9D001B74  00A42825   OR A1, A1, A0
9D001B78  00052C00   SLL A1, A1, 16
9D001B7C  9204001B   LBU A0, 27(S0)
9D001B80  00042200   SLL A0, A0, 8
9D001B84  9206001A   LBU A2, 26(S0)
9D001B88  00862025   OR A0, A0, A2
9D001B8C  00A42025   OR A0, A1, A0
9D001B90  AE240010   SW A0, 16(S1)
2288:                		fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
9D001B94  9205001F   LBU A1, 31(S0)
9D001B98  00052E00   SLL A1, A1, 24
9D001B9C  9204001E   LBU A0, 30(S0)
9D001BA0  00042400   SLL A0, A0, 16
9D001BA4  00A42025   OR A0, A1, A0
9D001BA8  9205001C   LBU A1, 28(S0)
9D001BAC  00852025   OR A0, A0, A1
9D001BB0  9205001D   LBU A1, 29(S0)
9D001BB4  00052A00   SLL A1, A1, 8
9D001BB8  00852025   OR A0, A0, A1
9D001BBC  AE24000C   SW A0, 12(S1)
2289:                		fp->fptr = 0; /* File pointer */
9D001BC0  AE200008   SW ZERO, 8(S1)
2290:                		fp->dsect = 0;
9D001BC4  AE200018   SW ZERO, 24(S1)
2291:                #if _USE_FASTSEEK
2292:                		fp->cltbl = 0; /* Normal seek mode */
9D001BC8  AE200024   SW ZERO, 36(S1)
2293:                #endif
2294:                		fp->fs = dj.fs;
9D001BCC  AE230000   SW V1, 0(S1)
2295:                		fp->id = dj.fs->id; /* Validate file object */
9D001BD0  94630006   LHU V1, 6(V1)
9D001BD4  0B400704   J 0x9D001C10
9D001BD8  A6230004   SH V1, 4(S1)
2296:                	}
2297:                
2298:                	LEAVE_FF(dj.fs, res);
2299:                }
9D001C10  8FBF004C   LW RA, 76(SP)
9D001C14  8FB40048   LW S4, 72(SP)
9D001C18  8FB30044   LW S3, 68(SP)
9D001C1C  8FB20040   LW S2, 64(SP)
9D001C20  8FB1003C   LW S1, 60(SP)
9D001C24  8FB00038   LW S0, 56(SP)
9D001C28  03E00008   JR RA
9D001C2C  27BD0050   ADDIU SP, SP, 80
2300:                
2301:                /*-----------------------------------------------------------------------*/
2302:                /* Read File                                                             */
2303:                /*-----------------------------------------------------------------------*/
2304:                
2305:                FRESULT f_read(FIL *fp, /* Pointer to the file object */
2306:                                void *buff, /* Pointer to data buffer */
2307:                                UINT btr, /* Number of bytes to read */
2308:                                UINT *br /* Pointer to number of bytes read */
2309:                                ) {
9D001C30  27BDFFC8   ADDIU SP, SP, -56
9D001C34  AFBF0034   SW RA, 52(SP)
9D001C38  AFBE0030   SW S8, 48(SP)
9D001C3C  AFB7002C   SW S7, 44(SP)
9D001C40  AFB60028   SW S6, 40(SP)
9D001C44  AFB50024   SW S5, 36(SP)
9D001C48  AFB40020   SW S4, 32(SP)
9D001C4C  AFB3001C   SW S3, 28(SP)
9D001C50  AFB20018   SW S2, 24(SP)
9D001C54  AFB10014   SW S1, 20(SP)
9D001C58  AFB00010   SW S0, 16(SP)
9D001C5C  00808021   ADDU S0, A0, ZERO
9D001C60  00A09821   ADDU S3, A1, ZERO
9D001C64  00C0A021   ADDU S4, A2, ZERO
9D001C68  00E09021   ADDU S2, A3, ZERO
2310:                	FRESULT res;
2311:                	DWORD clst, sect, remain;
2312:                	UINT rcnt, cc;
2313:                	PF_BYTE csect, *rbuff = buff;
2314:                
2315:                	*br = 0; /* Initialize byte counter */
9D001C6C  ACE00000   SW ZERO, 0(A3)
2316:                
2317:                	res = validate(fp->fs, fp->id); /* Check validity */
9D001C70  8C840000   LW A0, 0(A0)
9D001C74  0F4000E7   JAL validate
9D001C78  96050004   LHU A1, 4(S0)
9D001C7C  00401821   ADDU V1, V0, ZERO
2318:                	if (res != FR_OK)
9D001C80  1460008C   BNE V1, ZERO, 0x9D001EB4
9D001C84  8FBF0034   LW RA, 52(SP)
2319:                		LEAVE_FF(fp->fs, res);
2320:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D001C88  92030006   LBU V1, 6(S0)
9D001C8C  7C032420   SEB A0, V1
9D001C90  04800087   BLTZ A0, 0x9D001EB0
9D001C94  24020002   ADDIU V0, ZERO, 2
2321:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2322:                	if (!(fp->flag & FA_READ)) /* Check access mode */
9D001C98  30630001   ANDI V1, V1, 1
9D001C9C  10600084   BEQ V1, ZERO, 0x9D001EB0
9D001CA0  24020007   ADDIU V0, ZERO, 7
2323:                		LEAVE_FF(fp->fs, FR_DENIED);
2324:                	remain = fp->fsize - fp->fptr;
9D001CA4  8E11000C   LW S1, 12(S0)
9D001CA8  8E020008   LW V0, 8(S0)
9D001CAC  02228823   SUBU S1, S1, V0
9D001CB0  0234102B   SLTU V0, S1, S4
9D001CB4  0282880A   MOVZ S1, S4, V0
2325:                	if (btr > remain)
2326:                		btr = (UINT) remain; /* Truncate btr by remaining bytes */
2327:                
2328:                	for (;btr; /* Repeat until all data read */
9D001CB8  1220007C   BEQ S1, ZERO, 0x9D001EAC
9D001CBC  241E0200   ADDIU S8, ZERO, 512
9D001E9C  1620FF88   BNE S1, ZERO, 0x9D001CC0
9D001EA0  AE420000   SW V0, 0(S2)
9D001EA4  0B4007AC   J 0x9D001EB0
9D001EA8  00001021   ADDU V0, ZERO, ZERO
9D001EAC  00001021   ADDU V0, ZERO, ZERO
2329:                	rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
9D001E80  02749821   ADDU S3, S3, S4
9D001E84  8E020008   LW V0, 8(S0)
9D001E88  00541021   ADDU V0, V0, S4
9D001E8C  AE020008   SW V0, 8(S0)
9D001E90  8E420000   LW V0, 0(S2)
9D001E94  00541021   ADDU V0, V0, S4
9D001E98  02348823   SUBU S1, S1, S4
2330:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D001CC0  8E050008   LW A1, 8(S0)
9D001CC4  30A201FF   ANDI V0, A1, 511
9D001CC8  54400057   BNEL V0, ZERO, 0x9D001E28
9D001CCC  8E140008   LW S4, 8(S0)
2331:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D001CD0  8E040000   LW A0, 0(S0)
9D001CD4  0005AA42   SRL S5, A1, 9
9D001CD8  90820002   LBU V0, 2(A0)
9D001CDC  2442FFFF   ADDIU V0, V0, -1
9D001CE0  02A2A824   AND S5, S5, V0
9D001CE4  32B500FF   ANDI S5, S5, 255
2332:                			if (!csect) { /* On the cluster boundary? */
9D001CE8  56A0001F   BNEL S5, ZERO, 0x9D001D68
9D001CEC  8E160000   LW S6, 0(S0)
2333:                				if (fp->fptr == 0) { /* On the top of the file? */
9D001CF0  54A00003   BNEL A1, ZERO, 0x9D001D00
9D001CF4  8E020024   LW V0, 36(S0)
9D001CF8  0B400748   J 0x9D001D20
9D001CFC  8E020010   LW V0, 16(S0)
2334:                					clst = fp->sclust; /* Follow from the origin */
2335:                				} else { /* Middle or end of the file */
2336:                #if _USE_FASTSEEK
2337:                					if (fp->cltbl)
9D001D00  10400005   BEQ V0, ZERO, 0x9D001D18
9D001D04  00000000   NOP
2338:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D001D08  0F400009   JAL clmt_clust
9D001D0C  02002021   ADDU A0, S0, ZERO
9D001D10  0B400749   J 0x9D001D24
9D001D14  2C430002   SLTIU V1, V0, 2
2339:                					else
2340:                #endif
2341:                						clst = get_fat(fp->fs, fp->clust); /* Follow cluster chain on the FAT */
9D001D18  0F40014E   JAL get_fat
9D001D1C  8E050014   LW A1, 20(S0)
2342:                				}
2343:                				if (clst < 2)
9D001D20  2C430002   SLTIU V1, V0, 2
9D001D24  10600007   BEQ V1, ZERO, 0x9D001D44
9D001D28  2403FFFF   ADDIU V1, ZERO, -1
2344:                					ABORT(fp->fs, FR_INT_ERR);
9D001D2C  92030006   LBU V1, 6(S0)
9D001D30  2402FF80   ADDIU V0, ZERO, -128
9D001D34  00621025   OR V0, V1, V0
9D001D38  A2020006   SB V0, 6(S0)
9D001D3C  0B4007AC   J 0x9D001EB0
9D001D40  24020002   ADDIU V0, ZERO, 2
2345:                				if (clst == 0xFFFFFFFF)
9D001D44  54430007   BNEL V0, V1, 0x9D001D64
9D001D48  AE020014   SW V0, 20(S0)
2346:                					ABORT(fp->fs, FR_DISK_ERR);
9D001D4C  92030006   LBU V1, 6(S0)
9D001D50  2402FF80   ADDIU V0, ZERO, -128
9D001D54  00621025   OR V0, V1, V0
9D001D58  A2020006   SB V0, 6(S0)
9D001D5C  0B4007AC   J 0x9D001EB0
9D001D60  24020001   ADDIU V0, ZERO, 1
2347:                				fp->clust = clst; /* Update current cluster */
2348:                			}
2349:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D001D64  8E160000   LW S6, 0(S0)
9D001D68  02C02021   ADDU A0, S6, ZERO
9D001D6C  0F400142   JAL clust2sect
9D001D70  8E050014   LW A1, 20(S0)
2350:                			if (!sect)
9D001D74  14400007   BNE V0, ZERO, 0x9D001D94
9D001D78  0011A242   SRL S4, S1, 9
2351:                				ABORT(fp->fs, FR_INT_ERR);
9D001D7C  92030006   LBU V1, 6(S0)
9D001D80  2402FF80   ADDIU V0, ZERO, -128
9D001D84  00621025   OR V0, V1, V0
9D001D88  A2020006   SB V0, 6(S0)
9D001D8C  0B4007AC   J 0x9D001EB0
9D001D90  24020002   ADDIU V0, ZERO, 2
2352:                			sect += csect;
2353:                			cc = btr / SS(fp->fs); /* When remaining bytes >= sector size, */
2354:                			if (cc) { /* Read maximum contiguous sectors directly */
9D001D94  12800022   BEQ S4, ZERO, 0x9D001E20
9D001D98  0055B821   ADDU S7, V0, S5
2355:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D001D9C  92C20002   LBU V0, 2(S6)
9D001DA0  02951821   ADDU V1, S4, S5
9D001DA4  0043182B   SLTU V1, V0, V1
2356:                					cc = fp->fs->csize - csect;
9D001DA8  0055A823   SUBU S5, V0, S5
9D001DAC  02A3A00B   MOVN S4, S5, V1
2357:                				if (disk_read(fp->fs->drv, rbuff, sect, (PF_BYTE) cc) != RES_OK)
9D001DB0  92C40001   LBU A0, 1(S6)
9D001DB4  02602821   ADDU A1, S3, ZERO
9D001DB8  02E03021   ADDU A2, S7, ZERO
9D001DBC  0F402F71   JAL disk_read
9D001DC0  328700FF   ANDI A3, S4, 255
9D001DC4  50400007   BEQL V0, ZERO, 0x9D001DE4
9D001DC8  8E050000   LW A1, 0(S0)
2358:                					ABORT(fp->fs, FR_DISK_ERR);
9D001DCC  92030006   LBU V1, 6(S0)
9D001DD0  2402FF80   ADDIU V0, ZERO, -128
9D001DD4  00621025   OR V0, V1, V0
9D001DD8  A2020006   SB V0, 6(S0)
9D001DDC  0B4007AC   J 0x9D001EB0
9D001DE0  24020001   ADDIU V0, ZERO, 1
2359:                #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
2360:                #if _FS_TINY
2361:                				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
9D001DE4  90A20004   LBU V0, 4(A1)
9D001DE8  50400025   BEQL V0, ZERO, 0x9D001E80
9D001DEC  0014A240   SLL S4, S4, 9
9D001DF0  8CA20030   LW V0, 48(A1)
9D001DF4  0057B823   SUBU S7, V0, S7
9D001DF8  02F4102B   SLTU V0, S7, S4
9D001DFC  50400020   BEQL V0, ZERO, 0x9D001E80
9D001E00  0014A240   SLL S4, S4, 9
2362:                				mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
9D001E04  00172240   SLL A0, S7, 9
9D001E08  02642021   ADDU A0, S3, A0
9D001E0C  24A50034   ADDIU A1, A1, 52
9D001E10  0F400000   JAL mem_cpy
9D001E14  03C03021   ADDU A2, S8, ZERO
2363:                #else
2364:                				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
2365:                					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf,
2366:                							SS(fp->fs));
2367:                #endif
2368:                #endif
2369:                				rcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2370:                				continue;
9D001E18  0B4007A0   J 0x9D001E80
9D001E1C  0014A240   SLL S4, S4, 9
2371:                			}
2372:                #if !_FS_TINY
2373:                			if (fp->dsect != sect) { /* Load data sector if not in cache */
2374:                #if !_FS_READONLY
2375:                				if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2376:                					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2377:                							!= RES_OK)
2378:                						ABORT(fp->fs, FR_DISK_ERR);
2379:                					fp->flag &= ~FA__DIRTY;
2380:                				}
2381:                #endif
2382:                				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK) /* Fill sector cache */
2383:                					ABORT(fp->fs, FR_DISK_ERR);
2384:                			}
2385:                #endif
2386:                			fp->dsect = sect;
9D001E20  AE170018   SW S7, 24(S0)
2387:                		}
2388:                		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs)); /* Get partial sector data from sector buffer */
9D001E24  8E140008   LW S4, 8(S0)
9D001E28  329401FF   ANDI S4, S4, 511
9D001E2C  03D4A023   SUBU S4, S8, S4
9D001E30  0291102B   SLTU V0, S4, S1
9D001E34  0222A00A   MOVZ S4, S1, V0
2389:                		if (rcnt > btr)
2390:                			rcnt = btr;
2391:                #if _FS_TINY
2392:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D001E38  8E040000   LW A0, 0(S0)
9D001E3C  0F40006F   JAL move_window
9D001E40  8E050018   LW A1, 24(S0)
9D001E44  50400007   BEQL V0, ZERO, 0x9D001E64
9D001E48  8E050008   LW A1, 8(S0)
2393:                		ABORT(fp->fs, FR_DISK_ERR);
9D001E4C  92030006   LBU V1, 6(S0)
9D001E50  2402FF80   ADDIU V0, ZERO, -128
9D001E54  00621025   OR V0, V1, V0
9D001E58  A2020006   SB V0, 6(S0)
9D001E5C  0B4007AC   J 0x9D001EB0
9D001E60  24020001   ADDIU V0, ZERO, 1
2394:                		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
9D001E64  30A501FF   ANDI A1, A1, 511
9D001E68  8E020000   LW V0, 0(S0)
9D001E6C  00452821   ADDU A1, V0, A1
9D001E70  02602021   ADDU A0, S3, ZERO
9D001E74  24A50034   ADDIU A1, A1, 52
9D001E78  0F400000   JAL mem_cpy
9D001E7C  02803021   ADDU A2, S4, ZERO
2395:                #else
2396:                		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
2397:                #endif
2398:                	}
2399:                
2400:                	LEAVE_FF(fp->fs, FR_OK);
2401:                }
9D001EB0  8FBF0034   LW RA, 52(SP)
9D001EB4  8FBE0030   LW S8, 48(SP)
9D001EB8  8FB7002C   LW S7, 44(SP)
9D001EBC  8FB60028   LW S6, 40(SP)
9D001EC0  8FB50024   LW S5, 36(SP)
9D001EC4  8FB40020   LW S4, 32(SP)
9D001EC8  8FB3001C   LW S3, 28(SP)
9D001ECC  8FB20018   LW S2, 24(SP)
9D001ED0  8FB10014   LW S1, 20(SP)
9D001ED4  8FB00010   LW S0, 16(SP)
9D001ED8  03E00008   JR RA
9D001EDC  27BD0038   ADDIU SP, SP, 56
2402:                
2403:                #if !_FS_READONLY
2404:                /*-----------------------------------------------------------------------*/
2405:                /* Write File                                                            */
2406:                /*-----------------------------------------------------------------------*/
2407:                
2408:                FRESULT f_write(FIL *fp, /* Pointer to the file object */
2409:                                const void *buff, /* Pointer to the data to be written */
2410:                                UINT btw, /* Number of bytes to write */
2411:                                UINT *bw /* Pointer to number of bytes written */
2412:                                ) {
9D001EE0  27BDFFC8   ADDIU SP, SP, -56
9D001EE4  AFBF0034   SW RA, 52(SP)
9D001EE8  AFBE0030   SW S8, 48(SP)
9D001EEC  AFB7002C   SW S7, 44(SP)
9D001EF0  AFB60028   SW S6, 40(SP)
9D001EF4  AFB50024   SW S5, 36(SP)
9D001EF8  AFB40020   SW S4, 32(SP)
9D001EFC  AFB3001C   SW S3, 28(SP)
9D001F00  AFB20018   SW S2, 24(SP)
9D001F04  AFB10014   SW S1, 20(SP)
9D001F08  AFB00010   SW S0, 16(SP)
9D001F0C  00808021   ADDU S0, A0, ZERO
9D001F10  00A09821   ADDU S3, A1, ZERO
9D001F14  00C08821   ADDU S1, A2, ZERO
9D001F18  00E09021   ADDU S2, A3, ZERO
2413:                	FRESULT res;
2414:                	DWORD clst, sect;
2415:                	UINT wcnt, cc;
2416:                	const PF_BYTE *wbuff = buff;
2417:                	PF_BYTE csect;
2418:                
2419:                	*bw = 0; /* Initialize byte counter */
9D001F1C  ACE00000   SW ZERO, 0(A3)
2420:                
2421:                	res = validate(fp->fs, fp->id); /* Check validity */
9D001F20  8C840000   LW A0, 0(A0)
9D001F24  0F4000E7   JAL validate
9D001F28  96050004   LHU A1, 4(S0)
9D001F2C  00401821   ADDU V1, V0, ZERO
2422:                	if (res != FR_OK)
9D001F30  146000BA   BNE V1, ZERO, 0x9D00221C
9D001F34  8FBF0034   LW RA, 52(SP)
2423:                		LEAVE_FF(fp->fs, res);
2424:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D001F38  92030006   LBU V1, 6(S0)
9D001F3C  7C032420   SEB A0, V1
9D001F40  048000B5   BLTZ A0, 0x9D002218
9D001F44  24020002   ADDIU V0, ZERO, 2
2425:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2426:                	if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D001F48  30630002   ANDI V1, V1, 2
9D001F4C  306300FF   ANDI V1, V1, 255
9D001F50  106000B1   BEQ V1, ZERO, 0x9D002218
9D001F54  24020007   ADDIU V0, ZERO, 7
2427:                		LEAVE_FF(fp->fs, FR_DENIED);
2428:                	if ((DWORD) (fp->fsize + btw) < fp->fsize)
9D001F58  8E02000C   LW V0, 12(S0)
9D001F5C  02221821   ADDU V1, S1, V0
9D001F60  0062102B   SLTU V0, V1, V0
9D001F64  544000A4   BNEL V0, ZERO, 0x9D0021F8
9D001F68  8E020008   LW V0, 8(S0)
2429:                		btw = 0; /* File size cannot reach 4GB */
2430:                
2431:                	for (; btw; /* Repeat until all data written */
9D001F6C  122000A1   BEQ S1, ZERO, 0x9D0021F4
9D001F70  241E0200   ADDIU S8, ZERO, 512
9D0021EC  1620FF61   BNE S1, ZERO, 0x9D001F74
9D0021F0  AE420000   SW V0, 0(S2)
2432:                	wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
9D0021D0  02749821   ADDU S3, S3, S4
9D0021D4  8E020008   LW V0, 8(S0)
9D0021D8  00541021   ADDU V0, V0, S4
9D0021DC  AE020008   SW V0, 8(S0)
9D0021E0  8E420000   LW V0, 0(S2)
9D0021E4  00541021   ADDU V0, V0, S4
9D0021E8  02348823   SUBU S1, S1, S4
2433:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D001F74  8E050008   LW A1, 8(S0)
9D001F78  30A201FF   ANDI V0, A1, 511
9D001F7C  5440007B   BNEL V0, ZERO, 0x9D00216C
9D001F80  8E140008   LW S4, 8(S0)
2434:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D001F84  8E040000   LW A0, 0(S0)
9D001F88  0005AA42   SRL S5, A1, 9
9D001F8C  90820002   LBU V0, 2(A0)
9D001F90  2442FFFF   ADDIU V0, V0, -1
9D001F94  02A2A824   AND S5, S5, V0
9D001F98  32B500FF   ANDI S5, S5, 255
2435:                			if (!csect) { /* On the cluster boundary? */
9D001F9C  56A00026   BNEL S5, ZERO, 0x9D002038
9D001FA0  8C830030   LW V1, 48(A0)
2436:                				if (fp->fptr == 0) { /* On the top of the file? */
9D001FA4  54A00008   BNEL A1, ZERO, 0x9D001FC8
9D001FA8  8E020024   LW V0, 36(S0)
2437:                					clst = fp->sclust; /* Follow from the origin */
9D001FAC  8E020010   LW V0, 16(S0)
2438:                					if (clst == 0) /* When no cluster is allocated, */
9D001FB0  1440000F   BNE V0, ZERO, 0x9D001FF0
9D001FB4  24030001   ADDIU V1, ZERO, 1
2439:                						fp->sclust = clst = create_chain(fp->fs, 0); /* Create a new cluster chain */
9D001FB8  0F400284   JAL create_chain
9D001FBC  00000000   NOP
9D001FC0  0B4007FA   J 0x9D001FE8
9D001FC4  AE020010   SW V0, 16(S0)
2440:                				} else { /* Middle or end of the file */
2441:                #if _USE_FASTSEEK
2442:                					if (fp->cltbl)
9D001FC8  10400005   BEQ V0, ZERO, 0x9D001FE0
9D001FCC  00000000   NOP
2443:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D001FD0  0F400009   JAL clmt_clust
9D001FD4  02002021   ADDU A0, S0, ZERO
9D001FD8  0B4007FA   J 0x9D001FE8
9D001FDC  00000000   NOP
2444:                					else
2445:                #endif
2446:                						clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
9D001FE0  0F400284   JAL create_chain
9D001FE4  8E050014   LW A1, 20(S0)
2447:                				}
2448:                				if (clst == 0)
9D001FE8  10400082   BEQ V0, ZERO, 0x9D0021F4
9D001FEC  24030001   ADDIU V1, ZERO, 1
2449:                					break; /* Could not allocate a new cluster (disk full) */
2450:                				if (clst == 1)
9D001FF0  14430007   BNE V0, V1, 0x9D002010
9D001FF4  2403FFFF   ADDIU V1, ZERO, -1
2451:                					ABORT(fp->fs, FR_INT_ERR);
9D001FF8  92030006   LBU V1, 6(S0)
9D001FFC  2402FF80   ADDIU V0, ZERO, -128
9D002000  00621025   OR V0, V1, V0
9D002004  A2020006   SB V0, 6(S0)
9D002008  0B400886   J 0x9D002218
9D00200C  24020002   ADDIU V0, ZERO, 2
2452:                				if (clst == 0xFFFFFFFF)
9D002010  54430007   BNEL V0, V1, 0x9D002030
9D002014  AE020014   SW V0, 20(S0)
2453:                					ABORT(fp->fs, FR_DISK_ERR);
9D002018  92030006   LBU V1, 6(S0)
9D00201C  2402FF80   ADDIU V0, ZERO, -128
9D002020  00621025   OR V0, V1, V0
9D002024  A2020006   SB V0, 6(S0)
9D002028  0B400886   J 0x9D002218
9D00202C  24020001   ADDIU V0, ZERO, 1
2454:                				fp->clust = clst; /* Update current cluster */
2455:                			}
2456:                #if _FS_TINY
2457:                			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0)) /* Write-back sector cache */
9D002030  8E040000   LW A0, 0(S0)
9D002034  8C830030   LW V1, 48(A0)
9D002038  8E020018   LW V0, 24(S0)
9D00203C  5462000B   BNEL V1, V0, 0x9D00206C
9D002040  8E160000   LW S6, 0(S0)
9D002044  0F40006F   JAL move_window
9D002048  00002821   ADDU A1, ZERO, ZERO
9D00204C  50400007   BEQL V0, ZERO, 0x9D00206C
9D002050  8E160000   LW S6, 0(S0)
2458:                			ABORT(fp->fs, FR_DISK_ERR);
9D002054  92030006   LBU V1, 6(S0)
9D002058  2402FF80   ADDIU V0, ZERO, -128
9D00205C  00621025   OR V0, V1, V0
9D002060  A2020006   SB V0, 6(S0)
9D002064  0B400886   J 0x9D002218
9D002068  24020001   ADDIU V0, ZERO, 1
2459:                #else
2460:                			if (fp->flag & FA__DIRTY) { /* Write-back sector cache */
2461:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2462:                					ABORT(fp->fs, FR_DISK_ERR);
2463:                				fp->flag &= ~FA__DIRTY;
2464:                			}
2465:                #endif
2466:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D00206C  02C02021   ADDU A0, S6, ZERO
9D002070  0F400142   JAL clust2sect
9D002074  8E050014   LW A1, 20(S0)
2467:                			if (!sect)
9D002078  14400007   BNE V0, ZERO, 0x9D002098
9D00207C  0011A242   SRL S4, S1, 9
2468:                				ABORT(fp->fs, FR_INT_ERR);
9D002080  92030006   LBU V1, 6(S0)
9D002084  2402FF80   ADDIU V0, ZERO, -128
9D002088  00621025   OR V0, V1, V0
9D00208C  A2020006   SB V0, 6(S0)
9D002090  0B400886   J 0x9D002218
9D002094  24020002   ADDIU V0, ZERO, 2
2469:                			sect += csect;
2470:                			cc = btw / SS(fp->fs); /* When remaining bytes >= sector size, */
2471:                			if (cc) { /* Write maximum contiguous sectors directly */
9D002098  12800021   BEQ S4, ZERO, 0x9D002120
9D00209C  0055B821   ADDU S7, V0, S5
2472:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D0020A0  92C20002   LBU V0, 2(S6)
9D0020A4  02951821   ADDU V1, S4, S5
9D0020A8  0043182B   SLTU V1, V0, V1
2473:                					cc = fp->fs->csize - csect;
9D0020AC  0055A823   SUBU S5, V0, S5
9D0020B0  02A3A00B   MOVN S4, S5, V1
2474:                				if (disk_write(fp->fs->drv, wbuff, sect, (PF_BYTE) cc)
9D0020B4  92C40001   LBU A0, 1(S6)
9D0020B8  02602821   ADDU A1, S3, ZERO
9D0020BC  02E03021   ADDU A2, S7, ZERO
9D0020C0  0F402FA8   JAL disk_write
9D0020C4  328700FF   ANDI A3, S4, 255
9D0020C8  50400007   BEQL V0, ZERO, 0x9D0020E8
9D0020CC  8E040000   LW A0, 0(S0)
2475:                						!= RES_OK)
2476:                					ABORT(fp->fs, FR_DISK_ERR);
9D0020D0  92030006   LBU V1, 6(S0)
9D0020D4  2402FF80   ADDIU V0, ZERO, -128
9D0020D8  00621025   OR V0, V1, V0
9D0020DC  A2020006   SB V0, 6(S0)
9D0020E0  0B400886   J 0x9D002218
9D0020E4  24020001   ADDIU V0, ZERO, 1
2477:                #if _FS_TINY
2478:                				if (fp->fs->winsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
9D0020E8  8C820030   LW V0, 48(A0)
9D0020EC  0057B823   SUBU S7, V0, S7
9D0020F0  02F4102B   SLTU V0, S7, S4
9D0020F4  50400036   BEQL V0, ZERO, 0x9D0021D0
9D0020F8  0014A240   SLL S4, S4, 9
2479:                					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
9D0020FC  00172A40   SLL A1, S7, 9
9D002100  24840034   ADDIU A0, A0, 52
9D002104  02652821   ADDU A1, S3, A1
9D002108  0F400000   JAL mem_cpy
9D00210C  03C03021   ADDU A2, S8, ZERO
2480:                					fp->fs->wflag = 0;
9D002110  8E020000   LW V0, 0(S0)
9D002114  A0400004   SB ZERO, 4(V0)
2481:                				}
2482:                #else
2483:                				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
2484:                					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)),
2485:                							SS(fp->fs));
2486:                					fp->flag &= ~FA__DIRTY;
2487:                				}
2488:                #endif
2489:                				wcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2490:                				continue;
9D002118  0B400874   J 0x9D0021D0
9D00211C  0014A240   SLL S4, S4, 9
2491:                			}
2492:                #if _FS_TINY
2493:                			if (fp->fptr >= fp->fsize) { /* Avoid silly cache filling at growing edge */
9D002120  8E030008   LW V1, 8(S0)
9D002124  8E02000C   LW V0, 12(S0)
9D002128  0062102B   SLTU V0, V1, V0
9D00212C  5440000E   BNEL V0, ZERO, 0x9D002168
9D002130  AE170018   SW S7, 24(S0)
2494:                				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
9D002134  02C02021   ADDU A0, S6, ZERO
9D002138  0F40006F   JAL move_window
9D00213C  00002821   ADDU A1, ZERO, ZERO
9D002140  50400007   BEQL V0, ZERO, 0x9D002160
9D002144  8E020000   LW V0, 0(S0)
9D002148  92030006   LBU V1, 6(S0)
9D00214C  2402FF80   ADDIU V0, ZERO, -128
9D002150  00621025   OR V0, V1, V0
9D002154  A2020006   SB V0, 6(S0)
9D002158  0B400886   J 0x9D002218
9D00215C  24020001   ADDIU V0, ZERO, 1
2495:                				fp->fs->winsect = sect;
9D002160  AC570030   SW S7, 48(V0)
2496:                			}
2497:                #else
2498:                			if (fp->dsect != sect) { /* Fill sector cache with file data */
2499:                				if (fp->fptr < fp->fsize && disk_read(fp->fs->drv, fp->buf,
2500:                						sect, 1) != RES_OK)
2501:                					ABORT(fp->fs, FR_DISK_ERR);
2502:                			}
2503:                #endif
2504:                			fp->dsect = sect;
9D002164  AE170018   SW S7, 24(S0)
2505:                		}
2506:                		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
9D002168  8E140008   LW S4, 8(S0)
9D00216C  329401FF   ANDI S4, S4, 511
9D002170  03D4A023   SUBU S4, S8, S4
9D002174  0291102B   SLTU V0, S4, S1
9D002178  0222A00A   MOVZ S4, S1, V0
2507:                		if (wcnt > btw)
2508:                			wcnt = btw;
2509:                #if _FS_TINY
2510:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D00217C  8E040000   LW A0, 0(S0)
9D002180  0F40006F   JAL move_window
9D002184  8E050018   LW A1, 24(S0)
9D002188  50400007   BEQL V0, ZERO, 0x9D0021A8
9D00218C  8E040008   LW A0, 8(S0)
2511:                		ABORT(fp->fs, FR_DISK_ERR);
9D002190  92030006   LBU V1, 6(S0)
9D002194  2402FF80   ADDIU V0, ZERO, -128
9D002198  00621025   OR V0, V1, V0
9D00219C  A2020006   SB V0, 6(S0)
9D0021A0  0B400886   J 0x9D002218
9D0021A4  24020001   ADDIU V0, ZERO, 1
2512:                		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
9D0021A8  308401FF   ANDI A0, A0, 511
9D0021AC  8E020000   LW V0, 0(S0)
9D0021B0  00442021   ADDU A0, V0, A0
9D0021B4  24840034   ADDIU A0, A0, 52
9D0021B8  02602821   ADDU A1, S3, ZERO
9D0021BC  0F400000   JAL mem_cpy
9D0021C0  02803021   ADDU A2, S4, ZERO
2513:                		fp->fs->wflag = 1;
9D0021C4  8E020000   LW V0, 0(S0)
9D0021C8  24030001   ADDIU V1, ZERO, 1
9D0021CC  A0430004   SB V1, 4(V0)
2514:                #else
2515:                		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
2516:                		fp->flag |= FA__DIRTY;
2517:                #endif
2518:                	}
2519:                
2520:                	if (fp->fptr > fp->fsize)
9D0021F4  8E020008   LW V0, 8(S0)
9D0021F8  8E03000C   LW V1, 12(S0)
9D0021FC  0062182B   SLTU V1, V1, V0
9D002200  54600001   BNEL V1, ZERO, 0x9D002208
9D002204  AE02000C   SW V0, 12(S0)
2521:                		fp->fsize = fp->fptr; /* Update file size if needed */
2522:                	fp->flag |= FA__WRITTEN; /* Set file change flag */
9D002208  92020006   LBU V0, 6(S0)
9D00220C  34420020   ORI V0, V0, 32
9D002210  A2020006   SB V0, 6(S0)
2523:                
2524:                	LEAVE_FF(fp->fs, FR_OK);
9D002214  00001021   ADDU V0, ZERO, ZERO
2525:                }
9D002218  8FBF0034   LW RA, 52(SP)
9D00221C  8FBE0030   LW S8, 48(SP)
9D002220  8FB7002C   LW S7, 44(SP)
9D002224  8FB60028   LW S6, 40(SP)
9D002228  8FB50024   LW S5, 36(SP)
9D00222C  8FB40020   LW S4, 32(SP)
9D002230  8FB3001C   LW S3, 28(SP)
9D002234  8FB20018   LW S2, 24(SP)
9D002238  8FB10014   LW S1, 20(SP)
9D00223C  8FB00010   LW S0, 16(SP)
9D002240  03E00008   JR RA
9D002244  27BD0038   ADDIU SP, SP, 56
2526:                
2527:                /*-----------------------------------------------------------------------*/
2528:                /* Synchronize the File Object                                           */
2529:                /*-----------------------------------------------------------------------*/
2530:                
2531:                FRESULT f_sync(FIL *fp /* Pointer to the file object */
2532:                ) {
9D002248  27BDFFE0   ADDIU SP, SP, -32
9D00224C  AFBF001C   SW RA, 28(SP)
9D002250  AFB10018   SW S1, 24(SP)
9D002254  AFB00014   SW S0, 20(SP)
9D002258  00808021   ADDU S0, A0, ZERO
2533:                	FRESULT res;
2534:                	DWORD tim;
2535:                	PF_BYTE *dir;
2536:                
2537:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D00225C  8C840000   LW A0, 0(A0)
9D002260  0F4000E7   JAL validate
9D002264  96050004   LHU A1, 4(S0)
2538:                	if (res == FR_OK) {
9D002268  14400033   BNE V0, ZERO, 0x9D002338
9D00226C  8FBF001C   LW RA, 28(SP)
2539:                		if (fp->flag & FA__WRITTEN) { /* Has the file been written? */
9D002270  92030006   LBU V1, 6(S0)
9D002274  30630020   ANDI V1, V1, 32
9D002278  306300FF   ANDI V1, V1, 255
9D00227C  1060002F   BEQ V1, ZERO, 0x9D00233C
9D002280  8FB10018   LW S1, 24(SP)
2540:                #if !_FS_TINY	/* Write-back dirty buffer */
2541:                			if (fp->flag & FA__DIRTY) {
2542:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2543:                					LEAVE_FF(fp->fs, FR_DISK_ERR);
2544:                				fp->flag &= ~FA__DIRTY;
2545:                			}
2546:                #endif
2547:                			/* Update the directory entry */
2548:                			res = move_window(fp->fs, fp->dir_sect);
9D002284  8E040000   LW A0, 0(S0)
9D002288  0F40006F   JAL move_window
9D00228C  8E05001C   LW A1, 28(S0)
2549:                			if (res == FR_OK) {
9D002290  14400029   BNE V0, ZERO, 0x9D002338
9D002294  8FBF001C   LW RA, 28(SP)
2550:                				dir = fp->dir_ptr;
9D002298  8E110020   LW S1, 32(S0)
2551:                				dir[DIR_Attr] |= AM_ARC; /* Set archive bit */
9D00229C  9222000B   LBU V0, 11(S1)
9D0022A0  34420020   ORI V0, V0, 32
9D0022A4  A222000B   SB V0, 11(S1)
2552:                				ST_DWORD(dir+DIR_FileSize, fp->fsize); /* Update file size */
9D0022A8  8E02000C   LW V0, 12(S0)
9D0022AC  A222001C   SB V0, 28(S1)
9D0022B0  9602000C   LHU V0, 12(S0)
9D0022B4  00021202   SRL V0, V0, 8
9D0022B8  A222001D   SB V0, 29(S1)
9D0022BC  9602000E   LHU V0, 14(S0)
9D0022C0  A222001E   SB V0, 30(S1)
9D0022C4  9202000F   LBU V0, 15(S0)
9D0022C8  A222001F   SB V0, 31(S1)
2553:                				ST_CLUST(dir, fp->sclust); /* Update start cluster */
9D0022CC  8E020010   LW V0, 16(S0)
9D0022D0  A222001A   SB V0, 26(S1)
9D0022D4  96020010   LHU V0, 16(S0)
9D0022D8  00021202   SRL V0, V0, 8
9D0022DC  A222001B   SB V0, 27(S1)
9D0022E0  96020012   LHU V0, 18(S0)
9D0022E4  A2220014   SB V0, 20(S1)
9D0022E8  96020012   LHU V0, 18(S0)
9D0022EC  00021202   SRL V0, V0, 8
2554:                				tim = get_fattime(); /* Update updated time */
9D0022F0  0F4030CD   JAL get_fattime
9D0022F4  A2220015   SB V0, 21(S1)
2555:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D0022F8  A2220016   SB V0, 22(S1)
9D0022FC  7C433A00   EXT V1, V0, 8, 8
9D002300  A2230017   SB V1, 23(S1)
9D002304  00021C02   SRL V1, V0, 16
9D002308  A2230018   SB V1, 24(S1)
9D00230C  00021602   SRL V0, V0, 24
9D002310  A2220019   SB V0, 25(S1)
2556:                				fp->flag &= ~FA__WRITTEN;
9D002314  92020006   LBU V0, 6(S0)
9D002318  7C022944   INS V0, ZERO, 5, 1
9D00231C  A2020006   SB V0, 6(S0)
2557:                				fp->fs->wflag = 1;
9D002320  8E020000   LW V0, 0(S0)
9D002324  24030001   ADDIU V1, ZERO, 1
9D002328  A0430004   SB V1, 4(V0)
2558:                				res = sync(fp->fs);
9D00232C  0F4000FE   JAL sync
9D002330  8E040000   LW A0, 0(S0)
2559:                			}
2560:                		}
2561:                	}
2562:                
2563:                	LEAVE_FF(fp->fs, res);
2564:                }
9D002334  8FBF001C   LW RA, 28(SP)
9D002338  8FB10018   LW S1, 24(SP)
9D00233C  8FB00014   LW S0, 20(SP)
9D002340  03E00008   JR RA
9D002344  27BD0020   ADDIU SP, SP, 32
2565:                
2566:                #endif /* !_FS_READONLY */
2567:                
2568:                /*-----------------------------------------------------------------------*/
2569:                /* Close File                                                            */
2570:                /*-----------------------------------------------------------------------*/
2571:                
2572:                FRESULT f_close(FIL *fp /* Pointer to the file object to be closed */
2573:                ) {
9D002348  27BDFFE8   ADDIU SP, SP, -24
9D00234C  AFBF0014   SW RA, 20(SP)
9D002350  AFB00010   SW S0, 16(SP)
2574:                	FRESULT res;
2575:                
2576:                #if _FS_READONLY
2577:                	FATFS *fs = fp->fs;
2578:                	res = validate(fs, fp->id);
2579:                	if (res == FR_OK) fp->fs = 0; /* Discard file object */
2580:                	LEAVE_FF(fs, res);
2581:                
2582:                #else
2583:                	res = f_sync(fp); /* Flush cached data */
9D002354  0F400892   JAL f_sync
9D002358  00808021   ADDU S0, A0, ZERO
2584:                #if _FS_SHARE
2585:                	if (res == FR_OK) { /* Decrement open counter */
2586:                #if _FS_REENTRANT
2587:                		res = validate(fp->fs, fp->id);
2588:                		if (res == FR_OK) {
2589:                			res = dec_lock(fp->lockid);
2590:                			unlock_fs(fp->fs, FR_OK);
2591:                		}
2592:                #else
2593:                		res = dec_lock(fp->lockid);
2594:                #endif
2595:                	}
2596:                #endif
2597:                	if (res == FR_OK)
9D00235C  50400001   BEQL V0, ZERO, 0x9D002364
9D002360  AE000000   SW ZERO, 0(S0)
2598:                		fp->fs = 0; /* Discard file object */
2599:                	return res;
2600:                #endif
2601:                }
9D002364  8FBF0014   LW RA, 20(SP)
9D002368  8FB00010   LW S0, 16(SP)
9D00236C  03E00008   JR RA
9D002370  27BD0018   ADDIU SP, SP, 24
2602:                
2603:                /*-----------------------------------------------------------------------*/
2604:                /* Current Drive/Directory Handlings                                     */
2605:                /*-----------------------------------------------------------------------*/
2606:                
2607:                #if _FS_RPATH >= 1
2608:                
2609:                FRESULT f_chdrive (
2610:                		PF_BYTE drv /* Drive number */
2611:                )
2612:                {
2613:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
9D002374  14800003   BNE A0, ZERO, 0x9D002384
9D002378  2402000B   ADDIU V0, ZERO, 11
2614:                
2615:                	CurrVol = drv;
9D00237C  A3808048   SB ZERO, -32696(GP)
2616:                
2617:                	return FR_OK;
9D002380  00001021   ADDU V0, ZERO, ZERO
2618:                }
9D002384  03E00008   JR RA
9D002388  00000000   NOP
2619:                
2620:                FRESULT f_chdir (
2621:                		const TCHAR *path /* Pointer to the directory path */
2622:                )
2623:                {
9D00238C  27BDFFC0   ADDIU SP, SP, -64
9D002390  AFBF003C   SW RA, 60(SP)
9D002394  AFA40040   SW A0, 64(SP)
2624:                	FRESULT res;
2625:                	DIR dj;
2626:                	DEF_NAMEBUF;
2627:                
2628:                	res = chk_mounted(&path, &dj.fs, 0);
9D002398  27A40040   ADDIU A0, SP, 64
9D00239C  27A50010   ADDIU A1, SP, 16
9D0023A0  0F400521   JAL chk_mounted
9D0023A4  00003021   ADDU A2, ZERO, ZERO
2629:                	if (res == FR_OK) {
9D0023A8  14400023   BNE V0, ZERO, 0x9D002438
9D0023AC  8FBF003C   LW RA, 60(SP)
2630:                		INIT_BUF(dj);
9D0023B0  27A2002C   ADDIU V0, SP, 44
9D0023B4  AFA20028   SW V0, 40(SP)
2631:                		res = follow_path(&dj, path); /* Follow the path */
9D0023B8  27A40010   ADDIU A0, SP, 16
9D0023BC  0F400367   JAL follow_path
9D0023C0  8FA50040   LW A1, 64(SP)
2632:                		FREE_BUF();
2633:                		if (res == FR_OK) { /* Follow completed */
9D0023C4  14400019   BNE V0, ZERO, 0x9D00242C
9D0023C8  38440004   XORI A0, V0, 4
2634:                			if (!dj.dir) {
9D0023CC  8FA30024   LW V1, 36(SP)
9D0023D0  54600005   BNEL V1, ZERO, 0x9D0023E8
9D0023D4  9064000B   LBU A0, 11(V1)
2635:                				dj.fs->cdir = dj.sclust; /* Start directory itself */
9D0023D8  8FA40018   LW A0, 24(SP)
9D0023DC  8FA30010   LW V1, 16(SP)
9D0023E0  0B40090D   J 0x9D002434
9D0023E4  AC640018   SW A0, 24(V1)
2636:                			} else {
2637:                				if (dj.dir[DIR_Attr] & AM_DIR) /* Reached to the directory */
9D0023E8  30840010   ANDI A0, A0, 16
9D0023EC  308400FF   ANDI A0, A0, 255
9D0023F0  50800010   BEQL A0, ZERO, 0x9D002434
9D0023F4  24020005   ADDIU V0, ZERO, 5
2638:                				dj.fs->cdir = LD_CLUST(dj.dir);
9D0023F8  90650015   LBU A1, 21(V1)
9D0023FC  00052A00   SLL A1, A1, 8
9D002400  90640014   LBU A0, 20(V1)
9D002404  00A42825   OR A1, A1, A0
9D002408  00052C00   SLL A1, A1, 16
9D00240C  9064001B   LBU A0, 27(V1)
9D002410  00042200   SLL A0, A0, 8
9D002414  9063001A   LBU V1, 26(V1)
9D002418  00832025   OR A0, A0, V1
9D00241C  00A42025   OR A0, A1, A0
9D002420  8FA30010   LW V1, 16(SP)
9D002424  0B40090D   J 0x9D002434
9D002428  AC640018   SW A0, 24(V1)
2639:                				else
2640:                				res = FR_NO_PATH; /* Reached but a file */
2641:                			}
2642:                		}
2643:                		if (res == FR_NO_FILE) res = FR_NO_PATH;
9D00242C  24030005   ADDIU V1, ZERO, 5
9D002430  0064100A   MOVZ V0, V1, A0
2644:                	}
2645:                
2646:                	LEAVE_FF(dj.fs, res);
2647:                }
9D002434  8FBF003C   LW RA, 60(SP)
9D002438  03E00008   JR RA
9D00243C  27BD0040   ADDIU SP, SP, 64
2648:                
2649:                #if _FS_RPATH >= 2
2650:                FRESULT f_getcwd (
2651:                		TCHAR *path, /* Pointer to the directory path */
2652:                		UINT sz_path /* Size of path */
2653:                )
2654:                {
9D002440  27BDFF90   ADDIU SP, SP, -112
9D002444  AFBF006C   SW RA, 108(SP)
9D002448  AFB60068   SW S6, 104(SP)
9D00244C  AFB50064   SW S5, 100(SP)
9D002450  AFB40060   SW S4, 96(SP)
9D002454  AFB3005C   SW S3, 92(SP)
9D002458  AFB20058   SW S2, 88(SP)
9D00245C  AFB10054   SW S1, 84(SP)
9D002460  AFB00050   SW S0, 80(SP)
9D002464  AFA40070   SW A0, 112(SP)
9D002468  00A0A021   ADDU S4, A1, ZERO
2655:                	FRESULT res;
2656:                	DIR dj;
2657:                	UINT i, n;
2658:                	DWORD ccl;
2659:                	TCHAR *tp;
2660:                	FILINFO fno;
2661:                	DEF_NAMEBUF;
2662:                
2663:                	*path = 0;
9D00246C  A0800000   SB ZERO, 0(A0)
2664:                	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0); /* Get current volume */
9D002470  27A40070   ADDIU A0, SP, 112
9D002474  27A50010   ADDIU A1, SP, 16
9D002478  0F400521   JAL chk_mounted
9D00247C  00003021   ADDU A2, ZERO, ZERO
2665:                	if (res == FR_OK) {
9D002480  14400089   BNE V0, ZERO, 0x9D0026A8
9D002484  00409021   ADDU S2, V0, ZERO
2666:                		INIT_BUF(dj);
9D002488  27A20044   ADDIU V0, SP, 68
9D00248C  AFA20028   SW V0, 40(SP)
2667:                		i = sz_path; /* Bottom of buffer (dir stack base) */
9D0024A0  02808021   ADDU S0, S4, ZERO
2668:                		dj.sclust = dj.fs->cdir; /* Start to follow upper dir from current dir */
9D002490  8FA20010   LW V0, 16(SP)
9D002494  8C560018   LW S6, 24(V0)
2669:                		while ((ccl = dj.sclust) != 0) { /* Repeat while current dir is a sub-dir */
9D002498  12C0007C   BEQ S6, ZERO, 0x9D00268C
9D00249C  AFB60018   SW S6, 24(SP)
9D0025F8  8FB60018   LW S6, 24(SP)
9D0025FC  16C0FFAC   BNE S6, ZERO, 0x9D0024B0
9D002600  27A40010   ADDIU A0, SP, 16
9D002604  0B400993   J 0x9D00264C
9D002608  8FA30070   LW V1, 112(SP)
2670:                			res = dir_sdi(&dj, 1); /* Get parent dir */
9D0024AC  27A40010   ADDIU A0, SP, 16
9D0024B0  0F4001B0   JAL dir_sdi
9D0024B4  24050001   ADDIU A1, ZERO, 1
2671:                			if (res != FR_OK) break;
9D0024B8  5440006D   BNEL V0, ZERO, 0x9D002670
9D0024BC  00409021   ADDU S2, V0, ZERO
2672:                			res = dir_read(&dj);
9D0024C0  0F4004C2   JAL dir_read
9D0024C4  27A40010   ADDIU A0, SP, 16
2673:                			if (res != FR_OK) break;
9D0024C8  54400069   BNEL V0, ZERO, 0x9D002670
9D0024CC  00409021   ADDU S2, V0, ZERO
2674:                			dj.sclust = LD_CLUST(dj.dir); /* Goto parent dir */
9D0024D0  8FA20024   LW V0, 36(SP)
9D0024D4  90430015   LBU V1, 21(V0)
9D0024D8  00031A00   SLL V1, V1, 8
9D0024DC  90440014   LBU A0, 20(V0)
9D0024E0  00641825   OR V1, V1, A0
9D0024E4  00031C00   SLL V1, V1, 16
9D0024E8  9045001B   LBU A1, 27(V0)
9D0024EC  00052A00   SLL A1, A1, 8
9D0024F0  9044001A   LBU A0, 26(V0)
9D0024F4  00A41025   OR V0, A1, A0
9D0024F8  00621025   OR V0, V1, V0
9D0024FC  AFA20018   SW V0, 24(SP)
2675:                			res = dir_sdi(&dj, 0);
9D002500  27A40010   ADDIU A0, SP, 16
9D002504  0F4001B0   JAL dir_sdi
9D002508  00002821   ADDU A1, ZERO, ZERO
2676:                			if (res != FR_OK) break;
9D00250C  14400057   BNE V0, ZERO, 0x9D00266C
9D002510  00408821   ADDU S1, V0, ZERO
2677:                			do { /* Find the entry links to the child dir */
2678:                				res = dir_read(&dj);
9D002514  0F4004C2   JAL dir_read
9D002518  27A40010   ADDIU A0, SP, 16
2679:                				if (res != FR_OK) break;
9D00251C  14400011   BNE V0, ZERO, 0x9D002564
9D002520  8FA30024   LW V1, 36(SP)
2680:                				if (ccl == LD_CLUST(dj.dir)) break; /* Found the entry */
9D002524  90640015   LBU A0, 21(V1)
9D002528  00042200   SLL A0, A0, 8
9D00252C  90620014   LBU V0, 20(V1)
9D002530  00822025   OR A0, A0, V0
9D002534  00042400   SLL A0, A0, 16
9D002538  9062001B   LBU V0, 27(V1)
9D00253C  00021200   SLL V0, V0, 8
9D002540  9063001A   LBU V1, 26(V1)
9D002544  00431025   OR V0, V0, V1
9D002548  00821025   OR V0, A0, V0
9D00254C  10560009   BEQ V0, S6, 0x9D002574
9D002550  27A40010   ADDIU A0, SP, 16
2681:                				res = dir_next(&dj, 0);
9D002554  0F4002E8   JAL dir_next
9D002558  00002821   ADDU A1, ZERO, ZERO
2682:                			}while (res == FR_OK);
9D00255C  1040FFED   BEQ V0, ZERO, 0x9D002514
9D002560  00000000   NOP
2683:                			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
9D0024A4  24150004   ADDIU S5, ZERO, 4
9D002564  50550042   BEQL V0, S5, 0x9D002670
9D002568  24120002   ADDIU S2, ZERO, 2
2684:                			if (res != FR_OK) break;
9D00256C  54400040   BNEL V0, ZERO, 0x9D002670
9D002570  00409021   ADDU S2, V0, ZERO
2685:                #if _USE_LFN
2686:                			fno.lfname = path;
2687:                			fno.lfsize = i;
2688:                #endif
2689:                			get_fileinfo(&dj, &fno); /* Get the dir name and push it to the buffer */
9D002574  27A40010   ADDIU A0, SP, 16
9D002578  0F400026   JAL get_fileinfo
9D00257C  27A5002C   ADDIU A1, SP, 44
2690:                			tp = fno.fname;
2691:                			if (_USE_LFN && *path) tp = path;
2692:                			for (n = 0; tp[n]; n++);
9D002580  83A20035   LB V0, 53(SP)
9D002584  1040003C   BEQ V0, ZERO, 0x9D002678
9D002588  00001021   ADDU V0, ZERO, ZERO
9D00258C  24420001   ADDIU V0, V0, 1
9D002590  27A4002C   ADDIU A0, SP, 44
9D002594  00821821   ADDU V1, A0, V0
9D002598  80630009   LB V1, 9(V1)
9D00259C  5460FFFD   BNEL V1, ZERO, 0x9D002594
9D0025A0  24420001   ADDIU V0, V0, 1
2693:                			if (i < n + 3) {
9D0025A4  24430003   ADDIU V1, V0, 3
9D0025A8  0203182B   SLTU V1, S0, V1
9D0025AC  54600030   BNEL V1, ZERO, 0x9D002670
9D0025B0  24120011   ADDIU S2, ZERO, 17
9D002678  2E020003   SLTIU V0, S0, 3
9D00267C  1040FFDB   BEQ V0, ZERO, 0x9D0025EC
9D002680  2610FFFF   ADDIU S0, S0, -1
2694:                				res = FR_NOT_ENOUGH_CORE; break;
9D002684  0B40099C   J 0x9D002670
9D002688  24120011   ADDIU S2, ZERO, 17
2695:                			}
2696:                			while (n) path[--i] = tp[--n];
9D0025B4  1040000C   BEQ V0, ZERO, 0x9D0025E8
9D0025B8  00401821   ADDU V1, V0, ZERO
9D0025BC  02002021   ADDU A0, S0, ZERO
9D0025C0  2484FFFF   ADDIU A0, A0, -1
9D0025C4  2463FFFF   ADDIU V1, V1, -1
9D0025C8  27A60010   ADDIU A2, SP, 16
9D0025CC  00C32821   ADDU A1, A2, V1
9D0025D0  80A60025   LB A2, 37(A1)
9D0025D4  8FA50070   LW A1, 112(SP)
9D0025D8  00A42821   ADDU A1, A1, A0
9D0025DC  1460FFF8   BNE V1, ZERO, 0x9D0025C0
9D0025E0  A0A60000   SB A2, 0(A1)
9D0025E4  02028023   SUBU S0, S0, V0
2697:                			path[--i] = '/';
9D0024A8  2413002F   ADDIU S3, ZERO, 47
9D0025E8  2610FFFF   ADDIU S0, S0, -1
9D0025EC  8FA20070   LW V0, 112(SP)
9D0025F0  00501021   ADDU V0, V0, S0
9D0025F4  A0530000   SB S3, 0(V0)
2698:                		}
2699:                		tp = path;
9D002670  0B400991   J 0x9D002644
9D002674  8FA20070   LW V0, 112(SP)
9D00268C  8FA30070   LW V1, 112(SP)
2700:                		if (res == FR_OK) {
2701:                			*tp++ = '0' + CurrVol; /* Put drive number */
9D00264C  93828048   LBU V0, -32696(GP)
9D002650  24420030   ADDIU V0, V0, 48
9D002654  A0620000   SB V0, 0(V1)
9D002690  93828048   LBU V0, -32696(GP)
9D002694  24420030   ADDIU V0, V0, 48
9D002698  A0620000   SB V0, 0(V1)
2702:                			*tp++ = ':';
9D002658  2402003A   ADDIU V0, ZERO, 58
9D002664  0B400987   J 0x9D00261C
9D002668  24620002   ADDIU V0, V1, 2
9D00266C  00409021   ADDU S2, V0, ZERO
9D00269C  2402003A   ADDIU V0, ZERO, 58
9D0026A0  0B400983   J 0x9D00260C
9D0026A4  A0620001   SB V0, 1(V1)
2703:                			if (i == sz_path) { /* Root-dir */
9D00265C  1214FFEB   BEQ S0, S4, 0x9D00260C
9D002660  A0620001   SB V0, 1(V1)
2704:                				*tp++ = '/';
9D00260C  24620003   ADDIU V0, V1, 3
9D002610  2404002F   ADDIU A0, ZERO, 47
9D002614  0B400991   J 0x9D002644
9D002618  A0640002   SB A0, 2(V1)
2705:                			} else { /* Sub-dir */
2706:                				do /* Add stacked path str */
2707:                				*tp++ = path[i++];
9D00261C  24420001   ADDIU V0, V0, 1
9D002620  26030001   ADDIU V1, S0, 1
9D002624  8FA40070   LW A0, 112(SP)
9D002628  00908021   ADDU S0, A0, S0
9D00262C  82040000   LB A0, 0(S0)
9D002630  A044FFFF   SB A0, -1(V0)
2708:                				while (i < sz_path);
9D002634  0074202B   SLTU A0, V1, S4
9D002638  1480FFF8   BNE A0, ZERO, 0x9D00261C
9D00263C  00608021   ADDU S0, V1, ZERO
9D002640  02209021   ADDU S2, S1, ZERO
2709:                			}
2710:                		}
2711:                		*tp = 0;
9D002644  0B4009AA   J 0x9D0026A8
9D002648  A0400000   SB ZERO, 0(V0)
2712:                		FREE_BUF();
2713:                	}
2714:                
2715:                	LEAVE_FF(dj.fs, res);
2716:                }
9D0026A8  02401021   ADDU V0, S2, ZERO
9D0026AC  8FBF006C   LW RA, 108(SP)
9D0026B0  8FB60068   LW S6, 104(SP)
9D0026B4  8FB50064   LW S5, 100(SP)
9D0026B8  8FB40060   LW S4, 96(SP)
9D0026BC  8FB3005C   LW S3, 92(SP)
9D0026C0  8FB20058   LW S2, 88(SP)
9D0026C4  8FB10054   LW S1, 84(SP)
9D0026C8  8FB00050   LW S0, 80(SP)
9D0026CC  03E00008   JR RA
9D0026D0  27BD0070   ADDIU SP, SP, 112
2717:                #endif /* _FS_RPATH >= 2 */
2718:                #endif /* _FS_RPATH >= 1 */
2719:                
2720:                #if _FS_MINIMIZE <= 2
2721:                /*-----------------------------------------------------------------------*/
2722:                /* Seek File R/W Pointer                                                 */
2723:                /*-----------------------------------------------------------------------*/
2724:                
2725:                FRESULT f_lseek(FIL *fp, /* Pointer to the file object */
2726:                                DWORD ofs /* File pointer from top of file */
2727:                                ) {
9D0026D4  27BDFFC8   ADDIU SP, SP, -56
9D0026D8  AFBF0034   SW RA, 52(SP)
9D0026DC  AFB70030   SW S7, 48(SP)
9D0026E0  AFB6002C   SW S6, 44(SP)
9D0026E4  AFB50028   SW S5, 40(SP)
9D0026E8  AFB40024   SW S4, 36(SP)
9D0026EC  AFB30020   SW S3, 32(SP)
9D0026F0  AFB2001C   SW S2, 28(SP)
9D0026F4  AFB10018   SW S1, 24(SP)
9D0026F8  AFB00014   SW S0, 20(SP)
9D0026FC  00808021   ADDU S0, A0, ZERO
9D002700  00A08821   ADDU S1, A1, ZERO
2728:                	FRESULT res;
2729:                
2730:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D002704  8C840000   LW A0, 0(A0)
9D002708  0F4000E7   JAL validate
9D00270C  96050004   LHU A1, 4(S0)
2731:                	if (res != FR_OK)
9D002710  144000E9   BNE V0, ZERO, 0x9D002AB8
9D002714  00401821   ADDU V1, V0, ZERO
2732:                		LEAVE_FF(fp->fs, res);
2733:                	if (fp->flag & FA__ERROR) /* Check abort flag */
9D002718  92120006   LBU S2, 6(S0)
9D00271C  7C121420   SEB V0, S2
9D002720  044000E5   BLTZ V0, 0x9D002AB8
9D002724  24030002   ADDIU V1, ZERO, 2
2734:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2735:                
2736:                #if _USE_FASTSEEK
2737:                	if (fp->cltbl) { /* Fast seek */
9D002728  8E020024   LW V0, 36(S0)
9D00272C  1040005A   BEQ V0, ZERO, 0x9D002898
9D002730  2403FFFF   ADDIU V1, ZERO, -1
2738:                		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
2739:                
2740:                		if (ofs == CREATE_LINKMAP) { /* Create CLMT */
9D002734  56230037   BNEL S1, V1, 0x9D002814
9D002738  8E02000C   LW V0, 12(S0)
2741:                			tbl = fp->cltbl;
2742:                			tlen = *tbl++;
9D00273C  24560004   ADDIU S6, V0, 4
2743:                			ulen = 2; /* Given table size and required table size */
9D0027F0  24150002   ADDIU S5, ZERO, 2
2744:                			cl = fp->sclust; /* Top of the chain */
9D002740  8E140010   LW S4, 16(S0)
2745:                			if (cl) {
9D002744  1280002A   BEQ S4, ZERO, 0x9D0027F0
9D002748  8C570000   LW S7, 0(V0)
9D00274C  24150002   ADDIU S5, ZERO, 2
2746:                				do {
2747:                					/* Get a fragment */
2748:                					tcl = cl;
2749:                					ncl = 0;
9D002758  00009021   ADDU S2, ZERO, ZERO
2750:                					ulen += 2; /* Top, length and used items */
9D0027B8  26B50002   ADDIU S5, S5, 2
2751:                					do {
2752:                						pcl = cl;
2753:                						ncl++;
9D00275C  26520001   ADDIU S2, S2, 1
2754:                						cl = get_fat(fp->fs, cl);
9D002754  02808821   ADDU S1, S4, ZERO
9D002760  8E040000   LW A0, 0(S0)
9D002764  0F40014E   JAL get_fat
9D002768  02202821   ADDU A1, S1, ZERO
9D0027E8  0B4009D6   J 0x9D002758
9D0027EC  02808821   ADDU S1, S4, ZERO
2755:                						if (cl <= 1)
9D00276C  2C430002   SLTIU V1, V0, 2
9D002770  10600007   BEQ V1, ZERO, 0x9D002790
9D002774  00000000   NOP
2756:                							ABORT(fp->fs, FR_INT_ERR);
9D002778  92030006   LBU V1, 6(S0)
9D00277C  2402FF80   ADDIU V0, ZERO, -128
9D002780  00621025   OR V0, V1, V0
9D002784  A2020006   SB V0, 6(S0)
9D002788  0B400AAE   J 0x9D002AB8
9D00278C  24030002   ADDIU V1, ZERO, 2
2757:                						if (cl == 0xFFFFFFFF)
9D002750  2413FFFF   ADDIU S3, ZERO, -1
9D002790  14530007   BNE V0, S3, 0x9D0027B0
9D002794  26310001   ADDIU S1, S1, 1
2758:                							ABORT(fp->fs, FR_DISK_ERR);
9D002798  92030006   LBU V1, 6(S0)
9D00279C  2402FF80   ADDIU V0, ZERO, -128
9D0027A0  00621025   OR V0, V1, V0
9D0027A4  A2020006   SB V0, 6(S0)
9D0027A8  0B400AAE   J 0x9D002AB8
9D0027AC  24030001   ADDIU V1, ZERO, 1
2759:                					} while (cl == pcl + 1);
9D0027B0  5222FFEB   BEQL S1, V0, 0x9D002760
9D0027B4  26520001   ADDIU S2, S2, 1
2760:                					if (ulen <= tlen) { /* Store the length and top of the fragment */
9D0027BC  02F5182B   SLTU V1, S7, S5
9D0027C0  54600005   BNEL V1, ZERO, 0x9D0027D8
9D0027C4  8E030000   LW V1, 0(S0)
2761:                						*tbl++ = ncl;
9D0027C8  AED20000   SW S2, 0(S6)
2762:                						*tbl++ = tcl;
9D0027CC  AED40004   SW S4, 4(S6)
9D0027D0  26D60008   ADDIU S6, S6, 8
2763:                					}
2764:                				} while (cl < fp->fs->n_fatent); /* Repeat until end of chain */
9D0027D4  8E030000   LW V1, 0(S0)
9D0027D8  8C63001C   LW V1, 28(V1)
9D0027DC  0043182B   SLTU V1, V0, V1
9D0027E0  10600004   BEQ V1, ZERO, 0x9D0027F4
9D0027E4  0040A021   ADDU S4, V0, ZERO
2765:                			}
2766:                			*fp->cltbl = ulen; /* Number of items used */
9D0027F4  8E020024   LW V0, 36(S0)
9D0027F8  AC550000   SW S5, 0(V0)
2767:                			if (ulen <= tlen)
9D0027FC  02F5A82B   SLTU S5, S7, S5
9D002800  16A000AD   BNE S5, ZERO, 0x9D002AB8
9D002804  24030011   ADDIU V1, ZERO, 17
2768:                				*tbl = 0; /* Terminate table */
9D002808  AEC00000   SW ZERO, 0(S6)
9D00280C  0B400AAE   J 0x9D002AB8
9D002810  00001821   ADDU V1, ZERO, ZERO
9D002814  0051182B   SLTU V1, V0, S1
9D002818  0043880B   MOVN S1, V0, V1
2769:                			else
2770:                				res = FR_NOT_ENOUGH_CORE; /* Given table size is smaller than required */
2771:                
2772:                		} else { /* Fast seek */
2773:                			if (ofs > fp->fsize) /* Clip offset at the file size */
2774:                				ofs = fp->fsize;
2775:                			fp->fptr = ofs; /* Set file pointer */
9D00281C  AE110008   SW S1, 8(S0)
2776:                			if (ofs) {
9D002820  122000A5   BEQ S1, ZERO, 0x9D002AB8
9D002824  00001821   ADDU V1, ZERO, ZERO
2777:                				fp->clust = clmt_clust(fp, ofs - 1);
9D002828  2634FFFF   ADDIU S4, S1, -1
9D00282C  02002021   ADDU A0, S0, ZERO
9D002830  0F400009   JAL clmt_clust
9D002834  02802821   ADDU A1, S4, ZERO
9D002838  AE020014   SW V0, 20(S0)
2778:                				dsc = clust2sect(fp->fs, fp->clust);
9D00283C  8E130000   LW S3, 0(S0)
9D002840  02602021   ADDU A0, S3, ZERO
9D002844  0F400142   JAL clust2sect
9D002848  00402821   ADDU A1, V0, ZERO
2779:                				if (!dsc)
9D00284C  54400006   BNEL V0, ZERO, 0x9D002868
9D002850  92640002   LBU A0, 2(S3)
2780:                					ABORT(fp->fs, FR_INT_ERR);
9D002854  2402FF80   ADDIU V0, ZERO, -128
9D002858  02429025   OR S2, S2, V0
9D00285C  A2120006   SB S2, 6(S0)
9D002860  0B400AAE   J 0x9D002AB8
9D002864  24030002   ADDIU V1, ZERO, 2
2781:                				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
9D002874  00141A42   SRL V1, S4, 9
9D002878  2484FFFF   ADDIU A0, A0, -1
9D00287C  00641824   AND V1, V1, A0
9D002880  00431021   ADDU V0, V0, V1
2782:                				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) { /* Refill sector cache if needed */
9D002868  323101FF   ANDI S1, S1, 511
9D00286C  12200092   BEQ S1, ZERO, 0x9D002AB8
9D002870  00001821   ADDU V1, ZERO, ZERO
9D002884  8E030018   LW V1, 24(S0)
9D002888  1062008B   BEQ V1, V0, 0x9D002AB8
9D00288C  00001821   ADDU V1, ZERO, ZERO
2783:                #if !_FS_TINY
2784:                #if !_FS_READONLY
2785:                					if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2786:                						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2787:                								!= RES_OK)
2788:                							ABORT(fp->fs, FR_DISK_ERR);
2789:                						fp->flag &= ~FA__DIRTY;
2790:                					}
2791:                #endif
2792:                					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK) /* Load current sector */
2793:                						ABORT(fp->fs, FR_DISK_ERR);
2794:                #endif
2795:                					fp->dsect = dsc;
9D002890  0B400AAE   J 0x9D002AB8
9D002894  AE020018   SW V0, 24(S0)
2796:                				}
2797:                			}
2798:                		}
2799:                	} else
2800:                #endif
2801:                
2802:                	/* Normal Seek */
2803:                	{
2804:                		DWORD clst, bcs, nsect, ifptr;
2805:                
2806:                		if (ofs > fp->fsize /* In read-only mode, clip offset with the file size */
9D002898  8E02000C   LW V0, 12(S0)
9D00289C  0051182B   SLTU V1, V0, S1
9D0028A0  50600005   BEQL V1, ZERO, 0x9D0028B8
9D0028A4  8E020008   LW V0, 8(S0)
2807:                #if !_FS_READONLY
2808:                				&& !(fp->flag & FA_WRITE)
9D0028A8  32520002   ANDI S2, S2, 2
9D0028AC  325200FF   ANDI S2, S2, 255
2809:                #endif
2810:                		)
2811:                			ofs = fp->fsize;
9D0028B0  0052880A   MOVZ S1, V0, S2
2812:                
2813:                		ifptr = fp->fptr;
9D0028B4  8E020008   LW V0, 8(S0)
2814:                		fp->fptr = nsect = 0;
9D0028B8  AE000008   SW ZERO, 8(S0)
2815:                		if (ofs) {
9D0028BC  1220007E   BEQ S1, ZERO, 0x9D002AB8
9D0028C0  00001821   ADDU V1, ZERO, ZERO
2816:                			bcs = (DWORD) fp->fs->csize * SS(fp->fs); /* Cluster size (byte) */
9D0028C4  8E040000   LW A0, 0(S0)
9D0028C8  90920002   LBU S2, 2(A0)
2817:                			if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
9D0028CC  10400012   BEQ V0, ZERO, 0x9D002918
9D0028D0  00129240   SLL S2, S2, 9
9D0028D4  2442FFFF   ADDIU V0, V0, -1
9D0028D8  2623FFFF   ADDIU V1, S1, -1
9D0028DC  0072001B   DIVU V1, S2
9D0028E0  024001F4   TEQ S2, ZERO
9D0028E4  00001812   MFLO V1
9D0028E8  0052001B   DIVU V0, S2
9D0028EC  024001F4   TEQ S2, ZERO
9D0028F0  00002812   MFLO A1
9D0028F4  0065182B   SLTU V1, V1, A1
9D0028F8  54600008   BNEL V1, ZERO, 0x9D00291C
9D0028FC  8E020010   LW V0, 16(S0)
2818:                				fp->fptr = (ifptr - 1) & ~(bcs - 1); /* start from the current cluster */
9D002900  00121823   SUBU V1, ZERO, S2
9D002904  00621024   AND V0, V1, V0
9D002908  AE020008   SW V0, 8(S0)
2819:                				ofs -= fp->fptr;
9D00290C  02228823   SUBU S1, S1, V0
2820:                				clst = fp->clust;
9D002910  0B400A5D   J 0x9D002974
9D002914  8E020014   LW V0, 20(S0)
2821:                			} else { /* When seek to back cluster, */
2822:                				clst = fp->sclust; /* start from the first cluster */
9D002918  8E020010   LW V0, 16(S0)
2823:                #if !_FS_READONLY
2824:                				if (clst == 0) { /* If no cluster chain, create a new chain */
9D00291C  54400015   BNEL V0, ZERO, 0x9D002974
9D002920  AE020014   SW V0, 20(S0)
2825:                					clst = create_chain(fp->fs, 0);
9D002924  0F400284   JAL create_chain
9D002928  00002821   ADDU A1, ZERO, ZERO
2826:                					if (clst == 1)
9D00292C  24030001   ADDIU V1, ZERO, 1
9D002930  54430007   BNEL V0, V1, 0x9D002950
9D002934  2403FFFF   ADDIU V1, ZERO, -1
2827:                						ABORT(fp->fs, FR_INT_ERR);
9D002938  92030006   LBU V1, 6(S0)
9D00293C  2402FF80   ADDIU V0, ZERO, -128
9D002940  00621025   OR V0, V1, V0
9D002944  A2020006   SB V0, 6(S0)
9D002948  0B400AAE   J 0x9D002AB8
9D00294C  24030002   ADDIU V1, ZERO, 2
2828:                					if (clst == 0xFFFFFFFF)
9D002950  54430007   BNEL V0, V1, 0x9D002970
9D002954  AE020010   SW V0, 16(S0)
2829:                						ABORT(fp->fs, FR_DISK_ERR);
9D002958  92030006   LBU V1, 6(S0)
9D00295C  2402FF80   ADDIU V0, ZERO, -128
9D002960  00621025   OR V0, V1, V0
9D002964  A2020006   SB V0, 6(S0)
9D002968  0B400AAE   J 0x9D002AB8
9D00296C  24030001   ADDIU V1, ZERO, 1
2830:                					fp->sclust = clst;
2831:                				}
2832:                #endif
2833:                				fp->clust = clst;
9D002970  AE020014   SW V0, 20(S0)
2834:                			}
2835:                			if (clst != 0) {
9D002974  10400041   BEQ V0, ZERO, 0x9D002A7C
9D002978  00001821   ADDU V1, ZERO, ZERO
2836:                				while (ofs > bcs) { /* Cluster following loop */
9D00297C  0251182B   SLTU V1, S2, S1
9D002980  1060002C   BEQ V1, ZERO, 0x9D002A34
9D002984  2413FFFF   ADDIU S3, ZERO, -1
9D002A20  0251182B   SLTU V1, S2, S1
9D002A24  5460FFD9   BNEL V1, ZERO, 0x9D00298C
9D002A28  92030006   LBU V1, 6(S0)
9D002A2C  0B400A8E   J 0x9D002A38
9D002A30  8E030008   LW V1, 8(S0)
2837:                #if !_FS_READONLY
2838:                					if (fp->flag & FA_WRITE) { /* Check if in write mode or not */
9D002988  92030006   LBU V1, 6(S0)
9D00298C  30630002   ANDI V1, V1, 2
9D002990  306300FF   ANDI V1, V1, 255
9D002994  10600007   BEQ V1, ZERO, 0x9D0029B4
9D002998  8E040000   LW A0, 0(S0)
2839:                						clst = create_chain(fp->fs, clst); /* Force stretch if in write mode */
9D00299C  0F400284   JAL create_chain
9D0029A0  00402821   ADDU A1, V0, ZERO
2840:                						if (clst == 0) { /* When disk gets full, clip file size */
9D0029A4  14400005   BNE V0, ZERO, 0x9D0029BC
9D0029A8  00000000   NOP
9D0029AC  0B400A8D   J 0x9D002A34
9D0029B0  02408821   ADDU S1, S2, ZERO
2841:                							ofs = bcs;
2842:                							break;
2843:                						}
2844:                					} else
2845:                #endif
2846:                						clst = get_fat(fp->fs, clst); /* Follow cluster chain if not in write mode */
9D0029B4  0F40014E   JAL get_fat
9D0029B8  00402821   ADDU A1, V0, ZERO
2847:                					if (clst == 0xFFFFFFFF)
9D0029BC  54530007   BNEL V0, S3, 0x9D0029DC
9D0029C0  2C430002   SLTIU V1, V0, 2
2848:                						ABORT(fp->fs, FR_DISK_ERR);
9D0029C4  92030006   LBU V1, 6(S0)
9D0029C8  2402FF80   ADDIU V0, ZERO, -128
9D0029CC  00621025   OR V0, V1, V0
9D0029D0  A2020006   SB V0, 6(S0)
9D0029D4  0B400AAE   J 0x9D002AB8
9D0029D8  24030001   ADDIU V1, ZERO, 1
2849:                					if (clst <= 1 || clst >= fp->fs->n_fatent)
9D0029DC  54600007   BNEL V1, ZERO, 0x9D0029FC
9D0029E0  92030006   LBU V1, 6(S0)
9D0029E4  8E030000   LW V1, 0(S0)
9D0029E8  8C63001C   LW V1, 28(V1)
9D0029EC  0043182B   SLTU V1, V0, V1
9D0029F0  54600007   BNEL V1, ZERO, 0x9D002A10
9D0029F4  AE020014   SW V0, 20(S0)
2850:                						ABORT(fp->fs, FR_INT_ERR);
9D0029F8  92030006   LBU V1, 6(S0)
9D0029FC  2402FF80   ADDIU V0, ZERO, -128
9D002A00  00621025   OR V0, V1, V0
9D002A04  A2020006   SB V0, 6(S0)
9D002A08  0B400AAE   J 0x9D002AB8
9D002A0C  24030002   ADDIU V1, ZERO, 2
2851:                					fp->clust = clst;
2852:                					fp->fptr += bcs;
9D002A10  8E030008   LW V1, 8(S0)
9D002A14  00721821   ADDU V1, V1, S2
9D002A18  AE030008   SW V1, 8(S0)
2853:                					ofs -= bcs;
9D002A1C  02328823   SUBU S1, S1, S2
2854:                				}
2855:                				fp->fptr += ofs;
9D002A34  8E030008   LW V1, 8(S0)
9D002A38  00711821   ADDU V1, V1, S1
9D002A3C  AE030008   SW V1, 8(S0)
2856:                				if (ofs % SS(fp->fs)) {
9D002A40  322301FF   ANDI V1, S1, 511
9D002A44  1060000D   BEQ V1, ZERO, 0x9D002A7C
9D002A48  00001821   ADDU V1, ZERO, ZERO
2857:                					nsect = clust2sect(fp->fs, clst); /* Current sector */
9D002A4C  8E040000   LW A0, 0(S0)
9D002A50  0F400142   JAL clust2sect
9D002A54  00402821   ADDU A1, V0, ZERO
2858:                					if (!nsect)
9D002A58  54400007   BNEL V0, ZERO, 0x9D002A78
9D002A5C  00111A42   SRL V1, S1, 9
2859:                						ABORT(fp->fs, FR_INT_ERR);
9D002A60  92030006   LBU V1, 6(S0)
9D002A64  2402FF80   ADDIU V0, ZERO, -128
9D002A68  00621025   OR V0, V1, V0
9D002A6C  A2020006   SB V0, 6(S0)
9D002A70  0B400AAE   J 0x9D002AB8
9D002A74  24030002   ADDIU V1, ZERO, 2
9D002A78  00431821   ADDU V1, V0, V1
2860:                					nsect += ofs / SS(fp->fs);
2861:                				}
2862:                			}
2863:                		}
2864:                		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) { /* Fill sector cache if needed */
9D002A7C  8E020008   LW V0, 8(S0)
9D002A80  304401FF   ANDI A0, V0, 511
9D002A84  50800005   BEQL A0, ZERO, 0x9D002A9C
9D002A88  8E04000C   LW A0, 12(S0)
9D002A8C  8E040018   LW A0, 24(S0)
9D002A90  54830001   BNEL A0, V1, 0x9D002A98
9D002A94  AE030018   SW V1, 24(S0)
2865:                #if !_FS_TINY
2866:                #if !_FS_READONLY
2867:                			if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2868:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2869:                					ABORT(fp->fs, FR_DISK_ERR);
2870:                				fp->flag &= ~FA__DIRTY;
2871:                			}
2872:                #endif
2873:                			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK) /* Fill sector cache */
2874:                				ABORT(fp->fs, FR_DISK_ERR);
2875:                #endif
2876:                			fp->dsect = nsect;
2877:                		}
2878:                #if !_FS_READONLY
2879:                		if (fp->fptr > fp->fsize) { /* Set file change flag if the file size is extended */
9D002A98  8E04000C   LW A0, 12(S0)
9D002A9C  0082202B   SLTU A0, A0, V0
9D002AA0  10800005   BEQ A0, ZERO, 0x9D002AB8
9D002AA4  00001821   ADDU V1, ZERO, ZERO
2880:                			fp->fsize = fp->fptr;
9D002AA8  AE02000C   SW V0, 12(S0)
2881:                			fp->flag |= FA__WRITTEN;
9D002AAC  92020006   LBU V0, 6(S0)
9D002AB0  34420020   ORI V0, V0, 32
9D002AB4  A2020006   SB V0, 6(S0)
2882:                		}
2883:                #endif
2884:                	}
2885:                
2886:                	LEAVE_FF(fp->fs, res);
2887:                }
9D002AB8  00601021   ADDU V0, V1, ZERO
9D002ABC  8FBF0034   LW RA, 52(SP)
9D002AC0  8FB70030   LW S7, 48(SP)
9D002AC4  8FB6002C   LW S6, 44(SP)
9D002AC8  8FB50028   LW S5, 40(SP)
9D002ACC  8FB40024   LW S4, 36(SP)
9D002AD0  8FB30020   LW S3, 32(SP)
9D002AD4  8FB2001C   LW S2, 28(SP)
9D002AD8  8FB10018   LW S1, 24(SP)
9D002ADC  8FB00014   LW S0, 20(SP)
9D002AE0  03E00008   JR RA
9D002AE4  27BD0038   ADDIU SP, SP, 56
2888:                
2889:                #if _FS_MINIMIZE <= 1
2890:                /*-----------------------------------------------------------------------*/
2891:                /* Create a Directroy Object                                             */
2892:                /*-----------------------------------------------------------------------*/
2893:                
2894:                FRESULT f_opendir(DIR *dj, /* Pointer to directory object to create */
2895:                const TCHAR *path /* Pointer to the directory path */
2896:                ) {
9D002AE8  27BDFFD8   ADDIU SP, SP, -40
9D002AEC  AFBF0024   SW RA, 36(SP)
9D002AF0  AFB00020   SW S0, 32(SP)
9D002AF4  00808021   ADDU S0, A0, ZERO
9D002AF8  AFA5002C   SW A1, 44(SP)
2897:                	FRESULT res;
2898:                	DEF_NAMEBUF;
2899:                
2900:                	res = chk_mounted(&path, &dj->fs, 0);
9D002AFC  27A4002C   ADDIU A0, SP, 44
9D002B00  02002821   ADDU A1, S0, ZERO
9D002B04  0F400521   JAL chk_mounted
9D002B08  00003021   ADDU A2, ZERO, ZERO
2901:                	if (res == FR_OK) {
9D002B0C  14400028   BNE V0, ZERO, 0x9D002BB0
9D002B10  8FBF0024   LW RA, 36(SP)
2902:                		INIT_BUF(*dj);
9D002B14  27A20010   ADDIU V0, SP, 16
9D002B18  AE020018   SW V0, 24(S0)
2903:                		res = follow_path(dj, path); /* Follow the path to the directory */
9D002B1C  02002021   ADDU A0, S0, ZERO
9D002B20  0F400367   JAL follow_path
9D002B24  8FA5002C   LW A1, 44(SP)
2904:                		FREE_BUF();
2905:                		if (res == FR_OK) { /* Follow completed */
9D002B28  14400015   BNE V0, ZERO, 0x9D002B80
9D002B2C  38440004   XORI A0, V0, 4
2906:                			if (dj->dir) { /* It is not the root dir */
9D002B30  8E030014   LW V1, 20(S0)
9D002B34  50600016   BEQL V1, ZERO, 0x9D002B90
9D002B38  8E020000   LW V0, 0(S0)
2907:                				if (dj->dir[DIR_Attr] & AM_DIR) { /* The object is a directory */
9D002B3C  9064000B   LBU A0, 11(V1)
9D002B40  30840010   ANDI A0, A0, 16
9D002B44  308400FF   ANDI A0, A0, 255
9D002B48  10800018   BEQ A0, ZERO, 0x9D002BAC
9D002B4C  24020005   ADDIU V0, ZERO, 5
2908:                					dj->sclust = LD_CLUST(dj->dir);
9D002B50  90640015   LBU A0, 21(V1)
9D002B54  00042200   SLL A0, A0, 8
9D002B58  90620014   LBU V0, 20(V1)
9D002B5C  00822025   OR A0, A0, V0
9D002B60  00042400   SLL A0, A0, 16
9D002B64  9062001B   LBU V0, 27(V1)
9D002B68  00021200   SLL V0, V0, 8
9D002B6C  9063001A   LBU V1, 26(V1)
9D002B70  00431025   OR V0, V0, V1
9D002B74  00821025   OR V0, A0, V0
9D002B78  0B400AE3   J 0x9D002B8C
9D002B7C  AE020008   SW V0, 8(S0)
2909:                				} else { /* The object is not a directory */
2910:                					res = FR_NO_PATH;
2911:                				}
2912:                			}
2913:                			if (res == FR_OK) {
2914:                				dj->id = dj->fs->id;
9D002B8C  8E020000   LW V0, 0(S0)
9D002B90  94420006   LHU V0, 6(V0)
9D002B94  A6020004   SH V0, 4(S0)
2915:                				res = dir_sdi(dj, 0); /* Rewind dir */
9D002B98  02002021   ADDU A0, S0, ZERO
9D002B9C  0F4001B0   JAL dir_sdi
9D002BA0  00002821   ADDU A1, ZERO, ZERO
2916:                			}
2917:                		}
2918:                		if (res == FR_NO_FILE){
2919:                			res = FR_NO_PATH;
9D002B80  24030005   ADDIU V1, ZERO, 5
9D002B84  0B400AEB   J 0x9D002BAC
9D002B88  0064100A   MOVZ V0, V1, A0
9D002BA4  0B400AE0   J 0x9D002B80
9D002BA8  38440004   XORI A0, V0, 4
2920:                                }
2921:                	}
2922:                	LEAVE_FF(dj->fs, res);
2923:                }
9D002BAC  8FBF0024   LW RA, 36(SP)
9D002BB0  8FB00020   LW S0, 32(SP)
9D002BB4  03E00008   JR RA
9D002BB8  27BD0028   ADDIU SP, SP, 40
2924:                
2925:                /*-----------------------------------------------------------------------*/
2926:                /* Read Directory Entry in Sequense                                      */
2927:                /*-----------------------------------------------------------------------*/
2928:                
2929:                FRESULT f_readdir(DIR *dj, /* Pointer to the open directory object */
2930:                FILINFO *fno /* Pointer to file information to return */
2931:                ) {
9D002BBC  27BDFFD0   ADDIU SP, SP, -48
9D002BC0  AFBF002C   SW RA, 44(SP)
9D002BC4  AFB20028   SW S2, 40(SP)
9D002BC8  AFB10024   SW S1, 36(SP)
9D002BCC  AFB00020   SW S0, 32(SP)
9D002BD0  00808021   ADDU S0, A0, ZERO
9D002BD4  00A09021   ADDU S2, A1, ZERO
2932:                	FRESULT res;
2933:                	DEF_NAMEBUF;
2934:                
2935:                	res = validate(dj->fs, dj->id); /* Check validity of the object */
9D002BD8  8C840000   LW A0, 0(A0)
9D002BDC  0F4000E7   JAL validate
9D002BE0  96050004   LHU A1, 4(S0)
2936:                	if (res == FR_OK) {
9D002BE4  1440001C   BNE V0, ZERO, 0x9D002C58
9D002BE8  00408821   ADDU S1, V0, ZERO
2937:                		if (!fno) {
9D002BEC  16400006   BNE S2, ZERO, 0x9D002C08
9D002BF0  27A20010   ADDIU V0, SP, 16
2938:                			res = dir_sdi(dj, 0); /* Rewind the directory object */
9D002BF4  02002021   ADDU A0, S0, ZERO
9D002BF8  0F4001B0   JAL dir_sdi
9D002BFC  00002821   ADDU A1, ZERO, ZERO
9D002C00  0B400B16   J 0x9D002C58
9D002C04  00408821   ADDU S1, V0, ZERO
2939:                		} else {
2940:                			INIT_BUF(*dj);
9D002C08  AE020018   SW V0, 24(S0)
2941:                			res = dir_read(dj); /* Read an directory item */
9D002C0C  0F4004C2   JAL dir_read
9D002C10  02002021   ADDU A0, S0, ZERO
2942:                			if (res == FR_NO_FILE) { /* Reached end of dir */
9D002C14  24030004   ADDIU V1, ZERO, 4
9D002C18  14430003   BNE V0, V1, 0x9D002C28
9D002C1C  00000000   NOP
2943:                				dj->sect = 0;
9D002C20  0B400B0C   J 0x9D002C30
9D002C24  AE000010   SW ZERO, 16(S0)
2944:                				res = FR_OK;
2945:                			}
2946:                			if (res == FR_OK) { /* A valid entry is found */
9D002C28  5440000B   BNEL V0, ZERO, 0x9D002C58
9D002C2C  00408821   ADDU S1, V0, ZERO
2947:                				get_fileinfo(dj, fno); /* Get the object information */
9D002C30  02002021   ADDU A0, S0, ZERO
9D002C34  0F400026   JAL get_fileinfo
9D002C38  02402821   ADDU A1, S2, ZERO
2948:                				res = dir_next(dj, 0); /* Increment index for next */
9D002C3C  02002021   ADDU A0, S0, ZERO
9D002C40  0F4002E8   JAL dir_next
9D002C44  00002821   ADDU A1, ZERO, ZERO
2949:                				if (res == FR_NO_FILE) {
9D002C48  24030004   ADDIU V1, ZERO, 4
9D002C4C  54430002   BNEL V0, V1, 0x9D002C58
9D002C50  00408821   ADDU S1, V0, ZERO
9D002C54  AE000010   SW ZERO, 16(S0)
2950:                					dj->sect = 0;
2951:                					res = FR_OK;
2952:                				}
2953:                			} FREE_BUF();
2954:                		}
2955:                	}
2956:                
2957:                	LEAVE_FF(dj->fs, res);
2958:                }
9D002C58  02201021   ADDU V0, S1, ZERO
9D002C5C  8FBF002C   LW RA, 44(SP)
9D002C60  8FB20028   LW S2, 40(SP)
9D002C64  8FB10024   LW S1, 36(SP)
9D002C68  8FB00020   LW S0, 32(SP)
9D002C6C  03E00008   JR RA
9D002C70  27BD0030   ADDIU SP, SP, 48
2959:                
2960:                #if _FS_MINIMIZE == 0
2961:                /*-----------------------------------------------------------------------*/
2962:                /* Get File Status                                                       */
2963:                /*-----------------------------------------------------------------------*/
2964:                
2965:                FRESULT f_stat(const TCHAR *path, /* Pointer to the file path */
2966:                                FILINFO *fno /* Pointer to file information to return */
2967:                                ) {
9D002C74  27BDFFB8   ADDIU SP, SP, -72
9D002C78  AFBF0044   SW RA, 68(SP)
9D002C7C  AFB10040   SW S1, 64(SP)
9D002C80  AFB0003C   SW S0, 60(SP)
9D002C84  AFA40048   SW A0, 72(SP)
9D002C88  00A08821   ADDU S1, A1, ZERO
2968:                	FRESULT res;
2969:                	DIR dj;
2970:                	DEF_NAMEBUF;
2971:                
2972:                	res = chk_mounted(&path, &dj.fs, 0);
9D002C8C  27A40048   ADDIU A0, SP, 72
9D002C90  27A50010   ADDIU A1, SP, 16
9D002C94  0F400521   JAL chk_mounted
9D002C98  00003021   ADDU A2, ZERO, ZERO
2973:                	if (res == FR_OK) {
9D002C9C  14400010   BNE V0, ZERO, 0x9D002CE0
9D002CA0  00408021   ADDU S0, V0, ZERO
2974:                		INIT_BUF(dj);
9D002CA4  27A2002C   ADDIU V0, SP, 44
9D002CA8  AFA20028   SW V0, 40(SP)
2975:                		res = follow_path(&dj, path); /* Follow the file path */
9D002CAC  27A40010   ADDIU A0, SP, 16
9D002CB0  0F400367   JAL follow_path
9D002CB4  8FA50048   LW A1, 72(SP)
2976:                		if (res == FR_OK) { /* Follow completed */
9D002CB8  14400009   BNE V0, ZERO, 0x9D002CE0
9D002CBC  00408021   ADDU S0, V0, ZERO
2977:                			if (dj.dir) /* Found an object */
9D002CC0  8FA20024   LW V0, 36(SP)
9D002CC4  10400005   BEQ V0, ZERO, 0x9D002CDC
9D002CC8  27A40010   ADDIU A0, SP, 16
2978:                				get_fileinfo(&dj, fno);
9D002CCC  0F400026   JAL get_fileinfo
9D002CD0  02202821   ADDU A1, S1, ZERO
9D002CD4  0B400B39   J 0x9D002CE4
9D002CD8  02001021   ADDU V0, S0, ZERO
2979:                			else
2980:                				/* It is root dir */
2981:                				res = FR_INVALID_NAME;
9D002CDC  24100006   ADDIU S0, ZERO, 6
2982:                		}FREE_BUF();
2983:                	}
2984:                
2985:                	LEAVE_FF(dj.fs, res);
2986:                }
9D002CE0  02001021   ADDU V0, S0, ZERO
9D002CE4  8FBF0044   LW RA, 68(SP)
9D002CE8  8FB10040   LW S1, 64(SP)
9D002CEC  8FB0003C   LW S0, 60(SP)
9D002CF0  03E00008   JR RA
9D002CF4  27BD0048   ADDIU SP, SP, 72
2987:                
2988:                #if !_FS_READONLY
2989:                /*-----------------------------------------------------------------------*/
2990:                /* Get Number of Free Clusters                                           */
2991:                /*-----------------------------------------------------------------------*/
2992:                
2993:                FRESULT f_getfree(const TCHAR *path, /* Pointer to the logical drive number (root dir) */
2994:                DWORD *nclst, /* Pointer to the variable to return number of free clusters */
2995:                FATFS **fatfs /* Pointer to pointer to corresponding file system object to return */
2996:                ) {
9D002CF8  27BDFFC8   ADDIU SP, SP, -56
9D002CFC  AFBF0034   SW RA, 52(SP)
9D002D00  AFB70030   SW S7, 48(SP)
9D002D04  AFB6002C   SW S6, 44(SP)
9D002D08  AFB50028   SW S5, 40(SP)
9D002D0C  AFB40024   SW S4, 36(SP)
9D002D10  AFB30020   SW S3, 32(SP)
9D002D14  AFB2001C   SW S2, 28(SP)
9D002D18  AFB10018   SW S1, 24(SP)
9D002D1C  AFB00014   SW S0, 20(SP)
9D002D20  AFA40038   SW A0, 56(SP)
9D002D24  00A0B021   ADDU S6, A1, ZERO
9D002D28  00C09021   ADDU S2, A2, ZERO
2997:                	FRESULT res;
2998:                	DWORD n, clst, sect, stat;
2999:                	UINT i;
3000:                	PF_BYTE fat, *p;
3001:                
3002:                	/* Get drive number */
3003:                	res = chk_mounted(&path, fatfs, 0);
9D002D2C  27A40038   ADDIU A0, SP, 56
9D002D30  00C02821   ADDU A1, A2, ZERO
9D002D34  0F400521   JAL chk_mounted
9D002D38  00003021   ADDU A2, ZERO, ZERO
3004:                	if (res == FR_OK) {
9D002D3C  1440005C   BNE V0, ZERO, 0x9D002EB0
9D002D40  0040A821   ADDU S5, V0, ZERO
3005:                		/* If free_clust is valid, return it without full cluster scan */
3006:                		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
9D002D44  8E420000   LW V0, 0(S2)
9D002D48  8C430010   LW V1, 16(V0)
9D002D4C  8C50001C   LW S0, 28(V0)
9D002D50  2604FFFE   ADDIU A0, S0, -2
9D002D54  0083202B   SLTU A0, A0, V1
9D002D58  54800003   BNEL A0, ZERO, 0x9D002D68
9D002D5C  90530000   LBU S3, 0(V0)
9D002D60  0B400BAC   J 0x9D002EB0
9D002D64  AEC30000   SW V1, 0(S6)
3007:                			*nclst = (*fatfs)->free_clust;
3008:                		} else {
3009:                			/* Get number of free clusters */
3010:                			fat = (*fatfs)->fs_type;
3011:                			n = 0;
9D002DCC  00008821   ADDU S1, ZERO, ZERO
3012:                			if (fat == FS_FAT12) {
9D002D68  24030001   ADDIU V1, ZERO, 1
9D002D6C  56630015   BNEL S3, V1, 0x9D002DC4
9D002D70  8C450024   LW A1, 36(V0)
9D002D74  24100002   ADDIU S0, ZERO, 2
9D002D78  00008821   ADDU S1, ZERO, ZERO
3013:                				clst = 2;
3014:                				do {
3015:                					stat = get_fat(*fatfs, clst);
9D002D84  8E440000   LW A0, 0(S2)
9D002D88  0F40014E   JAL get_fat
9D002D8C  02002821   ADDU A1, S0, ZERO
3016:                					if (stat == 0xFFFFFFFF) {
9D002D7C  2413FFFF   ADDIU S3, ZERO, -1
9D002D90  50530044   BEQL V0, S3, 0x9D002EA4
9D002D94  24150001   ADDIU S5, ZERO, 1
3017:                						res = FR_DISK_ERR;
3018:                						break;
3019:                					}
3020:                					if (stat == 1) {
9D002D80  24140001   ADDIU S4, ZERO, 1
9D002D98  10540041   BEQ V0, S4, 0x9D002EA0
9D002D9C  2C420001   SLTIU V0, V0, 1
3021:                						res = FR_INT_ERR;
9D002EA0  24150002   ADDIU S5, ZERO, 2
3022:                						break;
3023:                					}
3024:                					if (stat == 0)
3025:                						n++;
9D002DA0  02228821   ADDU S1, S1, V0
3026:                				} while (++clst < (*fatfs)->n_fatent);
9D002DA4  26100001   ADDIU S0, S0, 1
9D002DA8  8E420000   LW V0, 0(S2)
9D002DAC  8C42001C   LW V0, 28(V0)
9D002DB0  0202102B   SLTU V0, S0, V0
9D002DB4  5440FFF4   BNEL V0, ZERO, 0x9D002D88
9D002DB8  8E440000   LW A0, 0(S2)
9D002DBC  0B400BAA   J 0x9D002EA8
9D002DC0  8E420000   LW V0, 0(S2)
3027:                			} else {
3028:                				clst = (*fatfs)->n_fatent;
3029:                				sect = (*fatfs)->fatbase;
3030:                				i = 0;
9D002DC8  00002021   ADDU A0, ZERO, ZERO
3031:                				p = 0;
9D002DC4  00001821   ADDU V1, ZERO, ZERO
3032:                				do {
3033:                					if (!i) {
9D002DD4  14800008   BNE A0, ZERO, 0x9D002DF8
9D002DD8  24B70001   ADDIU S7, A1, 1
3034:                						res = move_window(*fatfs, sect++);
9D002DDC  0F40006F   JAL move_window
9D002DE0  8E440000   LW A0, 0(S2)
9D002E74  0040A821   ADDU S5, V0, ZERO
3035:                						if (res != FR_OK)
9D002DE4  14400023   BNE V0, ZERO, 0x9D002E74
9D002DE8  02E02821   ADDU A1, S7, ZERO
3036:                							break;
3037:                						p = (*fatfs)->win;
9D002DEC  8E430000   LW V1, 0(S2)
9D002DF0  24630034   ADDIU V1, V1, 52
3038:                						i = SS(*fatfs);
9D002DF4  24040200   ADDIU A0, ZERO, 512
3039:                					}
3040:                					if (fat == FS_FAT16) {
9D002DD0  24140002   ADDIU S4, ZERO, 2
9D002DF8  5674000B   BNEL S3, S4, 0x9D002E28
9D002DFC  90660003   LBU A2, 3(V1)
3041:                						if (LD_WORD(p) == 0)
9D002E00  90620001   LBU V0, 1(V1)
9D002E04  00021200   SLL V0, V0, 8
9D002E08  90660000   LBU A2, 0(V1)
9D002E0C  00461025   OR V0, V0, A2
9D002E10  7C021620   SEH V0, V0
3042:                							n++;
9D002E14  2C420001   SLTIU V0, V0, 1
9D002E18  02228821   ADDU S1, S1, V0
3043:                						p += 2;
9D002E1C  24630002   ADDIU V1, V1, 2
9D002E20  0B400B98   J 0x9D002E60
9D002E24  2484FFFE   ADDIU A0, A0, -2
3044:                						i -= 2;
3045:                					} else {
3046:                						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0)
9D002E28  00063600   SLL A2, A2, 24
9D002E2C  90620002   LBU V0, 2(V1)
9D002E30  00021400   SLL V0, V0, 16
9D002E34  00C21025   OR V0, A2, V0
9D002E38  90660000   LBU A2, 0(V1)
9D002E3C  00461025   OR V0, V0, A2
9D002E40  90660001   LBU A2, 1(V1)
9D002E44  00063200   SLL A2, A2, 8
9D002E48  00461025   OR V0, V0, A2
9D002E4C  7C42D800   EXT V0, V0, 0, 28
3047:                							n++;
9D002E50  2C420001   SLTIU V0, V0, 1
9D002E54  02228821   ADDU S1, S1, V0
3048:                						p += 4;
9D002E58  24630004   ADDIU V1, V1, 4
3049:                						i -= 4;
9D002E5C  2484FFFC   ADDIU A0, A0, -4
3050:                					}
3051:                				} while (--clst);
9D002E60  2610FFFF   ADDIU S0, S0, -1
9D002E64  1600FFDB   BNE S0, ZERO, 0x9D002DD4
9D002E68  00000000   NOP
9D002E6C  0B400B9F   J 0x9D002E7C
9D002E70  8E420000   LW V0, 0(S2)
3052:                			}
3053:                			(*fatfs)->free_clust = n;
9D002E78  8E420000   LW V0, 0(S2)
9D002E7C  AC510010   SW S1, 16(V0)
9D002EA4  8E420000   LW V0, 0(S2)
9D002EA8  0B400BA6   J 0x9D002E98
9D002EAC  AC510010   SW S1, 16(V0)
3054:                			if (fat == FS_FAT32)
9D002E80  24020003   ADDIU V0, ZERO, 3
9D002E84  5662000A   BNEL S3, V0, 0x9D002EB0
9D002E88  AED10000   SW S1, 0(S6)
3055:                				(*fatfs)->fsi_flag = 1;
9D002E8C  8E420000   LW V0, 0(S2)
9D002E90  24030001   ADDIU V1, ZERO, 1
9D002E94  A0430005   SB V1, 5(V0)
3056:                			*nclst = n;
9D002E98  0B400BAC   J 0x9D002EB0
9D002E9C  AED10000   SW S1, 0(S6)
3057:                		}
3058:                	}
3059:                	LEAVE_FF(*fatfs, res);
3060:                }
9D002EB0  02A01021   ADDU V0, S5, ZERO
9D002EB4  8FBF0034   LW RA, 52(SP)
9D002EB8  8FB70030   LW S7, 48(SP)
9D002EBC  8FB6002C   LW S6, 44(SP)
9D002EC0  8FB50028   LW S5, 40(SP)
9D002EC4  8FB40024   LW S4, 36(SP)
9D002EC8  8FB30020   LW S3, 32(SP)
9D002ECC  8FB2001C   LW S2, 28(SP)
9D002ED0  8FB10018   LW S1, 24(SP)
9D002ED4  8FB00014   LW S0, 20(SP)
9D002ED8  03E00008   JR RA
9D002EDC  27BD0038   ADDIU SP, SP, 56
3061:                
3062:                /*-----------------------------------------------------------------------*/
3063:                /* Truncate File                                                         */
3064:                /*-----------------------------------------------------------------------*/
3065:                
3066:                FRESULT f_truncate(FIL *fp /* Pointer to the file object */
3067:                ) {
9D002EE0  27BDFFE0   ADDIU SP, SP, -32
9D002EE4  AFBF001C   SW RA, 28(SP)
9D002EE8  AFB20018   SW S2, 24(SP)
9D002EEC  AFB10014   SW S1, 20(SP)
9D002EF0  AFB00010   SW S0, 16(SP)
9D002EF4  00808021   ADDU S0, A0, ZERO
3068:                	FRESULT res;
3069:                	DWORD ncl;
3070:                
3071:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D002EF8  8C840000   LW A0, 0(A0)
9D002EFC  0F4000E7   JAL validate
9D002F00  96050004   LHU A1, 4(S0)
3072:                	if (res == FR_OK) {
9D002F04  1440003E   BNE V0, ZERO, 0x9D003000
9D002F08  00408821   ADDU S1, V0, ZERO
3073:                		if (fp->flag & FA__ERROR) { /* Check abort flag */
9D002F0C  92020006   LBU V0, 6(S0)
9D002F10  7C021C20   SEB V1, V0
9D002F14  04600036   BLTZ V1, 0x9D002FF0
9D002F18  30420002   ANDI V0, V0, 2
3074:                			res = FR_INT_ERR;
9D002FF0  0B400C00   J 0x9D003000
9D002FF4  24110002   ADDIU S1, ZERO, 2
3075:                		} else {
3076:                			if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D002F1C  304200FF   ANDI V0, V0, 255
9D002F20  50400037   BEQL V0, ZERO, 0x9D003000
9D002F24  24110007   ADDIU S1, ZERO, 7
9D002F28  0B400BF6   J 0x9D002FD8
9D002F2C  8E020008   LW V0, 8(S0)
3077:                				res = FR_DENIED;
3078:                		}
3079:                	}
3080:                	if (res == FR_OK) {
3081:                		if (fp->fsize > fp->fptr) {
9D002FD8  8E03000C   LW V1, 12(S0)
9D002FDC  0043182B   SLTU V1, V0, V1
9D002FE0  5460FFD3   BNEL V1, ZERO, 0x9D002F30
9D002FE4  AE02000C   SW V0, 12(S0)
9D002FE8  0B400C01   J 0x9D003004
9D002FEC  02201021   ADDU V0, S1, ZERO
3082:                			fp->fsize = fp->fptr; /* Set file size to current R/W point */
3083:                			fp->flag |= FA__WRITTEN;
9D002F30  92030006   LBU V1, 6(S0)
9D002F34  34630020   ORI V1, V1, 32
3084:                			if (fp->fptr == 0) { /* When set file size to zero, remove entire cluster chain */
9D002F38  14400007   BNE V0, ZERO, 0x9D002F58
9D002F3C  A2030006   SB V1, 6(S0)
3085:                				res = remove_chain(fp->fs, fp->sclust);
9D002F40  8E040000   LW A0, 0(S0)
9D002F44  0F4004E9   JAL remove_chain
9D002F48  8E050010   LW A1, 16(S0)
9D002F4C  00408821   ADDU S1, V0, ZERO
9D002F50  0B400BEF   J 0x9D002FBC
9D002F54  AE000010   SW ZERO, 16(S0)
3086:                				fp->sclust = 0;
3087:                			} else { /* When truncate a part of the file, remove remaining clusters */
3088:                				ncl = get_fat(fp->fs, fp->clust);
9D002F58  8E040000   LW A0, 0(S0)
9D002F5C  0F40014E   JAL get_fat
9D002F60  8E050014   LW A1, 20(S0)
9D002F64  00409021   ADDU S2, V0, ZERO
3089:                				res = FR_OK;
3090:                				if (ncl == 0xFFFFFFFF)
9D002F74  2C420001   SLTIU V0, V0, 1
3091:                					res = FR_DISK_ERR;
3092:                				if (ncl == 1)
9D002F68  24020001   ADDIU V0, ZERO, 1
9D002F6C  12420022   BEQ S2, V0, 0x9D002FF8
9D002F70  26420001   ADDIU V0, S2, 1
3093:                					res = FR_INT_ERR;
9D002FF8  0B400BF1   J 0x9D002FC4
9D002FFC  24110002   ADDIU S1, ZERO, 2
3094:                				if (res == FR_OK && ncl < fp->fs->n_fatent) {
9D002F78  54400012   BNEL V0, ZERO, 0x9D002FC4
9D002F7C  00408821   ADDU S1, V0, ZERO
9D002F80  8E040000   LW A0, 0(S0)
9D002F84  8C82001C   LW V0, 28(A0)
9D002F88  0242102B   SLTU V0, S2, V0
9D002F8C  1040001D   BEQ V0, ZERO, 0x9D003004
9D002F90  02201021   ADDU V0, S1, ZERO
3095:                					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
9D002F94  8E050014   LW A1, 20(S0)
9D002F98  3C060FFF   LUI A2, 4095
9D002F9C  0F400217   JAL put_fat
9D002FA0  34C6FFFF   ORI A2, A2, -1
3096:                					if (res == FR_OK)
9D002FA4  14400007   BNE V0, ZERO, 0x9D002FC4
9D002FA8  00408821   ADDU S1, V0, ZERO
3097:                						res = remove_chain(fp->fs, ncl);
9D002FAC  8E040000   LW A0, 0(S0)
9D002FB0  0F4004E9   JAL remove_chain
9D002FB4  02402821   ADDU A1, S2, ZERO
9D002FB8  00408821   ADDU S1, V0, ZERO
3098:                				}
3099:                			}
3100:                		}
3101:                		if (res != FR_OK)
9D002FBC  12200011   BEQ S1, ZERO, 0x9D003004
9D002FC0  02201021   ADDU V0, S1, ZERO
3102:                			fp->flag |= FA__ERROR;
9D002FC4  92030006   LBU V1, 6(S0)
9D002FC8  2402FF80   ADDIU V0, ZERO, -128
9D002FCC  00621025   OR V0, V1, V0
9D002FD0  0B400C00   J 0x9D003000
9D002FD4  A2020006   SB V0, 6(S0)
3103:                	}
3104:                
3105:                	LEAVE_FF(fp->fs, res);
3106:                }
9D003000  02201021   ADDU V0, S1, ZERO
9D003004  8FBF001C   LW RA, 28(SP)
9D003008  8FB20018   LW S2, 24(SP)
9D00300C  8FB10014   LW S1, 20(SP)
9D003010  8FB00010   LW S0, 16(SP)
9D003014  03E00008   JR RA
9D003018  27BD0020   ADDIU SP, SP, 32
3107:                
3108:                /*-----------------------------------------------------------------------*/
3109:                /* Delete a File or Directory                                            */
3110:                /*-----------------------------------------------------------------------*/
3111:                
3112:                FRESULT f_unlink(const TCHAR *path /* Pointer to the file or directory path */
3113:                ) {
9D00301C  27BDFFA0   ADDIU SP, SP, -96
9D003020  AFBF005C   SW RA, 92(SP)
9D003024  AFB00058   SW S0, 88(SP)
9D003028  AFA40060   SW A0, 96(SP)
3114:                	FRESULT res;
3115:                	DIR dj, sdj;
3116:                	PF_BYTE *dir;
3117:                	DWORD dclst;
3118:                	DEF_NAMEBUF;
3119:                
3120:                	res = chk_mounted(&path, &dj.fs, 1);
9D00302C  27A40060   ADDIU A0, SP, 96
9D003030  27A50010   ADDIU A1, SP, 16
9D003034  0F400521   JAL chk_mounted
9D003038  24060001   ADDIU A2, ZERO, 1
3121:                	if (res == FR_OK) {
9D00303C  14400055   BNE V0, ZERO, 0x9D003194
9D003040  8FBF005C   LW RA, 92(SP)
3122:                		INIT_BUF(dj);
9D003044  27A20048   ADDIU V0, SP, 72
9D003048  AFA20028   SW V0, 40(SP)
3123:                		res = follow_path(&dj, path); /* Follow the file path */
9D00304C  27A40010   ADDIU A0, SP, 16
9D003050  0F400367   JAL follow_path
9D003054  8FA50060   LW A1, 96(SP)
3124:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D003058  1440004E   BNE V0, ZERO, 0x9D003194
9D00305C  8FBF005C   LW RA, 92(SP)
9D003060  8FA20028   LW V0, 40(SP)
9D003064  9043000B   LBU V1, 11(V0)
9D003068  30630020   ANDI V1, V1, 32
9D00306C  306300FF   ANDI V1, V1, 255
9D003070  14600047   BNE V1, ZERO, 0x9D003190
9D003074  24020006   ADDIU V0, ZERO, 6
9D003078  0B400C47   J 0x9D00311C
9D00307C  8FA30024   LW V1, 36(SP)
3125:                			res = FR_INVALID_NAME; /* Cannot remove dot entry */
3126:                #if _FS_SHARE
3127:                		if (res == FR_OK) res = chk_lock(&dj, 2); /* Cannot remove open file */
3128:                #endif
3129:                		if (res == FR_OK) { /* The object is accessible */
3130:                			dir = dj.dir;
3131:                			if (!dir) {
9D00311C  5460FFD8   BNEL V1, ZERO, 0x9D003080
9D003120  9064000B   LBU A0, 11(V1)
9D003124  0B400C51   J 0x9D003144
9D003128  24020006   ADDIU V0, ZERO, 6
3132:                				res = FR_INVALID_NAME; /* Cannot remove the start directory */
3133:                			} else {
3134:                				if (dir[DIR_Attr] & AM_RDO)
9D003080  30840001   ANDI A0, A0, 1
9D003084  14800042   BNE A0, ZERO, 0x9D003190
9D003088  24020007   ADDIU V0, ZERO, 7
9D00308C  0B400C53   J 0x9D00314C
9D003090  90620015   LBU V0, 21(V1)
3135:                					res = FR_DENIED; /* Cannot remove R/O object */
3136:                			}
3137:                			dclst = LD_CLUST(dir);
9D00314C  00021200   SLL V0, V0, 8
9D003150  90640014   LBU A0, 20(V1)
9D003154  00441025   OR V0, V0, A0
9D003158  00021400   SLL V0, V0, 16
9D00315C  9070001B   LBU S0, 27(V1)
9D003160  00108200   SLL S0, S0, 8
9D003164  9064001A   LBU A0, 26(V1)
9D003168  02048025   OR S0, S0, A0
9D00316C  00508025   OR S0, V0, S0
3138:                			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) { /* Is it a sub-dir? */
9D003170  9062000B   LBU V0, 11(V1)
9D003174  30420010   ANDI V0, V0, 16
9D003178  304200FF   ANDI V0, V0, 255
9D00317C  1440FFC5   BNE V0, ZERO, 0x9D003094
9D003180  2E030002   SLTIU V1, S0, 2
9D003184  0B400C4B   J 0x9D00312C
9D003188  00000000   NOP
9D00318C  24020007   ADDIU V0, ZERO, 7
3139:                				if (dclst < 2) {
9D003094  1460003E   BNE V1, ZERO, 0x9D003190
9D003098  24020002   ADDIU V0, ZERO, 2
3140:                					res = FR_INT_ERR;
3141:                				} else {
3142:                					mem_cpy(&sdj, &dj, sizeof(DIR)); /* Check if the sub-dir is empty or not */
9D00309C  27A4002C   ADDIU A0, SP, 44
9D0030A0  27A50010   ADDIU A1, SP, 16
9D0030A4  0F400000   JAL mem_cpy
9D0030A8  2406001C   ADDIU A2, ZERO, 28
3143:                					sdj.sclust = dclst;
9D0030AC  AFB00034   SW S0, 52(SP)
3144:                					res = dir_sdi(&sdj, 2); /* Exclude dot entries */
9D0030B0  27A4002C   ADDIU A0, SP, 44
9D0030B4  0F4001B0   JAL dir_sdi
9D0030B8  24050002   ADDIU A1, ZERO, 2
3145:                					if (res == FR_OK) {
9D0030BC  14400035   BNE V0, ZERO, 0x9D003194
9D0030C0  8FBF005C   LW RA, 92(SP)
3146:                						res = dir_read(&sdj);
9D0030C4  0F4004C2   JAL dir_read
9D0030C8  27A4002C   ADDIU A0, SP, 44
3147:                						if (res == FR_OK /* Not empty dir */
9D0030CC  50400030   BEQL V0, ZERO, 0x9D003190
9D0030D0  24020007   ADDIU V0, ZERO, 7
3148:                #if _FS_RPATH
3149:                							|| dclst == sdj.fs->cdir /* Current dir */
9D0030D4  8FA3002C   LW V1, 44(SP)
9D0030D8  8C630018   LW V1, 24(V1)
9D0030DC  1070002B   BEQ V1, S0, 0x9D00318C
9D0030E0  24030004   ADDIU V1, ZERO, 4
3150:                #endif
3151:                							) res = FR_DENIED;
3152:                						if (res == FR_NO_FILE)
9D0030E4  10430011   BEQ V0, V1, 0x9D00312C
9D0030E8  8FBF005C   LW RA, 92(SP)
9D0030EC  0B400C66   J 0x9D003198
9D0030F0  8FB00058   LW S0, 88(SP)
3153:                							res = FR_OK; /* Empty */
3154:                					}
3155:                				}
3156:                			}
3157:                			if (res == FR_OK) {
3158:                				res = dir_remove(&dj); /* Remove the directory entry */
9D00312C  0F400201   JAL dir_remove
9D003130  27A40010   ADDIU A0, SP, 16
3159:                				if (res == FR_OK) {
9D003134  1040FFEF   BEQ V0, ZERO, 0x9D0030F4
9D003138  8FBF005C   LW RA, 92(SP)
9D00313C  0B400C66   J 0x9D003198
9D003140  8FB00058   LW S0, 88(SP)
3160:                					if (dclst) /* Remove the cluster chain if exist */
9D0030F4  12000005   BEQ S0, ZERO, 0x9D00310C
9D0030F8  8FA40010   LW A0, 16(SP)
3161:                						res = remove_chain(dj.fs, dclst);
9D0030FC  0F4004E9   JAL remove_chain
9D003100  02002821   ADDU A1, S0, ZERO
3162:                					if (res == FR_OK)
9D003104  54400023   BNEL V0, ZERO, 0x9D003194
9D003108  8FBF005C   LW RA, 92(SP)
3163:                						res = sync(dj.fs);
9D00310C  0F4000FE   JAL sync
9D003110  8FA40010   LW A0, 16(SP)
3164:                				}
3165:                			}
3166:                		}FREE_BUF();
3167:                	}
3168:                	LEAVE_FF(dj.fs, res);
3169:                }
9D003114  0B400C65   J 0x9D003194
9D003118  8FBF005C   LW RA, 92(SP)
9D003144  0B400C65   J 0x9D003194
9D003148  8FBF005C   LW RA, 92(SP)
9D003190  8FBF005C   LW RA, 92(SP)
9D003194  8FB00058   LW S0, 88(SP)
9D003198  03E00008   JR RA
9D00319C  27BD0060   ADDIU SP, SP, 96
3170:                
3171:                /*-----------------------------------------------------------------------*/
3172:                /* Create a Directory                                                    */
3173:                /*-----------------------------------------------------------------------*/
3174:                
3175:                FRESULT f_mkdir(const TCHAR *path /* Pointer to the directory path */
3176:                ) {
9D0031A0  27BDFF88   ADDIU SP, SP, -120
9D0031A4  AFBF0074   SW RA, 116(SP)
9D0031A8  AFBE0070   SW S8, 112(SP)
9D0031AC  AFB7006C   SW S7, 108(SP)
9D0031B0  AFB60068   SW S6, 104(SP)
9D0031B4  AFB50064   SW S5, 100(SP)
9D0031B8  AFB40060   SW S4, 96(SP)
9D0031BC  AFB3005C   SW S3, 92(SP)
9D0031C0  AFB20058   SW S2, 88(SP)
9D0031C4  AFB10054   SW S1, 84(SP)
9D0031C8  AFB00050   SW S0, 80(SP)
3177:                	FRESULT res;
3178:                	DIR dj;
3179:                	PF_BYTE *dir, n;
3180:                	DWORD dsc, dcl, pcl, tim = get_fattime();
9D0031CC  0F4030CD   JAL get_fattime
9D0031D0  AFA40078   SW A0, 120(SP)
9D0031D4  0040A821   ADDU S5, V0, ZERO
3181:                	DEF_NAMEBUF;
3182:                
3183:                	res = chk_mounted(&path, &dj.fs, 1);
9D0031D8  27A40078   ADDIU A0, SP, 120
9D0031DC  27A50010   ADDIU A1, SP, 16
9D0031E0  0F400521   JAL chk_mounted
9D0031E4  24060001   ADDIU A2, ZERO, 1
3184:                	if (res == FR_OK) {
9D0031E8  144000A0   BNE V0, ZERO, 0x9D00346C
9D0031EC  00408021   ADDU S0, V0, ZERO
3185:                		INIT_BUF(dj);
9D0031F0  27A2002C   ADDIU V0, SP, 44
9D0031F4  AFA20028   SW V0, 40(SP)
3186:                		res = follow_path(&dj, path); /* Follow the file path */
9D0031F8  27A40010   ADDIU A0, SP, 16
9D0031FC  0F400367   JAL follow_path
9D003200  8FA50078   LW A1, 120(SP)
3187:                		if (res == FR_OK)
9D003204  50400099   BEQL V0, ZERO, 0x9D00346C
9D003208  24100008   ADDIU S0, ZERO, 8
3188:                			res = FR_EXIST; /* Any object with same name is already existing */
3189:                		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
9D00320C  24030004   ADDIU V1, ZERO, 4
9D003210  54430096   BNEL V0, V1, 0x9D00346C
9D003214  00408021   ADDU S0, V0, ZERO
9D003218  8FA20028   LW V0, 40(SP)
9D00321C  9042000B   LBU V0, 11(V0)
9D003220  30420020   ANDI V0, V0, 32
9D003224  304200FF   ANDI V0, V0, 255
9D003228  54400090   BNEL V0, ZERO, 0x9D00346C
9D00322C  24100006   ADDIU S0, ZERO, 6
9D003230  0B400D0F   J 0x9D00343C
9D003234  8FA40010   LW A0, 16(SP)
3190:                			res = FR_INVALID_NAME;
3191:                		if (res == FR_NO_FILE) { /* Can create a new directory */
3192:                			dcl = create_chain(dj.fs, 0); /* Allocate a cluster for the new directory table */
9D00343C  0F400284   JAL create_chain
9D003440  00002821   ADDU A1, ZERO, ZERO
3193:                			res = FR_OK;
3194:                			if (dcl == 0)
9D003444  1040FF83   BEQ V0, ZERO, 0x9D003254
9D003448  0040A021   ADDU S4, V0, ZERO
9D00344C  0B400C8E   J 0x9D003238
9D003450  24020001   ADDIU V0, ZERO, 1
3195:                				res = FR_DENIED; /* No space to allocate a new cluster */
9D003254  24100007   ADDIU S0, ZERO, 7
3196:                			if (dcl == 1)
9D003238  52820064   BEQL S4, V0, 0x9D0033CC
9D00323C  24100002   ADDIU S0, ZERO, 2
3197:                				res = FR_INT_ERR;
3198:                			if (dcl == 0xFFFFFFFF)
9D003240  2402FFFF   ADDIU V0, ZERO, -1
9D003244  52820061   BEQL S4, V0, 0x9D0033CC
9D003248  24100001   ADDIU S0, ZERO, 1
9D00324C  0B400C96   J 0x9D003258
9D003250  00000000   NOP
3199:                				res = FR_DISK_ERR;
3200:                			if (res == FR_OK) /* Flush FAT */
9D003258  1600005C   BNE S0, ZERO, 0x9D0033CC
9D00325C  8FA40010   LW A0, 16(SP)
3201:                				res = move_window(dj.fs, 0);
9D003260  0F40006F   JAL move_window
9D003264  00002821   ADDU A1, ZERO, ZERO
3202:                			if (res == FR_OK) { /* Initialize the new directory table */
9D003268  14400058   BNE V0, ZERO, 0x9D0033CC
9D00326C  00408021   ADDU S0, V0, ZERO
3203:                				dsc = clust2sect(dj.fs, dcl);
9D003270  8FB20010   LW S2, 16(SP)
9D003274  02402021   ADDU A0, S2, ZERO
9D003278  0F400142   JAL clust2sect
9D00327C  02802821   ADDU A1, S4, ZERO
9D003280  00408021   ADDU S0, V0, ZERO
3204:                				dir = dj.fs->win;
9D003284  26530034   ADDIU S3, S2, 52
9D003288  26510234   ADDIU S1, S2, 564
3205:                				mem_set(dir, 0, SS(dj.fs));
3206:                				mem_set(dir + DIR_Name, ' ', 8 + 3); /* Create "." entry */
3207:                				dir[DIR_Name] = '.';
9D0032B4  2416002E   ADDIU S6, ZERO, 46
9D0032B8  A2560034   SB S6, 52(S2)
3208:                				dir[DIR_Attr] = AM_DIR;
9D0032BC  24020010   ADDIU V0, ZERO, 16
9D0032C0  A242003F   SB V0, 63(S2)
3209:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D0032C4  32A200FF   ANDI V0, S5, 255
9D0032C8  AFA20038   SW V0, 56(SP)
9D0032CC  A242004A   SB V0, 74(S2)
9D0032D0  7EA33A00   EXT V1, S5, 8, 8
9D0032D4  AFA3003C   SW V1, 60(SP)
9D0032D8  A243004B   SB V1, 75(S2)
9D0032DC  7EA23C00   EXT V0, S5, 16, 8
9D0032E0  AFA20040   SW V0, 64(SP)
9D0032E4  A242004C   SB V0, 76(S2)
9D0032E8  0015AE02   SRL S5, S5, 24
9D0032EC  AFB50044   SW S5, 68(SP)
9D0032F0  A255004D   SB S5, 77(S2)
3210:                				ST_CLUST(dir, dcl);
9D0032F4  328300FF   ANDI V1, S4, 255
9D0032F8  AFA30048   SW V1, 72(SP)
9D0032FC  A243004E   SB V1, 78(S2)
9D003300  7E823A00   EXT V0, S4, 8, 8
9D003304  AFA2004C   SW V0, 76(SP)
9D003308  A242004F   SB V0, 79(S2)
9D00330C  0014F402   SRL S8, S4, 16
9D003310  33D700FF   ANDI S7, S8, 255
9D003314  A2570048   SB S7, 72(S2)
9D003318  001EF202   SRL S8, S8, 8
9D00331C  A25E0049   SB S8, 73(S2)
3211:                				mem_cpy(dir + SZ_DIR, dir, SZ_DIR); /* Create ".." entry */
9D003320  26440054   ADDIU A0, S2, 84
9D003324  02602821   ADDU A1, S3, ZERO
9D003328  0F400000   JAL mem_cpy
9D00332C  24060020   ADDIU A2, ZERO, 32
3212:                				dir[33] = '.';
9D003330  A2560055   SB S6, 85(S2)
3213:                				pcl = dj.sclust;
3214:                				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
9D003334  8FA30010   LW V1, 16(SP)
9D003338  90650000   LBU A1, 0(V1)
9D00333C  24040003   ADDIU A0, ZERO, 3
9D003340  14A40004   BNE A1, A0, 0x9D003354
9D003344  8FA20018   LW V0, 24(SP)
9D003348  8C640028   LW A0, 40(V1)
3215:                					pcl = 0;
9D00334C  00822026   XOR A0, A0, V0
9D003350  0004100A   MOVZ V0, ZERO, A0
3216:                				ST_CLUST(dir+SZ_DIR, pcl);
9D003354  A242006E   SB V0, 110(S2)
9D003358  7C443A00   EXT A0, V0, 8, 8
9D00335C  A244006F   SB A0, 111(S2)
9D003360  00021402   SRL V0, V0, 16
9D003364  A2420068   SB V0, 104(S2)
9D003368  00021202   SRL V0, V0, 8
9D00336C  A2420069   SB V0, 105(S2)
3217:                				for (n = dj.fs->csize; n; n--) { /* Write dot entries and clear following sectors */
9D003370  90620002   LBU V0, 2(V1)
9D003374  10400037   BEQ V0, ZERO, 0x9D003454
9D003378  2442FFFF   ADDIU V0, V0, -1
9D00337C  305600FF   ANDI S6, V0, 255
9D003380  26D60001   ADDIU S6, S6, 1
9D003384  02D0B021   ADDU S6, S6, S0
9D0033BC  12560025   BEQ S2, S6, 0x9D003454
9D0033C0  00000000   NOP
3218:                					dj.fs->winsect = dsc++;
9D00338C  8FA40010   LW A0, 16(SP)
9D003390  26120001   ADDIU S2, S0, 1
9D003394  AC900030   SW S0, 48(A0)
9D0033C4  0B400CE3   J 0x9D00338C
9D0033C8  02408021   ADDU S0, S2, ZERO
3219:                					dj.fs->wflag = 1;
9D003388  24150001   ADDIU S5, ZERO, 1
9D003398  A0950004   SB S5, 4(A0)
3220:                					res = move_window(dj.fs, 0);
9D00339C  0F40006F   JAL move_window
9D0033A0  00002821   ADDU A1, ZERO, ZERO
3221:                					if (res != FR_OK)
9D0033A4  14400009   BNE V0, ZERO, 0x9D0033CC
9D0033A8  00408021   ADDU S0, V0, ZERO
9D0033AC  02601021   ADDU V0, S3, ZERO
3222:                						break;
3223:                					mem_set(dir, 0, SS(dj.fs));
3224:                				}
3225:                			}
3226:                			if (res == FR_OK)
3227:                				res = dir_register(&dj); /* Register the object to the directoy */
9D003454  0F40048D   JAL dir_register
9D003458  27A40010   ADDIU A0, SP, 16
3228:                			if (res != FR_OK) {
9D00345C  1040FFE0   BEQ V0, ZERO, 0x9D0033E0
9D003460  00408021   ADDU S0, V0, ZERO
9D003464  0B400CF4   J 0x9D0033D0
9D003468  8FA40010   LW A0, 16(SP)
3229:                				remove_chain(dj.fs, dcl); /* Could not register, remove cluster chain */
9D0033CC  8FA40010   LW A0, 16(SP)
9D0033D0  0F4004E9   JAL remove_chain
9D0033D4  02802821   ADDU A1, S4, ZERO
9D0033D8  0B400D1C   J 0x9D003470
9D0033DC  02001021   ADDU V0, S0, ZERO
3230:                			} else {
3231:                				dir = dj.dir;
9D0033E0  8FA20024   LW V0, 36(SP)
3232:                				dir[DIR_Attr] = AM_DIR; /* Attribute */
9D0033E4  24030010   ADDIU V1, ZERO, 16
9D0033E8  A043000B   SB V1, 11(V0)
3233:                				ST_DWORD(dir+DIR_WrtTime, tim); /* Created time */
9D0033EC  8FA30038   LW V1, 56(SP)
9D0033F0  A0430016   SB V1, 22(V0)
9D0033F4  8FA3003C   LW V1, 60(SP)
9D0033F8  A0430017   SB V1, 23(V0)
9D0033FC  8FA30040   LW V1, 64(SP)
9D003400  A0430018   SB V1, 24(V0)
9D003404  8FA30044   LW V1, 68(SP)
9D003408  A0430019   SB V1, 25(V0)
3234:                				ST_CLUST(dir, dcl); /* Table start cluster */
9D00340C  8FA30048   LW V1, 72(SP)
9D003410  A043001A   SB V1, 26(V0)
9D003414  8FA3004C   LW V1, 76(SP)
9D003418  A043001B   SB V1, 27(V0)
9D00341C  A0570014   SB S7, 20(V0)
9D003420  A05E0015   SB S8, 21(V0)
3235:                				dj.fs->wflag = 1;
9D003424  8FA40010   LW A0, 16(SP)
9D003428  24020001   ADDIU V0, ZERO, 1
3236:                				res = sync(dj.fs);
9D00342C  0F4000FE   JAL sync
9D003430  A0820004   SB V0, 4(A0)
9D003434  0B400D1B   J 0x9D00346C
9D003438  00408021   ADDU S0, V0, ZERO
3237:                			}
3238:                		}FREE_BUF();
3239:                	}
3240:                
3241:                	LEAVE_FF(dj.fs, res);
3242:                }
9D00346C  02001021   ADDU V0, S0, ZERO
9D003470  8FBF0074   LW RA, 116(SP)
9D003474  8FBE0070   LW S8, 112(SP)
9D003478  8FB7006C   LW S7, 108(SP)
9D00347C  8FB60068   LW S6, 104(SP)
9D003480  8FB50064   LW S5, 100(SP)
9D003484  8FB40060   LW S4, 96(SP)
9D003488  8FB3005C   LW S3, 92(SP)
9D00348C  8FB20058   LW S2, 88(SP)
9D003490  8FB10054   LW S1, 84(SP)
9D003494  8FB00050   LW S0, 80(SP)
9D003498  03E00008   JR RA
9D00349C  27BD0078   ADDIU SP, SP, 120
3243:                
3244:                /*-----------------------------------------------------------------------*/
3245:                /* Change Attribute                                                      */
3246:                /*-----------------------------------------------------------------------*/
3247:                
3248:                FRESULT f_chmod(const TCHAR *path, /* Pointer to the file path */
3249:                PF_BYTE value, /* Attribute bits */
3250:                PF_BYTE mask /* Attribute mask to change */
3251:                ) {
9D0034A0  27BDFFB8   ADDIU SP, SP, -72
9D0034A4  AFBF0044   SW RA, 68(SP)
9D0034A8  AFB10040   SW S1, 64(SP)
9D0034AC  AFB0003C   SW S0, 60(SP)
9D0034B0  AFA40048   SW A0, 72(SP)
9D0034B4  00A08021   ADDU S0, A1, ZERO
9D0034B8  00C08821   ADDU S1, A2, ZERO
3252:                	FRESULT res;
3253:                	DIR dj;
3254:                	PF_BYTE *dir;
3255:                	DEF_NAMEBUF;
3256:                
3257:                	res = chk_mounted(&path, &dj.fs, 1);
9D0034BC  27A40048   ADDIU A0, SP, 72
9D0034C0  27A50010   ADDIU A1, SP, 16
9D0034C4  0F400521   JAL chk_mounted
9D0034C8  24060001   ADDIU A2, ZERO, 1
3258:                	if (res == FR_OK) {
9D0034CC  14400020   BNE V0, ZERO, 0x9D003550
9D0034D0  8FBF0044   LW RA, 68(SP)
3259:                		INIT_BUF(dj);
9D0034D4  27A2002C   ADDIU V0, SP, 44
9D0034D8  AFA20028   SW V0, 40(SP)
3260:                		res = follow_path(&dj, path); /* Follow the file path */
9D0034DC  27A40010   ADDIU A0, SP, 16
9D0034E0  0F400367   JAL follow_path
9D0034E4  8FA50048   LW A1, 72(SP)
3261:                		FREE_BUF();
3262:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D0034E8  14400019   BNE V0, ZERO, 0x9D003550
9D0034EC  8FBF0044   LW RA, 68(SP)
9D0034F0  8FA20028   LW V0, 40(SP)
9D0034F4  9043000B   LBU V1, 11(V0)
9D0034F8  30630020   ANDI V1, V1, 32
9D0034FC  306300FF   ANDI V1, V1, 255
9D003500  14600012   BNE V1, ZERO, 0x9D00354C
9D003504  24020006   ADDIU V0, ZERO, 6
9D003508  0B400D51   J 0x9D003544
9D00350C  8FA30024   LW V1, 36(SP)
3263:                			res = FR_INVALID_NAME;
3264:                		if (res == FR_OK) {
3265:                			dir = dj.dir;
3266:                			if (!dir) { /* Is it a root directory? */
9D003544  1460FFF2   BNE V1, ZERO, 0x9D003510
9D003548  24020006   ADDIU V0, ZERO, 6
3267:                				res = FR_INVALID_NAME;
3268:                			} else { /* File or sub directory */
3269:                				mask &= AM_RDO | AM_HID | AM_SYS | AM_ARC; /* Valid attribute mask */
9D003510  32310027   ANDI S1, S1, 39
3270:                				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr]
9D003518  9062000B   LBU V0, 11(V1)
9D00351C  00821024   AND V0, A0, V0
9D003520  02308824   AND S1, S1, S0
9D003524  00518825   OR S1, V0, S1
9D003528  A071000B   SB S1, 11(V1)
3271:                						& (PF_BYTE) ~mask); /* Apply attribute change */
9D003514  00112027   NOR A0, ZERO, S1
3272:                				dj.fs->wflag = 1;
9D00352C  8FA40010   LW A0, 16(SP)
9D003530  24020001   ADDIU V0, ZERO, 1
3273:                				res = sync(dj.fs);
9D003534  0F4000FE   JAL sync
9D003538  A0820004   SB V0, 4(A0)
3274:                			}
3275:                		}
3276:                	}
3277:                
3278:                	LEAVE_FF(dj.fs, res);
3279:                }
9D00353C  0B400D54   J 0x9D003550
9D003540  8FBF0044   LW RA, 68(SP)
9D00354C  8FBF0044   LW RA, 68(SP)
9D003550  8FB10040   LW S1, 64(SP)
9D003554  8FB0003C   LW S0, 60(SP)
9D003558  03E00008   JR RA
9D00355C  27BD0048   ADDIU SP, SP, 72
3280:                
3281:                /*-----------------------------------------------------------------------*/
3282:                /* Change Timestamp                                                      */
3283:                /*-----------------------------------------------------------------------*/
3284:                
3285:                FRESULT f_utime(const TCHAR *path, /* Pointer to the file/directory name */
3286:                const FILINFO *fno /* Pointer to the time stamp to be set */
3287:                ) {
9D003560  27BDFFC0   ADDIU SP, SP, -64
9D003564  AFBF003C   SW RA, 60(SP)
9D003568  AFB00038   SW S0, 56(SP)
9D00356C  AFA40040   SW A0, 64(SP)
9D003570  00A08021   ADDU S0, A1, ZERO
3288:                	FRESULT res;
3289:                	DIR dj;
3290:                	PF_BYTE *dir;
3291:                	DEF_NAMEBUF;
3292:                
3293:                	res = chk_mounted(&path, &dj.fs, 1);
9D003574  27A40040   ADDIU A0, SP, 64
9D003578  27A50010   ADDIU A1, SP, 16
9D00357C  0F400521   JAL chk_mounted
9D003580  24060001   ADDIU A2, ZERO, 1
3294:                	if (res == FR_OK) {
9D003584  14400023   BNE V0, ZERO, 0x9D003614
9D003588  8FBF003C   LW RA, 60(SP)
3295:                		INIT_BUF(dj);
9D00358C  27A2002C   ADDIU V0, SP, 44
9D003590  AFA20028   SW V0, 40(SP)
3296:                		res = follow_path(&dj, path); /* Follow the file path */
9D003594  27A40010   ADDIU A0, SP, 16
9D003598  0F400367   JAL follow_path
9D00359C  8FA50040   LW A1, 64(SP)
3297:                		FREE_BUF();
3298:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D0035A0  1440001C   BNE V0, ZERO, 0x9D003614
9D0035A4  8FBF003C   LW RA, 60(SP)
9D0035A8  8FA20028   LW V0, 40(SP)
9D0035AC  9043000B   LBU V1, 11(V0)
9D0035B0  30630020   ANDI V1, V1, 32
9D0035B4  306300FF   ANDI V1, V1, 255
9D0035B8  14600015   BNE V1, ZERO, 0x9D003610
9D0035BC  24020006   ADDIU V0, ZERO, 6
9D0035C0  0B400D82   J 0x9D003608
9D0035C4  8FA30024   LW V1, 36(SP)
3299:                			res = FR_INVALID_NAME;
3300:                		if (res == FR_OK) {
3301:                			dir = dj.dir;
3302:                			if (!dir) { /* Root directory */
9D003608  1460FFEF   BNE V1, ZERO, 0x9D0035C8
9D00360C  24020006   ADDIU V0, ZERO, 6
3303:                				res = FR_INVALID_NAME;
3304:                			} else { /* File or sub-directory */
3305:                				ST_WORD(dir+DIR_WrtTime, fno->ftime);
9D0035C8  96020006   LHU V0, 6(S0)
9D0035CC  A0620016   SB V0, 22(V1)
9D0035D0  96020006   LHU V0, 6(S0)
9D0035D4  00021202   SRL V0, V0, 8
9D0035D8  A0620017   SB V0, 23(V1)
3306:                				ST_WORD(dir+DIR_WrtDate, fno->fdate);
9D0035DC  96020004   LHU V0, 4(S0)
9D0035E0  A0620018   SB V0, 24(V1)
9D0035E4  96020004   LHU V0, 4(S0)
9D0035E8  00021202   SRL V0, V0, 8
9D0035EC  A0620019   SB V0, 25(V1)
3307:                				dj.fs->wflag = 1;
9D0035F0  8FA40010   LW A0, 16(SP)
9D0035F4  24020001   ADDIU V0, ZERO, 1
3308:                				res = sync(dj.fs);
9D0035F8  0F4000FE   JAL sync
9D0035FC  A0820004   SB V0, 4(A0)
3309:                			}
3310:                		}
3311:                	}
3312:                
3313:                	LEAVE_FF(dj.fs, res);
3314:                }
9D003600  0B400D85   J 0x9D003614
9D003604  8FBF003C   LW RA, 60(SP)
9D003610  8FBF003C   LW RA, 60(SP)
9D003614  8FB00038   LW S0, 56(SP)
9D003618  03E00008   JR RA
9D00361C  27BD0040   ADDIU SP, SP, 64
3315:                
3316:                /*-----------------------------------------------------------------------*/
3317:                /* Rename File/Directory                                                 */
3318:                /*-----------------------------------------------------------------------*/
3319:                
3320:                FRESULT f_rename(const TCHAR *path_old, /* Pointer to the old name */
3321:                const TCHAR *path_new /* Pointer to the new name */
3322:                ) {
9D003620  27BDFF80   ADDIU SP, SP, -128
9D003624  AFBF007C   SW RA, 124(SP)
9D003628  AFB10078   SW S1, 120(SP)
9D00362C  AFB00074   SW S0, 116(SP)
9D003630  AFA40080   SW A0, 128(SP)
9D003634  00A08021   ADDU S0, A1, ZERO
3323:                	FRESULT res;
3324:                	DIR djo, djn;
3325:                	PF_BYTE buf[21], *dir;
3326:                	DWORD dw;
3327:                	DEF_NAMEBUF;
3328:                
3329:                	res = chk_mounted(&path_old, &djo.fs, 1);
9D003638  27A40080   ADDIU A0, SP, 128
9D00363C  27A50010   ADDIU A1, SP, 16
9D003640  0F400521   JAL chk_mounted
9D003644  24060001   ADDIU A2, ZERO, 1
3330:                	if (res == FR_OK) {
9D003648  14400070   BNE V0, ZERO, 0x9D00380C
9D00364C  8FBF007C   LW RA, 124(SP)
3331:                		djn.fs = djo.fs;
9D003650  8FA20010   LW V0, 16(SP)
9D003654  AFA2002C   SW V0, 44(SP)
3332:                		INIT_BUF(djo);
9D003658  27A20060   ADDIU V0, SP, 96
9D00365C  AFA20028   SW V0, 40(SP)
3333:                		res = follow_path(&djo, path_old); /* Check old object */
9D003660  27A40010   ADDIU A0, SP, 16
9D003664  0F400367   JAL follow_path
9D003668  8FA50080   LW A1, 128(SP)
3334:                		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
9D00366C  14400067   BNE V0, ZERO, 0x9D00380C
9D003670  8FBF007C   LW RA, 124(SP)
9D003674  8FA20028   LW V0, 40(SP)
9D003678  9043000B   LBU V1, 11(V0)
9D00367C  30630020   ANDI V1, V1, 32
9D003680  306300FF   ANDI V1, V1, 255
9D003684  14600060   BNE V1, ZERO, 0x9D003808
9D003688  24020006   ADDIU V0, ZERO, 6
9D00368C  0B400DFA   J 0x9D0037E8
9D003690  8FA50024   LW A1, 36(SP)
3335:                			res = FR_INVALID_NAME;
3336:                #if _FS_SHARE
3337:                		if (res == FR_OK) res = chk_lock(&djo, 2);
3338:                #endif
3339:                		if (res == FR_OK) { /* Old object is found */
3340:                			if (!djo.dir) { /* Is root dir? */
9D0037E8  14A0FFAA   BNE A1, ZERO, 0x9D003694
9D0037EC  24020004   ADDIU V0, ZERO, 4
9D0037F0  0B400E03   J 0x9D00380C
9D0037F4  8FBF007C   LW RA, 124(SP)
3341:                				res = FR_NO_FILE;
3342:                			} else {
3343:                				mem_cpy(buf, djo.dir + DIR_Attr, 21); /* Save the object information except for name */
9D003694  27A40048   ADDIU A0, SP, 72
9D003698  24A5000B   ADDIU A1, A1, 11
9D00369C  0F400000   JAL mem_cpy
9D0036A0  24060015   ADDIU A2, ZERO, 21
3344:                				mem_cpy(&djn, &djo, sizeof(DIR)); /* Check new object */
9D0036A4  27A4002C   ADDIU A0, SP, 44
9D0036A8  27A50010   ADDIU A1, SP, 16
9D0036AC  0F400000   JAL mem_cpy
9D0036B0  2406001C   ADDIU A2, ZERO, 28
3345:                				res = follow_path(&djn, path_new);
9D0036B4  27A4002C   ADDIU A0, SP, 44
9D0036B8  0F400367   JAL follow_path
9D0036BC  02002821   ADDU A1, S0, ZERO
3346:                				if (res == FR_OK)
9D0036C0  50400051   BEQL V0, ZERO, 0x9D003808
9D0036C4  24020008   ADDIU V0, ZERO, 8
3347:                					res = FR_EXIST; /* The new object name is already existing */
3348:                				if (res == FR_NO_FILE) { /* Is it a valid path and no name collision? */
9D0036C8  24030004   ADDIU V1, ZERO, 4
9D0036CC  1443004F   BNE V0, V1, 0x9D00380C
9D0036D0  8FBF007C   LW RA, 124(SP)
3349:                					/* Start critical section that any interruption or error can cause cross-link */
3350:                					res = dir_register(&djn); /* Register the new entry */
9D0036D4  0F40048D   JAL dir_register
9D0036D8  27A4002C   ADDIU A0, SP, 44
3351:                					if (res == FR_OK) {
9D0036DC  1440004B   BNE V0, ZERO, 0x9D00380C
9D0036E0  8FBF007C   LW RA, 124(SP)
3352:                						dir = djn.dir; /* Copy object information except for name */
9D0036E4  8FB00040   LW S0, 64(SP)
3353:                						mem_cpy(dir + 13, buf + 2, 19);
9D0036E8  2604000D   ADDIU A0, S0, 13
9D0036EC  27A5004A   ADDIU A1, SP, 74
9D0036F0  0F400000   JAL mem_cpy
9D0036F4  24060013   ADDIU A2, ZERO, 19
3354:                						dir[DIR_Attr] = buf[0] | AM_ARC;
9D0036F8  93A20048   LBU V0, 72(SP)
9D0036FC  34420020   ORI V0, V0, 32
9D003700  A202000B   SB V0, 11(S0)
3355:                						djo.fs->wflag = 1;
9D003704  24030001   ADDIU V1, ZERO, 1
9D003708  8FA20010   LW V0, 16(SP)
9D00370C  A0430004   SB V1, 4(V0)
3356:                						if (djo.sclust != djn.sclust
9D003710  8FA20034   LW V0, 52(SP)
9D003714  8FA30018   LW V1, 24(SP)
9D003718  10620037   BEQ V1, V0, 0x9D0037F8
9D00371C  00000000   NOP
3357:                								&& (dir[DIR_Attr] & AM_DIR)) { /* Update .. entry in the directory if needed */
9D003720  9202000B   LBU V0, 11(S0)
9D003724  30420010   ANDI V0, V0, 16
9D003728  304200FF   ANDI V0, V0, 255
9D00372C  10400032   BEQ V0, ZERO, 0x9D0037F8
9D003730  8FB1002C   LW S1, 44(SP)
3358:                							dw = clust2sect(djn.fs, LD_CLUST(dir));
9D003734  92050015   LBU A1, 21(S0)
9D003738  00052A00   SLL A1, A1, 8
9D00373C  92020014   LBU V0, 20(S0)
9D003740  00A22825   OR A1, A1, V0
9D003744  00052C00   SLL A1, A1, 16
9D003748  9203001B   LBU V1, 27(S0)
9D00374C  00031A00   SLL V1, V1, 8
9D003750  9202001A   LBU V0, 26(S0)
9D003754  00621025   OR V0, V1, V0
9D003758  02202021   ADDU A0, S1, ZERO
9D00375C  0F400142   JAL clust2sect
9D003760  00A22825   OR A1, A1, V0
9D003764  00402821   ADDU A1, V0, ZERO
3359:                							if (!dw) {
9D003768  10A00027   BEQ A1, ZERO, 0x9D003808
9D00376C  24020002   ADDIU V0, ZERO, 2
3360:                								res = FR_INT_ERR;
3361:                							} else {
3362:                								res = move_window(djn.fs, dw);
9D003770  0F40006F   JAL move_window
9D003774  02202021   ADDU A0, S1, ZERO
3363:                								dir = djn.fs->win + SZ_DIR; /* .. entry */
3364:                								if (res == FR_OK && dir[1] == '.') {
9D003778  14400023   BNE V0, ZERO, 0x9D003808
9D00377C  8FA3002C   LW V1, 44(SP)
9D003780  90640055   LBU A0, 85(V1)
9D003784  2402002E   ADDIU V0, ZERO, 46
9D003788  1482001B   BNE A0, V0, 0x9D0037F8
9D00378C  24020003   ADDIU V0, ZERO, 3
3365:                									dw
3366:                											= (djn.fs->fs_type == FS_FAT32
3367:                													&& djn.sclust
9D00379C  8C620028   LW V0, 40(V1)
9D0037A0  8FA40034   LW A0, 52(SP)
9D0037A4  14820002   BNE A0, V0, 0x9D0037B0
9D0037A8  8FA20034   LW V0, 52(SP)
3368:                															== djn.fs->dirbase) ? 0
3369:                													: djn.sclust;
9D003790  90640000   LBU A0, 0(V1)
9D003794  14820006   BNE A0, V0, 0x9D0037B0
9D003798  8FA20034   LW V0, 52(SP)
9D0037AC  00001021   ADDU V0, ZERO, ZERO
3370:                									ST_CLUST(dir, dw);
9D0037B0  A062006E   SB V0, 110(V1)
9D0037B4  7C443A00   EXT A0, V0, 8, 8
9D0037B8  A064006F   SB A0, 111(V1)
9D0037BC  00021402   SRL V0, V0, 16
9D0037C0  A0620068   SB V0, 104(V1)
9D0037C4  00021202   SRL V0, V0, 8
9D0037C8  A0620069   SB V0, 105(V1)
3371:                									djn.fs->wflag = 1;
9D0037CC  24020001   ADDIU V0, ZERO, 1
9D0037D0  0B400DFE   J 0x9D0037F8
9D0037D4  A0620004   SB V0, 4(V1)
3372:                								}
3373:                							}
3374:                						}
3375:                						if (res == FR_OK) {
3376:                							res = dir_remove(&djo); /* Remove old entry */
9D0037F8  0F400201   JAL dir_remove
9D0037FC  27A40010   ADDIU A0, SP, 16
3377:                							if (res == FR_OK)
9D003800  1040FFF5   BEQ V0, ZERO, 0x9D0037D8
9D003804  00000000   NOP
3378:                								res = sync(djo.fs);
9D0037D8  0F4000FE   JAL sync
9D0037DC  8FA40010   LW A0, 16(SP)
3379:                						}
3380:                					}
3381:                					/* End critical section */
3382:                				}
3383:                			}
3384:                		}FREE_BUF();
3385:                	}
3386:                	LEAVE_FF(djo.fs, res);
3387:                }
9D0037E0  0B400E03   J 0x9D00380C
9D0037E4  8FBF007C   LW RA, 124(SP)
9D003808  8FBF007C   LW RA, 124(SP)
9D00380C  8FB10078   LW S1, 120(SP)
9D003810  8FB00074   LW S0, 116(SP)
9D003814  03E00008   JR RA
9D003818  27BD0080   ADDIU SP, SP, 128
3388:                
3389:                #endif /* !_FS_READONLY */
3390:                #endif /* _FS_MINIMIZE == 0 */
3391:                #endif /* _FS_MINIMIZE <= 1 */
3392:                #endif /* _FS_MINIMIZE <= 2 */
3393:                
3394:                /*-----------------------------------------------------------------------*/
3395:                /* Forward data to the stream directly (available on only tiny cfg)      */
3396:                /*-----------------------------------------------------------------------*/
3397:                #if _USE_FORWARD && _FS_TINY
3398:                
3399:                FRESULT f_forward (
3400:                		FIL *fp, /* Pointer to the file object */
3401:                		UINT (*func)(const PF_BYTE*,UINT), /* Pointer to the streaming function */
3402:                		UINT btr, /* Number of bytes to forward */
3403:                		UINT *bf /* Pointer to number of bytes forwarded */
3404:                )
3405:                {
3406:                	FRESULT res;
3407:                	DWORD remain, clst, sect;
3408:                	UINT rcnt;
3409:                	PF_BYTE csect;
3410:                
3411:                	*bf = 0; /* Initialize byte counter */
3412:                
3413:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
3414:                	if (res != FR_OK) LEAVE_FF(fp->fs, res);
3415:                	if (fp->flag & FA__ERROR) /* Check error flag */
3416:                	LEAVE_FF(fp->fs, FR_INT_ERR);
3417:                	if (!(fp->flag & FA_READ)) /* Check access mode */
3418:                	LEAVE_FF(fp->fs, FR_DENIED);
3419:                
3420:                	remain = fp->fsize - fp->fptr;
3421:                	if (btr > remain) btr = (UINT)remain; /* Truncate btr by remaining bytes */
3422:                
3423:                	for (; btr && (*func)(0, 0); /* Repeat until all data transferred or stream becomes busy */
3424:                			fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
3425:                		csect = (PF_BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
3426:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
3427:                			if (!csect) { /* On the cluster boundary? */
3428:                				clst = (fp->fptr == 0) ? /* On the top of the file? */
3429:                				fp->sclust : get_fat(fp->fs, fp->clust);
3430:                				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
3431:                				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
3432:                				fp->clust = clst; /* Update current cluster */
3433:                			}
3434:                		}
3435:                		sect = clust2sect(fp->fs, fp->clust); /* Get current data sector */
3436:                		if (!sect) ABORT(fp->fs, FR_INT_ERR);
3437:                		sect += csect;
3438:                		if (move_window(fp->fs, sect)) /* Move sector window */
3439:                		ABORT(fp->fs, FR_DISK_ERR);
3440:                		fp->dsect = sect;
3441:                		rcnt = SS(fp->fs) - (PF_WORD)(fp->fptr % SS(fp->fs)); /* Forward data from sector window */
3442:                		if (rcnt > btr) rcnt = btr;
3443:                		rcnt = (*func)(&fp->fs->win[(PF_WORD)fp->fptr % SS(fp->fs)], rcnt);
3444:                		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
3445:                	}
3446:                
3447:                	LEAVE_FF(fp->fs, FR_OK);
3448:                }
3449:                #endif /* _USE_FORWARD */
3450:                
3451:                #if _USE_MKFS && !_FS_READONLY
3452:                /*-----------------------------------------------------------------------*/
3453:                /* Create File System on the Drive                                       */
3454:                /*-----------------------------------------------------------------------*/
3455:                #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
3456:                #define N_FATS		1		/* Number of FAT copies (1 or 2) */
3457:                
3458:                FRESULT f_mkfs (
3459:                		PF_BYTE drv, /* Logical drive number */
3460:                		PF_BYTE sfd, /* Partitioning rule 0:FDISK, 1:SFD */
3461:                		UINT au /* Allocation unit size [bytes] */
3462:                )
3463:                {
3464:                	static const PF_WORD vst[] = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0};
3465:                	static const PF_WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
3466:                	PF_BYTE fmt, md, sys, *tbl, pdrv, part;
3467:                	DWORD n_clst, vs, n, wsect;
3468:                	UINT i;
3469:                	DWORD b_vol, b_fat, b_dir, b_data; /* LBA */
3470:                	DWORD n_vol, n_rsv, n_fat, n_dir; /* Size */
3471:                	FATFS *fs;
3472:                	DSTATUS stat;
3473:                
3474:                	/* Check mounted drive and clear work area */
3475:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
3476:                	if (sfd > 1) return FR_INVALID_PARAMETER;
3477:                	if (au & (au - 1)) return FR_INVALID_PARAMETER;
3478:                	fs = FatFs[drv];
3479:                	if (!fs) return FR_NOT_ENABLED;
3480:                	fs->fs_type = 0;
3481:                	pdrv = LD2PD(drv); /* Physical drive */
3482:                	part = LD2PT(drv); /* Partition (0:auto detect, 1-4:get from partition table)*/
3483:                
3484:                	/* Get disk statics */
3485:                	stat = disk_initialize(pdrv);
3486:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3487:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3488:                #if _MAX_SS != 512					/* Get disk sector size */
3489:                	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
3490:                	return FR_DISK_ERR;
3491:                #endif
3492:                	if (_MULTI_PARTITION && part) {
3493:                		/* Get partition information from partition table in the MBR */
3494:                		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3495:                		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
3496:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3497:                		if (!tbl[4]) return FR_MKFS_ABORTED; /* No partition? */
3498:                		b_vol = LD_DWORD(tbl+8); /* Volume start sector */
3499:                		n_vol = LD_DWORD(tbl+12); /* Volume size */
3500:                	} else {
3501:                		/* Create a partition in this function */
3502:                		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
3503:                		return FR_DISK_ERR;
3504:                		b_vol = (sfd) ? 0 : 63; /* Volume start sector */
3505:                		n_vol -= b_vol; /* Volume size */
3506:                	}
3507:                
3508:                	if (!au) { /* AU auto selection */
3509:                		vs = n_vol / (2000 / (SS(fs) / 512));
3510:                		for (i = 0; vs < vst[i]; i++);
3511:                		au = cst[i];
3512:                	}
3513:                	au /= SS(fs); /* Number of sectors per cluster */
3514:                	if (au == 0) au = 1;
3515:                	if (au > 128) au = 128;
3516:                
3517:                	/* Pre-compute number of clusters and FAT syb-type */
3518:                	n_clst = n_vol / au;
3519:                	fmt = FS_FAT12;
3520:                	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
3521:                	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
3522:                
3523:                	/* Determine offset and size of FAT structure */
3524:                	if (fmt == FS_FAT32) {
3525:                		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
3526:                		n_rsv = 32;
3527:                		n_dir = 0;
3528:                	} else {
3529:                		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
3530:                		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
3531:                		n_rsv = 1;
3532:                		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
3533:                	}
3534:                	b_fat = b_vol + n_rsv; /* FAT area start sector */
3535:                	b_dir = b_fat + n_fat * N_FATS; /* Directory area start sector */
3536:                	b_data = b_dir + n_dir; /* Data area start sector */
3537:                	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED; /* Too small volume */
3538:                
3539:                	/* Align data start sector to erase block boundary (for flash memory media) */
3540:                	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
3541:                	n = (b_data + n - 1) & ~(n - 1); /* Next nearest erase block from current data start */
3542:                	n = (n - b_data) / N_FATS;
3543:                	if (fmt == FS_FAT32) { /* FAT32: Move FAT offset */
3544:                		n_rsv += n;
3545:                		b_fat += n;
3546:                	} else { /* FAT12/16: Expand FAT size */
3547:                		n_fat += n;
3548:                	}
3549:                
3550:                	/* Determine number of clusters and final check of validity of the FAT sub-type */
3551:                	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
3552:                	if ( (fmt == FS_FAT16 && n_clst < MIN_FAT16)
3553:                			|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
3554:                	return FR_MKFS_ABORTED;
3555:                
3556:                	switch (fmt) { /* Determine system ID for partition table */
3557:                		case FS_FAT12: sys = 0x01; break;
3558:                		case FS_FAT16: sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
3559:                		default: sys = 0x0C;
3560:                	}
3561:                
3562:                	if (_MULTI_PARTITION && part) {
3563:                		/* Update system ID in the partition table */
3564:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3565:                		tbl[4] = sys;
3566:                		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3567:                		md = 0xF8;
3568:                	} else {
3569:                		if (sfd) { /* No patition table (SFD) */
3570:                			md = 0xF0;
3571:                		} else { /* Create partition table (FDISK) */
3572:                			mem_set(fs->win, 0, SS(fs));
3573:                			tbl = fs->win+MBR_Table; /* Create partiton table for single partition in the drive */
3574:                			tbl[1] = 1; /* Partition start head */
3575:                			tbl[2] = 1; /* Partition start sector */
3576:                			tbl[3] = 0; /* Partition start cylinder */
3577:                			tbl[4] = sys; /* System type */
3578:                			tbl[5] = 254; /* Partition end head */
3579:                			n = (b_vol + n_vol) / 63 / 255;
3580:                			tbl[6] = (PF_BYTE)((n >> 2) | 63); /* Partiiton end sector */
3581:                			tbl[7] = (PF_BYTE)n; /* End cylinder */
3582:                			ST_DWORD(tbl+8, 63); /* Partition start in LBA */
3583:                			ST_DWORD(tbl+12, n_vol); /* Partition size in LBA */
3584:                			ST_WORD(fs->win+BS_55AA, 0xAA55); /* MBR signature */
3585:                			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) /* Write it to the MBR sector */
3586:                			return FR_DISK_ERR;
3587:                			md = 0xF8;
3588:                		}
3589:                	}
3590:                
3591:                	/* Create BPB in the VBR */
3592:                	tbl = fs->win; /* Clear sector */
3593:                	mem_set(tbl, 0, SS(fs));
3594:                	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
3595:                	i = SS(fs); /* Sector size */
3596:                	ST_WORD(tbl+BPB_BytsPerSec, i);
3597:                	tbl[BPB_SecPerClus] = (PF_BYTE)au; /* Sectors per cluster */
3598:                	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv); /* Reserved sectors */
3599:                	tbl[BPB_NumFATs] = N_FATS; /* Number of FATs */
3600:                	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR; /* Number of rootdir entries */
3601:                	ST_WORD(tbl+BPB_RootEntCnt, i);
3602:                	if (n_vol < 0x10000) { /* Number of total sectors */
3603:                		ST_WORD(tbl+BPB_TotSec16, n_vol);
3604:                	} else {
3605:                		ST_DWORD(tbl+BPB_TotSec32, n_vol);
3606:                	}
3607:                	tbl[BPB_Media] = md; /* Media descriptor */
3608:                	ST_WORD(tbl+BPB_SecPerTrk, 63); /* Number of sectors per track */
3609:                	ST_WORD(tbl+BPB_NumHeads, 255); /* Number of heads */
3610:                	ST_DWORD(tbl+BPB_HiddSec, b_vol); /* Hidden sectors */
3611:                	n = get_fattime(); /* Use current time as VSN */
3612:                	if (fmt == FS_FAT32) {
3613:                		ST_DWORD(tbl+BS_VolID32, n); /* VSN */
3614:                		ST_DWORD(tbl+BPB_FATSz32, n_fat); /* Number of sectors per FAT */
3615:                		ST_DWORD(tbl+BPB_RootClus, 2); /* Root directory start cluster (2) */
3616:                		ST_WORD(tbl+BPB_FSInfo, 1); /* FSInfo record offset (VBR+1) */
3617:                		ST_WORD(tbl+BPB_BkBootSec, 6); /* Backup boot record offset (VBR+6) */
3618:                		tbl[BS_DrvNum32] = 0x80; /* Drive number */
3619:                		tbl[BS_BootSig32] = 0x29; /* Extended boot signature */
3620:                		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19); /* Volume label, FAT signature */
3621:                	} else {
3622:                		ST_DWORD(tbl+BS_VolID, n); /* VSN */
3623:                		ST_WORD(tbl+BPB_FATSz16, n_fat); /* Number of sectors per FAT */
3624:                		tbl[BS_DrvNum] = 0x80; /* Drive number */
3625:                		tbl[BS_BootSig] = 0x29; /* Extended boot signature */
3626:                		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19); /* Volume label, FAT signature */
3627:                	}
3628:                	ST_WORD(tbl+BS_55AA, 0xAA55); /* Signature (Offset is fixed here regardless of sector size) */
3629:                	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK) /* Write it to the VBR sector */
3630:                	return FR_DISK_ERR;
3631:                	if (fmt == FS_FAT32) /* Write backup VBR if needed (VBR+6) */
3632:                	disk_write(pdrv, tbl, b_vol + 6, 1);
3633:                
3634:                	/* Initialize FAT area */
3635:                	wsect = b_fat;
3636:                	for (i = 0; i < N_FATS; i++) { /* Initialize each FAT copy */
3637:                		mem_set(tbl, 0, SS(fs)); /* 1st sector of the FAT  */
3638:                		n = md; /* Media descriptor byte */
3639:                		if (fmt != FS_FAT32) {
3640:                			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
3641:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT12/16) */
3642:                		} else {
3643:                			n |= 0xFFFFFF00;
3644:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT32) */
3645:                			ST_DWORD(tbl+4, 0xFFFFFFFF);
3646:                			ST_DWORD(tbl+8, 0x0FFFFFFF); /* Reserve cluster #2 for root dir */
3647:                		}
3648:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3649:                		return FR_DISK_ERR;
3650:                		mem_set(tbl, 0, SS(fs)); /* Fill following FAT entries with zero */
3651:                		for (n = 1; n < n_fat; n++) { /* This loop may take a time on FAT32 volume due to many single sector writes */
3652:                			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3653:                			return FR_DISK_ERR;
3654:                		}
3655:                	}
3656:                
3657:                	/* Initialize root directory */
3658:                	i = (fmt == FS_FAT32) ? au : n_dir;
3659:                	do {
3660:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3661:                		return FR_DISK_ERR;
3662:                	}while (--i);
3663:                
3664:                #if _USE_ERASE	/* Erase data area if needed */
3665:                	{
3666:                		DWORD eb[2];
3667:                
3668:                		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
3669:                		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
3670:                	}
3671:                #endif
3672:                
3673:                	/* Create FSInfo if needed */
3674:                	if (fmt == FS_FAT32) {
3675:                		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
3676:                		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
3677:                		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1); /* Number of free clusters */
3678:                		ST_DWORD(tbl+FSI_Nxt_Free, 2); /* Last allocated cluster# */
3679:                		ST_WORD(tbl+BS_55AA, 0xAA55);
3680:                		disk_write(pdrv, tbl, b_vol + 1, 1); /* Write original (VBR+1) */
3681:                		disk_write(pdrv, tbl, b_vol + 7, 1); /* Write backup (VBR+7) */
3682:                	}
3683:                
3684:                	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
3685:                }
3686:                
3687:                #if _MULTI_PARTITION == 2
3688:                /*-----------------------------------------------------------------------*/
3689:                /* Divide Physical Drive                                                 */
3690:                /*-----------------------------------------------------------------------*/
3691:                
3692:                FRESULT f_fdisk (
3693:                		PF_BYTE pdrv, /* Physical drive number */
3694:                		const DWORD szt[], /* Pointer to the size table for each partitions */
3695:                		void* work /* Pointer to the working buffer */
3696:                )
3697:                {
3698:                	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
3699:                	PF_BYTE s_hd, e_hd, *p, *buf = (PF_BYTE*)work;
3700:                	DSTATUS stat;
3701:                	DWORD sz_disk, sz_part, s_part;
3702:                
3703:                	stat = disk_initialize(pdrv);
3704:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3705:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3706:                	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
3707:                
3708:                	/* Determine CHS in the table regardless of the drive geometry */
3709:                	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2);
3710:                	if (n == 256) n--;
3711:                	e_hd = n - 1;
3712:                	sz_cyl = 63 * n;
3713:                	tot_cyl = sz_disk / sz_cyl;
3714:                
3715:                	/* Create partition table */
3716:                	mem_set(buf, 0, _MAX_SS);
3717:                	p = buf + MBR_Table; b_cyl = 0;
3718:                	for (i = 0; i < 4; i++, p += SZ_PTE) {
3719:                		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
3720:                		if (!p_cyl) continue;
3721:                		s_part = (DWORD)sz_cyl * b_cyl;
3722:                		sz_part = (DWORD)sz_cyl * p_cyl;
3723:                		if (i == 0) { /* Exclude first track of cylinder 0 */
3724:                			s_hd = 1;
3725:                			s_part += 63; sz_part -= 63;
3726:                		} else {
3727:                			s_hd = 0;
3728:                		}
3729:                		e_cyl = b_cyl + p_cyl - 1;
3730:                		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
3731:                
3732:                		/* Set partition table */
3733:                		p[1] = s_hd; /* Start head */
3734:                		p[2] = (PF_BYTE)((b_cyl >> 2) + 1); /* Start sector */
3735:                		p[3] = (PF_BYTE)b_cyl; /* Start cylinder */
3736:                		p[4] = 0x06; /* System type (temporary setting) */
3737:                		p[5] = e_hd; /* End head */
3738:                		p[6] = (PF_BYTE)((e_cyl >> 2) + 63); /* End sector */
3739:                		p[7] = (PF_BYTE)e_cyl; /* End cylinder */
3740:                		ST_DWORD(p + 8, s_part); /* Start sector in LBA */
3741:                		ST_DWORD(p + 12, sz_part); /* Partition size */
3742:                
3743:                		/* Next partition */
3744:                		b_cyl += p_cyl;
3745:                	}
3746:                	ST_WORD(p, 0xAA55);
3747:                
3748:                	/* Write it to the MBR */
3749:                	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
3750:                }
3751:                
3752:                #endif /* _MULTI_PARTITION == 2 */
3753:                #endif /* _USE_MKFS && !_FS_READONLY */
3754:                
3755:                #if _USE_STRFUNC
3756:                /*-----------------------------------------------------------------------*/
3757:                /* Get a string from the file                                            */
3758:                /*-----------------------------------------------------------------------*/
3759:                TCHAR* f_gets (
3760:                		TCHAR* buff, /* Pointer to the string buffer to read */
3761:                		int len, /* Size of string buffer (characters) */
3762:                		FIL* fil /* Pointer to the file object */
3763:                )
3764:                {
3765:                	int n = 0;
3766:                	TCHAR c, *p = buff;
3767:                	PF_BYTE s[2];
3768:                	UINT rc;
3769:                
3770:                	while (n < len - 1) { /* Read bytes until buffer gets filled */
3771:                		f_read(fil, s, 1, &rc);
3772:                		if (rc != 1) break; /* Break on EOF or error */
3773:                		c = s[0];
3774:                #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
3775:                		if (c >= 0x80) {
3776:                			if (c < 0xC0) continue; /* Skip stray trailer */
3777:                			if (c < 0xE0) { /* Two-byte sequense */
3778:                				f_read(fil, s, 1, &rc);
3779:                				if (rc != 1) break;
3780:                				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
3781:                				if (c < 0x80) c = '?';
3782:                			} else {
3783:                				if (c < 0xF0) { /* Three-byte sequense */
3784:                					f_read(fil, s, 2, &rc);
3785:                					if (rc != 2) break;
3786:                					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
3787:                					if (c < 0x800) c = '?';
3788:                				} else { /* Reject four-byte sequense */
3789:                					c = '?';
3790:                				}
3791:                			}
3792:                		}
3793:                #endif
3794:                #if _USE_STRFUNC >= 2
3795:                		if (c == '\r') continue; /* Strip '\r' */
3796:                #endif
3797:                		*p++ = c;
3798:                		n++;
3799:                		if (c == '\n') break; /* Break on EOL */
3800:                	}
3801:                	*p = 0;
3802:                	return n ? buff : 0; /* When no data read (eof or error), return with error. */
3803:                }
3804:                
3805:                #if !_FS_READONLY
3806:                #include <stdarg.h>
3807:                /*-----------------------------------------------------------------------*/
3808:                /* Put a character to the file                                           */
3809:                /*-----------------------------------------------------------------------*/
3810:                int f_putc (
3811:                		TCHAR c, /* A character to be output */
3812:                		FIL* fil /* Pointer to the file object */
3813:                )
3814:                {
3815:                	UINT bw, btw;
3816:                	PF_BYTE s[3];
3817:                
3818:                #if _USE_STRFUNC >= 2
3819:                	if (c == '\n') f_putc ('\r', fil); /* LF -> CRLF conversion */
3820:                #endif
3821:                
3822:                #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
3823:                	if (c < 0x80) { /* 7-bit */
3824:                		s[0] = (PF_BYTE)c;
3825:                		btw = 1;
3826:                	} else {
3827:                		if (c < 0x800) { /* 11-bit */
3828:                			s[0] = (PF_BYTE)(0xC0 | (c >> 6));
3829:                			s[1] = (PF_BYTE)(0x80 | (c & 0x3F));
3830:                			btw = 2;
3831:                		} else { /* 16-bit */
3832:                			s[0] = (PF_BYTE)(0xE0 | (c >> 12));
3833:                			s[1] = (PF_BYTE)(0x80 | ((c >> 6) & 0x3F));
3834:                			s[2] = (PF_BYTE)(0x80 | (c & 0x3F));
3835:                			btw = 3;
3836:                		}
3837:                	}
3838:                #else				/* Write the character without conversion */
3839:                	s[0] = (PF_BYTE)c;
3840:                	btw = 1;
3841:                #endif
3842:                	f_write(fil, s, btw, &bw); /* Write the char to the file */
3843:                	return (bw == btw) ? 1 : EOF; /* Return the result */
3844:                }
3845:                
3846:                /*-----------------------------------------------------------------------*/
3847:                /* Put a string to the file                                              */
3848:                /*-----------------------------------------------------------------------*/
3849:                int f_puts (
3850:                		const TCHAR* str, /* Pointer to the string to be output */
3851:                		FIL* fil /* Pointer to the file object */
3852:                )
3853:                {
3854:                	int n;
3855:                
3856:                	for (n = 0; *str; str++, n++) {
3857:                		if (f_putc(*str, fil) == EOF) return EOF;
3858:                	}
3859:                	return n;
3860:                }
3861:                
3862:                /*-----------------------------------------------------------------------*/
3863:                /* Put a formatted string to the file                                    */
3864:                /*-----------------------------------------------------------------------*/
3865:                int f_printf (
3866:                		FIL* fil, /* Pointer to the file object */
3867:                		const TCHAR* str, /* Pointer to the format string */
3868:                		... /* Optional arguments... */
3869:                )
3870:                {
3871:                	va_list arp;
3872:                	PF_BYTE f, r;
3873:                	UINT i, j, w;
3874:                	ULONG v;
3875:                	TCHAR c, d, s[16], *p;
3876:                	int res, chc, cc;
3877:                
3878:                	va_start(arp, str);
3879:                
3880:                	for (cc = res = 0; cc != EOF; res += cc) {
3881:                		c = *str++;
3882:                		if (c == 0) break; /* End of string */
3883:                		if (c != '%') { /* Non escape character */
3884:                			cc = f_putc(c, fil);
3885:                			if (cc != EOF) cc = 1;
3886:                			continue;
3887:                		}
3888:                		w = f = 0;
3889:                		c = *str++;
3890:                		if (c == '0') { /* Flag: '0' padding */
3891:                			f = 1; c = *str++;
3892:                		} else {
3893:                			if (c == '-') { /* Flag: left justified */
3894:                				f = 2; c = *str++;
3895:                			}
3896:                		}
3897:                		while (IsDigit(c)) { /* Precision */
3898:                			w = w * 10 + c - '0';
3899:                			c = *str++;
3900:                		}
3901:                		if (c == 'l' || c == 'L') { /* Prefix: Size is long int */
3902:                			f |= 4; c = *str++;
3903:                		}
3904:                		if (!c) break;
3905:                		d = c;
3906:                		if (IsLower(d)) d -= 0x20;
3907:                		switch (d) { /* Type is... */
3908:                			case 'S' : /* String */
3909:                			p = va_arg(arp, TCHAR*);
3910:                			for (j = 0; p[j]; j++);
3911:                			chc = 0;
3912:                			if (!(f & 2)) {
3913:                				while (j++ < w) chc += (cc = f_putc(' ', fil));
3914:                			}
3915:                			chc += (cc = f_puts(p, fil));
3916:                			while (j++ < w) chc += (cc = f_putc(' ', fil));
3917:                			if (cc != EOF) cc = chc;
3918:                			continue;
3919:                			case 'C' : /* Character */
3920:                			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
3921:                			case 'B' : /* Binary */
3922:                			r = 2; break;
3923:                			case 'O' : /* Octal */
3924:                			r = 8; break;
3925:                			case 'D' : /* Signed decimal */
3926:                			case 'U' : /* Unsigned decimal */
3927:                			r = 10; break;
3928:                			case 'X' : /* Hexdecimal */
3929:                			r = 16; break;
3930:                			default: /* Unknown type (passthrough) */
3931:                			cc = f_putc(c, fil); continue;
3932:                		}
3933:                
3934:                		/* Get an argument and put it in numeral */
3935:                		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
3936:                		if (d == 'D' && (v & 0x80000000)) {
3937:                			v = 0 - v;
3938:                			f |= 8;
3939:                		}
3940:                		i = 0;
3941:                		do {
3942:                			d = (TCHAR)(v % r); v /= r;
3943:                			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
3944:                			s[i++] = d + '0';
3945:                		}while (v && i < sizeof(s) / sizeof(s[0]));
3946:                		if (f & 8) s[i++] = '-';
3947:                		j = i; d = (f & 1) ? '0' : ' ';
3948:                		res = 0;
3949:                		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
3950:                		do res += (cc = f_putc(s[--i], fil)); while(i);
3951:                		while (j++ < w) res += (cc = f_putc(' ', fil));
3952:                		if (cc != EOF) cc = res;
3953:                	}
3954:                
3955:                	va_end(arp);
3956:                	return (cc == EOF) ? cc : res;
3957:                }
3958:                
3959:                #endif /* !_FS_READONLY */
3960:                #endif /* _USE_STRFUNC */
---  /home/jacques/github/vpc-32vga/hardware/Pinguino/diskio.c  -----------------------------------------
1:                   /*------------------------------------------------------------------------/
2:                    /  MMCv3/SDv1/SDv2 (in SPI mode) control module
3:                    /-------------------------------------------------------------------------/
4:                    /
5:                    /  Copyright (C) 2010, ChaN, all right reserved.
6:                    /
7:                    / * This software is a free software and there is NO WARRANTY.
8:                    / * No restriction on use. You can use, modify and redistribute it for
9:                    /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
10:                   / * Redistributions of source code must retain the above copyright notice.
11:                   /
12:                   /-------------------------------------------------------------------------*/
13:                  
14:                  // 07 May 2012 Changes made to allow SD card library to support
15:                  //					PIC32 Pinguino Micro and potentially other cards that
16:                  //					do not support the use of the RTCC library.
17:                  // 25 May 2012 Added includes for delay.c and digitalw.c
18:                  
19:                  #include <stdlib.h>
20:                  
21:                  //#include "ff.h"
22:                  #include "diskio.h"
23:                  //#include <delay.c>
24:                  //#include <digitalw.c>
25:                  #include "../HardwareProfile.h"
26:                  #include "sdmmc.h"
27:                  #include "../store/store_spi.h"
28:                  #include "../../shell.h"
29:                  
30:                  // For boards known to support the RTCC library ***Added 07 May 2012
31:                  // to allow SD Library to support PIC32 Pinguino Micro, which
32:                  // which does not have a RTCC crystal and associated components,
33:                  // and would not operate if #include <rtcc.c> is included.
34:                  // See also changes to get_fattime() below.
35:                  
36:                  #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
37:                  	#include <rtcc.c>
38:                  #endif
39:                  
40:                  /* Definitions for MMC/SDC command */
41:                  #define CMD0   (0)			/* GO_IDLE_STATE */
42:                  #define CMD1   (1)			/* SEND_OP_COND */
43:                  #define ACMD41 (41|0x80)	/* SEND_OP_COND (SDC) */
44:                  #define CMD8   (8)			/* SEND_IF_COND */
45:                  #define CMD9   (9)			/* SEND_CSD */
46:                  #define CMD10  (10)			/* SEND_CID */
47:                  #define CMD12  (12)			/* STOP_TRANSMISSION */
48:                  #define ACMD13 (13|0x80)	/* SD_STATUS (SDC) */
49:                  #define CMD16  (16)			/* SET_BLOCKLEN */
50:                  #define CMD17  (17)			/* READ_SINGLE_BLOCK */
51:                  #define CMD18  (18)			/* READ_MULTIPLE_BLOCK */
52:                  #define CMD23  (23)			/* SET_BLOCK_COUNT */
53:                  #define ACMD23 (23|0x80)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
54:                  #define CMD24  (24)			/* WRITE_BLOCK */
55:                  #define CMD25  (25)			/* WRITE_MULTIPLE_BLOCK */
56:                  #define CMD41  (41)			/* SEND_OP_COND (ACMD) */
57:                  #define CMD55  (55)			/* APP_CMD */
58:                  #define CMD58  (58)			/* READ_OCR */
59:                  
60:                  /* Port Controls  (Platform dependent) */
61:                  //#define SOCKPORT	PORTB		/* Socket contact port */
62:                  //#define SOCKWP	(1<<10)		/* Write protect switch (RB10) */
63:                  //#define SOCKINS	(1<<11)		/* Card detect switch (RB11) */
64:                  
65:                  //#define	FCLK_SLOW()			/* Set slow clock (100k-400k) */
66:                  //#define	FCLK_FAST()			/* Set fast clock (depends on the CSD) */
67:                  
68:                  
69:                  /*--------------------------------------------------------------------------
70:                  
71:                   Module Private Functions
72:                  
73:                   ---------------------------------------------------------------------------*/
74:                  
75:                  static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
76:                  
77:                  static volatile UINT16 Timer1, Timer2; /* 1000Hz decrement timer */
78:                  
79:                  static UINT16 CardType;
80:                  
81:                  /*-----------------------------------------------------------------------*/
82:                  /* Exchange a byte between PIC and MMC via SPI  (Platform dependent)     */
83:                  /*-----------------------------------------------------------------------*/
84:                  
85:                  #define xmit_spi(dat) 	writeSPI(dat)
86:                  #define rcvr_spi()	writeSPI(0xFF)
87:                  #define rcvr_spi_m(p)	SDC_SPIBUF = 0xFF; while (!SDC_SPISTATbits.SPIRBF); *(p) = (PF_BYTE)SDC_SPIBUF;
88:                  #define xchg_spi (dat)  writeSPI(dat)
89:                  #define DLY_US(i)	delay_us(i)
90:                  #define CS_H()		_sdc_deselect()//digitalwrite(SDCS, HIGH)
91:                  #define CS_L()		_sdc_select()//digitalwrite(SDCS, LOW)
92:                  
93:                  /*-----------------------------------------------------------------------*/
94:                  /* Wait for card ready                                                   */
95:                  /*-----------------------------------------------------------------------*/
96:                  
97:                  static
98:                  int wait_ready(void) {
9D00B7E8  27BDFFE0   ADDIU SP, SP, -32
9D00B7EC  AFBF001C   SW RA, 28(SP)
9D00B7F0  AFB10018   SW S1, 24(SP)
9D00B7F4  AFB00014   SW S0, 20(SP)
9D00B7F8  24101388   ADDIU S0, ZERO, 5000
99:                  	PF_BYTE d;
100:                 	UINT16 tmr;
101:                 
102:                 	for (tmr = 5000; tmr; tmr--) { /* Wait for ready in timeout of 500ms */
9D00B824  1600FFF5   BNE S0, ZERO, 0x9D00B7FC
9D00B828  3A2200FF   XORI V0, S1, 255
103:                 		d = rcvr_spi();
9D00B7FC  0F405F0D   JAL writeSPI
9D00B800  240400FF   ADDIU A0, ZERO, 255
9D00B804  00408821   ADDU S1, V0, ZERO
104:                 		if (d == 0xFF)
9D00B808  240200FF   ADDIU V0, ZERO, 255
9D00B80C  12220007   BEQ S1, V0, 0x9D00B82C
9D00B810  3A2200FF   XORI V0, S1, 255
105:                 			break;
106:                 		DLY_US(100);
9D00B814  0F403862   JAL delay_us
9D00B818  24040064   ADDIU A0, ZERO, 100
9D00B81C  2610FFFF   ADDIU S0, S0, -1
9D00B820  3210FFFF   ANDI S0, S0, -1
107:                 	}
108:                 
109:                 	return (d == 0xFF) ? 1 : 0;
110:                 }
9D00B82C  2C420001   SLTIU V0, V0, 1
9D00B830  8FBF001C   LW RA, 28(SP)
9D00B834  8FB10018   LW S1, 24(SP)
9D00B838  8FB00014   LW S0, 20(SP)
9D00B83C  03E00008   JR RA
9D00B840  27BD0020   ADDIU SP, SP, 32
111:                 
112:                 /*-----------------------------------------------------------------------*/
113:                 /* Deselect the card and release SPI bus                                 */
114:                 /*-----------------------------------------------------------------------*/
115:                 
116:                 #define deselect() disableSD();
117:                 
118:                 /*-----------------------------------------------------------------------*/
119:                 /* Select the card and wait ready                                        */
120:                 /*-----------------------------------------------------------------------*/
121:                 
122:                 static int select(void) /* 1:Successful, 0:Timeout */
123:                 {
9D00B9F0  27BDFFE8   ADDIU SP, SP, -24
9D00B9F4  AFBF0014   SW RA, 20(SP)
124:                 	enableSD();
9D00B9F8  0F404BC0   JAL enableSD
9D00B9FC  AFB00010   SW S0, 16(SP)
125:                 	rcvr_spi(); /* Dummy clock (force DO enabled) */
9D00BA00  0F405F0D   JAL writeSPI
9D00BA04  240400FF   ADDIU A0, ZERO, 255
126:                 
127:                 	if (wait_ready())
9D00BA08  0F402DFA   JAL wait_ready
9D00BA0C  00000000   NOP
9D00BA10  14400005   BNE V0, ZERO, 0x9D00BA28
9D00BA14  00408021   ADDU S0, V0, ZERO
128:                 		return 1; /* OK */
9D00BA28  24100001   ADDIU S0, ZERO, 1
129:                 	deselect();
9D00BA18  0F404BB6   JAL disableSD
9D00BA1C  00000000   NOP
130:                 	return 0; /* Timeout */
9D00BA20  0B402E8C   J 0x9D00BA30
9D00BA24  02001021   ADDU V0, S0, ZERO
131:                 }
9D00BA2C  02001021   ADDU V0, S0, ZERO
9D00BA30  8FBF0014   LW RA, 20(SP)
9D00BA34  8FB00010   LW S0, 16(SP)
9D00BA38  03E00008   JR RA
9D00BA3C  27BD0018   ADDIU SP, SP, 24
132:                 
133:                 void unmountSD(){
9D00BB54  27BDFFE8   ADDIU SP, SP, -24
9D00BB58  AFBF0014   SW RA, 20(SP)
134:                     deselect();
9D00BB5C  0F404BB6   JAL disableSD
9D00BB60  00000000   NOP
135:                     Stat=STA_NOINIT;
9D00BB64  24020001   ADDIU V0, ZERO, 1
9D00BB68  A3828010   SB V0, -32752(GP)
136:                 }
9D00BB6C  8FBF0014   LW RA, 20(SP)
9D00BB70  03E00008   JR RA
9D00BB74  27BD0018   ADDIU SP, SP, 24
137:                 
138:                 /*-----------------------------------------------------------------------*/
139:                 /* Receive a data packet from MMC                                        */
140:                 /*-----------------------------------------------------------------------*/
141:                 
142:                 static int rcvr_datablock( /* 1:OK, 0:Failed */
143:                                           PF_BYTE *buff, /* Data buffer to store received data */
144:                                           UINT16 btr /* Byte count (must be multiple of 4) */
145:                                           ) {
9D00B8D8  27BDFFE0   ADDIU SP, SP, -32
9D00B8DC  AFBF001C   SW RA, 28(SP)
9D00B8E0  AFB20018   SW S2, 24(SP)
9D00B8E4  AFB10014   SW S1, 20(SP)
9D00B8E8  AFB00010   SW S0, 16(SP)
9D00B8EC  00808021   ADDU S0, A0, ZERO
9D00B8F0  00A08821   ADDU S1, A1, ZERO
9D00B8F4  241203E8   ADDIU S2, ZERO, 1000
146:                 	PF_BYTE d;
147:                 	UINT16 tmr;
148:                 
149:                 	for (tmr = 1000; tmr; tmr--) { /* Wait for data packet in timeout of 100ms */
9D00B91C  1640FFF6   BNE S2, ZERO, 0x9D00B8F8
9D00B920  00001821   ADDU V1, ZERO, ZERO
9D00B924  0B402E76   J 0x9D00B9D8
9D00B928  00601021   ADDU V0, V1, ZERO
150:                 		d = rcvr_spi();
9D00B8F8  0F405F0D   JAL writeSPI
9D00B8FC  240400FF   ADDIU A0, ZERO, 255
151:                 		if (d != 0xFF)
9D00B900  240300FF   ADDIU V1, ZERO, 255
9D00B904  14430009   BNE V0, V1, 0x9D00B92C
9D00B908  240400FE   ADDIU A0, ZERO, 254
152:                 			break;
153:                 		DLY_US(100);
9D00B90C  0F403862   JAL delay_us
9D00B910  24040064   ADDIU A0, ZERO, 100
9D00B914  2652FFFF   ADDIU S2, S2, -1
9D00B918  3252FFFF   ANDI S2, S2, -1
154:                 	}
155:                 	if (d != 0xFE)
9D00B92C  14440029   BNE V0, A0, 0x9D00B9D4
9D00B930  00001821   ADDU V1, ZERO, ZERO
156:                 		return 0; /* If not valid data token, return with error */
157:                 
158:                 	do { /* Receive the data block into buffer */
159:                 		rcvr_spi_m(buff++);
9D00B934  3C04BF80   LUI A0, -16512
9D00B938  240500FF   ADDIU A1, ZERO, 255
9D00B93C  3C02BF80   LUI V0, -16512
9D00B940  AC855A20   SW A1, 23072(A0)
9D00B944  8C435A10   LW V1, 23056(V0)
9D00B948  30630001   ANDI V1, V1, 1
9D00B94C  1060FFFD   BEQ V1, ZERO, 0x9D00B944
9D00B950  00000000   NOP
9D00B954  8C835A20   LW V1, 23072(A0)
9D00B958  A2030000   SB V1, 0(S0)
160:                 		rcvr_spi_m(buff++);
9D00B95C  AC855A20   SW A1, 23072(A0)
9D00B960  8C435A10   LW V1, 23056(V0)
9D00B964  30630001   ANDI V1, V1, 1
9D00B968  1060FFFD   BEQ V1, ZERO, 0x9D00B960
9D00B96C  00000000   NOP
9D00B970  8C835A20   LW V1, 23072(A0)
9D00B974  A2030001   SB V1, 1(S0)
161:                 		rcvr_spi_m(buff++);
9D00B978  AC855A20   SW A1, 23072(A0)
9D00B97C  8C435A10   LW V1, 23056(V0)
9D00B980  30630001   ANDI V1, V1, 1
9D00B984  1060FFFD   BEQ V1, ZERO, 0x9D00B97C
9D00B988  00000000   NOP
9D00B98C  8C835A20   LW V1, 23072(A0)
9D00B990  A2030002   SB V1, 2(S0)
162:                 		rcvr_spi_m(buff++);
9D00B994  AC855A20   SW A1, 23072(A0)
9D00B998  8C435A10   LW V1, 23056(V0)
9D00B99C  30630001   ANDI V1, V1, 1
9D00B9A0  1060FFFD   BEQ V1, ZERO, 0x9D00B998
9D00B9A4  00000000   NOP
9D00B9A8  26100004   ADDIU S0, S0, 4
9D00B9AC  8C835A20   LW V1, 23072(A0)
163:                 	} while (btr -= 4);
9D00B9B0  2631FFFC   ADDIU S1, S1, -4
9D00B9B4  3231FFFF   ANDI S1, S1, -1
9D00B9B8  1620FFE1   BNE S1, ZERO, 0x9D00B940
9D00B9BC  A203FFFF   SB V1, -1(S0)
164:                 	rcvr_spi(); /* Discard CRC */
9D00B9C0  0F405F0D   JAL writeSPI
9D00B9C4  240400FF   ADDIU A0, ZERO, 255
165:                 	rcvr_spi();
9D00B9C8  0F405F0D   JAL writeSPI
9D00B9CC  240400FF   ADDIU A0, ZERO, 255
9D00B9D0  24030001   ADDIU V1, ZERO, 1
166:                 
167:                 	return 1; /* Return with success */
168:                 }
9D00B9D4  00601021   ADDU V0, V1, ZERO
9D00B9D8  8FBF001C   LW RA, 28(SP)
9D00B9DC  8FB20018   LW S2, 24(SP)
9D00B9E0  8FB10014   LW S1, 20(SP)
9D00B9E4  8FB00010   LW S0, 16(SP)
9D00B9E8  03E00008   JR RA
9D00B9EC  27BD0020   ADDIU SP, SP, 32
169:                 
170:                 /*-----------------------------------------------------------------------*/
171:                 /* Send a data packet to MMC                                             */
172:                 /*-----------------------------------------------------------------------*/
173:                 
174:                 #if _READONLY == 0
175:                 static int xmit_datablock( /* 1:OK, 0:Failed */
176:                                           const PF_BYTE *buff, /* 512 byte data block to be transmitted */
177:                                           PF_BYTE token /* Data token */
178:                                           ) {
9D00B844  27BDFFE0   ADDIU SP, SP, -32
9D00B848  AFBF001C   SW RA, 28(SP)
9D00B84C  AFB10018   SW S1, 24(SP)
9D00B850  AFB00014   SW S0, 20(SP)
9D00B854  00808021   ADDU S0, A0, ZERO
179:                 	PF_BYTE resp;
180:                 	UINT16 bc = BLK_SIZE;
181:                 
182:                 	if (!wait_ready())
9D00B858  0F402DFA   JAL wait_ready
9D00B85C  00A08821   ADDU S1, A1, ZERO
9D00B860  10400019   BEQ V0, ZERO, 0x9D00B8C8
9D00B864  8FBF001C   LW RA, 28(SP)
183:                 		return 0;
184:                 
185:                 	xmit_spi(token); /* Xmit a token */
9D00B868  0F405F0D   JAL writeSPI
9D00B86C  02202021   ADDU A0, S1, ZERO
186:                 	if (token != 0xFD) { /* Not StopTran token */
9D00B870  240200FD   ADDIU V0, ZERO, 253
9D00B874  12220012   BEQ S1, V0, 0x9D00B8C0
9D00B878  26110200   ADDIU S1, S0, 512
187:                 		do { /* Xmit the 512 byte data block to the MMC */
188:                 			xmit_spi(*buff++);
9D00B87C  0F405F0D   JAL writeSPI
9D00B880  92040000   LBU A0, 0(S0)
9D00B884  26100002   ADDIU S0, S0, 2
189:                 			xmit_spi(*buff++);
9D00B888  0F405F0D   JAL writeSPI
9D00B88C  9204FFFF   LBU A0, -1(S0)
190:                 		} while (bc -= 2);
9D00B890  1630FFFA   BNE S1, S0, 0x9D00B87C
9D00B894  00000000   NOP
191:                 		xmit_spi(0xFF); /* CRC (Dummy) */
9D00B898  0F405F0D   JAL writeSPI
9D00B89C  240400FF   ADDIU A0, ZERO, 255
192:                 		xmit_spi(0xFF);
9D00B8A0  0F405F0D   JAL writeSPI
9D00B8A4  240400FF   ADDIU A0, ZERO, 255
193:                 		resp = rcvr_spi(); /* Receive a data response */
9D00B8A8  0F405F0D   JAL writeSPI
9D00B8AC  240400FF   ADDIU A0, ZERO, 255
194:                 		if ((resp & 0x1F) != 0x05) /* If not accepted, return with error */
9D00B8B0  3042001F   ANDI V0, V0, 31
9D00B8B4  38420005   XORI V0, V0, 5
9D00B8B8  0B402E31   J 0x9D00B8C4
9D00B8BC  2C420001   SLTIU V0, V0, 1
195:                 			return 0;
196:                 	}
197:                 
198:                 	return 1;
9D00B8C0  24020001   ADDIU V0, ZERO, 1
199:                 }
9D00B8C4  8FBF001C   LW RA, 28(SP)
9D00B8C8  8FB10018   LW S1, 24(SP)
9D00B8CC  8FB00014   LW S0, 20(SP)
9D00B8D0  03E00008   JR RA
9D00B8D4  27BD0020   ADDIU SP, SP, 32
200:                 #endif	/* _READONLY */
201:                 
202:                 /*-----------------------------------------------------------------------*/
203:                 /* Send a command packet to MMC                                          */
204:                 /*-----------------------------------------------------------------------*/
205:                 
206:                 static PF_BYTE send_cmd(PF_BYTE cmd, /* Command byte */
207:                                         DWORD arg /* Argument */
208:                                         ) {
9D00BA40  27BDFFE0   ADDIU SP, SP, -32
9D00BA44  AFBF001C   SW RA, 28(SP)
9D00BA48  AFB10018   SW S1, 24(SP)
9D00BA4C  AFB00014   SW S0, 20(SP)
9D00BA50  00808021   ADDU S0, A0, ZERO
9D00BAE8  2410000A   ADDIU S0, ZERO, 10
9D00BB24  0B402EBB   J 0x9D00BAEC
9D00BB28  2410000A   ADDIU S0, ZERO, 10
9D00BB34  0B402EBB   J 0x9D00BAEC
9D00BB38  2410000A   ADDIU S0, ZERO, 10
209:                 	PF_BYTE n, res;
210:                 
211:                 	if (cmd & 0x80) { /* ACMD<n> is the command sequense of CMD55-CMD<n> */
9D00BA54  7C041420   SEB V0, A0
9D00BA58  04410008   BGEZ V0, 0x9D00BA7C
9D00BA5C  00A08821   ADDU S1, A1, ZERO
212:                 		cmd &= 0x7F;
9D00BA78  3210007F   ANDI S0, S0, 127
213:                 		res = send_cmd(CMD55, 0);
9D00BA60  24040037   ADDIU A0, ZERO, 55
9D00BA64  0F402E90   JAL send_cmd
9D00BA68  00002821   ADDU A1, ZERO, ZERO
214:                 		if (res > 1)
9D00BA6C  2C440002   SLTIU A0, V0, 2
9D00BA70  10800032   BEQ A0, ZERO, 0x9D00BB3C
9D00BA74  00401821   ADDU V1, V0, ZERO
215:                 			return res;
216:                 	}
217:                 
218:                 	/* Select the card and wait for ready */
219:                 	deselect();
9D00BA7C  0F404BB6   JAL disableSD
9D00BA80  00000000   NOP
220:                 	if (!select())
9D00BA84  0F402E7C   JAL select
9D00BA88  00000000   NOP
9D00BA8C  1040002B   BEQ V0, ZERO, 0x9D00BB3C
9D00BA90  240300FF   ADDIU V1, ZERO, 255
221:                 		return 0xFF;
222:                 
223:                 	/* Send command packet */
224:                 	xmit_spi(0x40 | cmd); /* Start + Command index */
9D00BA94  0F405F0D   JAL writeSPI
9D00BA98  36040040   ORI A0, S0, 64
225:                 	xmit_spi((PF_BYTE)(arg >> 24)); /* Argument[31..24] */
9D00BA9C  0F405F0D   JAL writeSPI
9D00BAA0  00112602   SRL A0, S1, 24
226:                 	xmit_spi((PF_BYTE)(arg >> 16)); /* Argument[23..16] */
9D00BAA4  0F405F0D   JAL writeSPI
9D00BAA8  7E243C00   EXT A0, S1, 16, 8
227:                 	xmit_spi((PF_BYTE)(arg >> 8)); /* Argument[15..8] */
9D00BAAC  0F405F0D   JAL writeSPI
9D00BAB0  7E243A00   EXT A0, S1, 8, 8
228:                 	xmit_spi((PF_BYTE)arg); /* Argument[7..0] */
9D00BAB4  0F405F0D   JAL writeSPI
9D00BAB8  322400FF   ANDI A0, S1, 255
229:                 	n = 0x01; /* Dummy CRC + Stop */
230:                 	if (cmd == CMD0)
9D00BABC  1200001B   BEQ S0, ZERO, 0x9D00BB2C
9D00BAC0  24020008   ADDIU V0, ZERO, 8
231:                 		n = 0x95; /* Valid CRC for CMD0(0) */
232:                 	if (cmd == CMD8)
9D00BAC4  12020015   BEQ S0, V0, 0x9D00BB1C
9D00BAC8  00000000   NOP
233:                 		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
234:                 	xmit_spi(n);
9D00BACC  0F405F0D   JAL writeSPI
9D00BAD0  24040001   ADDIU A0, ZERO, 1
9D00BB1C  0F405F0D   JAL writeSPI
9D00BB20  24040087   ADDIU A0, ZERO, 135
9D00BB2C  0F405F0D   JAL writeSPI
9D00BB30  24040095   ADDIU A0, ZERO, 149
235:                 
236:                 	/* Receive command response */
237:                 	if (cmd == CMD12)
9D00BAD4  2402000C   ADDIU V0, ZERO, 12
9D00BAD8  16020004   BNE S0, V0, 0x9D00BAEC
9D00BADC  2410000A   ADDIU S0, ZERO, 10
238:                 		rcvr_spi(); /* Skip a stuff byte when stop reading */
9D00BAE0  0F405F0D   JAL writeSPI
9D00BAE4  240400FF   ADDIU A0, ZERO, 255
239:                 	n = 10; /* Wait for a valid response in timeout of 10 attempts */
240:                 	do
241:                 		res = rcvr_spi();
9D00BAEC  0F405F0D   JAL writeSPI
9D00BAF0  240400FF   ADDIU A0, ZERO, 255
9D00BB14  0B402ECF   J 0x9D00BB3C
9D00BB18  00401821   ADDU V1, V0, ZERO
242:                 	while ((res & 0x80) && --n);
9D00BAF4  7C021C20   SEB V1, V0
9D00BAF8  04610006   BGEZ V1, 0x9D00BB14
9D00BAFC  2610FFFF   ADDIU S0, S0, -1
9D00BB00  321000FF   ANDI S0, S0, 255
9D00BB04  1600FFF9   BNE S0, ZERO, 0x9D00BAEC
9D00BB08  00401821   ADDU V1, V0, ZERO
9D00BB0C  0B402ED0   J 0x9D00BB40
9D00BB10  00601021   ADDU V0, V1, ZERO
243:                 
244:                 	return res; /* Return with the response value */
245:                 }
9D00BB3C  00601021   ADDU V0, V1, ZERO
9D00BB40  8FBF001C   LW RA, 28(SP)
9D00BB44  8FB10018   LW S1, 24(SP)
9D00BB48  8FB00014   LW S0, 20(SP)
9D00BB4C  03E00008   JR RA
9D00BB50  27BD0020   ADDIU SP, SP, 32
246:                 
247:                 /*--------------------------------------------------------------------------
248:                 
249:                  Public Functions
250:                 
251:                  ---------------------------------------------------------------------------*/
252:                 
253:                 /*-----------------------------------------------------------------------*/
254:                 /* Initialize Disk Drive                                                 */
255:                 /*-----------------------------------------------------------------------*/
256:                 
257:                 DSTATUS disk_initialize(PF_BYTE drv /* Physical drive number (0) */
258:                                         ) {
9D00BB80  27BDFFD8   ADDIU SP, SP, -40
9D00BB84  AFBF0024   SW RA, 36(SP)
9D00BB88  AFB10020   SW S1, 32(SP)
9D00BB8C  AFB0001C   SW S0, 28(SP)
259:                 	PF_BYTE n, ty, cmd, buf[4];
260:                 	UINT16 tmr;
261:                 	DSTATUS s = 0;
262:                 	if (drv)
9D00BB78  1480008A   BNE A0, ZERO, 0x9D00BDA4
9D00BB7C  24020001   ADDIU V0, ZERO, 1
263:                 		return STA_NOINIT; /* Supports only single drive */
264:                 	if (Stat & STA_NODISK)
9D00BB90  93828010   LBU V0, -32752(GP)
9D00BB94  30420002   ANDI V0, V0, 2
9D00BB98  304200FF   ANDI V0, V0, 255
9D00BB9C  10400004   BEQ V0, ZERO, 0x9D00BBB0
9D00BBA0  00000000   NOP
265:                 		return Stat; /* No card in the socket */
9D00BBA4  93828010   LBU V0, -32752(GP)
9D00BBA8  0B402F65   J 0x9D00BD94
9D00BBAC  304200FF   ANDI V0, V0, 255
266:                 
267:                 	deselect(); /* Force socket power on */
9D00BBB0  0F404BB6   JAL disableSD
9D00BBB4  2410000A   ADDIU S0, ZERO, 10
268:                 	spi_clock_freq(SLOW_CLOCK);
9D00BBB8  3C040001   LUI A0, 1
9D00BBBC  0F405EE7   JAL spi_clock_freq
9D00BBC0  348486A0   ORI A0, A0, -31072
269:                 	for (n = 10; n; n--)
9D00BBD4  1600FFFB   BNE S0, ZERO, 0x9D00BBC4
9D00BBD8  24030008   ADDIU V1, ZERO, 8
270:                 		rcvr_spi(); /* 80 dummy clocks */
9D00BBC4  0F405F0D   JAL writeSPI
9D00BBC8  240400FF   ADDIU A0, ZERO, 255
9D00BBCC  2610FFFF   ADDIU S0, S0, -1
9D00BBD0  321000FF   ANDI S0, S0, 255
271:                 //	CS_H();
272:                 //	for (n = 10; n; n--)
273:                 //		rcvr_spi(); /* 80 dummy clocks */
274:                     CS_L();
9D00BBDC  3C02BF88   LUI V0, -16504
9D00BBE0  AC436124   SW V1, 24868(V0)
275:                 	ty = 0;
276:                 	if (send_cmd(CMD0, 0) == 1) { /* Enter Idle state */
9D00BBE4  00002021   ADDU A0, ZERO, ZERO
9D00BBE8  0F402E90   JAL send_cmd
9D00BBEC  00002821   ADDU A1, ZERO, ZERO
9D00BBF0  24030001   ADDIU V1, ZERO, 1
9D00BBF4  54430065   BNEL V0, V1, 0x9D00BD8C
9D00BBF8  A780801E   SH ZERO, -32738(GP)
277:                 		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2? */
9D00BBFC  24040008   ADDIU A0, ZERO, 8
9D00BC00  0F402E90   JAL send_cmd
9D00BC04  240501AA   ADDIU A1, ZERO, 426
9D00BC08  24030001   ADDIU V1, ZERO, 1
9D00BC0C  14430033   BNE V0, V1, 0x9D00BCDC
9D00BC10  240400A9   ADDIU A0, ZERO, 169
9D00BC14  27B10014   ADDIU S1, SP, 20
9D00BC18  27B00010   ADDIU S0, SP, 16
278:                 			for (n = 0; n < 4; n++)
9D00BC2C  1611FFFB   BNE S0, S1, 0x9D00BC1C
9D00BC30  93A30012   LBU V1, 18(SP)
279:                 				buf[n] = rcvr_spi(); /* Get trailing return value of R7 resp */
9D00BC1C  0F405F0D   JAL writeSPI
9D00BC20  240400FF   ADDIU A0, ZERO, 255
9D00BC24  A2020000   SB V0, 0(S0)
9D00BC28  26100001   ADDIU S0, S0, 1
280:                 			if (buf[2] == 0x01 && buf[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
9D00BC34  24020001   ADDIU V0, ZERO, 1
9D00BC38  5462004E   BNEL V1, V0, 0x9D00BD74
9D00BC3C  A780801E   SH ZERO, -32738(GP)
9D00BC40  93A30013   LBU V1, 19(SP)
9D00BC44  240200AA   ADDIU V0, ZERO, 170
9D00BC48  54620050   BNEL V1, V0, 0x9D00BD8C
9D00BC4C  A780801E   SH ZERO, -32738(GP)
9D00BC50  241003E8   ADDIU S0, ZERO, 1000
281:                 				for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state (ACMD41 with HCS bit) */
9D00BC70  2610FFFF   ADDIU S0, S0, -1
9D00BC74  3210FFFF   ANDI S0, S0, -1
9D00BC78  1600FFF7   BNE S0, ZERO, 0x9D00BC58
9D00BC7C  240400A9   ADDIU A0, ZERO, 169
9D00BC80  0B402F63   J 0x9D00BD8C
9D00BC84  A780801E   SH ZERO, -32738(GP)
282:                 					if (send_cmd(ACMD41, 1UL << 30) == 0)
9D00BC54  240400A9   ADDIU A0, ZERO, 169
9D00BC58  0F402E90   JAL send_cmd
9D00BC5C  3C054000   LUI A1, 16384
9D00BC60  10400009   BEQ V0, ZERO, 0x9D00BC88
9D00BC64  00000000   NOP
283:                 						break;
284:                 					DLY_US(1000);
9D00BC68  0F403862   JAL delay_us
9D00BC6C  240403E8   ADDIU A0, ZERO, 1000
285:                 				}
286:                 				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
9D00BC88  52000040   BEQL S0, ZERO, 0x9D00BD8C
9D00BC8C  A780801E   SH ZERO, -32738(GP)
9D00BC90  2404003A   ADDIU A0, ZERO, 58
9D00BC94  0F402E90   JAL send_cmd
9D00BC98  00002821   ADDU A1, ZERO, ZERO
9D00BC9C  5440003B   BNEL V0, ZERO, 0x9D00BD8C
9D00BCA0  A780801E   SH ZERO, -32738(GP)
9D00BCA4  27B00010   ADDIU S0, SP, 16
287:                 					for (n = 0; n < 4; n++)
9D00BCB8  1630FFFB   BNE S1, S0, 0x9D00BCA8
9D00BCBC  93A40010   LBU A0, 16(SP)
288:                 						buf[n] = rcvr_spi();
9D00BCA8  0F405F0D   JAL writeSPI
9D00BCAC  240400FF   ADDIU A0, ZERO, 255
9D00BCB0  A2020000   SB V0, 0(S0)
9D00BCB4  26100001   ADDIU S0, S0, 1
289:                 					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 */
9D00BCC0  30840040   ANDI A0, A0, 64
9D00BCC4  308400FF   ANDI A0, A0, 255
9D00BCC8  24030004   ADDIU V1, ZERO, 4
9D00BCCC  2402000C   ADDIU V0, ZERO, 12
9D00BCD0  0064100A   MOVZ V0, V1, A0
290:                 				}
291:                 			}
292:                 		} else { /* SDv1 or MMCv3 */
293:                 			if (send_cmd(ACMD41, 0) <= 1) {
9D00BCDC  0F402E90   JAL send_cmd
9D00BCE0  00002821   ADDU A1, ZERO, ZERO
9D00BCE4  2C420002   SLTIU V0, V0, 2
294:                 				ty = CT_SD1;
9D00BCE8  24030002   ADDIU V1, ZERO, 2
9D00BCEC  24040001   ADDIU A0, ZERO, 1
9D00BCF0  00608821   ADDU S1, V1, ZERO
9D00BCF4  0082880A   MOVZ S1, A0, V0
295:                 				cmd = ACMD41; /* SDv1 */
296:                 			} else {
297:                 				ty = CT_MMC;
298:                 				cmd = CMD1; /* MMCv3 */
299:                 			}
300:                 			for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state */
9D00BCF8  241003E8   ADDIU S0, ZERO, 1000
9D00BD18  2610FFFF   ADDIU S0, S0, -1
9D00BD1C  3210FFFF   ANDI S0, S0, -1
9D00BD20  1600FFF7   BNE S0, ZERO, 0x9D00BD00
9D00BD24  240400A9   ADDIU A0, ZERO, 169
9D00BD28  0B402F63   J 0x9D00BD8C
9D00BD2C  A780801E   SH ZERO, -32738(GP)
301:                 				if (send_cmd(ACMD41, 0) == 0)
9D00BCFC  240400A9   ADDIU A0, ZERO, 169
9D00BD00  0F402E90   JAL send_cmd
9D00BD04  00002821   ADDU A1, ZERO, ZERO
9D00BD08  10400009   BEQ V0, ZERO, 0x9D00BD30
9D00BD0C  00000000   NOP
302:                 					break;
303:                 				DLY_US(1000);
9D00BD10  0F403862   JAL delay_us
9D00BD14  240403E8   ADDIU A0, ZERO, 1000
304:                 			}
305:                 			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
9D00BD30  52000016   BEQL S0, ZERO, 0x9D00BD8C
9D00BD34  A780801E   SH ZERO, -32738(GP)
9D00BD38  24040010   ADDIU A0, ZERO, 16
9D00BD3C  0F402E90   JAL send_cmd
9D00BD40  24050200   ADDIU A1, ZERO, 512
9D00BD44  54400011   BNEL V0, ZERO, 0x9D00BD8C
9D00BD48  A780801E   SH ZERO, -32738(GP)
306:                 				ty = 0;
307:                 		}
308:                 	}
309:                 	CardType = ty;
9D00BCD4  0B402F56   J 0x9D00BD58
9D00BCD8  A782801E   SH V0, -32738(GP)
9D00BD4C  A791801E   SH S1, -32738(GP)
310:                 	if (ty) {/* Initialization succeded */
9D00BD50  12200008   BEQ S1, ZERO, 0x9D00BD74
9D00BD54  24020001   ADDIU V0, ZERO, 1
311:                 		s &= ~STA_NOINIT;
9D00BD70  00001021   ADDU V0, ZERO, ZERO
312:                 		// 6. increase speed
313:                 		SPI2CON = 0; // disable the SPI2 module
9D00BD58  3C02BF80   LUI V0, -16512
9D00BD5C  AC405A00   SW ZERO, 23040(V0)
314:                 		SPI2BRG = 0; // maximum possible baud rate = Fpb/2
9D00BD60  3C03BF80   LUI V1, -16512
9D00BD64  AC605A30   SW ZERO, 23088(V1)
315:                 		SPI2CON = 0x8120; // re-enable the SPI2 module
9D00BD68  34038120   ORI V1, ZERO, -32480
9D00BD6C  AC435A00   SW V1, 23040(V0)
316:                 	} else {
317:                 		/* Initialization failed */
318:                 		s |= STA_NOINIT;
9D00BD8C  0B402F5D   J 0x9D00BD74
9D00BD90  24020001   ADDIU V0, ZERO, 1
319:                 	}
320:                 	Stat = s;
9D00BD74  A3828010   SB V0, -32752(GP)
321:                 
322:                 	deselect();
9D00BD78  0F404BB6   JAL disableSD
9D00BD7C  00000000   NOP
323:                 	return Stat;
9D00BD80  93828010   LBU V0, -32752(GP)
9D00BD84  0B402F65   J 0x9D00BD94
9D00BD88  304200FF   ANDI V0, V0, 255
324:                 }
9D00BD94  8FBF0024   LW RA, 36(SP)
9D00BD98  8FB10020   LW S1, 32(SP)
9D00BD9C  8FB0001C   LW S0, 28(SP)
9D00BDA0  27BD0028   ADDIU SP, SP, 40
9D00BDA4  03E00008   JR RA
9D00BDA8  00000000   NOP
325:                 
326:                 /*-----------------------------------------------------------------------*/
327:                 /* Get Disk Status                                                       */
328:                 /*-----------------------------------------------------------------------*/
329:                 
330:                 DSTATUS disk_status(PF_BYTE drv /* Physical drive number (0) */
331:                 ) {
332:                 	if (drv)
9D00BDAC  14800003   BNE A0, ZERO, 0x9D00BDBC
9D00BDB0  24020001   ADDIU V0, ZERO, 1
333:                 		return STA_NOINIT; /* Supports only single drive */
334:                 	return Stat;
9D00BDB4  93828010   LBU V0, -32752(GP)
9D00BDB8  304200FF   ANDI V0, V0, 255
335:                 }
9D00BDBC  03E00008   JR RA
9D00BDC0  00000000   NOP
336:                 
337:                 /*-----------------------------------------------------------------------*/
338:                 /* Read Sector(s)                                                        */
339:                 /*-----------------------------------------------------------------------*/
340:                 
341:                 DRESULT disk_read(PF_BYTE drv, /* Physical drive nmuber (0) */
342:                                   PF_BYTE *buff, /* Pointer to the data buffer to store read data */
343:                                   DWORD sector, /* Start sector number (LBA) */
344:                                   PF_BYTE count /* Sector count (1..255) */
345:                                   ) {
9D00BDCC  27BDFFE0   ADDIU SP, SP, -32
9D00BDD0  AFBF001C   SW RA, 28(SP)
9D00BDD4  AFB10018   SW S1, 24(SP)
9D00BDD8  AFB00014   SW S0, 20(SP)
346:                 	if (drv || !count)
9D00BDC4  14800034   BNE A0, ZERO, 0x9D00BE98
9D00BDC8  24020004   ADDIU V0, ZERO, 4
9D00BDDC  10E0002A   BEQ A3, ZERO, 0x9D00BE88
9D00BDE0  00E08021   ADDU S0, A3, ZERO
347:                 		return RES_PARERR;
348:                 	if (Stat & STA_NOINIT)
9D00BDE4  93838010   LBU V1, -32752(GP)
9D00BDE8  30630001   ANDI V1, V1, 1
9D00BDEC  14600026   BNE V1, ZERO, 0x9D00BE88
9D00BDF0  24020003   ADDIU V0, ZERO, 3
349:                 		return RES_NOTRDY;
350:                 
351:                 	if (!(CardType & CT_BLOCK))
9D00BDF4  9783801E   LHU V1, -32738(GP)
9D00BDF8  30630008   ANDI V1, V1, 8
9D00BDFC  3063FFFF   ANDI V1, V1, -1
352:                 		sector *= BLK_SIZE; /* Convert to byte address if needed */
9D00BE00  00061240   SLL V0, A2, 9
9D00BE04  0043300A   MOVZ A2, V0, V1
353:                 
354:                 	if (count == 1) { /* Single block read */
9D00BE08  24020001   ADDIU V0, ZERO, 1
9D00BE0C  14E2000A   BNE A3, V0, 0x9D00BE38
9D00BE10  00A08821   ADDU S1, A1, ZERO
355:                 		if ((send_cmd(CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
9D00BE14  24040011   ADDIU A0, ZERO, 17
9D00BE18  0F402E90   JAL send_cmd
9D00BE1C  00C02821   ADDU A1, A2, ZERO
9D00BE20  14400016   BNE V0, ZERO, 0x9D00BE7C
9D00BE24  02202021   ADDU A0, S1, ZERO
356:                 		&& rcvr_datablock(buff, BLK_SIZE))
9D00BE28  0F402E36   JAL rcvr_datablock
9D00BE2C  24050200   ADDIU A1, ZERO, 512
9D00BE30  0B402F9F   J 0x9D00BE7C
9D00BE34  2C500001   SLTIU S0, V0, 1
357:                 			count = 0;
358:                 	} else { /* Multiple block read */
359:                 		if (send_cmd(CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
9D00BE38  24040012   ADDIU A0, ZERO, 18
9D00BE3C  0F402E90   JAL send_cmd
9D00BE40  00C02821   ADDU A1, A2, ZERO
9D00BE44  1440000D   BNE V0, ZERO, 0x9D00BE7C
9D00BE48  00000000   NOP
360:                 			do {
361:                 				if (!rcvr_datablock(buff, BLK_SIZE))
9D00BE4C  02202021   ADDU A0, S1, ZERO
9D00BE50  0F402E36   JAL rcvr_datablock
9D00BE54  24050200   ADDIU A1, ZERO, 512
9D00BE58  10400006   BEQ V0, ZERO, 0x9D00BE74
9D00BE5C  2404000C   ADDIU A0, ZERO, 12
362:                 					break;
363:                 				buff += BLK_SIZE;
364:                 			} while (--count);
9D00BE60  2610FFFF   ADDIU S0, S0, -1
9D00BE64  321000FF   ANDI S0, S0, 255
9D00BE68  1600FFF8   BNE S0, ZERO, 0x9D00BE4C
9D00BE6C  26310200   ADDIU S1, S1, 512
365:                 			send_cmd(CMD12, 0); /* STOP_TRANSMISSION */
9D00BE70  2404000C   ADDIU A0, ZERO, 12
9D00BE74  0F402E90   JAL send_cmd
9D00BE78  00002821   ADDU A1, ZERO, ZERO
366:                 		}
367:                 	}
368:                 	deselect();
9D00BE7C  0F404BB6   JAL disableSD
9D00BE80  00000000   NOP
369:                 
370:                 	return count ? RES_ERROR : RES_OK;
9D00BE84  0010102B   SLTU V0, ZERO, S0
371:                 }
9D00BE88  8FBF001C   LW RA, 28(SP)
9D00BE8C  8FB10018   LW S1, 24(SP)
9D00BE90  8FB00014   LW S0, 20(SP)
9D00BE94  27BD0020   ADDIU SP, SP, 32
9D00BE98  03E00008   JR RA
9D00BE9C  00000000   NOP
372:                 
373:                 /*-----------------------------------------------------------------------*/
374:                 /* Write Sector(s)                                                       */
375:                 /*-----------------------------------------------------------------------*/
376:                 
377:                 #if _READONLY == 0
378:                 DRESULT disk_write(PF_BYTE drv, /* Physical drive number (0) */
379:                                    const PF_BYTE *buff, /* Pointer to the data to be written */
380:                                    DWORD sector, /* Start sector number (LBA) */
381:                                    PF_BYTE count /* Sector count (1..255) */
382:                                    ) {
9D00BEA8  27BDFFE0   ADDIU SP, SP, -32
9D00BEAC  AFBF001C   SW RA, 28(SP)
9D00BEB0  AFB20018   SW S2, 24(SP)
9D00BEB4  AFB10014   SW S1, 20(SP)
9D00BEB8  AFB00010   SW S0, 16(SP)
383:                 	if (drv || !count)
9D00BEA0  14800044   BNE A0, ZERO, 0x9D00BFB4
9D00BEA4  24020004   ADDIU V0, ZERO, 4
9D00BEBC  10E00038   BEQ A3, ZERO, 0x9D00BFA0
9D00BEC0  00E08021   ADDU S0, A3, ZERO
384:                 		return RES_PARERR;
385:                 	if (Stat & STA_NOINIT)
9D00BEC4  93838010   LBU V1, -32752(GP)
9D00BEC8  30630001   ANDI V1, V1, 1
9D00BECC  14600034   BNE V1, ZERO, 0x9D00BFA0
9D00BED0  24020003   ADDIU V0, ZERO, 3
386:                 		return RES_NOTRDY;
387:                 	if (Stat & STA_PROTECT)
9D00BED4  93838010   LBU V1, -32752(GP)
9D00BED8  30630004   ANDI V1, V1, 4
9D00BEDC  306300FF   ANDI V1, V1, 255
9D00BEE0  1460002F   BNE V1, ZERO, 0x9D00BFA0
9D00BEE4  24020002   ADDIU V0, ZERO, 2
9D00BEE8  00C09021   ADDU S2, A2, ZERO
388:                 		return RES_WRPRT;
389:                 
390:                 	if (!(CardType & CT_BLOCK))
9D00BEEC  9782801E   LHU V0, -32738(GP)
9D00BEF0  30440008   ANDI A0, V0, 8
9D00BEF4  3084FFFF   ANDI A0, A0, -1
391:                 		sector *= 512; /* Convert to byte address if needed */
9D00BEF8  00061A40   SLL V1, A2, 9
9D00BEFC  0064900A   MOVZ S2, V1, A0
392:                 
393:                 	if (count == 1) { /* Single block write */
9D00BF00  24030001   ADDIU V1, ZERO, 1
9D00BF04  14E3000A   BNE A3, V1, 0x9D00BF30
9D00BF08  00A08821   ADDU S1, A1, ZERO
394:                 		if ((send_cmd(CMD24, sector) == 0) /* WRITE_BLOCK */
9D00BF0C  24040018   ADDIU A0, ZERO, 24
9D00BF10  0F402E90   JAL send_cmd
9D00BF14  02402821   ADDU A1, S2, ZERO
9D00BF18  1440001E   BNE V0, ZERO, 0x9D00BF94
9D00BF1C  02202021   ADDU A0, S1, ZERO
395:                 		&& xmit_datablock(buff, 0xFE))
9D00BF20  0F402E11   JAL xmit_datablock
9D00BF24  240500FE   ADDIU A1, ZERO, 254
9D00BF28  0B402FE5   J 0x9D00BF94
9D00BF2C  2C500001   SLTIU S0, V0, 1
396:                 			count = 0;
397:                 	} else { /* Multiple block write */
398:                 		if (CardType & CT_SDC)
9D00BF30  30420006   ANDI V0, V0, 6
9D00BF34  10400005   BEQ V0, ZERO, 0x9D00BF4C
9D00BF38  24040019   ADDIU A0, ZERO, 25
399:                 			send_cmd(ACMD23, count);
9D00BF3C  24040097   ADDIU A0, ZERO, 151
9D00BF40  0F402E90   JAL send_cmd
9D00BF44  00E02821   ADDU A1, A3, ZERO
400:                 		if (send_cmd(CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
9D00BF48  24040019   ADDIU A0, ZERO, 25
9D00BF4C  0F402E90   JAL send_cmd
9D00BF50  02402821   ADDU A1, S2, ZERO
9D00BF54  1440000F   BNE V0, ZERO, 0x9D00BF94
9D00BF58  00000000   NOP
401:                 			do {
402:                 				if (!xmit_datablock(buff, 0xFC))
9D00BF5C  02202021   ADDU A0, S1, ZERO
9D00BF60  0F402E11   JAL xmit_datablock
9D00BF64  240500FC   ADDIU A1, ZERO, 252
9D00BF68  10400006   BEQ V0, ZERO, 0x9D00BF84
9D00BF6C  00002021   ADDU A0, ZERO, ZERO
403:                 					break;
404:                 				buff += 512;
405:                 			} while (--count);
9D00BF70  2610FFFF   ADDIU S0, S0, -1
9D00BF74  321000FF   ANDI S0, S0, 255
9D00BF78  1600FFF8   BNE S0, ZERO, 0x9D00BF5C
9D00BF7C  26310200   ADDIU S1, S1, 512
406:                 			if (!xmit_datablock(0, 0xFD)) /* STOP_TRAN token */
9D00BF80  00002021   ADDU A0, ZERO, ZERO
9D00BF84  0F402E11   JAL xmit_datablock
9D00BF88  240500FD   ADDIU A1, ZERO, 253
407:                 				count = 1;
9D00BF8C  24030001   ADDIU V1, ZERO, 1
9D00BF90  0062800A   MOVZ S0, V1, V0
408:                 		}
409:                 	}
410:                 	deselect();
9D00BF94  0F404BB6   JAL disableSD
9D00BF98  00000000   NOP
411:                 
412:                 	return count ? RES_ERROR : RES_OK;
9D00BF9C  0010102B   SLTU V0, ZERO, S0
413:                 }
9D00BFA0  8FBF001C   LW RA, 28(SP)
9D00BFA4  8FB20018   LW S2, 24(SP)
9D00BFA8  8FB10014   LW S1, 20(SP)
9D00BFAC  8FB00010   LW S0, 16(SP)
9D00BFB0  27BD0020   ADDIU SP, SP, 32
9D00BFB4  03E00008   JR RA
9D00BFB8  00000000   NOP
414:                 #endif /* _READONLY */
415:                 
416:                 /*-----------------------------------------------------------------------*/
417:                 /* Miscellaneous Functions                                               */
418:                 /*-----------------------------------------------------------------------*/
419:                 
420:                 DRESULT disk_ioctl(PF_BYTE drv, /* Physical drive number (0) */
421:                                    PF_BYTE ctrl, /* Control code */
422:                                    void *buff /* Buffer to send/receive data block */
423:                                    ) {
9D00BFC4  27BDFFD0   ADDIU SP, SP, -48
9D00BFC8  AFBF002C   SW RA, 44(SP)
9D00BFCC  AFB20028   SW S2, 40(SP)
9D00BFD0  AFB10024   SW S1, 36(SP)
9D00BFD4  AFB00020   SW S0, 32(SP)
424:                 	DRESULT res;
425:                 	PF_BYTE n, csd[16], *ptr = buff;
426:                 	DWORD csize;
427:                 
428:                 	if (drv)
9D00BFBC  148000DB   BNE A0, ZERO, 0x9D00C32C
9D00BFC0  24020004   ADDIU V0, ZERO, 4
429:                 		return RES_PARERR;
430:                 	if (Stat & STA_NOINIT)
9D00BFD8  93838010   LBU V1, -32752(GP)
9D00BFDC  30630001   ANDI V1, V1, 1
9D00BFE0  146000CD   BNE V1, ZERO, 0x9D00C318
9D00BFE4  24020003   ADDIU V0, ZERO, 3
431:                 		return RES_NOTRDY;
432:                 
433:                 	res = RES_ERROR;
434:                 	switch (ctrl) {
9D00BFE8  2CA2000F   SLTIU V0, A1, 15
9D00BFEC  104000C6   BEQ V0, ZERO, 0x9D00C308
9D00BFF0  00052880   SLL A1, A1, 2
9D00BFF4  3C029D01   LUI V0, -25343
9D00BFF8  2442C00C   ADDIU V0, V0, -16372
9D00BFFC  00452821   ADDU A1, V0, A1
9D00C000  8CA20000   LW V0, 0(A1)
9D00C004  00400008   JR V0
9D00C008  00C08021   ADDU S0, A2, ZERO
435:                 	case CTRL_SYNC: /* Flush dirty buffer if present */
436:                 		if (select()) {
9D00C048  0F402E7C   JAL select
9D00C04C  24110001   ADDIU S1, ZERO, 1
9D00C050  104000AE   BEQ V0, ZERO, 0x9D00C30C
9D00C054  00000000   NOP
437:                 			deselect();
9D00C058  0F404BB6   JAL disableSD
9D00C05C  00008821   ADDU S1, ZERO, ZERO
9D00C060  0B4030C3   J 0x9D00C30C
9D00C064  00000000   NOP
438:                 			res = RES_OK;
439:                 		}
440:                 		break;
441:                 
442:                 	case GET_SECTOR_COUNT: /* Get number of sectors on the disk (WORD) */
443:                 		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
9D00C068  24040009   ADDIU A0, ZERO, 9
9D00C06C  0F402E90   JAL send_cmd
9D00C070  00002821   ADDU A1, ZERO, ZERO
9D00C074  144000A5   BNE V0, ZERO, 0x9D00C30C
9D00C078  24110001   ADDIU S1, ZERO, 1
9D00C07C  27A40010   ADDIU A0, SP, 16
9D00C080  0F402E36   JAL rcvr_datablock
9D00C084  24050010   ADDIU A1, ZERO, 16
9D00C088  104000A0   BEQ V0, ZERO, 0x9D00C30C
9D00C08C  93A30010   LBU V1, 16(SP)
444:                 			if ((csd[0] >> 6) == 1) { /* SDv2? */
9D00C090  00031982   SRL V1, V1, 6
9D00C094  24020001   ADDIU V0, ZERO, 1
9D00C098  1462000A   BNE V1, V0, 0x9D00C0C4
9D00C09C  93A30018   LBU V1, 24(SP)
445:                 				csize = csd[9] + ((WORD) csd[8] << 8) + 1;
9D00C0A0  93A30019   LBU V1, 25(SP)
9D00C0A4  93A20018   LBU V0, 24(SP)
9D00C0A8  00021200   SLL V0, V0, 8
9D00C0AC  00621021   ADDU V0, V1, V0
9D00C0B0  24420001   ADDIU V0, V0, 1
446:                 				*(DWORD*) buff = (DWORD) csize << 10;
9D00C0B4  00021280   SLL V0, V0, 10
9D00C0B8  AE020000   SW V0, 0(S0)
9D00C0BC  0B4030C3   J 0x9D00C30C
9D00C0C0  00008821   ADDU S1, ZERO, ZERO
447:                 			} else { /* SDv1 or MMCv2 */
448:                 				n = (csd[5] & 15) + ((csd[10] & 128) >> 7)
9D00C0E8  93A40015   LBU A0, 21(SP)
9D00C0EC  3084000F   ANDI A0, A0, 15
9D00C0F0  93A2001A   LBU V0, 26(SP)
9D00C0F4  000211C2   SRL V0, V0, 7
9D00C0F8  00822021   ADDU A0, A0, V0
9D00C0FC  93A20019   LBU V0, 25(SP)
9D00C100  30420003   ANDI V0, V0, 3
9D00C104  00021040   SLL V0, V0, 1
449:                 						+ ((csd[9] & 3) << 1) + 2;
450:                 				csize = (csd[8] >> 6) + ((WORD) csd[7] << 2) + ((WORD) (csd[6]
9D00C0C4  00031982   SRL V1, V1, 6
9D00C0C8  93A20017   LBU V0, 23(SP)
9D00C0CC  00021080   SLL V0, V0, 2
9D00C0D0  00621821   ADDU V1, V1, V0
9D00C0E0  00621821   ADDU V1, V1, V0
451:                 						& 3) << 10) + 1;
9D00C0D4  93A20016   LBU V0, 22(SP)
9D00C0D8  30420003   ANDI V0, V0, 3
9D00C0DC  00021280   SLL V0, V0, 10
9D00C0E4  24630001   ADDIU V1, V1, 1
452:                 				*(DWORD*) buff = (DWORD) csize << (n - 9);
9D00C108  00821021   ADDU V0, A0, V0
9D00C10C  2442FFF9   ADDIU V0, V0, -7
9D00C110  00431004   SLLV V0, V1, V0
9D00C114  AE020000   SW V0, 0(S0)
453:                 			}
454:                 			res = RES_OK;
9D00C118  0B4030C3   J 0x9D00C30C
9D00C11C  00008821   ADDU S1, ZERO, ZERO
455:                 		}
456:                 		break;
457:                 
458:                 	case GET_SECTOR_SIZE: /* Get sectors on the disk (WORD) */
459:                 		*(WORD*) buff = 512;
9D00C120  24020200   ADDIU V0, ZERO, 512
9D00C124  A4C20000   SH V0, 0(A2)
460:                 		res = RES_OK;
461:                 		break;
9D00C128  0B4030C3   J 0x9D00C30C
9D00C12C  00008821   ADDU S1, ZERO, ZERO
462:                 
463:                 	case GET_BLOCK_SIZE: /* Get erase block size in unit of sectors (DWORD) */
464:                 		if (CardType & CT_SD2) { /* SDv2? */
9D00C130  9782801E   LHU V0, -32738(GP)
9D00C134  30420004   ANDI V0, V0, 4
9D00C138  3042FFFF   ANDI V0, V0, -1
9D00C13C  10400019   BEQ V0, ZERO, 0x9D00C1A4
9D00C140  24040009   ADDIU A0, ZERO, 9
465:                 			if (send_cmd(ACMD13, 0) == 0) { /* Read SD status */
9D00C144  2404008D   ADDIU A0, ZERO, 141
9D00C148  0F402E90   JAL send_cmd
9D00C14C  00002821   ADDU A1, ZERO, ZERO
9D00C150  1440006E   BNE V0, ZERO, 0x9D00C30C
9D00C154  24110001   ADDIU S1, ZERO, 1
466:                 				rcvr_spi();
9D00C158  0F405F0D   JAL writeSPI
9D00C15C  240400FF   ADDIU A0, ZERO, 255
467:                 				if (rcvr_datablock(csd, 16)) { /* Read partial block */
9D00C160  27A40010   ADDIU A0, SP, 16
9D00C164  0F402E36   JAL rcvr_datablock
9D00C168  24050010   ADDIU A1, ZERO, 16
9D00C16C  10400067   BEQ V0, ZERO, 0x9D00C30C
9D00C170  00000000   NOP
9D00C174  24110030   ADDIU S1, ZERO, 48
468:                 					for (n = 64 - 16; n; n--)
9D00C188  1620FFFB   BNE S1, ZERO, 0x9D00C178
9D00C18C  93A2001A   LBU V0, 26(SP)
469:                 						rcvr_spi(); /* Purge trailing data */
9D00C178  0F405F0D   JAL writeSPI
9D00C17C  240400FF   ADDIU A0, ZERO, 255
9D00C180  2631FFFF   ADDIU S1, S1, -1
9D00C184  323100FF   ANDI S1, S1, 255
470:                 					*(DWORD*) buff = 16UL << (csd[10] >> 4);
9D00C190  00021102   SRL V0, V0, 4
9D00C194  24030010   ADDIU V1, ZERO, 16
9D00C198  00431004   SLLV V0, V1, V0
9D00C19C  0B4030C3   J 0x9D00C30C
9D00C1A0  AE020000   SW V0, 0(S0)
471:                 					res = RES_OK;
472:                 				}
473:                 			}
474:                 		} else { /* SDv1 or MMCv3 */
475:                 			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) { /* Read CSD */
9D00C1A4  0F402E90   JAL send_cmd
9D00C1A8  00002821   ADDU A1, ZERO, ZERO
9D00C1AC  14400057   BNE V0, ZERO, 0x9D00C30C
9D00C1B0  24110001   ADDIU S1, ZERO, 1
9D00C1B4  27A40010   ADDIU A0, SP, 16
9D00C1B8  0F402E36   JAL rcvr_datablock
9D00C1BC  24050010   ADDIU A1, ZERO, 16
9D00C1C0  10400052   BEQ V0, ZERO, 0x9D00C30C
9D00C1C4  9782801E   LHU V0, -32738(GP)
476:                 				if (CardType & CT_SD1) { /* SDv1 */
9D00C1C8  30420002   ANDI V0, V0, 2
9D00C1CC  3042FFFF   ANDI V0, V0, -1
9D00C1D0  1040000E   BEQ V0, ZERO, 0x9D00C20C
9D00C1D4  93A2001B   LBU V0, 27(SP)
477:                 					*(DWORD*) buff = (((csd[10] & 63) << 1) + ((WORD) (csd[11]
9D00C1D8  93A3001A   LBU V1, 26(SP)
9D00C1DC  3063003F   ANDI V1, V1, 63
9D00C1E0  00031840   SLL V1, V1, 1
9D00C1E8  00621821   ADDU V1, V1, V0
9D00C200  AE020000   SW V0, 0(S0)
9D00C204  0B4030C3   J 0x9D00C30C
9D00C208  00008821   ADDU S1, ZERO, ZERO
478:                 							& 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
9D00C1E4  000211C2   SRL V0, V0, 7
9D00C1EC  24630001   ADDIU V1, V1, 1
9D00C1F0  93A2001D   LBU V0, 29(SP)
9D00C1F4  00021182   SRL V0, V0, 6
9D00C1F8  2442FFFF   ADDIU V0, V0, -1
9D00C1FC  00431004   SLLV V0, V1, V0
479:                 				} else { /* MMCv3 */
480:                 					*(DWORD*) buff = ((WORD) ((csd[10] & 124) >> 2) + 1)
9D00C20C  93A3001A   LBU V1, 26(SP)
9D00C210  7C632080   EXT V1, V1, 2, 5
9D00C214  24630001   ADDIU V1, V1, 1
9D00C230  AE020000   SW V0, 0(S0)
481:                 							* (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5)
9D00C218  30440003   ANDI A0, V0, 3
9D00C21C  000420C0   SLL A0, A0, 3
9D00C220  00021142   SRL V0, V0, 5
9D00C224  00821021   ADDU V0, A0, V0
9D00C22C  70621002   MUL V0, V1, V0
482:                 									+ 1);
9D00C228  24420001   ADDIU V0, V0, 1
483:                 				}
484:                 				res = RES_OK;
9D00C234  0B4030C3   J 0x9D00C30C
9D00C238  00008821   ADDU S1, ZERO, ZERO
485:                 			}
486:                 		}
487:                 		break;
488:                 
489:                 	case MMC_GET_TYPE: /* Get card type flags (1 byte) */
490:                 		*ptr = CardType;
9D00C23C  9782801E   LHU V0, -32738(GP)
9D00C240  A0C20000   SB V0, 0(A2)
491:                 		res = RES_OK;
492:                 		break;
9D00C244  0B4030C3   J 0x9D00C30C
9D00C248  00008821   ADDU S1, ZERO, ZERO
493:                 
494:                 	case MMC_GET_CSD: /* Receive CSD as a data block (16 bytes) */
495:                 		if ((send_cmd(CMD9, 0) == 0) /* READ_CSD */
9D00C24C  24040009   ADDIU A0, ZERO, 9
9D00C250  0F402E90   JAL send_cmd
9D00C254  00002821   ADDU A1, ZERO, ZERO
9D00C258  1440002C   BNE V0, ZERO, 0x9D00C30C
9D00C25C  24110001   ADDIU S1, ZERO, 1
496:                 		&& rcvr_datablock(buff, 16))
9D00C260  02002021   ADDU A0, S0, ZERO
9D00C264  0F402E36   JAL rcvr_datablock
9D00C268  24050010   ADDIU A1, ZERO, 16
9D00C26C  0B4030C3   J 0x9D00C30C
9D00C270  2C510001   SLTIU S1, V0, 1
497:                 			res = RES_OK;
498:                 		break;
499:                 
500:                 	case MMC_GET_CID: /* Receive CID as a data block (16 bytes) */
501:                 		if ((send_cmd(CMD10, 0) == 0) /* READ_CID */
9D00C274  2404000A   ADDIU A0, ZERO, 10
9D00C278  0F402E90   JAL send_cmd
9D00C27C  00002821   ADDU A1, ZERO, ZERO
9D00C280  14400022   BNE V0, ZERO, 0x9D00C30C
9D00C284  24110001   ADDIU S1, ZERO, 1
502:                 		&& rcvr_datablock(buff, 16))
9D00C288  02002021   ADDU A0, S0, ZERO
9D00C28C  0F402E36   JAL rcvr_datablock
9D00C290  24050010   ADDIU A1, ZERO, 16
9D00C294  0B4030C3   J 0x9D00C30C
9D00C298  2C510001   SLTIU S1, V0, 1
503:                 			res = RES_OK;
504:                 		break;
505:                 
506:                 	case MMC_GET_OCR: /* Receive OCR as an R3 resp (4 bytes) */
507:                 		if (send_cmd(CMD58, 0) == 0) { /* READ_OCR */
9D00C29C  2404003A   ADDIU A0, ZERO, 58
9D00C2A0  0F402E90   JAL send_cmd
9D00C2A4  00002821   ADDU A1, ZERO, ZERO
9D00C2A8  14400018   BNE V0, ZERO, 0x9D00C30C
9D00C2AC  24110001   ADDIU S1, ZERO, 1
9D00C2B0  00008821   ADDU S1, ZERO, ZERO
508:                 			for (n = 0; n < 4; n++)
9D00C2B4  24120004   ADDIU S2, ZERO, 4
9D00C2C8  1632FFFB   BNE S1, S2, 0x9D00C2B8
9D00C2CC  A0620000   SB V0, 0(V1)
9D00C2D0  0B4030C3   J 0x9D00C30C
9D00C2D4  00008821   ADDU S1, ZERO, ZERO
509:                 				*((PF_BYTE*) buff + n) = rcvr_spi();
9D00C2B8  0F405F0D   JAL writeSPI
9D00C2BC  240400FF   ADDIU A0, ZERO, 255
9D00C2C0  02111821   ADDU V1, S0, S1
9D00C2C4  26310001   ADDIU S1, S1, 1
510:                 			res = RES_OK;
511:                 		}
512:                 		break;
513:                 
514:                 	case MMC_GET_SDSTAT: /* Receive SD status as a data block (64 bytes) */
515:                 		if (send_cmd(ACMD13, 0) == 0) { /* SD_STATUS */
9D00C2D8  2404008D   ADDIU A0, ZERO, 141
9D00C2DC  0F402E90   JAL send_cmd
9D00C2E0  00002821   ADDU A1, ZERO, ZERO
9D00C2E4  14400009   BNE V0, ZERO, 0x9D00C30C
9D00C2E8  24110001   ADDIU S1, ZERO, 1
516:                 			rcvr_spi();
9D00C2EC  0F405F0D   JAL writeSPI
9D00C2F0  240400FF   ADDIU A0, ZERO, 255
517:                 			if (rcvr_datablock(buff, 64))
9D00C2F4  02002021   ADDU A0, S0, ZERO
9D00C2F8  0F402E36   JAL rcvr_datablock
9D00C2FC  24050040   ADDIU A1, ZERO, 64
9D00C300  0B4030C3   J 0x9D00C30C
9D00C304  2C510001   SLTIU S1, V0, 1
9D00C308  24110004   ADDIU S1, ZERO, 4
518:                 				res = RES_OK;
519:                 		}
520:                 		break;
521:                 
522:                 	default:
523:                 		res = RES_PARERR;
524:                 	}
525:                 
526:                 	deselect();
9D00C30C  0F404BB6   JAL disableSD
9D00C310  00000000   NOP
527:                 
528:                 	return res;
9D00C314  02201021   ADDU V0, S1, ZERO
529:                 }//disk_ioctl()
9D00C318  8FBF002C   LW RA, 44(SP)
9D00C31C  8FB20028   LW S2, 40(SP)
9D00C320  8FB10024   LW S1, 36(SP)
9D00C324  8FB00020   LW S0, 32(SP)
9D00C328  27BD0030   ADDIU SP, SP, 48
9D00C32C  03E00008   JR RA
9D00C330  00000000   NOP
530:                 
531:                 /*-----------------------------------------------------------------------*/
532:                 /* Device Timer Interrupt Procedure  (Platform dependent)                */
533:                 /*-----------------------------------------------------------------------*/
534:                 /* This function must be called in period of 1ms                         */
535:                 /*
536:                 void disk_timerproc(void) {
537:                 	static WORD pv;
538:                 	WORD p;
539:                 	PF_BYTE s;
540:                 	UINT16 n;
541:                 
542:                 	n = Timer1; // 1000Hz decrement timer
543:                 	if (n)
544:                 		Timer1 = --n;
545:                 	n = Timer2;
546:                 	if (n)
547:                 		Timer2 = --n;
548:                 
549:                 	p = pv;
550:                 	pv = getCD() & getWP(); // Sample socket switch
551:                 
552:                 	if (p == pv) { // Have contacts stabled?
553:                 		s = Stat;
554:                 
555:                 		if (p & getWP()) // WP is H (write protected)
556:                 			s |= STA_PROTECT;
557:                 		else
558:                 			//* WP is L (write enabled)
559:                 			s &= ~STA_PROTECT;
560:                 
561:                 		if (p & getCD()) // INS = H (Socket empty)
562:                 			s |= (STA_NODISK | STA_NOINIT);
563:                 		else
564:                 			// INS = L (Card inserted)
565:                 			s &= ~STA_NODISK;
566:                 
567:                 		Stat = s;
568:                 	}
569:                 }
570:                 */
571:                 
572:                 /*---------------------------------------------------------*/
573:                 /* User Provided RTC Function for FatFs module             */
574:                 /*---------------------------------------------------------*/
575:                 /* This is a real time clock service to be called from     */
576:                 /* FatFs module. Any valid time must be returned even if   */
577:                 /* the system does not support an RTC.                     */
578:                 /* This function is not required in read-only cfg.         */
579:                 
580:                 /*	The current time is returned packed into a DWORD
581:                 	(32 bit) value. The bit fields are as follows:
582:                 		bits 31:25	Year from 1980 (0..127)
583:                 		bits 24:21	Month (1..12)
584:                 		bits 20:16	Day in month (1..31)
585:                 		bits 15:11	Hour (0..23)
586:                 		bits 10:05	Minute (0..59)
587:                 		bits 04:00	Second / 2 (0..29)						*/
588:                 
589:                 DWORD get_fattime(void) {
590:                 	DWORD tmr = 0;
591:                 
592:                 // Pre-processor commands added so only use RTCC if the board is known
593:                 // to support the RTCC ** Added 07 May 2012
594:                 
595:                 // For boards known to support the RTCC library
596:                 
597:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
598:                 	rtccTime pTm, cTm;
599:                 	rtccDate pDt, cDt;
600:                 
601:                 	RTCC_GetTimeDate(&pTm, &pDt);	// get time and date from RTC
602:                 											// assumes RTC has been set and is running
603:                 											// OK - could be expanded to check that RTC
604:                 											// is running and that a valid value is
605:                 											// being returned by the RTC
606:                 	cTm = RTCC_ConvertTime(&pTm);	// convert time from bcd to decimal format
607:                 	cDt = RTCC_ConvertDate(&pDt);	// convert date from bcd to decimal format
608:                 
609:                 	/* Pack date and time into a DWORD variable */
610:                 //	tmr = (((DWORD) pDt.year - 80)) | ((DWORD) pDt.mon) | ((DWORD) pDt.mday)
611:                 //			| (WORD) (pTm.hour) | (WORD) (pTm.min) | (WORD) (pTm.sec);
612:                 	tmr = cDt.year + 20;
613:                    
614:                   // Correction according to a newer rtcc library, with diff struct members.
615:                   
616:                 	 tmr = (tmr << 4) | cDt.month;		// shifts left 4 bits and adds monthth
617:                 	tmr = (tmr << 5) | cDt.dayofmonth;		// shifts left 5 bits and adds m.day
618:                 	tmr = (tmr << 5) | cTm.hours;		// shifts left 5 bits and adds hour
619:                 	tmr = (tmr << 6) | cTm.minutes;		// shift left 6 bits and adds minutes
620:                 	tmr = (tmr << 5) | (cTm.seconds/2);	// shifts left 5 bits and adds seconds/2
621:                 
622:                 //	For other boards use a fixed date and time of 01 Jan 2012 12:00:00
623:                 #else
624:                      tmr = 12 + 20;
625:                      tmr = (tmr << 4) | 1;       // shifts left 4 bits and adds month
626:                      tmr = (tmr << 5) | 1;    	// shifts left 5 bits and adds m.day
627:                      tmr = (tmr << 5) | 12;    	// shifts left 5 bits and adds hour
628:                      tmr = (tmr << 6) | 0;       // shift left 6 bits and adds minutes
629:                      tmr = (tmr << 5) | (0/2);   // shifts left 5 bits and adds seconds/2
630:                 #endif
631:                 
632:                 	return tmr;
633:                 } // get_fattime()
9D00C334  3C024021   LUI V0, 16417
634:                 
635:                 void put_rc(FRESULT rc) {
636:                     char *fmt;
637:                 
638:                 	const char *str =
639:                                         "OK\0" "DISK_ERR\0" "INT_ERR\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0"
640:                                                 "INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
641:                                                 "INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
642:                                                 "LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0";
643:                 	FRESULT i;
644:                             for (i = 0; i != rc && *str; i++) {
645:                                     while (*str++)
646:                                             ;
647:                             }
648:                             print_error_msg(ERR_FIO,str,rc);
649:                 }//put_rc()
650:                 
---  /home/jacques/github/vpc-32vga/hardware/HardwareProfile.c  -----------------------------------------
1:                   /*
2:                   * Copyright 2013,2014,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   HardwareProfile.h
21:                   * Author: Jacques Deschênes
22:                   * Description: MCU hardware configuration
23:                   * Created on 17 avril 2013, 14:41
24:                   * rev: 2017-07-31
25:                   */
26:                  
27:                  #include "HardwareProfile.h"
28:                  #include <plib.h>
29:                  #include "sound/sound.h"
30:                  
31:                  #define TMR_COUNT 4
32:                  volatile unsigned int  sys_ticks; // milliseconds counter.
33:                  static volatile unsigned int timers[TMR_COUNT]; // count down timer
34:                  
35:                  
36:                  static volatile stime_t  stime;
37:                  static volatile sdate_t sdate;
38:                  
39:                  // boot time hardware initialization
40:                  void HardwareInit(){
9D00DF0C  27BDFFE8   ADDIU SP, SP, -24
9D00DF10  AFBF0014   SW RA, 20(SP)
41:                     SYSTEMConfig(mGetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
42:                     INTEnableSystemMultiVectoredInt();
9D00DF38  0F4064D3   JAL INTEnableSystemMultiVectoredInt
9D00DF3C  00000000   NOP
43:                      // MCU core timer configuration
44:                  #ifdef USE_CORE_TIMER
45:                     OpenCoreTimer(CORE_TICK_RATE); // 1 msec interrupt rate.
9D00DF40  0F406652   JAL OpenCoreTimer
9D00DF44  24044E20   ADDIU A0, ZERO, 20000
46:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_1 | CT_INT_SUB_PRIOR_0));
9D00DF48  24020001   ADDIU V0, ZERO, 1
9D00DF4C  3C03BF88   LUI V1, -16504
9D00DF50  AC621034   SW V0, 4148(V1)
9D00DF54  3C04BF88   LUI A0, -16504
9D00DF58  2403001C   ADDIU V1, ZERO, 28
9D00DF5C  AC831094   SW V1, 4244(A0)
9D00DF60  3C03BF88   LUI V1, -16504
9D00DF64  24070004   ADDIU A3, ZERO, 4
9D00DF68  AC671098   SW A3, 4248(V1)
9D00DF6C  24080003   ADDIU T0, ZERO, 3
9D00DF70  AC881094   SW T0, 4244(A0)
9D00DF74  AC601098   SW ZERO, 4248(V1)
9D00DF78  3C03BF88   LUI V1, -16504
9D00DF7C  AC621064   SW V0, 4196(V1)
9D00DF80  3C03BF88   LUI V1, -16504
9D00DF84  AC621068   SW V0, 4200(V1)
47:                  #endif
48:                     // disable all analogs inputs, not used by vpc32-v.
49:                     ANSELBCLR=0xFFFFFFFF;
9D00DF88  2403FFFF   ADDIU V1, ZERO, -1
9D00DF8C  3C04BF88   LUI A0, -16504
9D00DF90  AC836104   SW V1, 24836(A0)
50:                     ANSELACLR=0xFFFFFFFF;
9D00DF94  3C04BF88   LUI A0, -16504
9D00DF98  AC836004   SW V1, 24580(A0)
51:                      // serial port config
52:                     SER_LATSET=TX; // Set TX to high (idle state).
9D00DF9C  24030400   ADDIU V1, ZERO, 1024
9D00DFA0  3C04BF88   LUI A0, -16504
9D00DFA4  AC836138   SW V1, 24888(A0)
53:                     SER_TRISCLR=TX;  // set serial output pin.
9D00DFA8  3C04BF88   LUI A0, -16504
9D00DFAC  AC836114   SW V1, 24852(A0)
54:                     // Peripheral Pin Select
55:                     // see pps.h
56:                     PPSUnLock;  // unlock PPS to enable configuration
9D00DFB0  3C03BF81   LUI V1, -16511
9D00DFB4  9465F200   LHU A1, -3584(V1)
9D00DFB8  7C056B44   INS A1, ZERO, 13, 1
9D00DFBC  A465F200   SH A1, -3584(V1)
57:                     //keyboard
58:                     I2C1CONbits.DISSLW=1; // see pic32mx1xxx/2xxx-errata.pdf rev. E, point 9
9D00DFC0  3C05BF80   LUI A1, -16512
9D00DFC4  94A65000   LHU A2, 20480(A1)
9D00DFC8  7C464A44   INS A2, V0, 9, 1
9D00DFCC  A4A65000   SH A2, 20480(A1)
59:                     PPSInput(1,INT4,RPA0); // keyboard clock input use INT4
9D00DFD0  3C05BF81   LUI A1, -16511
9D00DFD4  90A6FA10   LBU A2, -1520(A1)
9D00DFD8  7C061804   INS A2, ZERO, 0, 4
9D00DFDC  A0A6FA10   SB A2, -1520(A1)
60:                     RPA1R=0; // no peripheral on RA1 (keyboard data) 
9D00DFE0  3C05BF81   LUI A1, -16511
9D00DFE4  ACA0FB04   SW ZERO, -1276(A1)
61:                     PPSOutput(4, RPB10, U2TX);  // U2TX on PB10
9D00DFE8  3C05BF81   LUI A1, -16511
9D00DFEC  90A6FB54   LBU A2, -1196(A1)
9D00DFF0  24090002   ADDIU T1, ZERO, 2
9D00DFF4  7D261804   INS A2, T1, 0, 4
9D00DFF8  A0A6FB54   SB A2, -1196(A1)
62:                     PPSInput (2, U2RX, RPB11);  // U2RX on PB11
9D00DFFC  3C05BF81   LUI A1, -16511
9D00E000  90A6FA58   LBU A2, -1448(A1)
9D00E004  7D061804   INS A2, T0, 0, 4
9D00E008  A0A6FA58   SB A2, -1448(A1)
63:                     PPSOutput(2,RPB5,OC2); // OC2  on PB5, VGA HSync signal.
9D00E00C  3C06BF81   LUI A2, -16511
9D00E010  90CAFB40   LBU T2, -1216(A2)
9D00E014  24050005   ADDIU A1, ZERO, 5
9D00E018  7CAA1804   INS T2, A1, 0, 4
9D00E01C  A0CAFB40   SB T2, -1216(A2)
64:                     OUT_PIN_PPS3_RPB13=OUT_FN_PPS3_OC4; // video SPI1 frame sync pulse ouput.
9D00E020  3C06BF81   LUI A2, -16511
9D00E024  90CAFB60   LBU T2, -1184(A2)
9D00E028  7CAA1804   INS T2, A1, 0, 4
9D00E02C  A0CAFB60   SB T2, -1184(A2)
65:                     // all these pins are VGA output pins
66:                     VGA_TRISCLR=(SPI_TRIG_OUT|VSYNC_OUT|HSYNC_OUT|VIDEO_OUT);
9D00E030  240A2070   ADDIU T2, ZERO, 8304
9D00E034  AC8A6114   SW T2, 24852(A0)
67:                     VGA_LATCLR=VIDEO_OUT;
9D00E038  AC906114   SW S0, 24852(A0)
68:                     PPSOutput(3,RPB13,OC4);  // OC4 generate frame signal for SPI1 (video) on RB13
9D00E03C  90CAFB60   LBU T2, -1184(A2)
9D00E040  7CAA1804   INS T2, A1, 0, 4
9D00E044  A0CAFB60   SB T2, -1184(A2)
69:                     PPSOutput(3,RPB6,SDO1); // SDO1 VGA video output on RB6
9D00E048  3C06BF81   LUI A2, -16511
9D00E04C  90CAFB44   LBU T2, -1212(A2)
9D00E050  7D0A1804   INS T2, T0, 0, 4
9D00E054  A0CAFB44   SB T2, -1212(A2)
70:                     PPSOutput(4,RPB9,OC3); // OC3 audio output on RB9.
9D00E058  3C06BF81   LUI A2, -16511
9D00E05C  90C8FB50   LBU T0, -1200(A2)
9D00E060  7CA81804   INS T0, A1, 0, 4
9D00E064  A0C8FB50   SB T0, -1200(A2)
71:                     PPSInput(1,SS1,RPB7); // SPI1 SS1 input on RPB7
9D00E068  3C05BF81   LUI A1, -16511
9D00E06C  90A6FA88   LBU A2, -1400(A1)
9D00E070  7CE61804   INS A2, A3, 0, 4
9D00E074  A0A6FA88   SB A2, -1400(A1)
72:                     PPSInput(3,SDI2,RPA4); // SD card and SPI RAM SDI (MISO) on RA4
9D00E078  3C05BF81   LUI A1, -16511
9D00E07C  90A6FA90   LBU A2, -1392(A1)
9D00E080  7D261804   INS A2, T1, 0, 4
9D00E084  A0A6FA90   SB A2, -1392(A1)
73:                     PPSOutput(2,RPB8,SDO2); // SD card and SPIRAM SDO  (MOSI) on RB8
9D00E088  3C05BF81   LUI A1, -16511
9D00E08C  90A6FB4C   LBU A2, -1204(A1)
9D00E090  7CE61804   INS A2, A3, 0, 4
9D00E094  A0A6FB4C   SB A2, -1204(A1)
74:                     // store interface output pins
75:                     STORE_TRISCLR=STORE_MOSI|STORE_CLK|SRAM_SEL|SDC_SEL;
9D00E098  34058109   ORI A1, ZERO, -32503
9D00E09C  AC856114   SW A1, 24852(A0)
76:                     PPSLock; // lock PPS to avoid accidental modification.
9D00E0A0  9464F200   LHU A0, -3584(V1)
9D00E0A4  7C446B44   INS A0, V0, 13, 1
9D00E0A8  A464F200   SH A0, -3584(V1)
77:                  }
9D00E0AC  8FBF0014   LW RA, 20(SP)
9D00E0B0  8FB00010   LW S0, 16(SP)
9D00E0B4  03E00008   JR RA
9D00E0B8  27BD0018   ADDIU SP, SP, 24
78:                  
79:                  // return the value of systicks counter
80:                  // millisecond since bootup
81:                  // rollover after ~ 50 days.
82:                  inline unsigned int ticks(void){
83:                      return sys_ticks;
9D00E0BC  8F828064   LW V0, -32668(GP)
84:                  } //ticks()
9D00E0C0  03E00008   JR RA
9D00E0C4  00000000   NOP
85:                  
86:                  
87:                  void set_time(unsigned short hr, unsigned short min, unsigned short sec){
88:                      stime.h=hr;
9D00E0C8  8F828038   LW V0, -32712(GP)
9D00E0CC  7C828304   INS V0, A0, 12, 5
9D00E0D0  AF828038   SW V0, -32712(GP)
89:                      stime.m=min;
9D00E0D4  8F828038   LW V0, -32712(GP)
9D00E0D8  7CA25984   INS V0, A1, 6, 6
9D00E0DC  AF828038   SW V0, -32712(GP)
90:                      stime.s=sec;
9D00E0E0  8F828038   LW V0, -32712(GP)
9D00E0E4  7CC22804   INS V0, A2, 0, 6
9D00E0E8  AF828038   SW V0, -32712(GP)
9D00E0EC  03E00008   JR RA
9D00E0F0  00000000   NOP
91:                  }
92:                  
93:                  void get_time(stime_t *t){
94:                      t->h=stime.h;
9D00E0F4  8F838038   LW V1, -32712(GP)
9D00E0F8  7C632300   EXT V1, V1, 12, 5
9D00E0FC  8C820000   LW V0, 0(A0)
9D00E100  7C628304   INS V0, V1, 12, 5
9D00E104  AC820000   SW V0, 0(A0)
95:                      t->m=stime.m;
9D00E108  8F838038   LW V1, -32712(GP)
9D00E10C  7C632980   EXT V1, V1, 6, 6
9D00E110  7C625984   INS V0, V1, 6, 6
9D00E114  AC820000   SW V0, 0(A0)
96:                      t->s=stime.s;
9D00E118  8F838038   LW V1, -32712(GP)
9D00E11C  7C622804   INS V0, V1, 0, 6
9D00E120  03E00008   JR RA
9D00E124  AC820000   SW V0, 0(A0)
97:                  }
98:                  
99:                  void set_date(unsigned year,unsigned month, unsigned day){
100:                     sdate.y=year&0xffff;
9D00E128  3084FFFF   ANDI A0, A0, -1
9D00E12C  A7848034   SH A0, -32716(GP)
101:                     sdate.m=month&0xf;
9D00E130  8F828034   LW V0, -32716(GP)
9D00E134  7CA29C04   INS V0, A1, 16, 4
9D00E138  AF828034   SW V0, -32716(GP)
102:                     sdate.d=day&0x1f;
9D00E13C  8F828034   LW V0, -32716(GP)
9D00E140  7CC2C504   INS V0, A2, 20, 5
9D00E144  AF828034   SW V0, -32716(GP)
9D00E148  03E00008   JR RA
9D00E14C  00000000   NOP
103:                 }
104:                 
105:                 void get_date(sdate_t *d){
106:                     d->y=sdate.y;
9D00E150  97828034   LHU V0, -32716(GP)
9D00E154  A4820000   SH V0, 0(A0)
107:                     d->m=sdate.m;
9D00E158  8F838034   LW V1, -32716(GP)
9D00E15C  7C631C00   EXT V1, V1, 16, 4
9D00E160  8C820000   LW V0, 0(A0)
9D00E164  7C629C04   INS V0, V1, 16, 4
9D00E168  AC820000   SW V0, 0(A0)
108:                     d->d=sdate.d;
9D00E16C  8F838034   LW V1, -32716(GP)
9D00E170  7C632500   EXT V1, V1, 20, 5
9D00E174  7C62C504   INS V0, V1, 20, 5
9D00E178  03E00008   JR RA
9D00E17C  AC820000   SW V0, 0(A0)
109:                 }
110:                 
111:                 const unsigned day_in_month[12]={31,28,31,30,31,30,31,31,30,31,30,31};
112:                 
113:                 BOOL leap_year(unsigned short year){
114:                     return (!(year/4) && (year/100)) || !(year/400); 
115:                 }
9D00E180  03E00008   JR RA
9D00E184  2C820190   SLTIU V0, A0, 400
116:                 
117:                 static void next_day(){
118:                     sdate.d++;
9D00E4E8  8F838034   LW V1, -32716(GP)
119:                     if (sdate.d>day_in_month[sdate.m-1]){
9D00E500  8F838034   LW V1, -32716(GP)
120:                         if(sdate.m==2){
9D00E534  8F838034   LW V1, -32716(GP)
121:                             if (!leap_year(sdate.y)|| (sdate.d==30)){sdate.m++;}
9D00E54C  97828034   LHU V0, -32716(GP)
122:                             sdate.d=1;
9D00E590  8F828034   LW V0, -32716(GP)
123:                         }else{
124:                             sdate.m++;
9D00E5A4  8F838034   LW V1, -32716(GP)
125:                             sdate.d=1;
9D00E5BC  8F828034   LW V0, -32716(GP)
126:                         }
127:                         if (sdate.m>12){
9D00E5CC  8F828034   LW V0, -32716(GP)
128:                             sdate.y++;
9D00E5E0  94430000   LHU V1, 0(V0)
129:                             sdate.m=1;
9D00E5F0  8F828034   LW V0, -32716(GP)
9D00E5F4  24030001   ADDIU V1, ZERO, 1
9D00E5F8  7C629C04   INS V0, V1, 16, 4
9D00E5FC  0B403985   J 0x9D00E614
9D00E600  AF828034   SW V0, -32716(GP)
130:                         }
131:                     }
132:                 }
133:                 
134:                 static void update_rtcc(){
135:                     stime.s++;
9D00E3FC  8F838038   LW V1, -32712(GP)
136:                     if (!(stime.s%60)){
9D00E410  8F828038   LW V0, -32712(GP)
137:                         stime.s=0;
9D00E444  8F828038   LW V0, -32712(GP)
138:                         stime.m++;
9D00E450  8F838038   LW V1, -32712(GP)
139:                         if (!(stime.m%60)){
9D00E468  8F828038   LW V0, -32712(GP)
140:                             stime.m=0;
9D00E49C  8F828038   LW V0, -32712(GP)
141:                             stime.h++;
9D00E4A8  8F838038   LW V1, -32712(GP)
142:                             if (stime.h==24){
9D00E4C0  8F838038   LW V1, -32712(GP)
143:                                 stime.h=0;
9D00E4DC  8F828038   LW V0, -32712(GP)
9D00E4E0  7C028304   INS V0, ZERO, 12, 5
9D00E4E4  AF828038   SW V0, -32712(GP)
9D00E4E8  8F838034   LW V1, -32716(GP)
9D00E4EC  7C632500   EXT V1, V1, 20, 5
9D00E4F0  24630001   ADDIU V1, V1, 1
9D00E4F4  8F828034   LW V0, -32716(GP)
9D00E4F8  7C62C504   INS V0, V1, 20, 5
9D00E4FC  AF828034   SW V0, -32716(GP)
9D00E500  8F838034   LW V1, -32716(GP)
9D00E504  7C632500   EXT V1, V1, 20, 5
9D00E508  8F848034   LW A0, -32716(GP)
9D00E50C  7C841C00   EXT A0, A0, 16, 4
9D00E510  2484FFFF   ADDIU A0, A0, -1
9D00E514  00042080   SLL A0, A0, 2
9D00E518  3C029D02   LUI V0, -25342
9D00E51C  244294B8   ADDIU V0, V0, -27464
9D00E520  00821021   ADDU V0, A0, V0
9D00E524  8C420000   LW V0, 0(V0)
9D00E528  0043102B   SLTU V0, V0, V1
9D00E52C  10400039   BEQ V0, ZERO, 0x9D00E614
9D00E530  00000000   NOP
9D00E534  8F838034   LW V1, -32716(GP)
9D00E538  3C02000F   LUI V0, 15
9D00E53C  00621824   AND V1, V1, V0
9D00E540  3C020002   LUI V0, 2
9D00E544  14620017   BNE V1, V0, 0x9D00E5A4
9D00E548  00000000   NOP
9D00E54C  97828034   LHU V0, -32716(GP)
9D00E550  3042FFFF   ANDI V0, V0, -1
9D00E554  2C420190   SLTIU V0, V0, 400
9D00E558  10400007   BEQ V0, ZERO, 0x9D00E578
9D00E55C  00000000   NOP
9D00E560  8F838034   LW V1, -32716(GP)
9D00E564  3C0201F0   LUI V0, 496
9D00E568  00621824   AND V1, V1, V0
9D00E56C  3C0201E0   LUI V0, 480
9D00E570  14620007   BNE V1, V0, 0x9D00E590
9D00E574  00000000   NOP
9D00E578  8F838034   LW V1, -32716(GP)
9D00E57C  7C631C00   EXT V1, V1, 16, 4
9D00E580  24630001   ADDIU V1, V1, 1
9D00E584  8F828034   LW V0, -32716(GP)
9D00E588  7C629C04   INS V0, V1, 16, 4
9D00E58C  AF828034   SW V0, -32716(GP)
9D00E590  8F828034   LW V0, -32716(GP)
9D00E594  24030001   ADDIU V1, ZERO, 1
9D00E598  7C62C504   INS V0, V1, 20, 5
9D00E59C  0B403973   J 0x9D00E5CC
9D00E5A0  AF828034   SW V0, -32716(GP)
9D00E5A4  8F838034   LW V1, -32716(GP)
9D00E5A8  7C631C00   EXT V1, V1, 16, 4
9D00E5AC  24630001   ADDIU V1, V1, 1
9D00E5B0  8F828034   LW V0, -32716(GP)
9D00E5B4  7C629C04   INS V0, V1, 16, 4
9D00E5B8  AF828034   SW V0, -32716(GP)
9D00E5BC  8F828034   LW V0, -32716(GP)
9D00E5C0  24030001   ADDIU V1, ZERO, 1
9D00E5C4  7C62C504   INS V0, V1, 20, 5
9D00E5C8  AF828034   SW V0, -32716(GP)
9D00E5CC  8F828034   LW V0, -32716(GP)
9D00E5D0  7C421C00   EXT V0, V0, 16, 4
9D00E5D4  2842000D   SLTI V0, V0, 13
9D00E5D8  1440000E   BNE V0, ZERO, 0x9D00E614
9D00E5DC  27828034   ADDIU V0, GP, -32716
9D00E5E0  94430000   LHU V1, 0(V0)
9D00E5E4  24630001   ADDIU V1, V1, 1
9D00E5E8  3063FFFF   ANDI V1, V1, -1
9D00E5EC  A4430000   SH V1, 0(V0)
9D00E5F0  8F828034   LW V0, -32716(GP)
9D00E5F4  24030001   ADDIU V1, ZERO, 1
9D00E5F8  7C629C04   INS V0, V1, 16, 4
9D00E5FC  0B403985   J 0x9D00E614
9D00E600  AF828034   SW V0, -32716(GP)
144:                                 next_day();
145:                             }
146:                         }
147:                     }
148:                     
149:                 }
150:                 
151:                 // pause execution for duration in microsecond.
152:                 // idle loop.
153:                 inline void delay_us(unsigned int usec){
154:                     for (usec=usec*(CLK_PER_USEC/3);usec;usec--);
9D00E188  00041080   SLL V0, A0, 2
9D00E18C  00041900   SLL V1, A0, 4
9D00E190  00621023   SUBU V0, V1, V0
9D00E194  00442021   ADDU A0, V0, A0
9D00E198  10800003   BEQ A0, ZERO, 0x9D00E1A8
9D00E19C  2484FFFF   ADDIU A0, A0, -1
9D00E1A0  1480FFFF   BNE A0, ZERO, 0x9D00E1A0
9D00E1A4  2484FFFF   ADDIU A0, A0, -1
9D00E1A8  03E00008   JR RA
9D00E1AC  00000000   NOP
155:                 }//delay_us()
156:                 
157:                 // pause execution for duration in millisecond.
158:                 // idle loop.
159:                 void delay_ms(unsigned int msec){
160:                 #ifdef USE_CORE_TIMER
161:                     unsigned int t0;
162:                     t0=sys_ticks+msec;
9D00E1B0  8F828064   LW V0, -32668(GP)
9D00E1B4  00822021   ADDU A0, A0, V0
163:                     while (sys_ticks!=t0);
9D00E1B8  8F828064   LW V0, -32668(GP)
9D00E1BC  1444FFFE   BNE V0, A0, 0x9D00E1B8
9D00E1C0  00000000   NOP
164:                 #else
165:                     while (msec--){
166:                         delay_us(1000);
167:                     }
168:                 #endif
169:                 } // delay_ms()
9D00E1C4  03E00008   JR RA
9D00E1C8  00000000   NOP
170:                 
171:                 // get_timer())
172:                 //  initialize a timer and return a pointer to it.
173:                 // input:
174:                 //      msec  duration in milliseconds
175:                 // output:
176:                 //      tmr*   Pointer to countdown variable, return NULL if none available
177:                 volatile unsigned int* get_timer(unsigned int msec){
178:                     int i;
179:                     for (i=0;i<TMR_COUNT;i++){
180:                         if (!timers[i]){
9D00E1CC  3C02A000   LUI V0, -24576
9D00E1D0  8C424C30   LW V0, 19504(V0)
9D00E1D4  10400011   BEQ V0, ZERO, 0x9D00E21C
9D00E1D8  00001821   ADDU V1, ZERO, ZERO
9D00E1DC  3C02A000   LUI V0, -24576
9D00E1E0  24424C30   ADDIU V0, V0, 19504
9D00E1E4  8C420004   LW V0, 4(V0)
9D00E1E8  1040000C   BEQ V0, ZERO, 0x9D00E21C
9D00E1EC  24030001   ADDIU V1, ZERO, 1
9D00E1F0  3C02A000   LUI V0, -24576
9D00E1F4  24424C30   ADDIU V0, V0, 19504
9D00E1F8  8C420008   LW V0, 8(V0)
9D00E1FC  10400007   BEQ V0, ZERO, 0x9D00E21C
9D00E200  24030002   ADDIU V1, ZERO, 2
9D00E204  3C02A000   LUI V0, -24576
9D00E208  24424C30   ADDIU V0, V0, 19504
9D00E20C  8C43000C   LW V1, 12(V0)
9D00E210  14600007   BNE V1, ZERO, 0x9D00E230
9D00E214  00001021   ADDU V0, ZERO, ZERO
9D00E218  24030003   ADDIU V1, ZERO, 3
181:                             timers[i]=msec;
9D00E21C  00031880   SLL V1, V1, 2
9D00E220  3C02A000   LUI V0, -24576
9D00E224  24424C30   ADDIU V0, V0, 19504
9D00E228  00621021   ADDU V0, V1, V0
9D00E22C  AC440000   SW A0, 0(V0)
182:                             return &timers[i];
183:                         }
184:                     }
185:                     return NULL;
186:                 }
9D00E230  03E00008   JR RA
9D00E234  00000000   NOP
187:                 // compute free bytes available on heap.
188:                 // successive allocation trial until sucess
189:                 // binary division algorithm
190:                 unsigned free_heap(){
9D00E238  27BDFFD8   ADDIU SP, SP, -40
9D00E23C  AFBF0024   SW RA, 36(SP)
9D00E240  AFB30020   SW S3, 32(SP)
9D00E244  AFB2001C   SW S2, 28(SP)
9D00E248  AFB10018   SW S1, 24(SP)
9D00E24C  AFB00014   SW S0, 20(SP)
191:                     unsigned top=RAM_SIZE,size,bottom=0;
9D00E250  00009821   ADDU S3, ZERO, ZERO
9D00E258  3C120001   LUI S2, 1
192:                     void *ptr=NULL;
193:                 
194:                     size=RAM_SIZE/2;
9D00E254  34108000   ORI S0, ZERO, -32768
195:                     while ((top-bottom)>16){
9D00E298  02531023   SUBU V0, S2, S3
9D00E29C  2C420011   SLTIU V0, V0, 17
9D00E2A0  1040FFEE   BEQ V0, ZERO, 0x9D00E25C
9D00E2A4  00000000   NOP
196:                         ptr=malloc(size);
9D00E25C  0F404DAF   JAL malloc
9D00E260  02002021   ADDU A0, S0, ZERO
197:                         if (!ptr){
9D00E264  14400006   BNE V0, ZERO, 0x9D00E280
9D00E268  00408821   ADDU S1, V0, ZERO
198:                             top=size;
199:                             size-=(top-bottom)>>1;
9D00E26C  02131023   SUBU V0, S0, S3
9D00E270  00021042   SRL V0, V0, 1
9D00E274  02009021   ADDU S2, S0, ZERO
9D00E278  0B4038A6   J 0x9D00E298
9D00E27C  02028023   SUBU S0, S0, V0
200:                         }else{
201:                             free(ptr);
9D00E280  0F40656A   JAL free
9D00E284  00402021   ADDU A0, V0, ZERO
202:                             bottom=size;
203:                             size+=(top-bottom)>>1;
9D00E288  02501023   SUBU V0, S2, S0
9D00E28C  00021042   SRL V0, V0, 1
9D00E290  02009821   ADDU S3, S0, ZERO
9D00E294  00508021   ADDU S0, V0, S0
204:                         }
205:                     }
206:                     if (ptr) free(ptr);
9D00E2A8  12200004   BEQ S1, ZERO, 0x9D00E2BC
9D00E2AC  02001021   ADDU V0, S0, ZERO
9D00E2B0  0F40656A   JAL free
9D00E2B4  02202021   ADDU A0, S1, ZERO
207:                     return size;
208:                 }
9D00E2B8  02001021   ADDU V0, S0, ZERO
9D00E2BC  8FBF0024   LW RA, 36(SP)
9D00E2C0  8FB30020   LW S3, 32(SP)
9D00E2C4  8FB2001C   LW S2, 28(SP)
9D00E2C8  8FB10018   LW S1, 24(SP)
9D00E2CC  8FB00014   LW S0, 20(SP)
9D00E2D0  03E00008   JR RA
9D00E2D4  27BD0028   ADDIU SP, SP, 40
209:                 
210:                 #ifdef USE_CORE_TIMER
211:                 //MCU core timer interrupt
212:                 // period 1msec
213:                 // also control TONE timer
214:                 void __ISR(_CORE_TIMER_VECTOR, IPL1SOFT) CoreTimerHandler(void){
9D00E2D8  415DE800   RDPGPR SP, SP
9D00E2DC  401A7000   MFC0 K0, EPC
9D00E2E0  401B6000   MFC0 K1, Status
9D00E2E4  27BDFFD0   ADDIU SP, SP, -48
9D00E2E8  AFBA002C   SW K0, 44(SP)
9D00E2EC  401A6002   MFC0 K0, SRSCtl
9D00E2F0  AFBB0028   SW K1, 40(SP)
9D00E2F4  AFBA0024   SW K0, 36(SP)
9D00E2F8  7C1B7844   INS K1, ZERO, 1, 15
9D00E2FC  377B0400   ORI K1, K1, 1024
9D00E300  409B6000   MTC0 K1, Status
9D00E304  AFA60014   SW A2, 20(SP)
9D00E308  AFA50010   SW A1, 16(SP)
9D00E30C  AFA4000C   SW A0, 12(SP)
9D00E310  AFA30008   SW V1, 8(SP)
9D00E314  AFA20004   SW V0, 4(SP)
9D00E318  00001012   MFLO V0
9D00E31C  AFA2001C   SW V0, 28(SP)
9D00E320  00001810   MFHI V1
9D00E324  AFA30018   SW V1, 24(SP)
9D00E38C  0B403981   J 0x9D00E604
9D00E390  00001021   ADDU V0, ZERO, ZERO
215:                      sys_ticks++;
9D00E328  8F828064   LW V0, -32668(GP)
9D00E32C  24420001   ADDIU V0, V0, 1
9D00E330  AF828064   SW V0, -32668(GP)
216:                 //     __asm__("addiu $sp,$sp,-4");
217:                 //     __asm__("sw $v0,0($sp)");
218:                      __asm__("mfc0 $v0, $11");
9D00E334  40025800   MFC0 V0, Compare
219:                      __asm__("addiu $v0,$v0,%0"::"I"(CORE_TICK_RATE));
9D00E338  24424E20   ADDIU V0, V0, 20000
220:                      __asm__("mtc0 $v0, $11");
9D00E33C  40825800   MTC0 V0, Compare
221:                 //     __asm__("lw $v0,0($sp)");
222:                 //     __asm__("addiu $sp,$sp,4");
223:                      mCTClearIntFlag();
9D00E340  24030001   ADDIU V1, ZERO, 1
9D00E344  3C02BF88   LUI V0, -16504
9D00E348  AC431034   SW V1, 4148(V0)
224:                      if ((fSound & TONE_ON) && !(--duration)){
9D00E34C  93828025   LBU V0, -32731(GP)
9D00E350  30420001   ANDI V0, V0, 1
9D00E354  104000AB   BEQ V0, ZERO, 0x9D00E604
9D00E358  00001021   ADDU V0, ZERO, ZERO
9D00E35C  8F828060   LW V0, -32672(GP)
9D00E360  2442FFFF   ADDIU V0, V0, -1
9D00E364  AF828060   SW V0, -32672(GP)
9D00E368  544000A6   BNEL V0, ZERO, 0x9D00E604
9D00E36C  00001021   ADDU V0, ZERO, ZERO
225:                          fSound &= ~TONE_ON;
9D00E370  93828025   LBU V0, -32731(GP)
9D00E374  304200FE   ANDI V0, V0, 254
9D00E378  A3828025   SB V0, -32731(GP)
226:                          mTone_off();
9D00E37C  3C02BF80   LUI V0, -16512
9D00E380  94433400   LHU V1, 13312(V0)
9D00E384  7C037BC4   INS V1, ZERO, 15, 1
9D00E388  A4433400   SH V1, 13312(V0)
227:                      }
228:                      int i;
229:                      for (i=0;i<TMR_COUNT;i++){
9D00E3BC  24420001   ADDIU V0, V0, 1
9D00E3C0  1445FFF5   BNE V0, A1, 0x9D00E398
9D00E3C4  00021880   SLL V1, V0, 2
9D00E60C  0B4038E5   J 0x9D00E394
9D00E610  24050004   ADDIU A1, ZERO, 4
230:                         if (timers[i]) timers[i]--;
9D00E394  00021880   SLL V1, V0, 2
9D00E398  00641821   ADDU V1, V1, A0
9D00E39C  8C630000   LW V1, 0(V1)
9D00E3A0  50600007   BEQL V1, ZERO, 0x9D00E3C0
9D00E3A4  24420001   ADDIU V0, V0, 1
9D00E3A8  00021880   SLL V1, V0, 2
9D00E3AC  00641821   ADDU V1, V1, A0
9D00E3B0  8C660000   LW A2, 0(V1)
9D00E3B4  24C6FFFF   ADDIU A2, A2, -1
9D00E3B8  AC660000   SW A2, 0(V1)
9D00E604  3C04A000   LUI A0, -24576
9D00E608  24844C30   ADDIU A0, A0, 19504
231:                      }
232:                      if (!(sys_ticks%1000)){
9D00E3C8  8F838064   LW V1, -32668(GP)
9D00E3CC  3C021062   LUI V0, 4194
9D00E3D0  24424DD3   ADDIU V0, V0, 19923
9D00E3D4  00620019   MULTU 0, V1, V0
9D00E3D8  00001010   MFHI V0
9D00E3DC  00021182   SRL V0, V0, 6
9D00E3E0  00022080   SLL A0, V0, 2
9D00E3E4  000229C0   SLL A1, V0, 7
9D00E3E8  00A42023   SUBU A0, A1, A0
9D00E3EC  00821021   ADDU V0, A0, V0
9D00E3F0  000210C0   SLL V0, V0, 3
9D00E3F4  14620087   BNE V1, V0, 0x9D00E614
9D00E3F8  00000000   NOP
233:                          update_rtcc();
234:                      }
235:                 }
9D00E614  8FA2001C   LW V0, 28(SP)
9D00E618  00400013   MTLO V0
9D00E61C  8FA30018   LW V1, 24(SP)
9D00E620  00600011   MTHI V1
9D00E624  8FA60014   LW A2, 20(SP)
9D00E628  8FA50010   LW A1, 16(SP)
9D00E62C  8FA4000C   LW A0, 12(SP)
9D00E630  8FA30008   LW V1, 8(SP)
9D00E634  8FA20004   LW V0, 4(SP)
9D00E638  41606000   DI ZERO
9D00E63C  000000C0   EHB
9D00E640  8FBA002C   LW K0, 44(SP)
9D00E644  8FBB0028   LW K1, 40(SP)
9D00E648  409A7000   MTC0 K0, EPC
9D00E64C  8FBA0024   LW K0, 36(SP)
9D00E650  27BD0030   ADDIU SP, SP, 48
9D00E654  409A6002   MTC0 K0, SRSCtl
9D00E658  41DDE800   WRPGPR SP, SP
9D00E65C  409B6000   MTC0 K1, Status
9D00E660  42000018   ERET
236:                 #endif
237:                 
---  /home/jacques/github/vpc-32vga/graphics.c  ---------------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   *  File: graphics.c
20:                   *  Author: Jacques Deschênes
21:                   *  Created on 2 novembre 2013
22:                   *  Description: fonctions graphiques.
23:                   *  REF: http://en.wikipedia.org/wiki/Midpoint_circle_algorithm
24:                   *  REF: http://members.chello.at/~easyfilter/bresenham.html
25:                   */
26:                  #include "hardware/tvout/vga.h"
27:                  #include <math.h>
28:                  
29:                  int getPixel(int x, int y){
30:                      int h,ofs;
31:                      h=x/32;
9D00CDC4  2486001F   ADDIU A2, A0, 31
9D00CDC8  28870000   SLTI A3, A0, 0
9D00CDCC  00C7200B   MOVN A0, A2, A3
9D00CDD0  00042143   SRA A0, A0, 5
32:                      ofs=31-x%32;
9D00CDA4  000417C3   SRA V0, A0, 31
9D00CDA8  000216C2   SRL V0, V0, 27
9D00CDAC  00821821   ADDU V1, A0, V0
9D00CDB0  3063001F   ANDI V1, V1, 31
9D00CDB4  00431823   SUBU V1, V0, V1
9D00CDB8  2463001F   ADDIU V1, V1, 31
33:                      return (video_bmp[y][h]&(1<<ofs))>>ofs;
9D00CDBC  24020001   ADDIU V0, ZERO, 1
9D00CDC0  00621004   SLLV V0, V0, V1
9D00CDD4  00053100   SLL A2, A1, 4
9D00CDD8  00C52823   SUBU A1, A2, A1
9D00CDDC  00A42021   ADDU A0, A1, A0
9D00CDE0  00042080   SLL A0, A0, 2
9D00CDE4  3C05A000   LUI A1, -24576
9D00CDE8  24A50070   ADDIU A1, A1, 112
9D00CDEC  00852021   ADDU A0, A0, A1
9D00CDF0  8C840000   LW A0, 0(A0)
9D00CDF4  00441024   AND V0, V0, A0
34:                  }//getPixel()
9D00CDF8  03E00008   JR RA
9D00CDFC  00621006   SRLV V0, V0, V1
35:                  
36:                  void setPixel(int x, int y){
37:                      int h,ofs;
38:                      if (y>(VRES-1)) return; // hors limites
9D00CE00  28A200F0   SLTI V0, A1, 240
9D00CE04  10400018   BEQ V0, ZERO, 0x9D00CE68
9D00CE08  2482001F   ADDIU V0, A0, 31
39:                      h= x/32;
9D00CE0C  28830000   SLTI V1, A0, 0
9D00CE10  0083100A   MOVZ V0, A0, V1
9D00CE14  00021143   SRA V0, V0, 5
40:                      if (h>HRES/32) return; // hors limites
9D00CE18  28430010   SLTI V1, V0, 16
9D00CE1C  10600012   BEQ V1, ZERO, 0x9D00CE68
9D00CE20  00051900   SLL V1, A1, 4
41:                      ofs = 31 - x%32;
9D00CE3C  00041FC3   SRA V1, A0, 31
9D00CE40  00031EC2   SRL V1, V1, 27
9D00CE44  00832021   ADDU A0, A0, V1
9D00CE48  3084001F   ANDI A0, A0, 31
9D00CE4C  00641823   SUBU V1, V1, A0
9D00CE50  2463001F   ADDIU V1, V1, 31
42:                      video_bmp[y][h]|= (1<<ofs);
9D00CE24  00652823   SUBU A1, V1, A1
9D00CE28  00A21021   ADDU V0, A1, V0
9D00CE2C  00021080   SLL V0, V0, 2
9D00CE30  3C03A000   LUI V1, -24576
9D00CE34  24630070   ADDIU V1, V1, 112
9D00CE38  00431021   ADDU V0, V0, V1
9D00CE54  24040001   ADDIU A0, ZERO, 1
9D00CE58  00641804   SLLV V1, A0, V1
9D00CE5C  8C440000   LW A0, 0(V0)
9D00CE60  00641825   OR V1, V1, A0
9D00CE64  AC430000   SW V1, 0(V0)
9D00CE68  03E00008   JR RA
9D00CE6C  00000000   NOP
43:                  } // setPixel()
44:                  
45:                  void clearPixel(int x, int y){
46:                      int h,ofs;
47:                      if (y>(VRES-1)) return; // hors limites
9D00CE70  28A200F0   SLTI V0, A1, 240
9D00CE74  10400019   BEQ V0, ZERO, 0x9D00CEDC
9D00CE78  2482001F   ADDIU V0, A0, 31
48:                      h= x/32;
9D00CE7C  28830000   SLTI V1, A0, 0
9D00CE80  0083100A   MOVZ V0, A0, V1
9D00CE84  00021143   SRA V0, V0, 5
49:                      if (h>HRES/32) return; // hors limites
9D00CE88  28430010   SLTI V1, V0, 16
9D00CE8C  10600013   BEQ V1, ZERO, 0x9D00CEDC
9D00CE90  00051900   SLL V1, A1, 4
50:                      ofs = 31 - x%32;
9D00CEAC  00041FC3   SRA V1, A0, 31
9D00CEB0  00031EC2   SRL V1, V1, 27
9D00CEB4  00832021   ADDU A0, A0, V1
9D00CEB8  3084001F   ANDI A0, A0, 31
9D00CEBC  00641823   SUBU V1, V1, A0
9D00CEC0  2463001F   ADDIU V1, V1, 31
51:                      video_bmp[y][h]&= ~(1<<ofs);
9D00CE94  00652823   SUBU A1, V1, A1
9D00CE98  00A21021   ADDU V0, A1, V0
9D00CE9C  00021080   SLL V0, V0, 2
9D00CEA0  3C03A000   LUI V1, -24576
9D00CEA4  24630070   ADDIU V1, V1, 112
9D00CEA8  00431021   ADDU V0, V0, V1
9D00CEC4  24040001   ADDIU A0, ZERO, 1
9D00CEC8  00641804   SLLV V1, A0, V1
9D00CECC  00031827   NOR V1, ZERO, V1
9D00CED0  8C440000   LW A0, 0(V0)
9D00CED4  00641824   AND V1, V1, A0
9D00CED8  AC430000   SW V1, 0(V0)
9D00CEDC  03E00008   JR RA
9D00CEE0  00000000   NOP
52:                  }//clearPixel()
53:                  
54:                  //  REF: http://members.chello.at/~easyfilter/bresenham.html
55:                  void line(int x0, int y0, int x1, int y1)
56:                  {
9D00CEE4  27BDFFC8   ADDIU SP, SP, -56
9D00CEE8  AFBF0034   SW RA, 52(SP)
9D00CEEC  AFBE0030   SW S8, 48(SP)
9D00CEF0  AFB7002C   SW S7, 44(SP)
9D00CEF4  AFB60028   SW S6, 40(SP)
9D00CEF8  AFB50024   SW S5, 36(SP)
9D00CEFC  AFB40020   SW S4, 32(SP)
9D00CF00  AFB3001C   SW S3, 28(SP)
9D00CF04  AFB20018   SW S2, 24(SP)
9D00CF08  AFB10014   SW S1, 20(SP)
9D00CF0C  AFB00010   SW S0, 16(SP)
9D00CF10  00808021   ADDU S0, A0, ZERO
9D00CF14  00A09021   ADDU S2, A1, ZERO
9D00CF18  00C0A021   ADDU S4, A2, ZERO
9D00CF1C  AFA70044   SW A3, 68(SP)
57:                     int dx =  abs(x1-x0), sx = x0<x1 ? 1 : -1;
9D00CF20  00C49823   SUBU S3, A2, A0
9D00CF24  001317C3   SRA V0, S3, 31
9D00CF28  00539826   XOR S3, V0, S3
9D00CF2C  02629823   SUBU S3, S3, V0
9D00CF30  0086F02A   SLT S8, A0, A2
9D00CF34  24020001   ADDIU V0, ZERO, 1
9D00CF38  2403FFFF   ADDIU V1, ZERO, -1
9D00CF3C  007E100A   MOVZ V0, V1, S8
9D00CF40  0040F021   ADDU S8, V0, ZERO
58:                     int dy = -abs(y1-y0), sy = y0<y1 ? 1 : -1;
9D00CF44  00E5B023   SUBU S6, A3, A1
9D00CF48  001617C3   SRA V0, S6, 31
9D00CF4C  0056B026   XOR S6, V0, S6
9D00CF50  02C2B023   SUBU S6, S6, V0
9D00CF54  0016A823   SUBU S5, ZERO, S6
9D00CF58  00A7B82A   SLT S7, A1, A3
9D00CF5C  24020001   ADDIU V0, ZERO, 1
9D00CF60  0077100A   MOVZ V0, V1, S7
9D00CF64  0040B821   ADDU S7, V0, ZERO
59:                     int err = dx+dy, e2; /* error value e_xy */
9D00CF68  02768823   SUBU S1, S3, S6
60:                  
61:                     for(;;){  /* loop */
62:                        setPixel(x0,y0);
9D00CF6C  02002021   ADDU A0, S0, ZERO
9D00CF70  0F403380   JAL setPixel
9D00CF74  02402821   ADDU A1, S2, ZERO
63:                        if (x0==x1 && y0==y1) break;
9D00CF78  16140004   BNE S0, S4, 0x9D00CF8C
9D00CF7C  00111040   SLL V0, S1, 1
9D00CF80  8FA20044   LW V0, 68(SP)
9D00CF84  1242000B   BEQ S2, V0, 0x9D00CFB4
9D00CF88  00111040   SLL V0, S1, 1
64:                        e2 = 2*err;
65:                        if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
9D00CF8C  0055182A   SLT V1, V0, S5
9D00CF90  14600003   BNE V1, ZERO, 0x9D00CFA0
9D00CF94  0262102A   SLT V0, S3, V0
9D00CF98  02368823   SUBU S1, S1, S6
9D00CF9C  021E8021   ADDU S0, S0, S8
66:                        if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
9D00CFA0  1440FFF3   BNE V0, ZERO, 0x9D00CF70
9D00CFA4  02002021   ADDU A0, S0, ZERO
9D00CFA8  02338821   ADDU S1, S1, S3
9D00CFAC  0B4033DC   J 0x9D00CF70
9D00CFB0  02579021   ADDU S2, S2, S7
67:                     }
68:                  }//line()
9D00CFB4  8FBF0034   LW RA, 52(SP)
9D00CFB8  8FBE0030   LW S8, 48(SP)
9D00CFBC  8FB7002C   LW S7, 44(SP)
9D00CFC0  8FB60028   LW S6, 40(SP)
9D00CFC4  8FB50024   LW S5, 36(SP)
9D00CFC8  8FB40020   LW S4, 32(SP)
9D00CFCC  8FB3001C   LW S3, 28(SP)
9D00CFD0  8FB20018   LW S2, 24(SP)
9D00CFD4  8FB10014   LW S1, 20(SP)
9D00CFD8  8FB00010   LW S0, 16(SP)
9D00CFDC  03E00008   JR RA
9D00CFE0  27BD0038   ADDIU SP, SP, 56
69:                  
70:                  void rectangle(int x1, int y1, int x2, int y2){
9D00CFE4  27BDFFD8   ADDIU SP, SP, -40
9D00CFE8  AFBF0024   SW RA, 36(SP)
9D00CFEC  AFB30020   SW S3, 32(SP)
9D00CFF0  AFB2001C   SW S2, 28(SP)
9D00CFF4  AFB10018   SW S1, 24(SP)
9D00CFF8  AFB00014   SW S0, 20(SP)
9D00CFFC  00809021   ADDU S2, A0, ZERO
9D00D000  00A09821   ADDU S3, A1, ZERO
9D00D004  00C08021   ADDU S0, A2, ZERO
9D00D008  00E08821   ADDU S1, A3, ZERO
71:                      line(x1,y1,x1,y2);
9D00D00C  0F4033B9   JAL line
9D00D010  00803021   ADDU A2, A0, ZERO
72:                      line(x2,y1,x2,y2);
9D00D014  02002021   ADDU A0, S0, ZERO
9D00D018  02602821   ADDU A1, S3, ZERO
9D00D01C  02003021   ADDU A2, S0, ZERO
9D00D020  0F4033B9   JAL line
9D00D024  02203821   ADDU A3, S1, ZERO
73:                      line(x1,y1,x2,y1);
9D00D028  02402021   ADDU A0, S2, ZERO
9D00D02C  02602821   ADDU A1, S3, ZERO
9D00D030  02003021   ADDU A2, S0, ZERO
9D00D034  0F4033B9   JAL line
9D00D038  02603821   ADDU A3, S3, ZERO
74:                      line(x1,y2,x2,y2);
9D00D03C  02402021   ADDU A0, S2, ZERO
9D00D040  02202821   ADDU A1, S1, ZERO
9D00D044  02003021   ADDU A2, S0, ZERO
9D00D048  0F4033B9   JAL line
9D00D04C  02203821   ADDU A3, S1, ZERO
75:                  }//rectangle()
9D00D050  8FBF0024   LW RA, 36(SP)
9D00D054  8FB30020   LW S3, 32(SP)
9D00D058  8FB2001C   LW S2, 28(SP)
9D00D05C  8FB10018   LW S1, 24(SP)
9D00D060  8FB00014   LW S0, 20(SP)
9D00D064  03E00008   JR RA
9D00D068  27BD0028   ADDIU SP, SP, 40
76:                  
77:                  //  REF: http://members.chello.at/~easyfilter/bresenham.html
78:                  void circle(int xc, int yc, int r)
79:                  {
9D00D06C  27BDFFD8   ADDIU SP, SP, -40
9D00D070  AFBF0024   SW RA, 36(SP)
9D00D074  AFB40020   SW S4, 32(SP)
9D00D078  AFB3001C   SW S3, 28(SP)
9D00D07C  AFB20018   SW S2, 24(SP)
9D00D080  AFB10014   SW S1, 20(SP)
9D00D084  AFB00010   SW S0, 16(SP)
9D00D088  0080A021   ADDU S4, A0, ZERO
9D00D08C  00A09821   ADDU S3, A1, ZERO
80:                     int x = -r, y = 0, err = 2-2*r; /* II. Quadrant */
9D00D090  00068023   SUBU S0, ZERO, A2
9D00D094  00109040   SLL S2, S0, 1
9D00D098  26520002   ADDIU S2, S2, 2
9D00D09C  00008821   ADDU S1, ZERO, ZERO
81:                     do {
82:                        setPixel(xc-x, yc+y); /*   I. Quadrant */
9D00D0A0  02902023   SUBU A0, S4, S0
9D00D0A4  0F403380   JAL setPixel
9D00D0A8  02712821   ADDU A1, S3, S1
83:                        setPixel(xc-y, yc-x); /*  II. Quadrant */
9D00D0AC  02912023   SUBU A0, S4, S1
9D00D0B0  0F403380   JAL setPixel
9D00D0B4  02702823   SUBU A1, S3, S0
84:                        setPixel(xc+x, yc-y); /* III. Quadrant */
9D00D0B8  02902021   ADDU A0, S4, S0
9D00D0BC  0F403380   JAL setPixel
9D00D0C0  02712823   SUBU A1, S3, S1
85:                        setPixel(xc+y, yc+x); /*  IV. Quadrant */
9D00D0C4  02912021   ADDU A0, S4, S1
9D00D0C8  0F403380   JAL setPixel
9D00D0CC  02702821   ADDU A1, S3, S0
86:                        r = err;
87:                        if (r <= y) err += ++y*2+1;           /* e_xy+e_y < 0 */
9D00D0D0  0232102A   SLT V0, S1, S2
9D00D0D4  5440000E   BNEL V0, ZERO, 0x9D00D110
9D00D0D8  26100001   ADDIU S0, S0, 1
9D00D0DC  26310001   ADDIU S1, S1, 1
9D00D0E0  00111040   SLL V0, S1, 1
9D00D0E4  24420001   ADDIU V0, V0, 1
9D00D0E8  00521021   ADDU V0, V0, S2
88:                        if (r > x || err > y) err += ++x*2+1; /* e_xy+e_x > 0 or no 2nd y-step */
9D00D0EC  0212902A   SLT S2, S0, S2
9D00D0F0  16400006   BNE S2, ZERO, 0x9D00D10C
9D00D0F4  00409021   ADDU S2, V0, ZERO
9D00D0F8  0222182A   SLT V1, S1, V0
9D00D0FC  10600007   BEQ V1, ZERO, 0x9D00D11C
9D00D100  00000000   NOP
9D00D104  0B403444   J 0x9D00D110
9D00D108  26100001   ADDIU S0, S0, 1
9D00D10C  26100001   ADDIU S0, S0, 1
9D00D110  00101040   SLL V0, S0, 1
9D00D114  24420001   ADDIU V0, V0, 1
9D00D118  02429021   ADDU S2, S2, V0
89:                     } while (x < 0);
9D00D11C  0600FFE1   BLTZ S0, 0x9D00D0A4
9D00D120  02902023   SUBU A0, S4, S0
90:                  }//circle()
9D00D124  8FBF0024   LW RA, 36(SP)
9D00D128  8FB40020   LW S4, 32(SP)
9D00D12C  8FB3001C   LW S3, 28(SP)
9D00D130  8FB20018   LW S2, 24(SP)
9D00D134  8FB10014   LW S1, 20(SP)
9D00D138  8FB00010   LW S0, 16(SP)
9D00D13C  03E00008   JR RA
9D00D140  27BD0028   ADDIU SP, SP, 40
91:                  
92:                  /* REF: http://members.chello.at/~easyfilter/bresenham.html
93:                   * dessine une ellipse circoncrite par un rectangle
94:                   */
95:                  void ellipse (int x0, int y0, int x1, int y1){
9D00D144  27BDFFC0   ADDIU SP, SP, -64
9D00D148  AFBF003C   SW RA, 60(SP)
9D00D14C  AFBE0038   SW S8, 56(SP)
9D00D150  AFB70034   SW S7, 52(SP)
9D00D154  AFB60030   SW S6, 48(SP)
9D00D158  AFB5002C   SW S5, 44(SP)
9D00D15C  AFB40028   SW S4, 40(SP)
9D00D160  AFB30024   SW S3, 36(SP)
9D00D164  AFB20020   SW S2, 32(SP)
9D00D168  AFB1001C   SW S1, 28(SP)
9D00D16C  AFB00018   SW S0, 24(SP)
9D00D170  00809821   ADDU S3, A0, ZERO
96:                     int a = abs(x1-x0), b = abs(y1-y0), b1 = b&1; /* values of diameter */
9D00D174  00C41023   SUBU V0, A2, A0
9D00D178  00021FC3   SRA V1, V0, 31
9D00D17C  00621026   XOR V0, V1, V0
9D00D180  00431023   SUBU V0, V0, V1
9D00D184  00E5B823   SUBU S7, A3, A1
9D00D188  00171FC3   SRA V1, S7, 31
9D00D18C  0077B826   XOR S7, V1, S7
9D00D190  02E3B823   SUBU S7, S7, V1
9D00D194  32F10001   ANDI S1, S7, 1
97:                     long dx = 4*(1-a)*b*b, dy = 4*(b1+1)*a*a; /* error increment */
9D00D198  24150001   ADDIU S5, ZERO, 1
9D00D19C  02A2A823   SUBU S5, S5, V0
9D00D1A0  0015A880   SLL S5, S5, 2
9D00D1A4  72B7A802   MUL S5, S5, S7
9D00D1A8  72B7A802   MUL S5, S5, S7
9D00D1AC  26360001   ADDIU S6, S1, 1
9D00D1B0  0016B080   SLL S6, S6, 2
9D00D1B4  72C2B002   MUL S6, S6, V0
9D00D1B8  72C2B002   MUL S6, S6, V0
98:                     long err = dx+dy+b1*a*a, e2; /* error of 1.step */
9D00D1BC  02B61821   ADDU V1, S5, S6
9D00D1C0  7222A002   MUL S4, S1, V0
9D00D1C4  72822002   MUL A0, S4, V0
9D00D1C8  0083A021   ADDU S4, A0, V1
99:                  
100:                    if (x0 > x1) { x0 = x1; x1 += a; } /* if called with swapped points */
9D00D1CC  00D3182A   SLT V1, A2, S3
9D00D1D0  10600003   BEQ V1, ZERO, 0x9D00D1E0
9D00D1D4  00C09021   ADDU S2, A2, ZERO
9D00D1D8  00C09821   ADDU S3, A2, ZERO
9D00D1DC  00C29021   ADDU S2, A2, V0
9D00D1E0  00A7802A   SLT S0, A1, A3
9D00D1E4  00F0280A   MOVZ A1, A3, S0
101:                    if (y0 > y1) y0 = y1; /* .. exchange them */
102:                    y0 += (b+1)/2; y1 = y0-b1;   /* starting pixel */
9D00D1E8  26E30001   ADDIU V1, S7, 1
9D00D1EC  000387C2   SRL S0, V1, 31
9D00D1F0  02038021   ADDU S0, S0, V1
9D00D1F4  00108043   SRA S0, S0, 1
9D00D1F8  02058021   ADDU S0, S0, A1
9D00D1FC  02118823   SUBU S1, S0, S1
103:                    a *= 8*a; b1 = 8*b*b;
9D00D200  70421002   MUL V0, V0, V0
9D00D204  000210C0   SLL V0, V0, 3
9D00D208  AFA20010   SW V0, 16(SP)
9D00D20C  72F7F002   MUL S8, S7, S7
9D00D210  001EF0C0   SLL S8, S8, 3
104:                 
105:                    do {
106:                        setPixel(x1, y0); /*   I. Quadrant */
9D00D214  02402021   ADDU A0, S2, ZERO
9D00D218  0F403380   JAL setPixel
9D00D21C  02002821   ADDU A1, S0, ZERO
107:                        setPixel(x0, y0); /*  II. Quadrant */
9D00D220  02602021   ADDU A0, S3, ZERO
9D00D224  0F403380   JAL setPixel
9D00D228  02002821   ADDU A1, S0, ZERO
108:                        setPixel(x0, y1); /* III. Quadrant */
9D00D22C  02602021   ADDU A0, S3, ZERO
9D00D230  0F403380   JAL setPixel
9D00D234  02202821   ADDU A1, S1, ZERO
109:                        setPixel(x1, y1); /*  IV. Quadrant */
9D00D238  02402021   ADDU A0, S2, ZERO
9D00D23C  0F403380   JAL setPixel
9D00D240  02202821   ADDU A1, S1, ZERO
110:                        e2 = 2*err;
9D00D244  00141040   SLL V0, S4, 1
111:                        if (e2 <= dy) { y0++; y1--; err += dy += a; }  /* y step */
9D00D248  02C2182A   SLT V1, S6, V0
9D00D24C  14600006   BNE V1, ZERO, 0x9D00D268
9D00D250  0055102A   SLT V0, V0, S5
9D00D254  26100001   ADDIU S0, S0, 1
9D00D258  2631FFFF   ADDIU S1, S1, -1
9D00D25C  8FA30010   LW V1, 16(SP)
9D00D260  02C3B021   ADDU S6, S6, V1
9D00D264  0296A021   ADDU S4, S4, S6
112:                        if (e2 >= dx || 2*err > dy) { x0++; x1--; err += dx += b1; } /* x step */
9D00D268  50400006   BEQL V0, ZERO, 0x9D00D284
9D00D26C  26730001   ADDIU S3, S3, 1
9D00D270  00141040   SLL V0, S4, 1
9D00D274  02C2102A   SLT V0, S6, V0
9D00D278  10400006   BEQ V0, ZERO, 0x9D00D294
9D00D27C  0253102A   SLT V0, S2, S3
9D00D280  26730001   ADDIU S3, S3, 1
9D00D284  2652FFFF   ADDIU S2, S2, -1
9D00D288  02BEA821   ADDU S5, S5, S8
9D00D28C  0295A021   ADDU S4, S4, S5
113:                    } while (x0 <= x1);
9D00D290  0253102A   SLT V0, S2, S3
9D00D294  1040FFE0   BEQ V0, ZERO, 0x9D00D218
9D00D298  02402021   ADDU A0, S2, ZERO
114:                 
115:                    while (y0-y1 < b) {  /* too early stop of flat ellipses a=1 */
9D00D29C  0211A023   SUBU S4, S0, S1
9D00D2A0  0297102A   SLT V0, S4, S7
9D00D2A4  10400016   BEQ V0, ZERO, 0x9D00D300
9D00D2A8  2673FFFF   ADDIU S3, S3, -1
9D00D2EC  0297102A   SLT V0, S4, S7
9D00D2F0  10400003   BEQ V0, ZERO, 0x9D00D300
9D00D2F4  02008821   ADDU S1, S0, ZERO
116:                        setPixel(x0-1, y0); /* -> finish tip of ellipse */
9D00D2B0  02602021   ADDU A0, S3, ZERO
9D00D2B4  0F403380   JAL setPixel
9D00D2B8  02002821   ADDU A1, S0, ZERO
117:                        setPixel(x1+1, y0++);
9D00D2AC  26520001   ADDIU S2, S2, 1
9D00D2BC  26150001   ADDIU S5, S0, 1
9D00D2C0  02402021   ADDU A0, S2, ZERO
9D00D2C4  0F403380   JAL setPixel
9D00D2C8  02002821   ADDU A1, S0, ZERO
9D00D2F8  0B4034AC   J 0x9D00D2B0
9D00D2FC  02A08021   ADDU S0, S5, ZERO
118:                        setPixel(x0-1, y1);
9D00D2CC  02602021   ADDU A0, S3, ZERO
9D00D2D0  0F403380   JAL setPixel
9D00D2D4  02202821   ADDU A1, S1, ZERO
119:                        setPixel(x1+1, y1--);
9D00D2D8  2630FFFF   ADDIU S0, S1, -1
9D00D2DC  02402021   ADDU A0, S2, ZERO
9D00D2E0  0F403380   JAL setPixel
9D00D2E4  02202821   ADDU A1, S1, ZERO
9D00D2E8  26940002   ADDIU S4, S4, 2
120:                    }
121:                 }//ellipse()
9D00D300  8FBF003C   LW RA, 60(SP)
9D00D304  8FBE0038   LW S8, 56(SP)
9D00D308  8FB70034   LW S7, 52(SP)
9D00D30C  8FB60030   LW S6, 48(SP)
9D00D310  8FB5002C   LW S5, 44(SP)
9D00D314  8FB40028   LW S4, 40(SP)
9D00D318  8FB30024   LW S3, 36(SP)
9D00D31C  8FB20020   LW S2, 32(SP)
9D00D320  8FB1001C   LW S1, 28(SP)
9D00D324  8FB00018   LW S0, 24(SP)
9D00D328  03E00008   JR RA
9D00D32C  27BD0040   ADDIU SP, SP, 64
122:                 
123:                 /*
124:                  * points[]={x1,y1,x2,y2,x3,y3,...}
125:                  * vertices est le nombre de points
126:                  */
127:                 void polygon(const int points[], int vertices){
9D00D330  27BDFFD8   ADDIU SP, SP, -40
9D00D334  AFBF0024   SW RA, 36(SP)
9D00D338  AFB30020   SW S3, 32(SP)
9D00D33C  AFB2001C   SW S2, 28(SP)
9D00D340  AFB10018   SW S1, 24(SP)
9D00D344  AFB00014   SW S0, 20(SP)
128:                     int i;
129:                     for(i=0;i<(2*vertices-2);i+=2){
9D00D348  24A5FFFF   ADDIU A1, A1, -1
9D00D34C  00059040   SLL S2, A1, 1
9D00D350  1A40000E   BLEZ S2, 0x9D00D38C
9D00D354  00809821   ADDU S3, A0, ZERO
9D00D358  00808021   ADDU S0, A0, ZERO
9D00D35C  00008821   ADDU S1, ZERO, ZERO
9D00D374  26310002   ADDIU S1, S1, 2
9D00D378  0232102A   SLT V0, S1, S2
9D00D37C  1440FFF8   BNE V0, ZERO, 0x9D00D360
9D00D380  26100008   ADDIU S0, S0, 8
9D00D384  0B4034E5   J 0x9D00D394
9D00D388  00118880   SLL S1, S1, 2
9D00D38C  00008821   ADDU S1, ZERO, ZERO
130:                         line(points[i],points[i+1],points[i+2],points[i+3]);
9D00D360  8E040000   LW A0, 0(S0)
9D00D364  8E050004   LW A1, 4(S0)
9D00D368  8E060008   LW A2, 8(S0)
9D00D36C  0F4033B9   JAL line
9D00D370  8E07000C   LW A3, 12(S0)
131:                     }
132:                     line(points[0],points[1],points[i],points[i+1]);
9D00D390  00118880   SLL S1, S1, 2
9D00D394  02718821   ADDU S1, S3, S1
9D00D398  8E640000   LW A0, 0(S3)
9D00D39C  8E650004   LW A1, 4(S3)
9D00D3A0  8E260000   LW A2, 0(S1)
9D00D3A4  0F4033B9   JAL line
9D00D3A8  8E270004   LW A3, 4(S1)
133:                 }//polygon()
9D00D3AC  8FBF0024   LW RA, 36(SP)
9D00D3B0  8FB30020   LW S3, 32(SP)
9D00D3B4  8FB2001C   LW S2, 28(SP)
9D00D3B8  8FB10018   LW S1, 24(SP)
9D00D3BC  8FB00014   LW S0, 20(SP)
9D00D3C0  03E00008   JR RA
9D00D3C4  27BD0028   ADDIU SP, SP, 40
134:                 
135:                 //  REF: http://members.chello.at/~easyfilter/bresenham.html
136:                 void bezier(int x0, int y0, int x1, int y1, int x2, int y2){
9D00D3C8  27BDFFB0   ADDIU SP, SP, -80
9D00D3CC  AFBF004C   SW RA, 76(SP)
9D00D3D0  AFBE0048   SW S8, 72(SP)
9D00D3D4  AFB70044   SW S7, 68(SP)
9D00D3D8  AFB60040   SW S6, 64(SP)
9D00D3DC  AFB5003C   SW S5, 60(SP)
9D00D3E0  AFB40038   SW S4, 56(SP)
9D00D3E4  AFB30034   SW S3, 52(SP)
9D00D3E8  AFB20030   SW S2, 48(SP)
9D00D3EC  AFB1002C   SW S1, 44(SP)
9D00D3F0  AFB00028   SW S0, 40(SP)
9D00D3F4  00809821   ADDU S3, A0, ZERO
9D00D3F8  00A0B021   ADDU S6, A1, ZERO
9D00D3FC  AFA60058   SW A2, 88(SP)
9D00D400  AFA7005C   SW A3, 92(SP)
9D00D404  8FB70060   LW S7, 96(SP)
137:                   int sx = x2-x1, sy = y2-y1;
9D00D408  02E6A023   SUBU S4, S7, A2
9D00D40C  8FA20064   LW V0, 100(SP)
9D00D410  00478823   SUBU S1, V0, A3
138:                   long xx = x0-x1, yy = y0-y1, xy;         /* relative values for checks */
9D00D414  0086A823   SUBU S5, A0, A2
9D00D418  00A79023   SUBU S2, A1, A3
139:                   double dx, dy, err, cur = xx*sy-yy*sx;                    /* curvature */
9D00D41C  72B12002   MUL A0, S5, S1
9D00D420  72541002   MUL V0, S2, S4
9D00D424  0F40636F   JAL sitofp
9D00D428  00822023   SUBU A0, A0, V0
9D00D42C  00408021   ADDU S0, V0, ZERO
140:                 
141:                   //if(xx*sx <= 0 && yy*sy <= 0) return;  /* sign of gradient must not change */
142:                 
143:                   if (sx*(long)sx+sy*(long)sy > xx*xx+yy*yy) { /* begin with longer part */
9D00D430  02310018   MULT 0, S1, S1
9D00D434  72940000   MADD 0, S4, S4
9D00D438  00001812   MFLO V1
9D00D43C  02520018   MULT 0, S2, S2
9D00D440  72B50000   MADD 0, S5, S5
9D00D444  00001012   MFLO V0
9D00D448  0043102A   SLT V0, V0, V1
9D00D44C  1040000A   BEQ V0, ZERO, 0x9D00D478
9D00D450  02002021   ADDU A0, S0, ZERO
144:                     x2 = x0; x0 = sx+x1; y2 = y0; y0 = sy+y1; cur = -cur;  /* swap P0 P2 */
9D00D454  3C028000   LUI V0, -32768
9D00D458  00508026   XOR S0, V0, S0
9D00D45C  02C01021   ADDU V0, S6, ZERO
9D00D460  8FB60064   LW S6, 100(SP)
9D00D464  AFA20064   SW V0, 100(SP)
9D00D468  02601021   ADDU V0, S3, ZERO
9D00D46C  02E09821   ADDU S3, S7, ZERO
9D00D470  0040B821   ADDU S7, V0, ZERO
145:                   }
146:                   if (cur != 0) {                                    /* no straight line */
9D00D474  02002021   ADDU A0, S0, ZERO
9D00D478  0F406123   JAL __lesf2
9D00D47C  00002821   ADDU A1, ZERO, ZERO
9D00D480  1040009F   BEQ V0, ZERO, 0x9D00D700
9D00D484  02B4A821   ADDU S5, S5, S4
147:                     xx += sx; xx *= sx = x0 < x2 ? 1 : -1;           /* x step direction */
9D00D488  0277202A   SLT A0, S3, S7
9D00D48C  24020001   ADDIU V0, ZERO, 1
9D00D490  2403FFFF   ADDIU V1, ZERO, -1
9D00D494  0064100A   MOVZ V0, V1, A0
9D00D498  AFA20018   SW V0, 24(SP)
9D00D49C  7055A802   MUL S5, V0, S5
148:                     yy += sy; yy *= sy = y0 < y2 ? 1 : -1;           /* y step direction */
9D00D4A0  02518821   ADDU S1, S2, S1
9D00D4A4  8FA20064   LW V0, 100(SP)
9D00D4A8  02C2202A   SLT A0, S6, V0
9D00D4AC  24020001   ADDIU V0, ZERO, 1
9D00D4B0  0064100A   MOVZ V0, V1, A0
9D00D4B4  AFA2001C   SW V0, 28(SP)
9D00D4B8  70518802   MUL S1, V0, S1
149:                     xy = 2*xx*yy; xx *= xx; yy *= yy;          /* differences 2nd degree */
9D00D4BC  0015F040   SLL S8, S5, 1
9D00D4C0  73D1F002   MUL S8, S8, S1
9D00D4C4  72B5A802   MUL S5, S5, S5
9D00D4C8  72318802   MUL S1, S1, S1
150:                     if (cur*sx*sy < 0) {                           /* negated curvature? */
9D00D4CC  0F40636F   JAL sitofp
9D00D4D0  8FA40018   LW A0, 24(SP)
9D00D4D4  AFA20020   SW V0, 32(SP)
9D00D4D8  0F40636F   JAL sitofp
9D00D4DC  8FA4001C   LW A0, 28(SP)
9D00D4E0  00409021   ADDU S2, V0, ZERO
9D00D4E4  8FA40020   LW A0, 32(SP)
9D00D4E8  0F4052FA   JAL __mulsf3
9D00D4EC  02002821   ADDU A1, S0, ZERO
9D00D4F0  00402021   ADDU A0, V0, ZERO
9D00D4F4  0F4052FA   JAL __mulsf3
9D00D4F8  02402821   ADDU A1, S2, ZERO
9D00D4FC  00402021   ADDU A0, V0, ZERO
9D00D500  0F406123   JAL __lesf2
9D00D504  00002821   ADDU A1, ZERO, ZERO
9D00D508  04410005   BGEZ V0, 0x9D00D520
9D00D50C  3C028000   LUI V0, -32768
151:                       xx = -xx; yy = -yy; xy = -xy; cur = -cur;
9D00D510  0015A823   SUBU S5, ZERO, S5
9D00D514  00118823   SUBU S1, ZERO, S1
9D00D518  001EF023   SUBU S8, ZERO, S8
9D00D51C  00508026   XOR S0, V0, S0
152:                     }
153:                     dx = 4.0*sy*cur*(x1-x0)+xx-xy;             /* differences 1st degree */
9D00D520  0F40636F   JAL sitofp
9D00D524  03C02021   ADDU A0, S8, ZERO
9D00D528  0040F021   ADDU S8, V0, ZERO
9D00D52C  02402021   ADDU A0, S2, ZERO
9D00D530  3C029D02   LUI V0, -25342
9D00D534  0F4052FA   JAL __mulsf3
9D00D538  8C459934   LW A1, -26316(V0)
9D00D53C  00402021   ADDU A0, V0, ZERO
9D00D540  0F4052FA   JAL __mulsf3
9D00D544  02002821   ADDU A1, S0, ZERO
9D00D548  00409021   ADDU S2, V0, ZERO
9D00D54C  8FA30058   LW V1, 88(SP)
9D00D550  0F40636F   JAL sitofp
9D00D554  00732023   SUBU A0, V1, S3
9D00D558  02402021   ADDU A0, S2, ZERO
9D00D55C  0F4052FA   JAL __mulsf3
9D00D560  00402821   ADDU A1, V0, ZERO
9D00D564  00409021   ADDU S2, V0, ZERO
9D00D568  0F40636F   JAL sitofp
9D00D56C  02A02021   ADDU A0, S5, ZERO
9D00D570  02402021   ADDU A0, S2, ZERO
9D00D574  0F404E54   JAL fpadd
9D00D578  00402821   ADDU A1, V0, ZERO
9D00D57C  00402021   ADDU A0, V0, ZERO
9D00D580  0F404E52   JAL __subsf3
9D00D584  03C02821   ADDU A1, S8, ZERO
9D00D588  0040A021   ADDU S4, V0, ZERO
154:                     dy = 4.0*sx*cur*(y0-y1)+yy-xy;
9D00D58C  8FA40020   LW A0, 32(SP)
9D00D590  3C029D02   LUI V0, -25342
9D00D594  0F4052FA   JAL __mulsf3
9D00D598  8C459934   LW A1, -26316(V0)
9D00D59C  00402021   ADDU A0, V0, ZERO
9D00D5A0  0F4052FA   JAL __mulsf3
9D00D5A4  02002821   ADDU A1, S0, ZERO
9D00D5A8  00408021   ADDU S0, V0, ZERO
9D00D5AC  8FA3005C   LW V1, 92(SP)
9D00D5B0  0F40636F   JAL sitofp
9D00D5B4  02C32023   SUBU A0, S6, V1
9D00D5B8  02002021   ADDU A0, S0, ZERO
9D00D5BC  0F4052FA   JAL __mulsf3
9D00D5C0  00402821   ADDU A1, V0, ZERO
9D00D5C4  00408021   ADDU S0, V0, ZERO
9D00D5C8  0F40636F   JAL sitofp
9D00D5CC  02202021   ADDU A0, S1, ZERO
9D00D5D0  02002021   ADDU A0, S0, ZERO
9D00D5D4  0F404E54   JAL fpadd
9D00D5D8  00402821   ADDU A1, V0, ZERO
9D00D5DC  00402021   ADDU A0, V0, ZERO
9D00D5E0  0F404E52   JAL __subsf3
9D00D5E4  03C02821   ADDU A1, S8, ZERO
9D00D5E8  00408021   ADDU S0, V0, ZERO
155:                     xx += xx; yy += yy; err = dx+dy+xy;                /* error 1st step */
9D00D5EC  0015A840   SLL S5, S5, 1
9D00D5F0  AFB50010   SW S5, 16(SP)
9D00D5F4  00118840   SLL S1, S1, 1
9D00D5F8  AFB10014   SW S1, 20(SP)
9D00D5FC  02802021   ADDU A0, S4, ZERO
9D00D600  0F404E54   JAL fpadd
9D00D604  00402821   ADDU A1, V0, ZERO
9D00D608  03C02021   ADDU A0, S8, ZERO
9D00D60C  0F404E54   JAL fpadd
9D00D610  00402821   ADDU A1, V0, ZERO
9D00D614  00409021   ADDU S2, V0, ZERO
156:                     do {
157:                       setPixel(x0,y0);                                     /* setPixel curve */
9D00D618  02602021   ADDU A0, S3, ZERO
9D00D61C  0F403380   JAL setPixel
9D00D620  02C02821   ADDU A1, S6, ZERO
158:                       if (x0 == x2 && y0 == y2) return;  /* last pixel -> curve finished */
9D00D624  16770004   BNE S3, S7, 0x9D00D638
9D00D628  02402021   ADDU A0, S2, ZERO
9D00D62C  8FA40064   LW A0, 100(SP)
9D00D630  12C40038   BEQ S6, A0, 0x9D00D714
9D00D634  02402021   ADDU A0, S2, ZERO
159:                       y1 = 2*err < dx;                  /* save value for test of y step */
9D00D638  0F404E54   JAL fpadd
9D00D63C  02402821   ADDU A1, S2, ZERO
9D00D640  0040A821   ADDU S5, V0, ZERO
160:                       if (2*err > dy) { x0 += sx; dx -= xy; err += dy += yy; } /* x step */
9D00D644  02002021   ADDU A0, S0, ZERO
9D00D648  0F406123   JAL __lesf2
9D00D64C  00402821   ADDU A1, V0, ZERO
9D00D650  04410012   BGEZ V0, 0x9D00D69C
9D00D654  02808821   ADDU S1, S4, ZERO
9D00D658  8FA20018   LW V0, 24(SP)
9D00D65C  02629821   ADDU S3, S3, V0
9D00D660  02802021   ADDU A0, S4, ZERO
9D00D664  0F404E52   JAL __subsf3
9D00D668  03C02821   ADDU A1, S8, ZERO
9D00D66C  00408821   ADDU S1, V0, ZERO
9D00D670  0F40636F   JAL sitofp
9D00D674  8FA40014   LW A0, 20(SP)
9D00D678  02002021   ADDU A0, S0, ZERO
9D00D67C  0F404E54   JAL fpadd
9D00D680  00402821   ADDU A1, V0, ZERO
9D00D684  00408021   ADDU S0, V0, ZERO
9D00D688  02402021   ADDU A0, S2, ZERO
9D00D68C  0F404E54   JAL fpadd
9D00D690  00402821   ADDU A1, V0, ZERO
9D00D694  0B4035A7   J 0x9D00D69C
9D00D698  00409021   ADDU S2, V0, ZERO
161:                       if (    y1    ) { y0 += sy; dy -= xy; err += dx += xx; } /* y step */
9D00D69C  02A02021   ADDU A0, S5, ZERO
9D00D6A0  0F406123   JAL __lesf2
9D00D6A4  02802821   ADDU A1, S4, ZERO
9D00D6A8  04410011   BGEZ V0, 0x9D00D6F0
9D00D6AC  02002021   ADDU A0, S0, ZERO
9D00D6B0  8FA3001C   LW V1, 28(SP)
9D00D6B4  02C3B021   ADDU S6, S6, V1
9D00D6B8  0F404E52   JAL __subsf3
9D00D6BC  03C02821   ADDU A1, S8, ZERO
9D00D6C0  00408021   ADDU S0, V0, ZERO
9D00D6C4  0F40636F   JAL sitofp
9D00D6C8  8FA40010   LW A0, 16(SP)
9D00D6CC  02202021   ADDU A0, S1, ZERO
9D00D6D0  0F404E54   JAL fpadd
9D00D6D4  00402821   ADDU A1, V0, ZERO
9D00D6D8  00408821   ADDU S1, V0, ZERO
9D00D6DC  02402021   ADDU A0, S2, ZERO
9D00D6E0  0F404E54   JAL fpadd
9D00D6E4  00402821   ADDU A1, V0, ZERO
9D00D6E8  00409021   ADDU S2, V0, ZERO
162:                     } while (dy < dx );           /* gradient negates -> algorithm fails */
9D00D6EC  02002021   ADDU A0, S0, ZERO
9D00D6F0  0F406123   JAL __lesf2
9D00D6F4  02202821   ADDU A1, S1, ZERO
9D00D6F8  0440FFC7   BLTZ V0, 0x9D00D618
9D00D6FC  0220A021   ADDU S4, S1, ZERO
163:                   }
164:                   line(x0,y0, x2,y2);                  /* setPixel remaining part to end */
9D00D700  02602021   ADDU A0, S3, ZERO
9D00D704  02C02821   ADDU A1, S6, ZERO
9D00D708  02E03021   ADDU A2, S7, ZERO
9D00D70C  0F4033B9   JAL line
9D00D710  8FA70064   LW A3, 100(SP)
165:                 }//besiez()
9D00D714  8FBF004C   LW RA, 76(SP)
9D00D718  8FBE0048   LW S8, 72(SP)
9D00D71C  8FB70044   LW S7, 68(SP)
9D00D720  8FB60040   LW S6, 64(SP)
9D00D724  8FB5003C   LW S5, 60(SP)
9D00D728  8FB40038   LW S4, 56(SP)
9D00D72C  8FB30034   LW S3, 52(SP)
9D00D730  8FB20030   LW S2, 48(SP)
9D00D734  8FB1002C   LW S1, 44(SP)
9D00D738  8FB00028   LW S0, 40(SP)
9D00D73C  03E00008   JR RA
9D00D740  27BD0050   ADDIU SP, SP, 80
166:                 
167:                 
168:                 void fill(int x, int y){
9D00D744  03E00008   JR RA
169:                 }//fill()
---  /home/jacques/github/vpc-32vga/editor.c  -----------------------------------------------------------
1:                   /*
2:                   * Copyright 2013,2016 Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  *
18:                   *  *  * ***  LICENCE ****
19:                   * This program is free software; you can redistribute it and/or modify
20:                   * it under the terms of the GNU General Public License as published by
21:                   * the Free Software Foundation; either version 3 of the License, or
22:                   * (at your option) any later version.
23:                   * 
24:                   * This program is distributed in the hope that it will be useful,
25:                   * but WITHOUT ANY WARRANTY; without even the implied warranty of
26:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
27:                   * GNU General Public License for more details.
28:                   * 
29:                   * You should have received a copy of the GNU General Public License
30:                   * along with this program; See 'copying.txt' in root directory of source.
31:                   * If not, write to the Free Software Foundation,
32:                   * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
33:                   *  
34:                   * to contact the author:  jd_temp@yahoo.fr
35:                   * 
36:                   */
37:                  
38:                  #include <stdlib.h>
39:                  #include <string.h>
40:                  #include <stdint.h>
41:                  #include <stdbool.h>
42:                  #include <ctype.h>
43:                  #include <stdio.h>
44:                  
45:                  //#include "Hardware/hardware.h"
46:                  #include "console.h"
47:                  #include "hardware/tvout/vga.h"
48:                  #include "hardware/spiram/spiram.h"
49:                  #include "hardware/ps2_kbd/keyboard.h"
50:                  #include "hardware/Pinguino/fileio.h"
51:                  #include "hardware/sound/sound.h"
52:                  #include "graphics.h"
53:                  #include "font.h"
54:                  #include "reader.h"
55:                  #include "vpcBASIC/vm.h"
56:                  
57:                  #define LAST_COL (CHAR_PER_LINE-1)
58:                  #define LINE_MAX_LEN (CHAR_PER_LINE-1)
59:                  #define LAST_LINE (LINE_PER_SCREEN-1)
60:                  #define SCREEN_SIZE (LINE_PER_SCREEN*CHAR_PER_LINE)
61:                  #define ED_BUFF_SIZE (SRAM_SIZE-2)
62:                  #define MAX_SIZE (ED_BUFF_SIZE)
63:                  
64:                  #define refused()  tone(500,100);
65:                  
66:                  #define MODE_INSERT 1
67:                  #define MODE_OVERWR 0
68:                  #define NAME_MAX_LEN 32
69:                  
70:                  //contient 1'écran texte
71:                  uint8_t screen[LINE_PER_SCREEN][CHAR_PER_LINE];
72:                  
73:                  typedef struct editor_state{
74:                      uint32_t fsize; // grandeur du fichier en octets.
75:                      uint32_t scr_first; //premier caractère visible
76:                      uint32_t gap_first; //position début gap
77:                      uint32_t tail; // position fin gap
78:                      int8_t scr_line; // ligne du curseur
79:                      int8_t scr_col; //colonne du curseur
80:                      struct {
81:                        uint8_t insert:1;
82:                        uint8_t modified:1;
83:                        uint8_t new:1;
84:                      }flags;
85:                  } ed_state_t;
86:                  
87:                  
88:                  //static char *split_buffer; // ligne en edition
89:                  static ed_state_t state;
90:                  
91:                  static char fname[32];
92:                  
93:                  typedef struct search_struct{
94:                     bool ignore_case;
95:                     bool loop;
96:                     bool found;
97:                     uint8_t col;
98:                     char target[CHAR_PER_LINE];
99:                  } search_t;
100:                 
101:                 static search_t search_info;
102:                 
103:                 static void open_file();
104:                 static void load_file(const char *name);
105:                 static void save_file();
106:                 static void save_file_as();
107:                 static void line_up();
108:                 static void line_down();
109:                 static void char_left();
110:                 static void char_right();
111:                 static void delete_left();
112:                 static void delete_at();
113:                 static void delete_to_end();
114:                 static void delete_to_start();
115:                 static void insert_char(char c);
116:                 static void replace_char(char c);
117:                 static void line_home();
118:                 static void line_end();
119:                 static void enter();
120:                 static void file_home();
121:                 static void file_end();
122:                 static void update_display();
123:                 static void page_up();
124:                 static void page_down();
125:                 static void word_right();
126:                 static void word_left();
127:                 static void goto_line();
128:                 static uint8_t get_line_forward(uint8_t* line, uint32_t from);
129:                 static uint8_t get_line_back(uint8_t* line, uint32_t from);
130:                 static void jump_to_line(uint16_t line_no);
131:                 
132:                 
133:                 static void print_line(uint8_t line){
9D003C00  27BDFFE8   ADDIU SP, SP, -24
9D003C04  AFBF0014   SW RA, 20(SP)
9D003C08  AFB00010   SW S0, 16(SP)
9D003C0C  00808021   ADDU S0, A0, ZERO
134:                     set_curpos(0,line);
9D003C10  00002021   ADDU A0, ZERO, ZERO
9D003C14  0F402CCF   JAL set_curpos
9D003C18  02002821   ADDU A1, S0, ZERO
135:                     clear_eol();
9D003C1C  0F402C98   JAL clear_eol
9D003C20  00000000   NOP
136:                     print(comm_channel,(char*)&screen[line]);
9D003C24  00101100   SLL V0, S0, 4
9D003C28  00108180   SLL S0, S0, 6
9D003C2C  00508021   ADDU S0, V0, S0
9D003C30  9784803C   LHU A0, -32708(GP)
9D003C34  3C05A000   LUI A1, -24576
9D003C38  24A538C8   ADDIU A1, A1, 14536
9D003C3C  0F402C18   JAL print
9D003C40  00B02821   ADDU A1, A1, S0
137:                 }
9D003C44  8FBF0014   LW RA, 20(SP)
9D003C48  8FB00010   LW S0, 16(SP)
9D003C4C  03E00008   JR RA
9D003C50  27BD0018   ADDIU SP, SP, 24
138:                 
139:                 static void prompt_continue(){
9D00381C  27BDFFE8   ADDIU SP, SP, -24
9D003820  AFBF0014   SW RA, 20(SP)
140:                     print(comm_channel,"\nany key...");//static uint8_t *llen;
9D003824  9784803C   LHU A0, -32708(GP)
9D003828  3C059D01   LUI A1, -25343
9D00382C  0F402C18   JAL print
9D003830  24A52BC8   ADDIU A1, A1, 11208
141:                     wait_key(comm_channel);
9D003834  0F402D86   JAL wait_key
9D003838  9784803C   LHU A0, -32708(GP)
142:                 }
9D00383C  8FBF0014   LW RA, 20(SP)
9D003840  03E00008   JR RA
9D003844  27BD0018   ADDIU SP, SP, 24
143:                 
144:                 static void ed_error(const char *msg, int code){//static uint8_t *llen;
9D003848  27BDFFE8   ADDIU SP, SP, -24
9D00384C  AFBF0014   SW RA, 20(SP)
9D003850  AFB00010   SW S0, 16(SP)
9D003854  00801021   ADDU V0, A0, ZERO
9D003858  00A08021   ADDU S0, A1, ZERO
145:                     println(comm_channel,msg);
9D00385C  9784803C   LHU A0, -32708(GP)
9D003860  0F402C2E   JAL println
9D003864  00402821   ADDU A1, V0, ZERO
146:                     print(comm_channel,"error code: ");
9D003868  9784803C   LHU A0, -32708(GP)
9D00386C  3C059D01   LUI A1, -25343
9D003870  0F402C18   JAL print
9D003874  24A52BD4   ADDIU A1, A1, 11220
147:                     print_int(comm_channel,code,0);
9D003878  9784803C   LHU A0, -32708(GP)
9D00387C  02002821   ADDU A1, S0, ZERO
9D003880  0F402C58   JAL print_int
9D003884  00003021   ADDU A2, ZERO, ZERO
148:                     if (comm_channel==LOCAL_CON){
9D003888  9782803C   LHU V0, -32708(GP)
9D00388C  14400006   BNE V0, ZERO, 0x9D0038A8
9D003890  8FBF0014   LW RA, 20(SP)
149:                         prompt_continue();
9D003894  0F400E07   JAL prompt_continue
9D003898  00000000   NOP
150:                         clear_screen();
9D00389C  0F402B6F   JAL clear_screen
9D0038A0  00000000   NOP
151:                     }
152:                 }
9D0038A4  8FBF0014   LW RA, 20(SP)
9D0038A8  8FB00010   LW S0, 16(SP)
9D0038AC  03E00008   JR RA
9D0038B0  27BD0018   ADDIU SP, SP, 24
153:                 
154:                 //si fichier modifié confirme 
155:                 //avant de continuer
156:                 static bool ask_confirm(){
9D003E94  27BDFFE8   ADDIU SP, SP, -24
9D003E98  AFBF0014   SW RA, 20(SP)
9D003E9C  AFB00010   SW S0, 16(SP)
157:                     char key;
158:                     bool answer=state.flags.modified;
9D003EA0  3C02A000   LUI V0, -24576
9D003EA4  8C4249D4   LW V0, 18900(V0)
159:                     if (answer){
9D003EA8  7C420440   EXT V0, V0, 17, 1
9D003EAC  10400024   BEQ V0, ZERO, 0x9D003F40
9D003EB0  24100001   ADDIU S0, ZERO, 1
160:                         tone(1000,100);
9D003EB4  240403E8   ADDIU A0, ZERO, 1000
9D003EB8  0F404971   JAL tone
9D003EBC  24050064   ADDIU A1, ZERO, 100
161:                         invert_video(true);
9D003EC0  0F402DE2   JAL invert_video
9D003EC4  24040001   ADDIU A0, ZERO, 1
162:                         set_curpos(0,0);
9D003EC8  00002021   ADDU A0, ZERO, ZERO
9D003ECC  0F402CCF   JAL set_curpos
9D003ED0  00002821   ADDU A1, ZERO, ZERO
163:                         clear_eol();
9D003ED4  0F402C98   JAL clear_eol
9D003ED8  00000000   NOP
164:                         print(comm_channel,"file unsaved! continue (y/n)?");
9D003EDC  9784803C   LHU A0, -32708(GP)
9D003EE0  3C059D01   LUI A1, -25343
9D003EE4  0F402C18   JAL print
9D003EE8  24A52BE4   ADDIU A1, A1, 11236
165:                         key= wait_key(comm_channel);
9D003EEC  0F402D86   JAL wait_key
9D003EF0  9784803C   LHU A0, -32708(GP)
166:                         answer=(key=='y')||(key=='Y');
9D003EF4  304200DF   ANDI V0, V0, 223
9D003EF8  38500059   XORI S0, V0, 89
9D003EFC  2E100001   SLTIU S0, S0, 1
167:                         invert_video(false);
9D003F00  0F402DE2   JAL invert_video
9D003F04  00002021   ADDU A0, ZERO, ZERO
168:                         set_curpos(0,0);
9D003F08  00002021   ADDU A0, ZERO, ZERO
9D003F0C  0F402CCF   JAL set_curpos
9D003F10  00002821   ADDU A1, ZERO, ZERO
169:                         clear_eol();
9D003F14  0F402C98   JAL clear_eol
9D003F18  00000000   NOP
170:                         print_line(0);
9D003F1C  0F400F00   JAL print_line
9D003F20  00002021   ADDU A0, ZERO, ZERO
171:                         set_curpos(state.scr_col,state.scr_line);
9D003F24  3C02A000   LUI V0, -24576
9D003F28  244249C4   ADDIU V0, V0, 18884
9D003F2C  80440011   LB A0, 17(V0)
9D003F30  80450010   LB A1, 16(V0)
9D003F34  3084FFFF   ANDI A0, A0, -1
9D003F38  0F402CCF   JAL set_curpos
9D003F3C  30A5FFFF   ANDI A1, A1, -1
172:                     }else{
173:                         answer=true;
174:                     }
175:                     return answer;
176:                 }
9D003F40  02001021   ADDU V0, S0, ZERO
9D003F44  8FBF0014   LW RA, 20(SP)
9D003F48  8FB00010   LW S0, 16(SP)
9D003F4C  03E00008   JR RA
9D003F50  27BD0018   ADDIU SP, SP, 24
177:                 
178:                 static void new_file(){
9D004894  27BDFFE8   ADDIU SP, SP, -24
9D004898  AFBF0014   SW RA, 20(SP)
179:                     if (ask_confirm()){
9D00489C  0F400FA5   JAL ask_confirm
9D0048A0  AFB00010   SW S0, 16(SP)
9D0048A4  10400026   BEQ V0, ZERO, 0x9D004940
9D0048A8  8FBF0014   LW RA, 20(SP)
180:                         invert_video(true);
9D0048AC  0F402DE2   JAL invert_video
9D0048B0  24040001   ADDIU A0, ZERO, 1
181:                         clear_screen();
9D0048B4  0F402B6F   JAL clear_screen
9D0048B8  3C10A000   LUI S0, -24576
182:                         sram_clear_block(0,ED_BUFF_SIZE);
9D0048BC  00002021   ADDU A0, ZERO, ZERO
9D0048C0  0F403ED0   JAL sram_clear_block
9D0048C4  3405FFFE   ORI A1, ZERO, -2
183:                         memset(&state,0,sizeof(ed_state_t));
9D0048C8  AE0049C4   SW ZERO, 18884(S0)
9D0048CC  261049C4   ADDIU S0, S0, 18884
9D0048D0  AE000004   SW ZERO, 4(S0)
9D0048D4  AE000008   SW ZERO, 8(S0)
9D0048D8  AE000010   SW ZERO, 16(S0)
184:                         memset(screen,0,SCREEN_SIZE);
9D0048DC  3C04A000   LUI A0, -24576
9D0048E0  248438C8   ADDIU A0, A0, 14536
9D0048E4  00002821   ADDU A1, ZERO, ZERO
9D0048E8  0F406056   JAL memset
9D0048EC  24060960   ADDIU A2, ZERO, 2400
185:                         state.flags.insert=MODE_INSERT;
9D0048F0  24030001   ADDIU V1, ZERO, 1
186:                         state.flags.new=1;
9D0048F4  00601021   ADDU V0, V1, ZERO
9D0048F8  7C621084   INS V0, V1, 2, 1
9D0048FC  A2020012   SB V0, 18(S0)
187:                         state.flags.modified=false;
188:                         state.tail=MAX_SIZE;
9D004900  3402FFFE   ORI V0, ZERO, -2
189:                         clear_screen();
9D004904  0F402B6F   JAL clear_screen
9D004908  AE02000C   SW V0, 12(S0)
190:                         fname[0]=0;
9D00490C  3C02A000   LUI V0, -24576
9D004910  A04049A4   SB ZERO, 18852(V0)
191:                         search_info.target[0]=0;
9D004914  3C03A000   LUI V1, -24576
9D004918  24624950   ADDIU V0, V1, 18768
9D00491C  A0400004   SB ZERO, 4(V0)
192:                         search_info.ignore_case=false;
9D004920  A0604950   SB ZERO, 18768(V1)
193:                         search_info.loop=false;
9D004924  A0400001   SB ZERO, 1(V0)
194:                         search_info.found=false;
9D004928  A0400002   SB ZERO, 2(V0)
195:                         invert_video(false);
9D00492C  0F402DE2   JAL invert_video
9D004930  00002021   ADDU A0, ZERO, ZERO
196:                         update_display();
9D004934  0F40107A   JAL update_display
9D004938  00000000   NOP
197:                     }
198:                 }//f()
9D00493C  8FBF0014   LW RA, 20(SP)
9D004940  8FB00010   LW S0, 16(SP)
9D004944  03E00008   JR RA
9D004948  27BD0018   ADDIU SP, SP, 24
199:                 
200:                 static bool quit;
201:                 
202:                 static void leave_editor(){
203:                     if (ask_confirm()){
9D006480  0F400FA5   JAL ask_confirm
204:                         set_cursor(CR_UNDER);
9D006490  0F402D63   JAL set_cursor
205:                         quit=true;
9D006498  24020001   ADDIU V0, ZERO, 1
206:                     }
207:                 }
208:                  
209:                 static void list_files(){
210:                     invert_video(true);
9D0062BC  0F402DE2   JAL invert_video
211:                     clear_screen();
9D0062C4  0F402B6F   JAL clear_screen
212:                     listDir(".");
9D0062CC  3C049D01   LUI A0, -25343
213:                     prompt_continue();
9D0062D8  0F400E07   JAL prompt_continue
214:                     invert_video(false);
9D0062E0  0F402DE2   JAL invert_video
215:                     update_display();
9D0062E8  0F40107A   JAL update_display
9D0062EC  00000000   NOP
216:                 }//f
217:                 
218:                 //initialement le curseur est au début de la ligne
219:                 static void mark_target(){
9D004B44  27BDFFD8   ADDIU SP, SP, -40
9D004B48  AFBF0024   SW RA, 36(SP)
9D004B4C  AFB30020   SW S3, 32(SP)
9D004B50  AFB2001C   SW S2, 28(SP)
9D004B54  AFB10018   SW S1, 24(SP)
9D004B58  AFB00014   SW S0, 20(SP)
220:                     int i,len;
221:                 
222:                     len=strlen(search_info.target);
9D004B5C  3C04A000   LUI A0, -24576
9D004B60  0F405701   JAL strlen
9D004B64  24844954   ADDIU A0, A0, 18772
9D004B68  00408821   ADDU S1, V0, ZERO
223:                     set_curpos(state.scr_col,state.scr_line);
9D004B6C  3C02A000   LUI V0, -24576
9D004B70  244249C4   ADDIU V0, V0, 18884
9D004B74  80440011   LB A0, 17(V0)
9D004B78  80450010   LB A1, 16(V0)
9D004B7C  3084FFFF   ANDI A0, A0, -1
9D004B80  0F402CCF   JAL set_curpos
9D004B84  30A5FFFF   ANDI A1, A1, -1
224:                     invert_video(true);
9D004B88  0F402DE2   JAL invert_video
9D004B8C  24040001   ADDIU A0, ZERO, 1
225:                     for (i=0;i<len;i++) put_char(comm_channel,screen[state.scr_line][state.scr_col+i]);
9D004B90  1A200013   BLEZ S1, 0x9D004BE0
9D004B94  00008021   ADDU S0, ZERO, ZERO
9D004B98  3C13A000   LUI S3, -24576
9D004B9C  3C12A000   LUI S2, -24576
9D004BA0  265238C8   ADDIU S2, S2, 14536
9D004BA4  266449C4   ADDIU A0, S3, 18884
9D004BA8  80830010   LB V1, 16(A0)
9D004BAC  80840011   LB A0, 17(A0)
9D004BB0  00031100   SLL V0, V1, 4
9D004BB4  00031980   SLL V1, V1, 6
9D004BB8  00431821   ADDU V1, V0, V1
9D004BBC  00721821   ADDU V1, V1, S2
9D004BC0  00701821   ADDU V1, V1, S0
9D004BC4  00641821   ADDU V1, V1, A0
9D004BC8  9784803C   LHU A0, -32708(GP)
9D004BCC  0F402B85   JAL put_char
9D004BD0  80650000   LB A1, 0(V1)
9D004BD4  26100001   ADDIU S0, S0, 1
9D004BD8  1630FFF3   BNE S1, S0, 0x9D004BA8
9D004BDC  266449C4   ADDIU A0, S3, 18884
226:                     invert_video(false);
9D004BE0  0F402DE2   JAL invert_video
9D004BE4  00002021   ADDU A0, ZERO, ZERO
227:                     set_curpos(state.scr_col,state.scr_line);
9D004BE8  3C02A000   LUI V0, -24576
9D004BEC  244249C4   ADDIU V0, V0, 18884
9D004BF0  80440011   LB A0, 17(V0)
9D004BF4  80450010   LB A1, 16(V0)
9D004BF8  3084FFFF   ANDI A0, A0, -1
9D004BFC  0F402CCF   JAL set_curpos
9D004C00  30A5FFFF   ANDI A1, A1, -1
228:                 }//f
9D004C04  8FBF0024   LW RA, 36(SP)
9D004C08  8FB30020   LW S3, 32(SP)
9D004C0C  8FB2001C   LW S2, 28(SP)
9D004C10  8FB10018   LW S1, 24(SP)
9D004C14  8FB00014   LW S0, 20(SP)
9D004C18  03E00008   JR RA
9D004C1C  27BD0028   ADDIU SP, SP, 40
229:                 
230:                 static int search_line(char *line, char *target, int from){
9D003B38  27BDFFD8   ADDIU SP, SP, -40
9D003B3C  AFBF0024   SW RA, 36(SP)
9D003B40  AFB40020   SW S4, 32(SP)
9D003B44  AFB3001C   SW S3, 28(SP)
9D003B48  AFB20018   SW S2, 24(SP)
9D003B4C  AFB10014   SW S1, 20(SP)
9D003B50  AFB00010   SW S0, 16(SP)
9D003B54  00809021   ADDU S2, A0, ZERO
231:                     int i,j=0;
9D003B68  00008821   ADDU S1, ZERO, ZERO
9D003BC4  00008821   ADDU S1, ZERO, ZERO
232:                     for (i=from;line[i];i++){
9D003B58  00861021   ADDU V0, A0, A2
9D003B5C  80430000   LB V1, 0(V0)
9D003B60  10600018   BEQ V1, ZERO, 0x9D003BC4
9D003B64  00C08021   ADDU S0, A2, ZERO
9D003BA8  26100001   ADDIU S0, S0, 1
9D003BAC  02501021   ADDU V0, S2, S0
9D003BB0  80430000   LB V1, 0(V0)
9D003BB4  1460FFF2   BNE V1, ZERO, 0x9D003B80
9D003BB8  02331021   ADDU V0, S1, S3
9D003BBC  0B400EF3   J 0x9D003BCC
9D003BC0  3C04A000   LUI A0, -24576
233:                         if (search_info.target[j]==line[i]){
9D003B6C  3C13A000   LUI S3, -24576
9D003B70  26734950   ADDIU S3, S3, 18768
9D003B7C  02331021   ADDU V0, S1, S3
9D003B80  80420004   LB V0, 4(V0)
9D003B84  54430008   BNEL V0, V1, 0x9D003BA8
9D003B88  00008821   ADDU S1, ZERO, ZERO
234:                             j++;
9D003B8C  26310001   ADDIU S1, S1, 1
235:                             if (j==strlen(search_info.target)){
9D003B74  3C14A000   LUI S4, -24576
9D003B78  26944954   ADDIU S4, S4, 18772
9D003B90  0F405701   JAL strlen
9D003B94  02802021   ADDU A0, S4, ZERO
9D003B98  16220004   BNE S1, V0, 0x9D003BAC
9D003B9C  26100001   ADDIU S0, S0, 1
9D003BA0  0B400EF8   J 0x9D003BE0
9D003BA4  02111023   SUBU V0, S0, S1
236:                                 i++;
237:                                 break;
238:                             }
239:                         }else{
240:                              j=0; 
241:                         }
242:                     }
243:                     return j==strlen(search_info.target)?i-j:-1;
9D003BC8  3C04A000   LUI A0, -24576
9D003BCC  0F405701   JAL strlen
9D003BD0  24844954   ADDIU A0, A0, 18772
9D003BD4  56220002   BNEL S1, V0, 0x9D003BE0
9D003BD8  2402FFFF   ADDIU V0, ZERO, -1
9D003BDC  02111023   SUBU V0, S0, S1
244:                 }//f
9D003BE0  8FBF0024   LW RA, 36(SP)
9D003BE4  8FB40020   LW S4, 32(SP)
9D003BE8  8FB3001C   LW S3, 28(SP)
9D003BEC  8FB20018   LW S2, 24(SP)
9D003BF0  8FB10014   LW S1, 20(SP)
9D003BF4  8FB00010   LW S0, 16(SP)
9D003BF8  03E00008   JR RA
9D003BFC  27BD0028   ADDIU SP, SP, 40
245:                 
246:                 static void search_next(){
9D004C20  27BDFF80   ADDIU SP, SP, -128
9D004C24  AFBF007C   SW RA, 124(SP)
9D004C28  AFB50078   SW S5, 120(SP)
9D004C2C  AFB40074   SW S4, 116(SP)
9D004C30  AFB30070   SW S3, 112(SP)
9D004C34  AFB2006C   SW S2, 108(SP)
9D004C38  AFB10068   SW S1, 104(SP)
9D004C3C  AFB00064   SW S0, 100(SP)
247:                     char line[CHAR_PER_LINE];
248:                     int len,lcount=0,pos;
249:                     uint16_t saddr;
250:                     
251:                     if (!search_info.target[0] || (!search_info.loop && (state.gap_first>=(state.fsize-1)))){
9D004C40  3C02A000   LUI V0, -24576
9D004C44  80424954   LB V0, 18772(V0)
9D004C48  1040000B   BEQ V0, ZERO, 0x9D004C78
9D004C4C  3C02A000   LUI V0, -24576
9D004C50  90424951   LBU V0, 18769(V0)
9D004C54  1440000D   BNE V0, ZERO, 0x9D004C8C
9D004C58  3C02A000   LUI V0, -24576
9D004C5C  244349C4   ADDIU V1, V0, 18884
9D004C60  8C4249C4   LW V0, 18884(V0)
9D004C64  2442FFFF   ADDIU V0, V0, -1
9D004C68  8C630008   LW V1, 8(V1)
9D004C6C  0062102B   SLTU V0, V1, V0
9D004C70  14400007   BNE V0, ZERO, 0x9D004C90
9D004C74  3C10A000   LUI S0, -24576
252:                         refused();
9D004C78  240401F4   ADDIU A0, ZERO, 500
9D004C7C  0F404971   JAL tone
9D004C80  24050064   ADDIU A1, ZERO, 100
253:                         return;
9D004C84  0B401415   J 0x9D005054
9D004C88  8FBF007C   LW RA, 124(SP)
254:                     }
255:                     search_info.found=false;
9D004C8C  3C10A000   LUI S0, -24576
9D004C90  26024950   ADDIU V0, S0, 18768
9D004C94  A0400002   SB ZERO, 2(V0)
256:                     strcpy(line,(char*)&screen[state.scr_line]);
9D004C98  3C02A000   LUI V0, -24576
9D004C9C  804249D4   LB V0, 18900(V0)
9D004CA0  00021900   SLL V1, V0, 4
9D004CA4  00021180   SLL V0, V0, 6
9D004CA8  00621021   ADDU V0, V1, V0
9D004CAC  27A40010   ADDIU A0, SP, 16
9D004CB0  3C05A000   LUI A1, -24576
9D004CB4  24A538C8   ADDIU A1, A1, 14536
9D004CB8  0F40557F   JAL strcpy
9D004CBC  00A22821   ADDU A1, A1, V0
257:                     if (search_info.ignore_case) uppercase(line);
9D004CC0  92024950   LBU V0, 18768(S0)
9D004CC4  10400004   BEQ V0, ZERO, 0x9D004CD8
9D004CC8  3C02A000   LUI V0, -24576
9D004CCC  0F402DEA   JAL uppercase
9D004CD0  27A40010   ADDIU A0, SP, 16
258:                     pos=search_line(line,search_info.target,state.scr_col+1);
9D004CD4  3C02A000   LUI V0, -24576
9D004CD8  805049D5   LB S0, 18901(V0)
9D004CDC  27A40010   ADDIU A0, SP, 16
9D004CE0  3C05A000   LUI A1, -24576
9D004CE4  24A54954   ADDIU A1, A1, 18772
9D004CE8  0F400ECE   JAL search_line
9D004CEC  26060001   ADDIU A2, S0, 1
259:                     if (pos>state.scr_col){
9D004CF0  0202182A   SLT V1, S0, V0
9D004CF4  10600008   BEQ V1, ZERO, 0x9D004D18
9D004CF8  3C11A000   LUI S1, -24576
260:                         search_info.col=pos;
9D004CFC  3C03A000   LUI V1, -24576
9D004D00  A0624953   SB V0, 18771(V1)
261:                         state.scr_col=pos;
9D004D04  3C03A000   LUI V1, -24576
262:                         mark_target();
9D004D08  0F4012D1   JAL mark_target
9D004D0C  A06249D5   SB V0, 18901(V1)
263:                         return;
9D004D10  0B401415   J 0x9D005054
9D004D14  8FBF007C   LW RA, 124(SP)
264:                     }
265:                     len=strlen((char*)&screen[state.scr_line]);
9D004D18  263149C4   ADDIU S1, S1, 18884
9D004D1C  82220010   LB V0, 16(S1)
9D004D20  00021900   SLL V1, V0, 4
9D004D24  00021180   SLL V0, V0, 6
9D004D28  00621021   ADDU V0, V1, V0
9D004D2C  3C04A000   LUI A0, -24576
9D004D30  248438C8   ADDIU A0, A0, 14536
9D004D34  0F405701   JAL strlen
9D004D38  00822021   ADDU A0, A0, V0
266:                     saddr=state.tail+(len-state.scr_col)+1;
9D004D3C  8E23000C   LW V1, 12(S1)
9D004D40  24630001   ADDIU V1, V1, 1
9D004D44  00708023   SUBU S0, V1, S0
9D004D48  02021021   ADDU V0, S0, V0
9D004D4C  3050FFFF   ANDI S0, V0, -1
267:                     while (saddr<ED_BUFF_SIZE){
9D004D50  3402FFFE   ORI V0, ZERO, -2
9D004D54  0202102B   SLTU V0, S0, V0
9D004D58  10400021   BEQ V0, ZERO, 0x9D004DE0
9D004D5C  00008821   ADDU S1, ZERO, ZERO
9D004D6C  3415FFFE   ORI S5, ZERO, -2
9D004DCC  0215102B   SLTU V0, S0, S5
9D004DD0  5440FFE8   BNEL V0, ZERO, 0x9D004D74
9D004DD4  26310001   ADDIU S1, S1, 1
9D004DD8  0B401379   J 0x9D004DE4
9D004DDC  3C02A000   LUI V0, -24576
268:                         lcount++;
9D004D70  26310001   ADDIU S1, S1, 1
269:                         len=get_line_forward((uint8_t*)line,saddr);
9D004D74  27A40010   ADDIU A0, SP, 16
9D004D78  0F400E50   JAL get_line_forward
9D004D7C  02002821   ADDU A1, S0, ZERO
270:                         if (search_info.ignore_case) uppercase(line);
9D004D60  3C14A000   LUI S4, -24576
9D004D80  92834950   LBU V1, 18768(S4)
9D004D84  10600003   BEQ V1, ZERO, 0x9D004D94
9D004D88  00409021   ADDU S2, V0, ZERO
9D004D8C  0F402DEA   JAL uppercase
9D004D90  27A40010   ADDIU A0, SP, 16
271:                         pos=search_line(line,search_info.target,0);
9D004D64  3C13A000   LUI S3, -24576
9D004D68  26734954   ADDIU S3, S3, 18772
9D004D94  27A40010   ADDIU A0, SP, 16
9D004D98  02602821   ADDU A1, S3, ZERO
9D004D9C  0F400ECE   JAL search_line
9D004DA0  00003021   ADDU A2, ZERO, ZERO
272:                         if (pos>-1){
9D004DA4  04420007   BLTZL V0, 0x9D004DC4
9D004DA8  26520001   ADDIU S2, S2, 1
273:                             search_info.found=true;
9D004DAC  3C03A000   LUI V1, -24576
9D004DB0  24634950   ADDIU V1, V1, 18768
9D004DB4  24040001   ADDIU A0, ZERO, 1
9D004DB8  A0640002   SB A0, 2(V1)
274:                             search_info.col=(uint8_t)pos;
275:                             break;
9D004DBC  0B401378   J 0x9D004DE0
9D004DC0  A0620003   SB V0, 3(V1)
276:                         }
277:                         saddr+=len+1;
9D004DC4  02128021   ADDU S0, S0, S2
9D004DC8  3210FFFF   ANDI S0, S0, -1
278:                     }//while
279:                     if (search_info.found){
9D004DE0  3C02A000   LUI V0, -24576
9D004DE4  90424952   LBU V0, 18770(V0)
9D004DE8  1040004F   BEQ V0, ZERO, 0x9D004F28
9D004DEC  3C02A000   LUI V0, -24576
280:                         pos=state.scr_line+lcount;
9D004DF0  3C10A000   LUI S0, -24576
9D004DF4  261049C4   ADDIU S0, S0, 18884
9D004DF8  82150010   LB S5, 16(S0)
281:                         line_down();
9D004DFC  0F401005   JAL line_down
9D004E00  02B1A821   ADDU S5, S5, S1
282:                         saddr=state.tail;
9D004E04  9605000C   LHU A1, 12(S0)
283:                         state.scr_col=search_info.col;
9D004E08  3C02A000   LUI V0, -24576
9D004E0C  90424953   LBU V0, 18771(V0)
284:                         while (lcount){
9D004E10  1220002C   BEQ S1, ZERO, 0x9D004EC4
9D004E14  A2020011   SB V0, 17(S0)
285:                             len=get_line_forward((uint8_t*)line,saddr);
9D004E1C  0F400E50   JAL get_line_forward
9D004E20  27A40010   ADDIU A0, SP, 16
286:                             lcount--;
9D004E24  2631FFFF   ADDIU S1, S1, -1
287:                             if (lcount){
9D004E28  12200014   BEQ S1, ZERO, 0x9D004E7C
9D004E2C  00409021   ADDU S2, V0, ZERO
288:                                 sram_write_block(state.gap_first,(uint8_t*)line,len+1);
9D004E18  3C14A000   LUI S4, -24576
9D004E30  24530001   ADDIU S3, V0, 1
9D004E34  269049C4   ADDIU S0, S4, 18884
9D004E38  8E040008   LW A0, 8(S0)
9D004E3C  27A50010   ADDIU A1, SP, 16
9D004E40  0F403F31   JAL sram_write_block
9D004E44  02603021   ADDU A2, S3, ZERO
289:                                 state.gap_first+=len+1;
9D004E48  8E020008   LW V0, 8(S0)
9D004E4C  24420001   ADDIU V0, V0, 1
9D004E50  00521021   ADDU V0, V0, S2
9D004E54  AE020008   SW V0, 8(S0)
290:                                 sram_clear_block(state.tail,len+1);
9D004E58  8E04000C   LW A0, 12(S0)
9D004E5C  0F403ED0   JAL sram_clear_block
9D004E60  02602821   ADDU A1, S3, ZERO
291:                                 state.tail+=len+1;
9D004E64  8E02000C   LW V0, 12(S0)
9D004E68  24420001   ADDIU V0, V0, 1
9D004E6C  00529021   ADDU S2, V0, S2
9D004E70  AE12000C   SW S2, 12(S0)
292:                                 saddr=state.tail;
9D004E74  0B401387   J 0x9D004E1C
9D004E78  3245FFFF   ANDI A1, S2, -1
293:                             }else{
294:                                 sram_write_block(state.gap_first,(uint8_t*)line,search_info.col);
9D004E7C  3C10A000   LUI S0, -24576
9D004E80  261049C4   ADDIU S0, S0, 18884
9D004E84  3C11A000   LUI S1, -24576
9D004E88  26314950   ADDIU S1, S1, 18768
9D004E8C  8E040008   LW A0, 8(S0)
9D004E90  27A50010   ADDIU A1, SP, 16
9D004E94  0F403F31   JAL sram_write_block
9D004E98  92260003   LBU A2, 3(S1)
295:                                 state.gap_first+=search_info.col;
9D004E9C  92250003   LBU A1, 3(S1)
9D004EA0  8E020008   LW V0, 8(S0)
9D004EA4  00A21021   ADDU V0, A1, V0
9D004EA8  AE020008   SW V0, 8(S0)
296:                                 sram_clear_block(state.tail,search_info.col);
9D004EAC  0F403ED0   JAL sram_clear_block
9D004EB0  8E04000C   LW A0, 12(S0)
297:                                 state.tail+=search_info.col;
9D004EB4  92230003   LBU V1, 3(S1)
9D004EB8  8E02000C   LW V0, 12(S0)
9D004EBC  00621021   ADDU V0, V1, V0
9D004EC0  AE02000C   SW V0, 12(S0)
298:                             }
299:                         }//while
300:                         if (pos>LAST_LINE){
9D004EC4  2AA2001E   SLTI V0, S5, 30
9D004EC8  5440000C   BNEL V0, ZERO, 0x9D004EFC
9D004ECC  7C152C20   SEB A1, S5
301:                             state.scr_first=state.gap_first-search_info.col;
9D004ED0  3C02A000   LUI V0, -24576
9D004ED4  244249C4   ADDIU V0, V0, 18884
9D004ED8  3C03A000   LUI V1, -24576
9D004EDC  90634953   LBU V1, 18771(V1)
9D004EE0  8C440008   LW A0, 8(V0)
9D004EE4  00831823   SUBU V1, A0, V1
9D004EE8  AC430004   SW V1, 4(V0)
302:                             state.scr_line=0;
303:                             update_display();
9D004EEC  0F40107A   JAL update_display
9D004EF0  A0400010   SB ZERO, 16(V0)
9D004EF4  0B4013C6   J 0x9D004F18
9D004EF8  00000000   NOP
304:                         }else{
305:                             state.scr_line=pos;
9D004EFC  3C02A000   LUI V0, -24576
9D004F00  244249C4   ADDIU V0, V0, 18884
9D004F04  A0450010   SB A1, 16(V0)
306:                             set_curpos(state.scr_col,state.scr_line);
9D004F08  80440011   LB A0, 17(V0)
9D004F0C  3084FFFF   ANDI A0, A0, -1
9D004F10  0F402CCF   JAL set_curpos
9D004F14  30A5FFFF   ANDI A1, A1, -1
307:                         }
308:                         mark_target();
9D004F18  0F4012D1   JAL mark_target
9D004F1C  00000000   NOP
9D004F20  0B401415   J 0x9D005054
9D004F24  8FBF007C   LW RA, 124(SP)
309:                     }else if (search_info.loop){
9D004F28  90424951   LBU V0, 18769(V0)
9D004F2C  10400045   BEQ V0, ZERO, 0x9D005044
9D004F30  3C02A000   LUI V0, -24576
310:                         saddr=0;
311:                         lcount=1;
312:                         while (saddr<state.gap_first){
9D004F34  8C4249CC   LW V0, 18892(V0)
9D004F38  1040003D   BEQ V0, ZERO, 0x9D005030
9D004F3C  00008021   ADDU S0, ZERO, ZERO
9D004F40  00002821   ADDU A1, ZERO, ZERO
9D004F44  24110001   ADDIU S1, ZERO, 1
9D004F54  3C15A000   LUI S5, -24576
9D004FB0  26A249C4   ADDIU V0, S5, 18884
9D004FB4  8C420008   LW V0, 8(V0)
9D004FB8  0202102B   SLTU V0, S0, V0
9D004FBC  1440FFE6   BNE V0, ZERO, 0x9D004F58
9D004FC0  02002821   ADDU A1, S0, ZERO
313:                             len=get_line_forward((uint8_t*)line,saddr);
9D004F58  0F400E50   JAL get_line_forward
9D004F5C  27A40010   ADDIU A0, SP, 16
314:                             if (search_info.ignore_case) uppercase(line);
9D004F48  3C14A000   LUI S4, -24576
9D004F60  92834950   LBU V1, 18768(S4)
9D004F64  10600003   BEQ V1, ZERO, 0x9D004F74
9D004F68  00409021   ADDU S2, V0, ZERO
9D004F6C  0F402DEA   JAL uppercase
9D004F70  27A40010   ADDIU A0, SP, 16
315:                             pos=search_line(line,search_info.target,0);
9D004F4C  3C13A000   LUI S3, -24576
9D004F50  26734954   ADDIU S3, S3, 18772
9D004F74  27A40010   ADDIU A0, SP, 16
9D004F78  02602821   ADDU A1, S3, ZERO
9D004F7C  0F400ECE   JAL search_line
9D004F80  00003021   ADDU A2, ZERO, ZERO
316:                             if (pos>-1){
9D004F84  04420007   BLTZL V0, 0x9D004FA4
9D004F88  26310001   ADDIU S1, S1, 1
317:                                 search_info.found=true;
9D004F8C  3C03A000   LUI V1, -24576
9D004F90  24634950   ADDIU V1, V1, 18768
9D004F94  24040001   ADDIU A0, ZERO, 1
9D004F98  A0640002   SB A0, 2(V1)
318:                                 search_info.col=(uint8_t)pos;
319:                                 break;
9D004F9C  0B4013F1   J 0x9D004FC4
9D004FA0  A0620003   SB V0, 3(V1)
320:                             }
321:                             lcount++;
322:                             saddr+=len+1;
9D004FA4  26520001   ADDIU S2, S2, 1
9D004FA8  02128021   ADDU S0, S0, S2
9D004FAC  3210FFFF   ANDI S0, S0, -1
323:                         }//while
324:                         if (search_info.found){
9D004FC4  3C02A000   LUI V0, -24576
9D004FC8  90424952   LBU V0, 18770(V0)
9D004FCC  10400019   BEQ V0, ZERO, 0x9D005034
9D004FD0  240401F4   ADDIU A0, ZERO, 500
325:                             jump_to_line(lcount);
9D004FD4  0F401158   JAL jump_to_line
9D004FD8  3224FFFF   ANDI A0, S1, -1
326:                             while (state.scr_col<search_info.col) char_right();
9D004FDC  3C02A000   LUI V0, -24576
9D004FE0  804349D5   LB V1, 18901(V0)
9D004FE4  3C02A000   LUI V0, -24576
9D004FE8  90424953   LBU V0, 18771(V0)
9D004FEC  0062102A   SLT V0, V1, V0
9D004FF0  1040000B   BEQ V0, ZERO, 0x9D005020
9D004FF4  3C11A000   LUI S1, -24576
9D004FF8  3C10A000   LUI S0, -24576
9D004FFC  0F401046   JAL char_right
9D005000  00000000   NOP
9D005004  262249C4   ADDIU V0, S1, 18884
9D005008  80430011   LB V1, 17(V0)
9D00500C  26024950   ADDIU V0, S0, 18768
9D005010  90420003   LBU V0, 3(V0)
9D005014  0062102A   SLT V0, V1, V0
9D005018  1440FFF8   BNE V0, ZERO, 0x9D004FFC
9D00501C  00000000   NOP
327:                             mark_target();
9D005020  0F4012D1   JAL mark_target
9D005024  00000000   NOP
9D005028  0B401415   J 0x9D005054
9D00502C  8FBF007C   LW RA, 124(SP)
328:                         }else{
329:                             refused();
9D005030  240401F4   ADDIU A0, ZERO, 500
9D005034  0F404971   JAL tone
9D005038  24050064   ADDIU A1, ZERO, 100
330:                         }
331:                     }else{
332:                         refused();
9D005044  240401F4   ADDIU A0, ZERO, 500
9D005048  0F404971   JAL tone
9D00504C  24050064   ADDIU A1, ZERO, 100
333:                     }
334:                 }//f
9D00503C  0B401415   J 0x9D005054
9D005040  8FBF007C   LW RA, 124(SP)
9D005050  8FBF007C   LW RA, 124(SP)
9D005054  8FB50078   LW S5, 120(SP)
9D005058  8FB40074   LW S4, 116(SP)
9D00505C  8FB30070   LW S3, 112(SP)
9D005060  8FB2006C   LW S2, 108(SP)
9D005064  8FB10068   LW S1, 104(SP)
9D005068  8FB00064   LW S0, 100(SP)
9D00506C  03E00008   JR RA
9D005070  27BD0080   ADDIU SP, SP, 128
335:                 
336:                 static bool parse_search_line(){
337:                     int pos=0;
338:                     char *str, prev=0;
339:                     int options=0;
340:                     
341:                     str=search_info.target;
342:                     while (str[pos]){
9D0060F4  82A20004   LB V0, 4(S5)
9D0060F8  10400066   BEQ V0, ZERO, 0x9D006294
9D0060FC  00008821   ADDU S1, ZERO, ZERO
9D006100  00002821   ADDU A1, ZERO, ZERO
9D006104  00002021   ADDU A0, ZERO, ZERO
9D006148  80630004   LB V1, 4(V1)
9D00614C  10600051   BEQ V1, ZERO, 0x9D006294
9D006150  02202821   ADDU A1, S1, ZERO
9D006154  00402021   ADDU A0, V0, ZERO
9D006158  0B401844   J 0x9D006110
9D00615C  00601021   ADDU V0, V1, ZERO
343:                         if (str[pos]=='-' && prev==' '){
9D006108  2406002D   ADDIU A2, ZERO, 45
9D00610C  24070020   ADDIU A3, ZERO, 32
9D006110  1446000C   BNE V0, A2, 0x9D006144
9D006114  26310001   ADDIU S1, S1, 1
9D006118  1487000A   BNE A0, A3, 0x9D006144
9D00611C  00000000   NOP
344:                             str[pos-1]=0;
9D006120  00B52821   ADDU A1, A1, S5
9D006124  A0A00003   SB ZERO, 3(A1)
345:                             prev='-';
346:                             pos++;
347:                             break;
348:                         }
349:                         prev=str[pos];
350:                         pos++;
351:                     }    
352:                     while (str[pos] && options!=3){
9D006128  02209821   ADDU S3, S1, ZERO
9D00612C  02351821   ADDU V1, S1, S5
9D006130  80630004   LB V1, 4(V1)
9D006134  1460000A   BNE V1, ZERO, 0x9D006160
9D006138  0000F021   ADDU S8, ZERO, ZERO
9D00613C  0B4018A5   J 0x9D006294
9D006140  00000000   NOP
9D006144  02B11821   ADDU V1, S5, S1
9D00627C  80630004   LB V1, 4(V1)
9D006280  10600004   BEQ V1, ZERO, 0x9D006294
9D006284  02209821   ADDU S3, S1, ZERO
9D006288  24040003   ADDIU A0, ZERO, 3
9D00628C  17C4FFB8   BNE S8, A0, 0x9D006170
9D006290  00000000   NOP
353:                         switch(str[pos]){
9D006160  24160049   ADDIU S6, ZERO, 73
9D006170  10760024   BEQ V1, S6, 0x9D006204
9D006174  2864004A   SLTI A0, V1, 74
9D006178  50800008   BEQL A0, ZERO, 0x9D00619C
9D00617C  24040069   ADDIU A0, ZERO, 105
9D006180  24020020   ADDIU V0, ZERO, 32
9D006184  10620039   BEQ V1, V0, 0x9D00626C
9D006188  2402002D   ADDIU V0, ZERO, 45
9D00618C  50620038   BEQL V1, V0, 0x9D006270
9D006190  02759821   ADDU S3, S3, S5
9D00619C  10640019   BEQ V1, A0, 0x9D006204
9D0061A0  2404006C   ADDIU A0, ZERO, 108
9D0061A4  10640003   BEQ V1, A0, 0x9D0061B4
9D0061A8  2404004C   ADDIU A0, ZERO, 76
9D0061AC  1464002B   BNE V1, A0, 0x9D00625C
9D0061B0  240401F4   ADDIU A0, ZERO, 500
354:                             case '-':
355:                             case ' ':
356:                                 break;
357:                             case 'l':
358:                             case 'L':
359:                                 if (prev!='-'){
9D0061B4  2403002D   ADDIU V1, ZERO, 45
9D0061B8  50430006   BEQL V0, V1, 0x9D0061D4
9D0061BC  24020001   ADDIU V0, ZERO, 1
360:                                     refused();
9D0061C0  240401F4   ADDIU A0, ZERO, 500
9D0061C4  0F404971   JAL tone
9D0061C8  24050064   ADDIU A1, ZERO, 100
361:                                     return false;
362:                                 }
363:                                 search_info.loop=true;
9D0061D4  A2A20001   SB V0, 1(S5)
364:                                 options|=1; 
9D0061EC  0B40189B   J 0x9D00626C
9D0061F0  37DE0001   ORI S8, S8, 1
365:                                 if (str[pos+1] && str[pos+1]!=' '){
9D0061D8  02751021   ADDU V0, S3, S5
9D0061DC  80420005   LB V0, 5(V0)
9D0061E0  7C022944   INS V0, ZERO, 5, 1
9D0061E4  14400003   BNE V0, ZERO, 0x9D0061F4
9D0061E8  240401F4   ADDIU A0, ZERO, 500
366:                                     refused();
9D0061F4  0F404971   JAL tone
9D0061F8  24050064   ADDIU A1, ZERO, 100
367:                                     return false;
368:                                 }
369:                                 break;
370:                             case 'i':
371:                             case 'I':
372:                                 if (prev!='-'){
9D006204  2403002D   ADDIU V1, ZERO, 45
9D006208  50430006   BEQL V0, V1, 0x9D006224
9D00620C  24020001   ADDIU V0, ZERO, 1
373:                                     refused();
9D006210  240401F4   ADDIU A0, ZERO, 500
9D006214  0F404971   JAL tone
9D006218  24050064   ADDIU A1, ZERO, 100
374:                                     return false;
375:                                 }
376:                                 search_info.ignore_case=true;
9D006224  A2E24950   SB V0, 18768(S7)
377:                                 options|=2;
9D006244  0B40189B   J 0x9D00626C
9D006248  37DE0002   ORI S8, S8, 2
378:                                 uppercase(str);
9D006164  3C04A000   LUI A0, -24576
9D006168  24844954   ADDIU A0, A0, 18772
9D00616C  AFA40088   SW A0, 136(SP)
9D006228  0F402DEA   JAL uppercase
9D00622C  8FA40088   LW A0, 136(SP)
379:                                 if (str[pos+1] && str[pos+1]!=' '){
9D006230  02751021   ADDU V0, S3, S5
9D006234  80420005   LB V0, 5(V0)
9D006238  7C022944   INS V0, ZERO, 5, 1
9D00623C  14400003   BNE V0, ZERO, 0x9D00624C
9D006240  240401F4   ADDIU A0, ZERO, 500
380:                                     refused();
9D00624C  0F404971   JAL tone
9D006250  24050064   ADDIU A1, ZERO, 100
381:                                     return false;
382:                                 }
383:                                 break;
384:                             default:
385:                                 refused();
9D006194  0B401897   J 0x9D00625C
9D006198  240401F4   ADDIU A0, ZERO, 500
9D00625C  0F404971   JAL tone
9D006260  24050064   ADDIU A1, ZERO, 100
386:                                 return false;
387:                         }//switch
388:                         prev=str[pos];
9D00626C  02759821   ADDU S3, S3, S5
9D006270  82620004   LB V0, 4(S3)
389:                         pos++;
9D006274  26310001   ADDIU S1, S1, 1
9D006278  02B11821   ADDU V1, S5, S1
390:                     }//while
391:                     return true;
392:                 }//f
393:                 
394:                 static void search(){
395:                     int len;
396:                     invert_video(true);
9D006068  0F402DE2   JAL invert_video
9D00606C  24040001   ADDIU A0, ZERO, 1
397:                     clear_screen();
9D006070  0F402B6F   JAL clear_screen
9D006074  00000000   NOP
398:                     print(comm_channel,"USAGE: target [-I] [-L]\n");
9D006078  9784803C   LHU A0, -32708(GP)
9D00607C  3C059D01   LUI A1, -25343
9D006080  0F402C18   JAL print
9D006084  24A52CC8   ADDIU A1, A1, 11464
399:                     search_info.found=false;
9D005420  3C17A000   LUI S7, -24576
9D005424  26F54950   ADDIU S5, S7, 18768
9D006088  A2A00002   SB ZERO, 2(S5)
400:                     search_info.loop=false;
9D00608C  A2A00001   SB ZERO, 1(S5)
401:                     search_info.ignore_case=false;
9D006090  A2E04950   SB ZERO, 18768(S7)
402:                     print(comm_channel,"? ");
9D006094  9784803C   LHU A0, -32708(GP)
9D006098  3C059D01   LUI A1, -25343
9D00609C  0F402C18   JAL print
9D0060A0  24A52CE4   ADDIU A1, A1, 11492
403:                     len=readline(comm_channel,search_info.target,CHAR_PER_LINE);
9D0060A4  9784803C   LHU A0, -32708(GP)
9D0060A8  3C05A000   LUI A1, -24576
9D0060AC  24A54954   ADDIU A1, A1, 18772
9D0060B0  0F402D9D   JAL readline
9D0060B4  24060050   ADDIU A2, ZERO, 80
9D0060B8  00408821   ADDU S1, V0, ZERO
404:                     if (search_info.target[len-1]=='\n'){
9D0060BC  2442FFFF   ADDIU V0, V0, -1
9D0060C0  00551821   ADDU V1, V0, S5
9D0060C4  80640004   LB A0, 4(V1)
9D0060C8  2403000A   ADDIU V1, ZERO, 10
9D0060CC  14830003   BNE A0, V1, 0x9D0060DC
9D0060D0  00551821   ADDU V1, V0, S5
405:                         search_info.target[len-1]=0;
9D0060D4  A0600004   SB ZERO, 4(V1)
406:                         len--;
9D0060D8  00408821   ADDU S1, V0, ZERO
407:                     }
408:                     invert_video(false);
9D0060DC  0F402DE2   JAL invert_video
9D0060E0  00002021   ADDU A0, ZERO, ZERO
409:                     update_display();
9D0060E4  0F40107A   JAL update_display
9D0060E8  00000000   NOP
410:                     if (len && parse_search_line()){
9D0060EC  12200142   BEQ S1, ZERO, 0x9D0065F8
9D0060F0  93828050   LBU V0, -32688(GP)
411:                         search_next();
9D006294  0F401308   JAL search_next
9D006298  00000000   NOP
412:                     }
413:                 }//f
414:                 
415:                 static bool get_file_name(char *name){
9D005074  27BDFFE0   ADDIU SP, SP, -32
9D005078  AFBF001C   SW RA, 28(SP)
9D00507C  AFB10018   SW S1, 24(SP)
9D005080  AFB00014   SW S0, 20(SP)
416:                     int len;
417:                     
418:                     crlf();
9D005084  0F402B60   JAL crlf
9D005088  00808021   ADDU S0, A0, ZERO
419:                     print(comm_channel,"file name? ");
9D00508C  9784803C   LHU A0, -32708(GP)
9D005090  3C059D01   LUI A1, -25343
9D005094  0F402C18   JAL print
9D005098  24A52C44   ADDIU A1, A1, 11332
420:                     len=readline(comm_channel,name,NAME_MAX_LEN);
9D00509C  9784803C   LHU A0, -32708(GP)
9D0050A0  02002821   ADDU A1, S0, ZERO
9D0050A4  0F402D9D   JAL readline
9D0050A8  24060020   ADDIU A2, ZERO, 32
9D0050AC  00408821   ADDU S1, V0, ZERO
421:                     if (name[len-1]=='\n')name[len-1]=0;
9D0050B0  2442FFFF   ADDIU V0, V0, -1
9D0050B4  02021021   ADDU V0, S0, V0
9D0050B8  80440000   LB A0, 0(V0)
9D0050BC  2403000A   ADDIU V1, ZERO, 10
9D0050C0  50830001   BEQL A0, V1, 0x9D0050C8
9D0050C4  A0400000   SB ZERO, 0(V0)
422:                     uppercase(name);
9D0050C8  0F402DEA   JAL uppercase
9D0050CC  02002021   ADDU A0, S0, ZERO
423:                     return len;
424:                 }//f()
9D0050D0  0011102B   SLTU V0, ZERO, S1
9D0050D4  8FBF001C   LW RA, 28(SP)
9D0050D8  8FB10018   LW S1, 24(SP)
9D0050DC  8FB00014   LW S0, 20(SP)
9D0050E0  03E00008   JR RA
9D0050E4  27BD0020   ADDIU SP, SP, 32
425:                 
426:                 static void load_file(const char *name){
9D00494C  27BDFE40   ADDIU SP, SP, -448
9D004950  AFBF01BC   SW RA, 444(SP)
9D004954  AFB501B8   SW S5, 440(SP)
9D004958  AFB401B4   SW S4, 436(SP)
9D00495C  AFB301B0   SW S3, 432(SP)
9D004960  AFB201AC   SW S2, 428(SP)
9D004964  AFB101A8   SW S1, 424(SP)
9D004968  AFB001A4   SW S0, 420(SP)
427:                     uint32_t saddr,fsize;
428:                     FRESULT result;
429:                     FIL fh;
430:                     int count, line_no=0;
431:                     char prev_c=0, c=0, buffer[CHAR_PER_LINE];
9D004A24  0000A821   ADDU S5, ZERO, ZERO
432:                     reader_t r;
433:                     
434:                     new_file();
9D00496C  0F401225   JAL new_file
9D004970  00808821   ADDU S1, A0, ZERO
435:                     strcpy(fname,name);
9D004974  3C10A000   LUI S0, -24576
9D004978  260449A4   ADDIU A0, S0, 18852
9D00497C  0F40557F   JAL strcpy
9D004980  02202821   ADDU A1, S1, ZERO
436:                     result=f_open(&fh,fname,FA_READ);
9D004984  27A40010   ADDIU A0, SP, 16
9D004988  260549A4   ADDIU A1, S0, 18852
9D00498C  0F400664   JAL f_open
9D004990  24060001   ADDIU A2, ZERO, 1
437:                     if (result){
9D004994  50400007   BEQL V0, ZERO, 0x9D0049B4
9D004998  3402FFFF   ORI V0, ZERO, -1
438:                         ed_error("File load failed!\n",result);
9D00499C  3C049D01   LUI A0, -25343
9D0049A0  24842C04   ADDIU A0, A0, 11268
9D0049A4  0F400E12   JAL ed_error
9D0049A8  00402821   ADDU A1, V0, ZERO
439:                         return;
9D0049AC  0B4012C9   J 0x9D004B24
9D0049B0  8FBF01BC   LW RA, 444(SP)
440:                     }
441:                     if (fh.fsize>MAX_SIZE){
9D0049B4  8FA3001C   LW V1, 28(SP)
9D0049B8  0062102B   SLTU V0, V1, V0
9D0049BC  14400007   BNE V0, ZERO, 0x9D0049DC
9D0049C0  3403FFFE   ORI V1, ZERO, -2
442:                         ed_error("File too big!\n",0);
9D0049C4  3C049D01   LUI A0, -25343
9D0049C8  24842C18   ADDIU A0, A0, 11288
9D0049CC  0F400E12   JAL ed_error
9D0049D0  00002821   ADDU A1, ZERO, ZERO
443:                         return;
9D0049D4  0B4012C9   J 0x9D004B24
9D0049D8  8FBF01BC   LW RA, 444(SP)
444:                     }
445:                     count=0;
9D004A28  00008821   ADDU S1, ZERO, ZERO
446:                     state.tail=MAX_SIZE;
9D0049DC  3C02A000   LUI V0, -24576
9D0049E0  AC4349D0   SW V1, 18896(V0)
447:                     saddr=0;
9D004A2C  00009821   ADDU S3, ZERO, ZERO
448:                     print(comm_channel,"loading file...\n");
9D0049E4  9784803C   LHU A0, -32708(GP)
9D0049E8  3C059D01   LUI A1, -25343
9D0049EC  0F402C18   JAL print
9D0049F0  24A52C28   ADDIU A1, A1, 11304
449:                     print_int(comm_channel,fsize,0);
9D0049F4  9784803C   LHU A0, -32708(GP)
9D0049F8  00002821   ADDU A1, ZERO, ZERO
9D0049FC  0F402C58   JAL print_int
9D004A00  00003021   ADDU A2, ZERO, ZERO
450:                     print(comm_channel," bytes");
9D004A04  9784803C   LHU A0, -32708(GP)
9D004A08  3C059D01   LUI A1, -25343
9D004A0C  0F402C18   JAL print
9D004A10  24A52C3C   ADDIU A1, A1, 11324
451:                     reader_init(&r,eDEV_SDCARD,&fh);
9D004A14  27A40088   ADDIU A0, SP, 136
9D004A18  24050002   ADDIU A1, ZERO, 2
9D004A1C  0F40528A   JAL reader_init
9D004A20  27A60010   ADDIU A2, SP, 16
452:                     while (!r.eof){
9D004A34  0B4012B5   J 0x9D004AD4
9D004A38  2412000D   ADDIU S2, ZERO, 13
9D004AD4  93A20194   LBU V0, 404(SP)
9D004AD8  1040FFD8   BEQ V0, ZERO, 0x9D004A3C
9D004ADC  00000000   NOP
453:                         c=reader_getc(&r);
9D004A3C  0F405290   JAL reader_getc
9D004A40  27A40088   ADDIU A0, SP, 136
454:                         switch(c){
9D004A30  2414000A   ADDIU S4, ZERO, 10
9D004A44  1054000F   BEQ V0, S4, 0x9D004A84
9D004A48  00408021   ADDU S0, V0, ZERO
9D004A4C  1052000D   BEQ V0, S2, 0x9D004A84
9D004A50  2402FFFF   ADDIU V0, ZERO, -1
9D004A54  1202000B   BEQ S0, V0, 0x9D004A84
9D004A58  2A020020   SLTI V0, S0, 32
455:                             case -1:
456:                             case CR:
457:                             case LF:
458:                                 break;
459:                             default:
460:                                 if (c>=32 && c<(32+FONT_SIZE)) buffer[count++]=c; else buffer[count++]=' ';
9D004A5C  14400005   BNE V0, ZERO, 0x9D004A74
9D004A60  27A30010   ADDIU V1, SP, 16
9D004A64  00711021   ADDU V0, V1, S1
9D004A68  A0500028   SB S0, 40(V0)
9D004A6C  0B4012A1   J 0x9D004A84
9D004A70  26310001   ADDIU S1, S1, 1
9D004A74  00711021   ADDU V0, V1, S1
9D004A78  24030020   ADDIU V1, ZERO, 32
9D004A7C  A0430028   SB V1, 40(V0)
9D004A80  26310001   ADDIU S1, S1, 1
461:                         }//switch(c)
462:                         if ((c==CR) || ((c==LF) && (prev_c!=CR)) || (count==(CHAR_PER_LINE-1))){
9D004A84  12120009   BEQ S0, S2, 0x9D004AAC
9D004A88  27A30010   ADDIU V1, SP, 16
9D004A8C  16140004   BNE S0, S4, 0x9D004AA0
9D004A90  2402004F   ADDIU V0, ZERO, 79
9D004A94  16B20006   BNE S5, S2, 0x9D004AB0
9D004A98  00711021   ADDU V0, V1, S1
9D004A9C  2402004F   ADDIU V0, ZERO, 79
9D004AA0  1622000C   BNE S1, V0, 0x9D004AD4
9D004AA4  0200A821   ADDU S5, S0, ZERO
463:                             buffer[count++]=0;
9D004AA8  27A30010   ADDIU V1, SP, 16
9D004AAC  00711021   ADDU V0, V1, S1
9D004AB0  A0400028   SB ZERO, 40(V0)
9D004AB4  26310001   ADDIU S1, S1, 1
464:                             line_no++;
465:                             sram_write_block(saddr,(uint8_t*)buffer,count);
9D004AB8  02602021   ADDU A0, S3, ZERO
9D004ABC  27A50038   ADDIU A1, SP, 56
9D004AC0  0F403F31   JAL sram_write_block
9D004AC4  02203021   ADDU A2, S1, ZERO
466:                             saddr+=count;
9D004AC8  02719821   ADDU S3, S3, S1
467:                             count=0;
9D004ACC  00008821   ADDU S1, ZERO, ZERO
9D004AD0  0200A821   ADDU S5, S0, ZERO
468:                         }
469:                         prev_c=c;
470:                     }
471:                     if (count){
9D004AE0  12200005   BEQ S1, ZERO, 0x9D004AF8
9D004AE4  02602021   ADDU A0, S3, ZERO
472:                         sram_write_block(saddr,(uint8_t*)buffer,count);
9D004AE8  27A50038   ADDIU A1, SP, 56
9D004AEC  0F403F31   JAL sram_write_block
9D004AF0  02203021   ADDU A2, S1, ZERO
473:                         saddr+=count;
9D004AF4  02339821   ADDU S3, S1, S3
474:                         line_no++;
475:                     }
476:                     f_close(&fh);
9D004AF8  0F4008D2   JAL f_close
9D004AFC  27A40010   ADDIU A0, SP, 16
477:                     invert_video(false);
9D004B00  0F402DE2   JAL invert_video
9D004B04  00002021   ADDU A0, ZERO, ZERO
478:                     state.fsize=saddr;
9D004B08  3C02A000   LUI V0, -24576
9D004B0C  AC5349C4   SW S3, 18884(V0)
479:                     state.gap_first=saddr;
9D004B10  244249C4   ADDIU V0, V0, 18884
9D004B14  AC530008   SW S3, 8(V0)
480:                     state.scr_first=saddr;
481:                     file_home();
9D004B18  0F4010E0   JAL file_home
9D004B1C  AC530004   SW S3, 4(V0)
482:                 }//f()
9D004B20  8FBF01BC   LW RA, 444(SP)
9D004B24  8FB501B8   LW S5, 440(SP)
9D004B28  8FB401B4   LW S4, 436(SP)
9D004B2C  8FB301B0   LW S3, 432(SP)
9D004B30  8FB201AC   LW S2, 428(SP)
9D004B34  8FB101A8   LW S1, 424(SP)
9D004B38  8FB001A4   LW S0, 420(SP)
9D004B3C  03E00008   JR RA
9D004B40  27BD01C0   ADDIU SP, SP, 448
483:                 
484:                 static void open_file(){
485:                     FIL fh;
486:                     FRESULT result;
487:                     char name[32];
488:                 
489:                     if (ask_confirm()){
9D0063E8  0F400FA5   JAL ask_confirm
9D0063EC  00000000   NOP
9D0063F0  10400081   BEQ V0, ZERO, 0x9D0065F8
9D0063F4  93828050   LBU V0, -32688(GP)
490:                         invert_video(true);
9D0063F8  0F402DE2   JAL invert_video
9D0063FC  24040001   ADDIU A0, ZERO, 1
491:                         clear_screen();    
9D006400  0F402B6F   JAL clear_screen
9D006404  00000000   NOP
492:                         print(comm_channel,"open file\n");
9D006408  9784803C   LHU A0, -32708(GP)
9D00640C  3C059D01   LUI A1, -25343
9D006410  0F402C18   JAL print
9D006414  24A52CF8   ADDIU A1, A1, 11512
493:                         if (get_file_name(name)){
9D006418  0F40141D   JAL get_file_name
9D00641C  27A40068   ADDIU A0, SP, 104
9D006420  1040000F   BEQ V0, ZERO, 0x9D006460
9D006424  27A40018   ADDIU A0, SP, 24
494:                             if (!(result=f_open(&fh,name,FA_READ))){
9D006428  27A50068   ADDIU A1, SP, 104
9D00642C  0F400664   JAL f_open
9D006430  24060001   ADDIU A2, ZERO, 1
9D006434  14400007   BNE V0, ZERO, 0x9D006454
9D006438  3C049D01   LUI A0, -25343
495:                                 f_close(&fh);
9D00643C  0F4008D2   JAL f_close
9D006440  27A40018   ADDIU A0, SP, 24
496:                                 load_file(name);
9D006444  0F401253   JAL load_file
9D006448  27A40068   ADDIU A0, SP, 104
497:                                 return;
498:                             }else{
499:                                 ed_error("faile to open file.",result);
9D006454  24842D04   ADDIU A0, A0, 11524
9D006458  0F400E12   JAL ed_error
9D00645C  00402821   ADDU A1, V0, ZERO
500:                             }
501:                         }
502:                         invert_video(false);
9D006460  0F402DE2   JAL invert_video
9D006464  00002021   ADDU A0, ZERO, ZERO
503:                         clear_screen();
9D006468  0F402B6F   JAL clear_screen
9D00646C  00000000   NOP
504:                         update_display();
9D006470  0F40107A   JAL update_display
9D006474  00000000   NOP
505:                     }
506:                 }//f()
507:                 
508:                 inline static void replace_nulls(uint8_t *buffer,int len){
509:                     int i;
510:                     for(i=0;i<=len;i++) if (!buffer[i]) buffer[i]=CR;
9D005188  04C0000B   BLTZ A2, 0x9D0051B8
9D00518C  02068021   ADDU S0, S0, A2
9D005190  27A20010   ADDIU V0, SP, 16
9D005194  00001821   ADDU V1, ZERO, ZERO
9D005198  2404000D   ADDIU A0, ZERO, 13
9D00519C  90450000   LBU A1, 0(V0)
9D0051A0  50A00001   BEQL A1, ZERO, 0x9D0051A8
9D0051A4  A0440000   SB A0, 0(V0)
9D0051A8  24630001   ADDIU V1, V1, 1
9D0051AC  00C3282A   SLT A1, A2, V1
9D0051B0  10A0FFFA   BEQ A1, ZERO, 0x9D00519C
9D0051B4  24420001   ADDIU V0, V0, 1
9D00520C  04C0000B   BLTZ A2, 0x9D00523C
9D005210  02068021   ADDU S0, S0, A2
9D005214  27A20010   ADDIU V0, SP, 16
9D005218  00001821   ADDU V1, ZERO, ZERO
9D00521C  2404000D   ADDIU A0, ZERO, 13
9D005220  90450000   LBU A1, 0(V0)
9D005224  50A00001   BEQL A1, ZERO, 0x9D00522C
9D005228  A0440000   SB A0, 0(V0)
9D00522C  24630001   ADDIU V1, V1, 1
9D005230  00C3282A   SLT A1, A2, V1
9D005234  10A0FFFA   BEQ A1, ZERO, 0x9D005220
9D005238  24420001   ADDIU V0, V0, 1
511:                 }//f
512:                 
513:                 static void save_file(){
9D0050E8  27BDFF28   ADDIU SP, SP, -216
9D0050EC  AFBF00D4   SW RA, 212(SP)
9D0050F0  AFB300D0   SW S3, 208(SP)
9D0050F4  AFB200CC   SW S2, 204(SP)
9D0050F8  AFB100C8   SW S1, 200(SP)
9D0050FC  AFB000C4   SW S0, 196(SP)
514:                 #define BUFFER_SIZE 128
515:                     uint8_t buffer[BUFFER_SIZE];
516:                     int size;
517:                     uint32_t saddr=0;
518:                     FRESULT result;
519:                     FIL fh;
520:                 
521:                     if ((result=f_open(&fh,fname,FA_WRITE+FA_CREATE_ALWAYS))){
9D005100  27A40094   ADDIU A0, SP, 148
9D005104  3C05A000   LUI A1, -24576
9D005108  24A549A4   ADDIU A1, A1, 18852
9D00510C  0F400664   JAL f_open
9D005110  2406000A   ADDIU A2, ZERO, 10
9D005114  10400006   BEQ V0, ZERO, 0x9D005130
9D005118  3C049D01   LUI A0, -25343
522:                         ed_error("failed to create file!\n",result);
9D00511C  24842C50   ADDIU A0, A0, 11344
9D005120  0F400E12   JAL ed_error
9D005124  00402821   ADDU A1, V0, ZERO
523:                         return;
9D005128  0B4014C6   J 0x9D005318
9D00512C  8FBF00D4   LW RA, 212(SP)
524:                     }
525:                     invert_video(true);
9D005130  0F402DE2   JAL invert_video
9D005134  24040001   ADDIU A0, ZERO, 1
526:                     clear_screen();
9D005138  0F402B6F   JAL clear_screen
9D00513C  00000000   NOP
527:                     print(comm_channel,"saving file...\n");
9D005140  9784803C   LHU A0, -32708(GP)
9D005144  3C059D01   LUI A1, -25343
9D005148  0F402C18   JAL print
9D00514C  24A52C68   ADDIU A1, A1, 11368
528:                     while ((result==FR_OK) && (saddr < state.gap_first)){
9D005150  3C02A000   LUI V0, -24576
9D005154  8C4649CC   LW A2, 18892(V0)
9D005158  10C00043   BEQ A2, ZERO, 0x9D005268
9D00515C  00008021   ADDU S0, ZERO, ZERO
9D005164  3C12A000   LUI S2, -24576
9D0051C8  1440002F   BNE V0, ZERO, 0x9D005288
9D0051CC  00409821   ADDU S3, V0, ZERO
9D0051D0  264249C4   ADDIU V0, S2, 18884
9D0051D4  8C460008   LW A2, 8(V0)
9D0051D8  0206102B   SLTU V0, S0, A2
9D0051DC  1440FFE3   BNE V0, ZERO, 0x9D00516C
9D0051E0  00D03023   SUBU A2, A2, S0
9D0051E4  0B40149B   J 0x9D00526C
9D0051E8  3C02A000   LUI V0, -24576
529:                         size=min(BUFFER_SIZE,state.gap_first-saddr);
9D005160  24110080   ADDIU S1, ZERO, 128
9D005168  00D03023   SUBU A2, A2, S0
9D00516C  2CC20081   SLTIU V0, A2, 129
9D005170  0222300A   MOVZ A2, S1, V0
9D005174  AFA60090   SW A2, 144(SP)
530:                         sram_read_block(saddr,buffer,size);
9D005178  02002021   ADDU A0, S0, ZERO
9D00517C  0F403F11   JAL sram_read_block
9D005180  27A50010   ADDIU A1, SP, 16
531:                         saddr+=size;
9D005184  8FA60090   LW A2, 144(SP)
532:                         replace_nulls(buffer,size);
533:                         result=f_write(&fh,buffer,size,&size);
9D0051B8  27A40094   ADDIU A0, SP, 148
9D0051BC  27A50010   ADDIU A1, SP, 16
9D0051C0  0F4007B8   JAL f_write
9D0051C4  27A70090   ADDIU A3, SP, 144
534:                     }
535:                     saddr=state.tail;
9D005268  3C02A000   LUI V0, -24576
9D00526C  8C5049D0   LW S0, 18896(V0)
536:                     while((result==FR_OK) && saddr < ED_BUFF_SIZE){
9D00524C  1440000E   BNE V0, ZERO, 0x9D005288
9D005250  00409821   ADDU S3, V0, ZERO
9D005254  0211102B   SLTU V0, S0, S1
9D005258  1440FFE5   BNE V0, ZERO, 0x9D0051F0
9D00525C  02303023   SUBU A2, S1, S0
9D005260  0B4014AA   J 0x9D0052A8
9D005264  00000000   NOP
9D005270  3402FFFE   ORI V0, ZERO, -2
9D005274  0202102B   SLTU V0, S0, V0
9D005278  1040000B   BEQ V0, ZERO, 0x9D0052A8
9D00527C  3411FFFE   ORI S1, ZERO, -2
537:                         size=min(BUFFER_SIZE,ED_BUFF_SIZE-saddr);
9D0051EC  02303023   SUBU A2, S1, S0
9D0051F0  2CC20081   SLTIU V0, A2, 129
9D0051F4  0242300A   MOVZ A2, S2, V0
9D0051F8  AFA60090   SW A2, 144(SP)
9D005280  0B40147B   J 0x9D0051EC
9D005284  24120080   ADDIU S2, ZERO, 128
538:                         sram_read_block(saddr,buffer,size);
9D0051FC  02002021   ADDU A0, S0, ZERO
9D005200  0F403F11   JAL sram_read_block
9D005204  27A50010   ADDIU A1, SP, 16
539:                         saddr+=size;
9D005208  8FA60090   LW A2, 144(SP)
540:                         replace_nulls(buffer,size);
541:                         result=f_write(&fh,buffer,size,&size);
9D00523C  27A40094   ADDIU A0, SP, 148
9D005240  27A50010   ADDIU A1, SP, 16
9D005244  0F4007B8   JAL f_write
9D005248  27A70090   ADDIU A3, SP, 144
542:                     }
543:                     f_close(&fh);
9D005288  0F4008D2   JAL f_close
9D00528C  27A40094   ADDIU A0, SP, 148
9D0052A8  0F4008D2   JAL f_close
9D0052AC  27A40094   ADDIU A0, SP, 148
544:                     if (result){
545:                         ed_error("diksI/O error...\n",result);
9D005290  3C049D01   LUI A0, -25343
9D005294  24842C78   ADDIU A0, A0, 11384
9D005298  0F400E12   JAL ed_error
9D00529C  02602821   ADDU A1, S3, ZERO
546:                         return;
9D0052A0  0B4014C6   J 0x9D005318
9D0052A4  8FBF00D4   LW RA, 212(SP)
547:                     }
548:                     state.flags.modified=false;
9D0052B0  3C10A000   LUI S0, -24576
9D0052B4  260249C4   ADDIU V0, S0, 18884
9D0052B8  90430012   LBU V1, 18(V0)
9D0052BC  7C030844   INS V1, ZERO, 1, 1
549:                     state.flags.new=0;
9D0052C0  7C031084   INS V1, ZERO, 2, 1
550:                     crlf();
9D0052C4  0F402B60   JAL crlf
9D0052C8  A0430012   SB V1, 18(V0)
551:                     print(comm_channel,fname);
9D0052CC  9784803C   LHU A0, -32708(GP)
9D0052D0  3C05A000   LUI A1, -24576
9D0052D4  0F402C18   JAL print
9D0052D8  24A549A4   ADDIU A1, A1, 18852
552:                     print(comm_channel," saved, size: ");
9D0052DC  9784803C   LHU A0, -32708(GP)
9D0052E0  3C059D01   LUI A1, -25343
9D0052E4  0F402C18   JAL print
9D0052E8  24A52C8C   ADDIU A1, A1, 11404
553:                     print_int(comm_channel,state.fsize,0);
9D0052EC  9784803C   LHU A0, -32708(GP)
9D0052F0  8E0549C4   LW A1, 18884(S0)
9D0052F4  0F402C58   JAL print_int
9D0052F8  00003021   ADDU A2, ZERO, ZERO
554:                     prompt_continue();
9D0052FC  0F400E07   JAL prompt_continue
9D005300  00000000   NOP
555:                     invert_video(false);
9D005304  0F402DE2   JAL invert_video
9D005308  00002021   ADDU A0, ZERO, ZERO
556:                     update_display();
9D00530C  0F40107A   JAL update_display
9D005310  00000000   NOP
557:                 }//f()
9D005314  8FBF00D4   LW RA, 212(SP)
9D005318  8FB300D0   LW S3, 208(SP)
9D00531C  8FB200CC   LW S2, 204(SP)
9D005320  8FB100C8   LW S1, 200(SP)
9D005324  8FB000C4   LW S0, 196(SP)
9D005328  03E00008   JR RA
9D00532C  27BD00D8   ADDIU SP, SP, 216
558:                 
559:                 static void save_file_as(){
9D005330  27BDFFC8   ADDIU SP, SP, -56
9D005334  AFBF0034   SW RA, 52(SP)
560:                     char name[32];
561:                     invert_video(true);
9D005338  0F402DE2   JAL invert_video
9D00533C  24040001   ADDIU A0, ZERO, 1
562:                     clear_screen();
9D005340  0F402B6F   JAL clear_screen
9D005344  00000000   NOP
563:                     if (get_file_name(name)){
9D005348  0F40141D   JAL get_file_name
9D00534C  27A40010   ADDIU A0, SP, 16
9D005350  10400008   BEQ V0, ZERO, 0x9D005374
9D005354  83A20010   LB V0, 16(SP)
564:                         if (strlen(name)){
9D005358  10400006   BEQ V0, ZERO, 0x9D005374
9D00535C  3C04A000   LUI A0, -24576
565:                             strcpy(fname,name);
9D005360  248449A4   ADDIU A0, A0, 18852
9D005364  0F40557F   JAL strcpy
9D005368  27A50010   ADDIU A1, SP, 16
566:                             save_file();
9D00536C  0F40143A   JAL save_file
9D005370  00000000   NOP
567:                         }
568:                     }
569:                     invert_video(false);
9D005374  0F402DE2   JAL invert_video
9D005378  00002021   ADDU A0, ZERO, ZERO
570:                     update_display();
9D00537C  0F40107A   JAL update_display
9D005380  00000000   NOP
571:                 }//f()
9D005384  8FBF0034   LW RA, 52(SP)
9D005388  03E00008   JR RA
9D00538C  27BD0038   ADDIU SP, SP, 56
572:                 
573:                 static void file_info(){
574:                     char line[CHAR_PER_LINE];
575:                     set_curpos(0,0);
9D005F84  00002021   ADDU A0, ZERO, ZERO
9D005F88  0F402CCF   JAL set_curpos
9D005F8C  00002821   ADDU A1, ZERO, ZERO
576:                     invert_video(true);
9D005F90  0F402DE2   JAL invert_video
9D005F94  24040001   ADDIU A0, ZERO, 1
577:                     clear_eol();
9D005F98  0F402C98   JAL clear_eol
9D005F9C  00000000   NOP
578:                     if (strlen(fname)){
9D005FA0  3C03A000   LUI V1, -24576
9D005FA4  806249A4   LB V0, 18852(V1)
9D005FA8  10400011   BEQ V0, ZERO, 0x9D005FF0
9D005FAC  260249C4   ADDIU V0, S0, 18884
579:                         sprintf(line,"file%c: %s, size: %d",state.flags.modified?'*':' ',fname,state.fsize);
9D005FB0  8C460010   LW A2, 16(V0)
9D005FB4  7CC60440   EXT A2, A2, 17, 1
9D005FB8  8E0249C4   LW V0, 18884(S0)
9D005FBC  AFA20010   SW V0, 16(SP)
9D005FC0  27A40018   ADDIU A0, SP, 24
9D005FC4  3C059D01   LUI A1, -25343
9D005FC8  24A52C9C   ADDIU A1, A1, 11420
9D005FCC  2402002A   ADDIU V0, ZERO, 42
9D005FD0  24030020   ADDIU V1, ZERO, 32
9D005FD4  0066100A   MOVZ V0, V1, A2
9D005FD8  00403021   ADDU A2, V0, ZERO
9D005FDC  3C02A000   LUI V0, -24576
9D005FE0  0F4062D6   JAL _sprintf_cdnopsuxX
9D005FE4  244749A4   ADDIU A3, V0, 18852
580:                     }else{
581:                         sprintf(line,"no name%c, size: %d",state.flags.modified?'*':' ',state.fsize);
9D005FF0  8C460010   LW A2, 16(V0)
9D005FF4  7CC60440   EXT A2, A2, 17, 1
9D005FF8  27A40018   ADDIU A0, SP, 24
9D005FFC  3C059D01   LUI A1, -25343
9D006000  24A52CB4   ADDIU A1, A1, 11444
9D006004  2402002A   ADDIU V0, ZERO, 42
9D006008  24030020   ADDIU V1, ZERO, 32
9D00600C  0066100A   MOVZ V0, V1, A2
9D006010  00403021   ADDU A2, V0, ZERO
9D006014  0F4062D6   JAL _sprintf_cdnopsuxX
9D006018  8E0749C4   LW A3, 18884(S0)
582:                     }
583:                     print(comm_channel,line);
9D005FE8  0B401808   J 0x9D006020
9D005FEC  9784803C   LHU A0, -32708(GP)
9D00601C  9784803C   LHU A0, -32708(GP)
9D006020  0F402C18   JAL print
9D006024  27A50018   ADDIU A1, SP, 24
584:                     prompt_continue();
9D006028  0F400E07   JAL prompt_continue
9D00602C  00000000   NOP
585:                     invert_video(false);
9D006030  0F402DE2   JAL invert_video
9D006034  00002021   ADDU A0, ZERO, ZERO
586:                     print_line(0);
9D006038  0F400F00   JAL print_line
9D00603C  00002021   ADDU A0, ZERO, ZERO
587:                     print_line(1);
9D006040  0F400F00   JAL print_line
9D006044  24040001   ADDIU A0, ZERO, 1
588:                     set_curpos(state.scr_col,state.scr_line);
9D006048  260249C4   ADDIU V0, S0, 18884
9D00604C  80440011   LB A0, 17(V0)
9D006050  80450010   LB A1, 16(V0)
9D006054  3084FFFF   ANDI A0, A0, -1
9D006058  0F402CCF   JAL set_curpos
9D00605C  30A5FFFF   ANDI A1, A1, -1
589:                 }
590:                 
591:                 
592:                 const char* hkeys[]={
593:                   "<CTRL-DEL> delete to end of line\n",
594:                   "<CTRL-A> save as\n",
595:                   "<CTRL-END> file end\n",
596:                   "<CTRL-F> list SDcard files\n",
597:                   "<CTRL-G> goto line...\n",
598:                   "<CTRL-H> display hotkeys\n",
599:                   "<CTRL-HOME> file start\n",
600:                   "<CTRL_LEFT> word left\n",
601:                   "<CTRL-N> new file...\n",
602:                   "<CTRL-O> open file...\n",
603:                   "<CTRL-Q> Quit editor\n",
604:                   "<CTRL-RIGHT> word right\n",
605:                   "<CTRL-S> save file\n",
606:                   "<F1> file name and size\n"
607:                   "<F3> set search criterion\n",
608:                   "<SHIFT-F3> search next\n",
609:                   ""
610:                 };
611:                 
612:                 //affiche les touches d'action
613:                 static void hot_keys(){
614:                     int i=0;
615:                 
616:                     invert_video(true);
9D006370  0F402DE2   JAL invert_video
617:                     clear_screen();
9D006378  0F402B6F   JAL clear_screen
618:                     while (strlen(hkeys[i])){    
9D006380  3C02A000   LUI V0, -24576
9D0063A0  8E250000   LW A1, 0(S1)
619:                         print(comm_channel,hkeys[i++]);
9D006398  0F402C18   JAL print
620:                     }
621:                     crlf();
9D0063B0  0F402B60   JAL crlf
622:                     prompt_continue();
9D0063B8  0F400E07   JAL prompt_continue
623:                     invert_video(false);
9D0063C0  0F402DE2   JAL invert_video
624:                     update_display();
9D0063C8  0F40107A   JAL update_display
625:                 }
626:                 
627:                 static void editor_init(){
628:                     invert_video(false);
9D0053D4  0F402DE2   JAL invert_video
629:                     set_cursor(CR_UNDER);
9D0053DC  0F402D63   JAL set_cursor
630:                     clear_screen();
9D0053E4  0F402B6F   JAL clear_screen
631:                     fname[0]=0;
9D0053EC  3C02A000   LUI V0, -24576
632:                     new_file();
9D0053F0  0F401225   JAL new_file
633:                 }//f()
634:                 
635:                 
636:                 void editor(const char* name){
9D005390  27BDFF48   ADDIU SP, SP, -184
9D005394  AFBF00B4   SW RA, 180(SP)
9D005398  AFBE00B0   SW S8, 176(SP)
9D00539C  AFB700AC   SW S7, 172(SP)
9D0053A0  AFB600A8   SW S6, 168(SP)
9D0053A4  AFB500A4   SW S5, 164(SP)
9D0053A8  AFB400A0   SW S4, 160(SP)
9D0053AC  AFB3009C   SW S3, 156(SP)
9D0053B0  AFB20098   SW S2, 152(SP)
9D0053B4  AFB10094   SW S1, 148(SP)
9D0053B8  AFB00090   SW S0, 144(SP)
9D0053BC  00808021   ADDU S0, A0, ZERO
637:                     unsigned short key;
638:                     FATFS fh;
639:                     FRESULT result;
640:                     
641:                     state.flags.modified=false;
9D0053C0  3C02A000   LUI V0, -24576
9D0053C4  244249C4   ADDIU V0, V0, 18884
9D0053C8  90430012   LBU V1, 18(V0)
9D0053CC  7C030844   INS V1, ZERO, 1, 1
9D0053D0  A0430012   SB V1, 18(V0)
642:                     editor_init();
643:                     if (name){
9D0053F8  52000004   BEQL S0, ZERO, 0x9D00540C
9D0053FC  A3808050   SB ZERO, -32688(GP)
644:                         load_file(name);
9D005400  0F401253   JAL load_file
9D005404  02002021   ADDU A0, S0, ZERO
645:                     }
646:                     quit=false;
9D005408  A3808050   SB ZERO, -32688(GP)
647:                     while(!quit){
9D005924  0B40197E   J 0x9D0065F8
9D005928  93828050   LBU V0, -32688(GP)
9D005AC0  0B40197E   J 0x9D0065F8
9D005AC4  93828050   LBU V0, -32688(GP)
9D005BD4  0B40197E   J 0x9D0065F8
9D005BD8  93828050   LBU V0, -32688(GP)
9D005C7C  0B40197E   J 0x9D0065F8
9D005C80  93828050   LBU V0, -32688(GP)
9D005CC8  0B40197E   J 0x9D0065F8
9D005CCC  93828050   LBU V0, -32688(GP)
9D005E34  0B40197E   J 0x9D0065F8
9D005E38  93828050   LBU V0, -32688(GP)
9D005F00  0B40197E   J 0x9D0065F8
9D005F04  93828050   LBU V0, -32688(GP)
9D005F7C  0B40197E   J 0x9D0065F8
9D005F80  93828050   LBU V0, -32688(GP)
9D006060  0B40197E   J 0x9D0065F8
9D006064  93828050   LBU V0, -32688(GP)
9D0061CC  0B40197E   J 0x9D0065F8
9D0061D0  93828050   LBU V0, -32688(GP)
9D0061FC  0B40197E   J 0x9D0065F8
9D006200  93828050   LBU V0, -32688(GP)
9D00621C  0B40197E   J 0x9D0065F8
9D006220  93828050   LBU V0, -32688(GP)
9D006254  0B40197E   J 0x9D0065F8
9D006258  93828050   LBU V0, -32688(GP)
9D006264  0B40197E   J 0x9D0065F8
9D006268  93828050   LBU V0, -32688(GP)
9D00629C  0B40197E   J 0x9D0065F8
9D0062A0  93828050   LBU V0, -32688(GP)
9D0062F0  0B40197E   J 0x9D0065F8
9D0062F4  93828050   LBU V0, -32688(GP)
9D006358  0B40197E   J 0x9D0065F8
9D00635C  93828050   LBU V0, -32688(GP)
9D006368  0B40197E   J 0x9D0065F8
9D00636C  93828050   LBU V0, -32688(GP)
9D0063D0  0B40197E   J 0x9D0065F8
9D0063D4  93828050   LBU V0, -32688(GP)
9D00644C  0B40197E   J 0x9D0065F8
9D006450  93828050   LBU V0, -32688(GP)
9D006478  0B40197E   J 0x9D0065F8
9D00647C  93828050   LBU V0, -32688(GP)
9D0065D0  0B40197E   J 0x9D0065F8
9D0065D4  93828050   LBU V0, -32688(GP)
9D0065E0  0B40197E   J 0x9D0065F8
9D0065E4  93828050   LBU V0, -32688(GP)
9D0065F4  93828050   LBU V0, -32688(GP)
9D0065F8  1040FB8B   BEQ V0, ZERO, 0x9D005428
9D0065FC  00000000   NOP
648:                         key=wait_key(comm_channel);
9D005428  0F402D86   JAL wait_key
9D00542C  9784803C   LHU A0, -32708(GP)
9D005430  00408821   ADDU S1, V0, ZERO
649:                         print_int(SERIAL_CON,key,0);
9D005434  24040001   ADDIU A0, ZERO, 1
9D005438  00402821   ADDU A1, V0, ZERO
9D00543C  0F402C58   JAL print_int
9D005440  00003021   ADDU A2, ZERO, ZERO
650:                         switch(key){
9D005418  3C129D00   LUI S2, -25344
9D00541C  26525460   ADDIU S2, S2, 21600
9D005444  2E2200BB   SLTIU V0, S1, 187
9D005448  1040042A   BEQ V0, ZERO, 0x9D0064F4
9D00544C  00111080   SLL V0, S1, 2
9D005450  02421021   ADDU V0, S2, V0
9D005454  8C420000   LW V0, 0(V0)
9D005458  00400008   JR V0
9D00545C  00000000   NOP
651:                             case VK_UP:
652:                                 line_up();
9D005798  0F400F15   JAL line_up
9D00579C  00000000   NOP
653:                                 break;
9D0057A0  0B40197E   J 0x9D0065F8
9D0057A4  93828050   LBU V0, -32688(GP)
654:                             case VK_DOWN:
655:                                 line_down();
9D0057A8  0F401005   JAL line_down
9D0057AC  00000000   NOP
656:                                 break;
9D0057B0  0B40197E   J 0x9D0065F8
9D0057B4  93828050   LBU V0, -32688(GP)
657:                             case VK_LEFT:
658:                                 char_left();
9D0057B8  0F400FD5   JAL char_left
9D0057BC  00000000   NOP
659:                                 break;
9D0057C0  0B40197E   J 0x9D0065F8
9D0057C4  93828050   LBU V0, -32688(GP)
660:                             case VK_CLEFT:
661:                                 word_left();
662:                                 break;
663:                             case VK_RIGHT:
664:                                 char_right();
9D00592C  0F401046   JAL char_right
9D005930  00000000   NOP
665:                                 break;
9D005934  0B40197E   J 0x9D0065F8
9D005938  93828050   LBU V0, -32688(GP)
666:                             case VK_CRIGHT:
667:                                 word_right();
668:                                 break;
669:                             case VK_HOME:
670:                                 line_home();
9D005AC8  0F400E2D   JAL line_home
9D005ACC  00000000   NOP
671:                                 break;
9D005AD0  0B40197E   J 0x9D0065F8
9D005AD4  93828050   LBU V0, -32688(GP)
672:                             case VK_CHOME:
673:                                 file_home();
9D005AD8  0F4010E0   JAL file_home
9D005ADC  00000000   NOP
674:                                 break;
9D005AE0  0B40197E   J 0x9D0065F8
9D005AE4  93828050   LBU V0, -32688(GP)
675:                             case VK_END:
676:                                 line_end();
9D005AE8  0F400E96   JAL line_end
9D005AEC  00000000   NOP
677:                                 break;
9D005AF0  0B40197E   J 0x9D0065F8
9D005AF4  93828050   LBU V0, -32688(GP)
678:                             case VK_CEND:
679:                                 file_end();
680:                                 break;
681:                             case VK_PGUP:
682:                                 page_up();
683:                                 break;
684:                             case VK_PGDN:
685:                                 page_down();
686:                                 break;
687:                             case VK_INSERT:
688:                                 state.flags.insert=~state.flags.insert;
9D005C84  260249C4   ADDIU V0, S0, 18884
9D005C88  8C440010   LW A0, 16(V0)
9D005C8C  7C840400   EXT A0, A0, 16, 1
9D005C90  00042027   NOR A0, ZERO, A0
9D005C94  90430012   LBU V1, 18(V0)
9D005C98  7C830004   INS V1, A0, 0, 1
9D005C9C  A0430012   SB V1, 18(V0)
689:                                 if (state.flags.insert){
9D005CA0  8C420010   LW V0, 16(V0)
9D005CA4  7C420400   EXT V0, V0, 16, 1
9D005CA8  10400005   BEQ V0, ZERO, 0x9D005CC0
9D005CAC  00000000   NOP
690:                                     set_cursor(CR_UNDER);
9D005CB0  0F402D63   JAL set_cursor
9D005CB4  00002021   ADDU A0, ZERO, ZERO
9D005CB8  0B40197E   J 0x9D0065F8
9D005CBC  93828050   LBU V0, -32688(GP)
691:                                 }else{
692:                                     set_cursor(CR_BLOCK);
9D005CC0  0F402D63   JAL set_cursor
9D005CC4  24040001   ADDIU A0, ZERO, 1
693:                                 }
694:                                 break;
695:                             case VK_DELETE:
696:                                 delete_at();
9D005CD0  0F40111E   JAL delete_at
9D005CD4  00000000   NOP
697:                                 break;
9D005CD8  0B40197E   J 0x9D0065F8
9D005CDC  93828050   LBU V0, -32688(GP)
698:                             case VK_CDEL:
699:                                 delete_to_end();
700:                                 break;
701:                             case VK_BACK:
702:                                 delete_left();
703:                                 break;
704:                             case VK_CBACK: 
705:                                 delete_to_start();
706:                                 break;
707:                             case VK_ENTER:
708:                                 enter();
709:                                 break;
710:                             case VK_F1:
711:                                 file_info();
712:                                 break;
713:                             case VK_F3:
714:                                 search();
715:                                 break;
716:                             case VK_F4:
717:                                 search_next();
9D0062A4  0F401308   JAL search_next
9D0062A8  00000000   NOP
718:                             case VK_CA: // <CTRL>-A  sauvegarde sous...
719:                                 save_file_as();
9D0062AC  0F4014CC   JAL save_file_as
9D0062B0  00000000   NOP
720:                                 break;
9D0062B4  0B40197E   J 0x9D0065F8
9D0062B8  93828050   LBU V0, -32688(GP)
721:                             case VK_CF: // <CTRL>-F liste des fichiers
722:                                 list_files();
723:                                 break;
724:                             case VK_CG:// <CTRL>-G  va à la ligne
725:                                 goto_line();
726:                                 break;
727:                             case VK_CK: // <CTRL>-K  affiche hot keys
728:                                 hot_keys();
729:                                 break;
730:                             case VK_CN: // <CTRL>-N  nouveau fichier
731:                                 new_file();
9D0063D8  0F401225   JAL new_file
9D0063DC  00000000   NOP
732:                                 break;
9D0063E0  0B40197E   J 0x9D0065F8
9D0063E4  93828050   LBU V0, -32688(GP)
733:                             case VK_CO: // <CTRL>-O  ouvrir un fichier
734:                                 open_file();
735:                                 break;
736:                             case VK_CQ: // <CTRL>-Q  quitter
737:                                 leave_editor();
738:                                 break;
739:                             case VK_CS: // <CTRL>-S  sauvegarde
740:                                 invert_video(true);
9D0064A4  0F402DE2   JAL invert_video
9D0064A8  24040001   ADDIU A0, ZERO, 1
741:                                 clear_screen();
9D0064AC  0F402B6F   JAL clear_screen
9D0064B0  00000000   NOP
742:                                 if (strlen(fname)) save_file(); else save_file_as();
9D0064B4  3C03A000   LUI V1, -24576
9D0064B8  806249A4   LB V0, 18852(V1)
9D0064BC  10400005   BEQ V0, ZERO, 0x9D0064D4
9D0064C0  00000000   NOP
9D0064C4  0F40143A   JAL save_file
9D0064C8  00000000   NOP
9D0064CC  0B401937   J 0x9D0064DC
9D0064D0  00000000   NOP
9D0064D4  0F4014CC   JAL save_file_as
9D0064D8  00000000   NOP
743:                                 invert_video(false);
9D0064DC  0F402DE2   JAL invert_video
9D0064E0  00002021   ADDU A0, ZERO, ZERO
744:                                 update_display();
9D0064E4  0F40107A   JAL update_display
9D0064E8  00000000   NOP
745:                                 break;
9D0064EC  0B40197E   J 0x9D0065F8
9D0064F0  93828050   LBU V0, -32688(GP)
746:                             default:
747:                                 if ((key>=32)&(key<FONT_SIZE+32)){
9D0064F4  2622FFE0   ADDIU V0, S1, -32
9D0064F8  3042FFFF   ANDI V0, V0, -1
9D0064FC  2C420060   SLTIU V0, V0, 96
9D006500  10400039   BEQ V0, ZERO, 0x9D0065E8
9D006504  260249C4   ADDIU V0, S0, 18884
748:                                     if (state.flags.insert){
9D00540C  3C10A000   LUI S0, -24576
9D006508  8C420010   LW V0, 16(V0)
9D00650C  7C420400   EXT V0, V0, 16, 1
9D006510  10400005   BEQ V0, ZERO, 0x9D006528
9D006514  7C11B420   SEB S6, S1
749:                                         insert_char(key);
9D006518  0F4011B1   JAL insert_char
9D00651C  7C112420   SEB A0, S1
9D006520  0B40197E   J 0x9D0065F8
9D006524  93828050   LBU V0, -32688(GP)
750:                                     }else{
751:                                         replace_char(key);
752:                                     }
753:                                 }else{
754:                                     refused();
9D0065E8  240401F4   ADDIU A0, ZERO, 500
9D0065EC  0F404971   JAL tone
9D0065F0  24050064   ADDIU A1, ZERO, 100
755:                                 }
756:                             }//switch
757:                     }
758:                     invert_video(false);
9D006600  0F402DE2   JAL invert_video
9D006604  00002021   ADDU A0, ZERO, ZERO
759:                     clear_screen();
9D006608  0F402B6F   JAL clear_screen
9D00660C  00000000   NOP
760:                 }//f()
9D006610  0B40198C   J 0x9D006630
9D006614  8FBF00B4   LW RA, 180(SP)
9D006630  8FBE00B0   LW S8, 176(SP)
761:                 
762:                 
763:                 // cherche ligne avant from
764:                 // condition: from doit pointé le premier caractère d'une ligne
765:                 // argurments:
766:                 //   line-> buffer recevant la ligne
767:                 //   from -> adresse SRAM début ligne courante
768:                 // retourne la longueur de la ligne
769:                 uint8_t get_line_back(uint8_t *line, uint32_t from){
770:                     int j,size;
771:                 
772:                     if (from==0){
773:                         line[0]=0;
774:                         return 0;
775:                     }
776:                     if (from<=state.gap_first){
777:                         size=min(CHAR_PER_LINE,from);
9D003C78  24020050   ADDIU V0, ZERO, 80
9D003C7C  2C900051   SLTIU S0, A0, 81
9D003C80  00401821   ADDU V1, V0, ZERO
9D003C84  0090180B   MOVN V1, A0, S0
9D003C88  00608021   ADDU S0, V1, ZERO
778:                         sram_read_block(from-size,line+(CHAR_PER_LINE-size),size);
9D003C8C  00432823   SUBU A1, V0, V1
9D003C90  00832023   SUBU A0, A0, V1
9D003C94  27A20010   ADDIU V0, SP, 16
9D003C98  00452821   ADDU A1, V0, A1
9D003C9C  0F403F11   JAL sram_read_block
9D003CA0  00603021   ADDU A2, V1, ZERO
779:                     }else{
780:                         size=min(from-state.tail,CHAR_PER_LINE);
781:                         sram_read_block(from-size,line+(CHAR_PER_LINE-size),size);
782:                         if (size<CHAR_PER_LINE && state.gap_first>0){
783:                             j=min(CHAR_PER_LINE-size,state.gap_first);
784:                             size+=j;
785:                             sram_read_block(state.gap_first-j,line+(CHAR_PER_LINE-size),j);
786:                         }
787:                     }
788:                     if (size<CHAR_PER_LINE) line[CHAR_PER_LINE-size-1]=0;
9D003CA4  2A020050   SLTI V0, S0, 80
9D003CA8  10400004   BEQ V0, ZERO, 0x9D003CBC
9D003CAC  93A4005F   LBU A0, 95(SP)
9D003CB0  03B08023   SUBU S0, SP, S0
9D003CB4  A200005F   SB ZERO, 95(S0)
789:                     j=CHAR_PER_LINE-1;
9D003CBC  2403004F   ADDIU V1, ZERO, 79
9D003CC0  2402004E   ADDIU V0, ZERO, 78
9D003CC4  0064100B   MOVN V0, V1, A0
790:                     if (!line[j]){
9D003CB8  93A4005F   LBU A0, 95(SP)
791:                         j--;
792:                     }
793:                     while (j>0 && line[j]) j--;
9D003CC8  03A21821   ADDU V1, SP, V0
9D003CCC  90630010   LBU V1, 16(V1)
9D003CD0  1060000F   BEQ V1, ZERO, 0x9D003D10
9D003CD4  00401821   ADDU V1, V0, ZERO
9D003CD8  2442FFFF   ADDIU V0, V0, -1
9D003CDC  18400007   BLEZ V0, 0x9D003CFC
9D003CE0  27A40010   ADDIU A0, SP, 16
9D003CE4  00821821   ADDU V1, A0, V0
9D003CE8  90630000   LBU V1, 0(V1)
9D003CEC  5460FFFB   BNEL V1, ZERO, 0x9D003CDC
9D003CF0  2442FFFF   ADDIU V0, V0, -1
794:                     if (!line[j]) strcpy((char*)line,(char*)&line[j+1]);
9D003CF4  0B400F44   J 0x9D003D10
9D003CF8  00401821   ADDU V1, V0, ZERO
9D003CFC  00401821   ADDU V1, V0, ZERO
9D003D00  03A21021   ADDU V0, SP, V0
9D003D04  90420010   LBU V0, 16(V0)
9D003D08  14400005   BNE V0, ZERO, 0x9D003D20
9D003D0C  00000000   NOP
9D003D10  24650001   ADDIU A1, V1, 1
9D003D14  27A40010   ADDIU A0, SP, 16
9D003D18  0F40557F   JAL strcpy
9D003D1C  00852821   ADDU A1, A0, A1
795:                     return strlen((char*)line);
9D003D20  0F405701   JAL strlen
9D003D24  27A40010   ADDIU A0, SP, 16
796:                 }//f()
797:                 
798:                 
799:                 //cherche ligne débutant a partir de from
800:                 //condition: from pointe le premier caractère de la ligne courante
801:                 // arguments:
802:                 //   from -> adresse SRAM début de ligne
803:                 //   line -> buffer recevant la ligne
804:                 // retourne la longueur de la ligne
805:                 uint8_t get_line_forward(uint8_t *line, uint32_t from){
9D003940  27BDFFD8   ADDIU SP, SP, -40
9D003944  AFBF0024   SW RA, 36(SP)
9D003948  AFB30020   SW S3, 32(SP)
9D00394C  AFB2001C   SW S2, 28(SP)
9D003950  AFB10018   SW S1, 24(SP)
9D003954  AFB00014   SW S0, 20(SP)
9D003958  00808021   ADDU S0, A0, ZERO
806:                     int j,size;
807:                     
808:                     if (from <= state.gap_first){
9D00395C  3C02A000   LUI V0, -24576
9D003960  8C5149CC   LW S1, 18892(V0)
9D003964  0225102B   SLTU V0, S1, A1
9D003968  1440001E   BNE V0, ZERO, 0x9D0039E4
9D00396C  00A02021   ADDU A0, A1, ZERO
809:                         size=min(CHAR_PER_LINE-1, state.gap_first-from);
9D003970  02258823   SUBU S1, S1, A1
9D003974  2E230050   SLTIU V1, S1, 80
9D003978  2402004F   ADDIU V0, ZERO, 79
9D00397C  0043880A   MOVZ S1, V0, V1
9D003980  02209021   ADDU S2, S1, ZERO
810:                         sram_read_block(from,line,size);
9D003984  02002821   ADDU A1, S0, ZERO
9D003988  0F403F11   JAL sram_read_block
9D00398C  02203021   ADDU A2, S1, ZERO
811:                         if (size<(CHAR_PER_LINE-1) && state.tail<MAX_SIZE){
9D003990  2A22004F   SLTI V0, S1, 79
9D003994  5040001D   BEQL V0, ZERO, 0x9D003A0C
9D003998  02129021   ADDU S2, S0, S2
9D00399C  3C02A000   LUI V0, -24576
9D0039A0  8C4449D0   LW A0, 18896(V0)
9D0039A4  3402FFFE   ORI V0, ZERO, -2
9D0039A8  0082102B   SLTU V0, A0, V0
9D0039AC  50400017   BEQL V0, ZERO, 0x9D003A0C
9D0039B0  02129021   ADDU S2, S0, S2
812:                             from=state.tail;
813:                             j=min(CHAR_PER_LINE-size-1,MAX_SIZE-from);
9D0039B4  2403004F   ADDIU V1, ZERO, 79
9D0039B8  00711823   SUBU V1, V1, S1
9D0039BC  3402FFFE   ORI V0, ZERO, -2
9D0039C0  00441023   SUBU V0, V0, A0
9D0039C4  0043982B   SLTU S3, V0, V1
9D0039C8  0073100A   MOVZ V0, V1, S3
9D0039CC  00409821   ADDU S3, V0, ZERO
814:                             sram_read_block(from,&line[size],j);
9D0039D0  02112821   ADDU A1, S0, S1
9D0039D4  0F403F11   JAL sram_read_block
9D0039D8  00403021   ADDU A2, V0, ZERO
815:                             size+=j;
9D0039DC  0B400E82   J 0x9D003A08
9D0039E0  02339021   ADDU S2, S1, S3
816:                         }
817:                     }else{
818:                         size=min(CHAR_PER_LINE-1,MAX_SIZE-from);
9D0039E4  3402FFFE   ORI V0, ZERO, -2
9D0039E8  00451023   SUBU V0, V0, A1
9D0039EC  2C520050   SLTIU S2, V0, 80
9D0039F0  2403004F   ADDIU V1, ZERO, 79
9D0039F4  0052180B   MOVN V1, V0, S2
9D0039F8  00609021   ADDU S2, V1, ZERO
819:                         sram_read_block(from,line,size);
9D0039FC  02002821   ADDU A1, S0, ZERO
9D003A00  0F403F11   JAL sram_read_block
9D003A04  00603021   ADDU A2, V1, ZERO
820:                     }
821:                     line[size]=0;
9D003A08  02129021   ADDU S2, S0, S2
9D003A0C  A2400000   SB ZERO, 0(S2)
822:                     size=strlen((char*)line);
9D003A10  0F405701   JAL strlen
9D003A14  02002021   ADDU A0, S0, ZERO
823:                     j=size;
824:                     while (j<CHAR_PER_LINE) line[j++]=0;
9D003A18  28440050   SLTI A0, V0, 80
9D003A1C  10800006   BEQ A0, ZERO, 0x9D003A38
9D003A20  00401821   ADDU V1, V0, ZERO
9D003A24  24040050   ADDIU A0, ZERO, 80
9D003A28  24630001   ADDIU V1, V1, 1
9D003A2C  02033021   ADDU A2, S0, V1
9D003A30  1464FFFD   BNE V1, A0, 0x9D003A28
9D003A34  A0C0FFFF   SB ZERO, -1(A2)
825:                     return size;
826:                 }//f()
9D003A38  304200FF   ANDI V0, V0, 255
9D003A3C  8FBF0024   LW RA, 36(SP)
9D003A40  8FB30020   LW S3, 32(SP)
9D003A44  8FB2001C   LW S2, 28(SP)
9D003A48  8FB10018   LW S1, 24(SP)
9D003A4C  8FB00014   LW S0, 20(SP)
9D003A50  03E00008   JR RA
9D003A54  27BD0028   ADDIU SP, SP, 40
827:                 
828:                 
829:                 static void update_display(){
9D0041E8  27BDFFD0   ADDIU SP, SP, -48
9D0041EC  AFBF002C   SW RA, 44(SP)
9D0041F0  AFB50028   SW S5, 40(SP)
9D0041F4  AFB40024   SW S4, 36(SP)
9D0041F8  AFB30020   SW S3, 32(SP)
9D0041FC  AFB2001C   SW S2, 28(SP)
9D004200  AFB10018   SW S1, 24(SP)
830:                     uint32_t from;
831:                     uint8_t scr_line=0, llen=0;
9D004240  00008021   ADDU S0, ZERO, ZERO
832:                     
833:                     clear_screen();
9D004204  0F402B6F   JAL clear_screen
9D004208  AFB00014   SW S0, 20(SP)
834:                     memset(screen,0,SCREEN_SIZE);
9D00420C  3C04A000   LUI A0, -24576
9D004210  248438C8   ADDIU A0, A0, 14536
9D004214  00002821   ADDU A1, ZERO, ZERO
9D004218  0F406056   JAL memset
9D00421C  24060960   ADDIU A2, ZERO, 2400
835:                     from=state.scr_first;
9D004220  3C02A000   LUI V0, -24576
9D004224  244249C4   ADDIU V0, V0, 18884
9D004228  8C510004   LW S1, 4(V0)
836:                     while (from < state.gap_first && scr_line<LINE_PER_SCREEN){
9D00422C  8C420008   LW V0, 8(V0)
9D004230  0222102B   SLTU V0, S1, V0
9D004234  1040003E   BEQ V0, ZERO, 0x9D004330
9D004238  3C12A000   LUI S2, -24576
9D00423C  265238C8   ADDIU S2, S2, 14536
9D004244  3C14A000   LUI S4, -24576
9D004248  2415001E   ADDIU S5, ZERO, 30
9D004270  268249C4   ADDIU V0, S4, 18884
9D004274  8C420008   LW V0, 8(V0)
9D004278  0222102B   SLTU V0, S1, V0
9D00427C  10400005   BEQ V0, ZERO, 0x9D004294
9D004280  321000FF   ANDI S0, S0, 255
9D004284  1615FFF1   BNE S0, S5, 0x9D00424C
9D004288  26520050   ADDIU S2, S2, 80
9D00428C  0B4010C4   J 0x9D004310
9D004290  3C02A000   LUI V0, -24576
837:                         llen=get_line_forward((uint8_t*)&screen[scr_line],from);
9D00424C  02402021   ADDU A0, S2, ZERO
9D004250  0F400E50   JAL get_line_forward
9D004254  02202821   ADDU A1, S1, ZERO
9D004258  00409821   ADDU S3, V0, ZERO
838:                         print_line(scr_line);
9D00425C  0F400F00   JAL print_line
9D004260  02002021   ADDU A0, S0, ZERO
839:                         scr_line++;
9D004264  26100001   ADDIU S0, S0, 1
840:                         from+=llen+1;
9D004268  26730001   ADDIU S3, S3, 1
9D00426C  02338821   ADDU S1, S1, S3
841:                     }
842:                     if (from<state.tail) from=state.tail;
9D004294  3C02A000   LUI V0, -24576
9D004298  8C4249D0   LW V0, 18896(V0)
9D00429C  0222182B   SLTU V1, S1, V0
9D0042A0  0043880B   MOVN S1, V0, V1
9D004330  3C02A000   LUI V0, -24576
9D004334  8C4249D0   LW V0, 18896(V0)
9D004338  0051182B   SLTU V1, V0, S1
9D00433C  0043880A   MOVZ S1, V0, V1
843:                     while (from<MAX_SIZE && scr_line<LINE_PER_SCREEN){
9D0042A4  3402FFFE   ORI V0, ZERO, -2
9D0042A8  0222102B   SLTU V0, S1, V0
9D0042AC  10400017   BEQ V0, ZERO, 0x9D00430C
9D0042B0  2E02001E   SLTIU V0, S0, 30
9D0042B4  14400027   BNE V0, ZERO, 0x9D004354
9D0042B8  3C14A000   LUI S4, -24576
9D0042F4  0233102B   SLTU V0, S1, S3
9D0042F8  10400004   BEQ V0, ZERO, 0x9D00430C
9D0042FC  321000FF   ANDI S0, S0, 255
9D004300  2E02001E   SLTIU V0, S0, 30
9D004304  1440FFF0   BNE V0, ZERO, 0x9D0042C8
9D004308  00102100   SLL A0, S0, 4
9D004340  3402FFFE   ORI V0, ZERO, -2
9D004344  0222102B   SLTU V0, S1, V0
9D004348  1040FFF0   BEQ V0, ZERO, 0x9D00430C
9D00434C  00008021   ADDU S0, ZERO, ZERO
9D004358  0B4010B1   J 0x9D0042C4
9D00435C  3413FFFE   ORI S3, ZERO, -2
844:                         llen=get_line_forward((uint8_t*)&screen[scr_line],from);
9D0042C4  00102100   SLL A0, S0, 4
9D0042C8  00101180   SLL V0, S0, 6
9D0042CC  00822021   ADDU A0, A0, V0
9D0042D0  02842021   ADDU A0, S4, A0
9D0042D4  0F400E50   JAL get_line_forward
9D0042D8  02202821   ADDU A1, S1, ZERO
9D0042DC  00409021   ADDU S2, V0, ZERO
9D004350  3C14A000   LUI S4, -24576
9D004354  269438C8   ADDIU S4, S4, 14536
845:                         print_line(scr_line);
9D0042E0  0F400F00   JAL print_line
9D0042E4  02002021   ADDU A0, S0, ZERO
846:                         scr_line++;
9D0042E8  26100001   ADDIU S0, S0, 1
847:                         from+=llen+1;
9D0042EC  26520001   ADDIU S2, S2, 1
9D0042F0  02328821   ADDU S1, S1, S2
848:                     }
849:                     set_curpos(state.scr_col,state.scr_line);
9D0042BC  0B4010C4   J 0x9D004310
9D0042C0  3C02A000   LUI V0, -24576
9D00430C  3C02A000   LUI V0, -24576
9D004310  244249C4   ADDIU V0, V0, 18884
9D004314  80440011   LB A0, 17(V0)
9D004318  80450010   LB A1, 16(V0)
9D00431C  3084FFFF   ANDI A0, A0, -1
9D004320  0F402CCF   JAL set_curpos
9D004324  30A5FFFF   ANDI A1, A1, -1
850:                 }//f();
9D004328  0B4010D8   J 0x9D004360
9D00432C  8FBF002C   LW RA, 44(SP)
9D004360  8FB50028   LW S5, 40(SP)
9D004364  8FB40024   LW S4, 36(SP)
9D004368  8FB30020   LW S3, 32(SP)
9D00436C  8FB2001C   LW S2, 28(SP)
9D004370  8FB10018   LW S1, 24(SP)
9D004374  8FB00014   LW S0, 20(SP)
9D004378  03E00008   JR RA
9D00437C  27BD0030   ADDIU SP, SP, 48
851:                 
852:                 
853:                 static void line_up(){
9D003C54  27BDFF90   ADDIU SP, SP, -112
9D003C58  AFBF006C   SW RA, 108(SP)
9D003C5C  AFB10068   SW S1, 104(SP)
854:                     uint8_t llen, line[CHAR_PER_LINE];
855:                     
856:                     line_home();
9D003C60  0F400E2D   JAL line_home
9D003C64  AFB00064   SW S0, 100(SP)
857:                     if (state.gap_first){ 
9D003C68  3C02A000   LUI V0, -24576
9D003C6C  8C4449CC   LW A0, 18892(V0)
9D003C70  10800084   BEQ A0, ZERO, 0x9D003E84
9D003C74  8FBF006C   LW RA, 108(SP)
858:                         llen=get_line_back(line,state.gap_first);
859:                         state.gap_first-=llen+1;
9D003D28  305100FF   ANDI S1, V0, 255
9D003D2C  3C10A000   LUI S0, -24576
9D003D30  261049C4   ADDIU S0, S0, 18884
9D003D34  8E040008   LW A0, 8(S0)
9D003D38  2484FFFF   ADDIU A0, A0, -1
9D003D3C  00912023   SUBU A0, A0, S1
9D003D40  AE040008   SW A0, 8(S0)
860:                         sram_clear_block(state.gap_first,llen);
9D003D44  0F403ED0   JAL sram_clear_block
9D003D48  02202821   ADDU A1, S1, ZERO
861:                         state.tail-=llen+1;
9D003D4C  8E04000C   LW A0, 12(S0)
9D003D50  2484FFFF   ADDIU A0, A0, -1
9D003D54  00912023   SUBU A0, A0, S1
9D003D58  AE04000C   SW A0, 12(S0)
862:                         sram_write_block(state.tail,line,llen+1);
9D003D5C  27A50010   ADDIU A1, SP, 16
9D003D60  0F403F31   JAL sram_write_block
9D003D64  26260001   ADDIU A2, S1, 1
863:                         state.scr_col=0;
9D003D68  A2000011   SB ZERO, 17(S0)
864:                         if (state.gap_first < state.scr_first){
9D003D6C  8E020008   LW V0, 8(S0)
9D003D70  8E030004   LW V1, 4(S0)
9D003D74  0043182B   SLTU V1, V0, V1
9D003D78  5060001C   BEQL V1, ZERO, 0x9D003DEC
9D003D7C  3C02A000   LUI V0, -24576
865:                             state.scr_first=state.gap_first;
9D003D80  3C03A000   LUI V1, -24576
866:                             scroll_down();
9D003D84  0F402B07   JAL scroll_down
9D003D88  AC6249C8   SW V0, 18888(V1)
867:                             memmove(&screen[1],screen, SCREEN_SIZE-CHAR_PER_LINE);
9D003D8C  3C04A000   LUI A0, -24576
9D003D90  24843918   ADDIU A0, A0, 14616
9D003D94  3C10A000   LUI S0, -24576
9D003D98  260538C8   ADDIU A1, S0, 14536
9D003D9C  0F406324   JAL memmove
9D003DA0  24060910   ADDIU A2, ZERO, 2320
868:                             memmove(screen,line,CHAR_PER_LINE);
9D003DA4  27A20010   ADDIU V0, SP, 16
9D003DA8  260338C8   ADDIU V1, S0, 14536
9D003DAC  27A40060   ADDIU A0, SP, 96
9D003DB0  8C480000   LW T0, 0(V0)
9D003DB4  8C470004   LW A3, 4(V0)
9D003DB8  8C460008   LW A2, 8(V0)
9D003DBC  8C45000C   LW A1, 12(V0)
9D003DC0  AC680000   SW T0, 0(V1)
9D003DC4  AC670004   SW A3, 4(V1)
9D003DC8  AC660008   SW A2, 8(V1)
9D003DCC  AC65000C   SW A1, 12(V1)
9D003DD0  24420010   ADDIU V0, V0, 16
9D003DD4  1444FFF6   BNE V0, A0, 0x9D003DB0
9D003DD8  24630010   ADDIU V1, V1, 16
869:                             print_line(0);
9D003DDC  0F400F00   JAL print_line
9D003DE0  00002021   ADDU A0, ZERO, ZERO
9D003DE4  0B400F9A   J 0x9D003E68
9D003DE8  3C02A000   LUI V0, -24576
870:                         }else{
871:                             state.scr_line--;
9D003DEC  244249C4   ADDIU V0, V0, 18884
9D003DF0  90440010   LBU A0, 16(V0)
9D003DF4  2484FFFF   ADDIU A0, A0, -1
9D003DF8  7C042420   SEB A0, A0
9D003DFC  A0440010   SB A0, 16(V0)
872:                             memmove(&screen[state.scr_line],line,CHAR_PER_LINE);
9D003E00  00042900   SLL A1, A0, 4
9D003E04  00041180   SLL V0, A0, 6
9D003E08  00A22821   ADDU A1, A1, V0
9D003E0C  27A30010   ADDIU V1, SP, 16
9D003E10  3C02A000   LUI V0, -24576
9D003E14  244238C8   ADDIU V0, V0, 14536
9D003E18  00451021   ADDU V0, V0, A1
9D003E1C  27A90060   ADDIU T1, SP, 96
9D003E20  8C680000   LW T0, 0(V1)
9D003E24  8C670004   LW A3, 4(V1)
9D003E28  8C660008   LW A2, 8(V1)
9D003E2C  8C65000C   LW A1, 12(V1)
9D003E30  A8480003   SWL T0, 3(V0)
9D003E34  B8480000   SWR T0, 0(V0)
9D003E38  A8470007   SWL A3, 7(V0)
9D003E3C  B8470004   SWR A3, 4(V0)
9D003E40  A846000B   SWL A2, 11(V0)
9D003E44  B8460008   SWR A2, 8(V0)
9D003E48  A845000F   SWL A1, 15(V0)
9D003E4C  B845000C   SWR A1, 12(V0)
9D003E50  24630010   ADDIU V1, V1, 16
9D003E54  1469FFF2   BNE V1, T1, 0x9D003E20
9D003E58  24420010   ADDIU V0, V0, 16
873:                             print_line(state.scr_line);
9D003E5C  0F400F00   JAL print_line
9D003E60  308400FF   ANDI A0, A0, 255
874:                             
875:                         }
876:                         set_curpos(state.scr_col,state.scr_line);
9D003E64  3C02A000   LUI V0, -24576
9D003E68  244249C4   ADDIU V0, V0, 18884
9D003E6C  80440011   LB A0, 17(V0)
9D003E70  80450010   LB A1, 16(V0)
9D003E74  3084FFFF   ANDI A0, A0, -1
9D003E78  0F402CCF   JAL set_curpos
9D003E7C  30A5FFFF   ANDI A1, A1, -1
9D003E80  8FBF006C   LW RA, 108(SP)
877:                     }
878:                 }//f()
9D003E84  8FB10068   LW S1, 104(SP)
9D003E88  8FB00064   LW S0, 100(SP)
9D003E8C  03E00008   JR RA
9D003E90  27BD0070   ADDIU SP, SP, 112
879:                 
880:                 static void line_down(){
9D004014  27BDFF90   ADDIU SP, SP, -112
9D004018  AFBF006C   SW RA, 108(SP)
9D00401C  AFB10068   SW S1, 104(SP)
881:                     uint8_t llen,line[CHAR_PER_LINE];
882:                     
883:                     line_end();
9D004020  0F400E96   JAL line_end
9D004024  AFB00064   SW S0, 100(SP)
884:                     if (state.tail==MAX_SIZE){
9D004028  3C02A000   LUI V0, -24576
9D00402C  8C4449D0   LW A0, 18896(V0)
9D004030  3402FFFE   ORI V0, ZERO, -2
9D004034  10820033   BEQ A0, V0, 0x9D004104
9D004038  3C10A000   LUI S0, -24576
885:                         return;
886:                     }
887:                     sram_write_byte(state.tail++,0);
9D00403C  261049C4   ADDIU S0, S0, 18884
9D004040  24820001   ADDIU V0, A0, 1
9D004044  AE02000C   SW V0, 12(S0)
9D004048  0F403EFC   JAL sram_write_byte
9D00404C  00002821   ADDU A1, ZERO, ZERO
888:                     sram_write_byte(state.gap_first++,0);
9D004050  8E040008   LW A0, 8(S0)
9D004054  24820001   ADDIU V0, A0, 1
9D004058  AE020008   SW V0, 8(S0)
9D00405C  0F403EFC   JAL sram_write_byte
9D004060  00002821   ADDU A1, ZERO, ZERO
889:                     state.scr_col=0;
9D004064  A2000011   SB ZERO, 17(S0)
890:                     state.scr_line++;
9D004068  92020010   LBU V0, 16(S0)
9D00406C  24420001   ADDIU V0, V0, 1
9D004070  7C021420   SEB V0, V0
9D004080  0B40103A   J 0x9D0040E8
9D004084  A06249D4   SB V0, 18900(V1)
891:                     if (state.scr_line==LINE_PER_SCREEN){
9D004074  2403001E   ADDIU V1, ZERO, 30
9D004078  10430003   BEQ V0, V1, 0x9D004088
9D00407C  3C03A000   LUI V1, -24576
892:                         state.scr_line--;
893:                         state.scr_first+=strlen((char*)&screen[0])+1;
9D004088  3C11A000   LUI S1, -24576
9D00408C  0F405701   JAL strlen
9D004090  262438C8   ADDIU A0, S1, 14536
9D004094  3C10A000   LUI S0, -24576
9D004098  261049C4   ADDIU S0, S0, 18884
9D00409C  8E030004   LW V1, 4(S0)
9D0040A0  24630001   ADDIU V1, V1, 1
9D0040A4  00621021   ADDU V0, V1, V0
894:                         scroll_up();
9D0040A8  0F402AF7   JAL scroll_up
9D0040AC  AE020004   SW V0, 4(S0)
895:                         memmove(screen,(void*)&screen[1],SCREEN_SIZE-CHAR_PER_LINE);
9D0040B0  262438C8   ADDIU A0, S1, 14536
9D0040B4  3C05A000   LUI A1, -24576
9D0040B8  24A53918   ADDIU A1, A1, 14616
9D0040BC  0F406324   JAL memmove
9D0040C0  24060910   ADDIU A2, ZERO, 2320
896:                         llen=get_line_forward(line,state.tail);
9D0040C4  27A40010   ADDIU A0, SP, 16
9D0040C8  0F400E50   JAL get_line_forward
9D0040CC  8E05000C   LW A1, 12(S0)
897:                         strcpy((char*)&screen[LAST_LINE],(char*)line);
9D0040D0  3C04A000   LUI A0, -24576
9D0040D4  248441D8   ADDIU A0, A0, 16856
9D0040D8  0F40557F   JAL strcpy
9D0040DC  27A50010   ADDIU A1, SP, 16
898:                         print_line(LAST_LINE);
9D0040E0  0F400F00   JAL print_line
9D0040E4  2404001D   ADDIU A0, ZERO, 29
899:                     }
900:                     set_curpos(state.scr_col,state.scr_line);
9D0040E8  3C02A000   LUI V0, -24576
9D0040EC  244249C4   ADDIU V0, V0, 18884
9D0040F0  80440011   LB A0, 17(V0)
9D0040F4  80450010   LB A1, 16(V0)
9D0040F8  3084FFFF   ANDI A0, A0, -1
9D0040FC  0F402CCF   JAL set_curpos
9D004100  30A5FFFF   ANDI A1, A1, -1
901:                 }//f()
9D004104  8FBF006C   LW RA, 108(SP)
9D004108  8FB10068   LW S1, 104(SP)
9D00410C  8FB00064   LW S0, 100(SP)
9D004110  03E00008   JR RA
9D004114  27BD0070   ADDIU SP, SP, 112
902:                 
903:                 //déplace le curseur vers la gauche d'un caractère
904:                 static void char_left(){
9D003F54  27BDFFE8   ADDIU SP, SP, -24
9D003F58  AFBF0014   SW RA, 20(SP)
9D003F5C  AFB00010   SW S0, 16(SP)
905:                     if (state.scr_col){
9D003F60  3C02A000   LUI V0, -24576
9D003F64  804249D5   LB V0, 18901(V0)
9D003F68  5040001F   BEQL V0, ZERO, 0x9D003FE8
9D003F6C  3C02A000   LUI V0, -24576
906:                         state.scr_col--;
9D003F70  2442FFFF   ADDIU V0, V0, -1
9D003F74  7C021420   SEB V0, V0
9D003F78  3C10A000   LUI S0, -24576
9D003F7C  261049C4   ADDIU S0, S0, 18884
9D003F80  A2020011   SB V0, 17(S0)
907:                         sram_write_byte(--state.tail,screen[state.scr_line][state.scr_col]);
9D003F84  8E04000C   LW A0, 12(S0)
9D003F88  2484FFFF   ADDIU A0, A0, -1
9D003F8C  AE04000C   SW A0, 12(S0)
9D003F90  82030010   LB V1, 16(S0)
9D003F94  00032900   SLL A1, V1, 4
9D003F98  00031980   SLL V1, V1, 6
9D003F9C  00A31821   ADDU V1, A1, V1
9D003FA0  00621021   ADDU V0, V1, V0
9D003FA4  3C05A000   LUI A1, -24576
9D003FA8  24A538C8   ADDIU A1, A1, 14536
9D003FAC  00451021   ADDU V0, V0, A1
9D003FB0  0F403EFC   JAL sram_write_byte
9D003FB4  90450000   LBU A1, 0(V0)
908:                         sram_write_byte(state.gap_first--,0);
9D003FB8  8E040008   LW A0, 8(S0)
9D003FBC  2482FFFF   ADDIU V0, A0, -1
9D003FC0  AE020008   SW V0, 8(S0)
9D003FC4  0F403EFC   JAL sram_write_byte
9D003FC8  00002821   ADDU A1, ZERO, ZERO
909:                         set_curpos(state.scr_col,state.scr_line);
9D003FCC  82040011   LB A0, 17(S0)
9D003FD0  82050010   LB A1, 16(S0)
9D003FD4  3084FFFF   ANDI A0, A0, -1
9D003FD8  0F402CCF   JAL set_curpos
9D003FDC  30A5FFFF   ANDI A1, A1, -1
9D003FE0  0B401002   J 0x9D004008
9D003FE4  8FBF0014   LW RA, 20(SP)
910:                     }else if (state.gap_first){
9D003FE8  8C4249CC   LW V0, 18892(V0)
9D003FEC  10400006   BEQ V0, ZERO, 0x9D004008
9D003FF0  8FBF0014   LW RA, 20(SP)
911:                         line_up();
9D003FF4  0F400F15   JAL line_up
9D003FF8  00000000   NOP
912:                         line_end();
9D003FFC  0F400E96   JAL line_end
9D004000  00000000   NOP
913:                     }
914:                 }//f()
9D004004  8FBF0014   LW RA, 20(SP)
9D004008  8FB00010   LW S0, 16(SP)
9D00400C  03E00008   JR RA
9D004010  27BD0018   ADDIU SP, SP, 24
915:                 
916:                 //déplace le curseur vers la droite d'un caractère
917:                 static void char_right(){
9D004130  27BDFFE8   ADDIU SP, SP, -24
9D004134  AFBF0014   SW RA, 20(SP)
9D004138  AFB00010   SW S0, 16(SP)
918:                     uint8_t c;
919:                     
920:                     if (state.gap_first==state.fsize) return;
9D004118  3C02A000   LUI V0, -24576
9D00411C  244349C4   ADDIU V1, V0, 18884
9D004120  8C630008   LW V1, 8(V1)
9D004124  8C4249C4   LW V0, 18884(V0)
9D004128  1062002D   BEQ V1, V0, 0x9D0041E0
9D00412C  3C04A000   LUI A0, -24576
921:                     if (state.scr_col<strlen((char*)&screen[state.scr_line])){
9D00413C  3C10A000   LUI S0, -24576
9D004140  261049C4   ADDIU S0, S0, 18884
9D004144  82020010   LB V0, 16(S0)
9D004148  00021900   SLL V1, V0, 4
9D00414C  00021180   SLL V0, V0, 6
9D004150  00621021   ADDU V0, V1, V0
9D004154  248438C8   ADDIU A0, A0, 14536
9D004158  0F405701   JAL strlen
9D00415C  00822021   ADDU A0, A0, V0
9D004160  82030011   LB V1, 17(S0)
9D004164  0062102B   SLTU V0, V1, V0
9D004168  10400018   BEQ V0, ZERO, 0x9D0041CC
9D00416C  3C10A000   LUI S0, -24576
922:                         c=sram_read_byte(state.tail);
9D004170  261049C4   ADDIU S0, S0, 18884
9D004174  0F403EEB   JAL sram_read_byte
9D004178  8E04000C   LW A0, 12(S0)
923:                         sram_write_byte(state.gap_first++,c);
9D00417C  8E040008   LW A0, 8(S0)
9D004180  24830001   ADDIU V1, A0, 1
9D004184  AE030008   SW V1, 8(S0)
9D004188  0F403EFC   JAL sram_write_byte
9D00418C  00402821   ADDU A1, V0, ZERO
924:                         sram_write_byte(state.tail++,0);
9D004190  8E04000C   LW A0, 12(S0)
9D004194  24820001   ADDIU V0, A0, 1
9D004198  AE02000C   SW V0, 12(S0)
9D00419C  0F403EFC   JAL sram_write_byte
9D0041A0  00002821   ADDU A1, ZERO, ZERO
925:                         state.scr_col++;
9D0041A4  92040011   LBU A0, 17(S0)
9D0041A8  24840001   ADDIU A0, A0, 1
9D0041AC  7C042420   SEB A0, A0
9D0041B0  A2040011   SB A0, 17(S0)
926:                         set_curpos(state.scr_col,state.scr_line);
9D0041B4  82050010   LB A1, 16(S0)
9D0041B8  3084FFFF   ANDI A0, A0, -1
9D0041BC  0F402CCF   JAL set_curpos
9D0041C0  30A5FFFF   ANDI A1, A1, -1
9D0041C4  0B401076   J 0x9D0041D8
9D0041C8  8FBF0014   LW RA, 20(SP)
927:                     }else{
928:                         line_down();
9D0041CC  0F401005   JAL line_down
9D0041D0  00000000   NOP
929:                     }
930:                 }//f()
9D0041D4  8FBF0014   LW RA, 20(SP)
9D0041D8  8FB00010   LW S0, 16(SP)
9D0041DC  27BD0018   ADDIU SP, SP, 24
9D0041E0  03E00008   JR RA
9D0041E4  00000000   NOP
931:                 
932:                 static void delete_left(){
933:                     if (state.gap_first){
9D005E14  260249C4   ADDIU V0, S0, 18884
934:                         char_left();
9D005E24  0F400FD5   JAL char_left
935:                         delete_at();
9D005E2C  0F40111E   JAL delete_at
9D005E30  00000000   NOP
936:                     }
937:                 } //f()
938:                 
939:                 static void delete_at(){
9D00448C  27BDFFE0   ADDIU SP, SP, -32
9D004490  AFBF001C   SW RA, 28(SP)
9D004494  AFB10018   SW S1, 24(SP)
9D004498  AFB00014   SW S0, 20(SP)
940:                 //    int llen,i;
941:                 //    char c;
942:                 //    uint8_t line[CHAR_PER_LINE];
943:                     
944:                     if (state.tail==MAX_SIZE) return;
9D004478  3C02A000   LUI V0, -24576
9D00447C  8C4449D0   LW A0, 18896(V0)
9D004480  3402FFFE   ORI V0, ZERO, -2
9D004484  10820034   BEQ A0, V0, 0x9D004558
9D004488  24820001   ADDIU V0, A0, 1
945:                     sram_write_byte(state.tail++,0);
9D00449C  3C11A000   LUI S1, -24576
9D0044A0  263049C4   ADDIU S0, S1, 18884
9D0044A4  AE02000C   SW V0, 12(S0)
9D0044A8  0F403EFC   JAL sram_write_byte
9D0044AC  00002821   ADDU A1, ZERO, ZERO
946:                     state.fsize--;
9D0044B0  8E2249C4   LW V0, 18884(S1)
9D0044B4  2442FFFF   ADDIU V0, V0, -1
9D0044B8  AE2249C4   SW V0, 18884(S1)
947:                     if (state.scr_col<strlen((char*)&screen[state.scr_line])){
9D0044BC  82110011   LB S1, 17(S0)
9D0044C0  82100010   LB S0, 16(S0)
9D0044C4  00101900   SLL V1, S0, 4
9D0044C8  00101180   SLL V0, S0, 6
9D0044CC  00621021   ADDU V0, V1, V0
9D0044D0  3C04A000   LUI A0, -24576
9D0044D4  248438C8   ADDIU A0, A0, 14536
9D0044D8  0F405701   JAL strlen
9D0044DC  00822021   ADDU A0, A0, V0
9D0044E0  0222102B   SLTU V0, S1, V0
9D0044E4  10400016   BEQ V0, ZERO, 0x9D004540
9D0044E8  00101900   SLL V1, S0, 4
948:                         strcpy((char*)&screen[state.scr_line][state.scr_col],
9D0044EC  00101180   SLL V0, S0, 6
9D0044F0  00621821   ADDU V1, V1, V0
9D0044F4  00712021   ADDU A0, V1, S1
9D0044F8  3C02A000   LUI V0, -24576
9D0044FC  244238C8   ADDIU V0, V0, 14536
9D004504  00712821   ADDU A1, V1, S1
9D004508  00442021   ADDU A0, V0, A0
9D00450C  0F40557F   JAL strcpy
9D004510  00452821   ADDU A1, V0, A1
949:                                 (char*)&screen[state.scr_line][state.scr_col+1]);
9D004500  26310001   ADDIU S1, S1, 1
950:                         print_line(state.scr_line);
9D004514  0F400F00   JAL print_line
9D004518  320400FF   ANDI A0, S0, 255
951:                         set_curpos(state.scr_col,state.scr_line);
9D00451C  3C02A000   LUI V0, -24576
9D004520  244249C4   ADDIU V0, V0, 18884
9D004524  80440011   LB A0, 17(V0)
9D004528  80450010   LB A1, 16(V0)
9D00452C  3084FFFF   ANDI A0, A0, -1
9D004530  0F402CCF   JAL set_curpos
9D004534  30A5FFFF   ANDI A1, A1, -1
9D004538  0B401153   J 0x9D00454C
9D00453C  8FBF001C   LW RA, 28(SP)
952:                     }else{
953:                         update_display();
9D004540  0F40107A   JAL update_display
9D004544  00000000   NOP
954:                     }
955:                 }//f()
9D004548  8FBF001C   LW RA, 28(SP)
9D00454C  8FB10018   LW S1, 24(SP)
9D004550  8FB00014   LW S0, 20(SP)
9D004554  27BD0020   ADDIU SP, SP, 32
9D004558  03E00008   JR RA
9D00455C  00000000   NOP
956:                 
957:                 //efface tous les caractères après le cursor
958:                 //jusqu'à la fin de ligne.
959:                 //si le curseur est au début de ligne
960:                 //la ligne est supprimée au complet '\n' inclus.
961:                 static void delete_to_end(){
962:                     uint8_t llen,c;
963:                     
964:                     if (state.fsize==0) return;
9D005CE0  8E0249C4   LW V0, 18884(S0)
9D005CE4  10400243   BEQ V0, ZERO, 0x9D0065F4
9D005CE8  261349C4   ADDIU S3, S0, 18884
965:                     llen=strlen((char*)&screen[state.scr_line]);
9D005CEC  82710010   LB S1, 16(S3)
9D005CF0  0011B100   SLL S6, S1, 4
9D005CF4  00111180   SLL V0, S1, 6
9D005CF8  02C2B021   ADDU S6, S6, V0
9D005CFC  0296B021   ADDU S6, S4, S6
9D005D00  0F405701   JAL strlen
9D005D04  02C02021   ADDU A0, S6, ZERO
966:                     if (state.scr_col){
9D005D08  82730011   LB S3, 17(S3)
9D005D0C  1260001A   BEQ S3, ZERO, 0x9D005D78
9D005D10  0040F021   ADDU S8, V0, ZERO
967:                         memset(&screen[state.scr_line][state.scr_col],0,CHAR_PER_LINE-state.scr_col);
9D005D14  00112100   SLL A0, S1, 4
9D005D18  00118980   SLL S1, S1, 6
9D005D1C  00912021   ADDU A0, A0, S1
9D005D20  00932021   ADDU A0, A0, S3
9D005D24  02842021   ADDU A0, S4, A0
9D005D28  00002821   ADDU A1, ZERO, ZERO
9D005D2C  24060050   ADDIU A2, ZERO, 80
9D005D30  0F406056   JAL memset
9D005D34  00D33023   SUBU A2, A2, S3
968:                         c=llen-state.scr_col;
9D005D38  03D39823   SUBU S3, S8, S3
969:                         sram_clear_block(state.tail,c);
9D005D3C  327300FF   ANDI S3, S3, 255
9D005D40  261149C4   ADDIU S1, S0, 18884
9D005D44  8E24000C   LW A0, 12(S1)
9D005D48  0F403ED0   JAL sram_clear_block
9D005D4C  02602821   ADDU A1, S3, ZERO
970:                         state.fsize-=c;
9D005D50  8E0249C4   LW V0, 18884(S0)
9D005D54  00531023   SUBU V0, V0, S3
9D005D58  AE0249C4   SW V0, 18884(S0)
971:                         state.tail+=c;
9D005D5C  8E22000C   LW V0, 12(S1)
9D005D60  02629821   ADDU S3, S3, V0
9D005D64  AE33000C   SW S3, 12(S1)
972:                         print_line(state.scr_line);
9D005D68  0F400F00   JAL print_line
9D005D6C  92240010   LBU A0, 16(S1)
973:                     }else{
974:                         memset(&screen[state.scr_line],0,CHAR_PER_LINE);
9D005D78  02C02021   ADDU A0, S6, ZERO
9D005D7C  00002821   ADDU A1, ZERO, ZERO
9D005D80  0F406056   JAL memset
9D005D84  24060050   ADDIU A2, ZERO, 80
975:                         sram_clear_block(state.tail,llen);
9D005D88  33DE00FF   ANDI S8, S8, 255
9D005D8C  261149C4   ADDIU S1, S0, 18884
9D005D90  8E24000C   LW A0, 12(S1)
9D005D94  0F403ED0   JAL sram_clear_block
9D005D98  03C02821   ADDU A1, S8, ZERO
976:                         state.tail+=llen;
9D005D9C  8E24000C   LW A0, 12(S1)
9D005DA0  03C42021   ADDU A0, S8, A0
9D005DA4  AE24000C   SW A0, 12(S1)
977:                         state.fsize-=llen;
9D005DA8  8E0249C4   LW V0, 18884(S0)
9D005DAC  005EF023   SUBU S8, V0, S8
978:                         if (state.tail<ED_BUFF_SIZE){
9D005DB0  3402FFFE   ORI V0, ZERO, -2
9D005DB4  0082102B   SLTU V0, A0, V0
9D005DB8  1040000E   BEQ V0, ZERO, 0x9D005DF4
9D005DBC  AE1E49C4   SW S8, 18884(S0)
979:                             c=sram_read_byte(state.tail);
9D005DC0  0F403EEB   JAL sram_read_byte
9D005DC4  00000000   NOP
980:                             if (c==0){
9D005DC8  1440000A   BNE V0, ZERO, 0x9D005DF4
9D005DCC  00000000   NOP
981:                                 sram_write_byte(state.tail,0);
9D005DD0  8E24000C   LW A0, 12(S1)
9D005DD4  0F403EFC   JAL sram_write_byte
9D005DD8  00002821   ADDU A1, ZERO, ZERO
982:                                 state.tail++;
9D005DDC  8E22000C   LW V0, 12(S1)
9D005DE0  24420001   ADDIU V0, V0, 1
9D005DE4  AE22000C   SW V0, 12(S1)
983:                                 state.fsize--;
9D005DE8  8E0249C4   LW V0, 18884(S0)
9D005DEC  2442FFFF   ADDIU V0, V0, -1
9D005DF0  AE0249C4   SW V0, 18884(S0)
984:                             }
985:                         }
986:                         update_display();
9D005DF4  0F40107A   JAL update_display
9D005DF8  00000000   NOP
987:                     }
988:                     state.flags.modified=true;
9D005D70  0B401780   J 0x9D005E00
9D005D74  260249C4   ADDIU V0, S0, 18884
9D005DFC  260249C4   ADDIU V0, S0, 18884
9D005E00  90430012   LBU V1, 18(V0)
9D005E04  24040001   ADDIU A0, ZERO, 1
9D005E08  7C830844   INS V1, A0, 1, 1
9D005E0C  0B40197D   J 0x9D0065F4
9D005E10  A0430012   SB V1, 18(V0)
989:                 }//f()
990:                 
991:                 static void delete_to_start(){
992:                     uint8_t buffer[CHAR_PER_LINE];
993:                     
994:                     if (state.scr_col){
9D005E3C  260249C4   ADDIU V0, S0, 18884
995:                         memset(buffer,0,CHAR_PER_LINE);
9D005E4C  27A40018   ADDIU A0, SP, 24
996:                         state.gap_first-=state.scr_col;
9D005E5C  261149C4   ADDIU S1, S0, 18884
997:                         sram_write_block(state.gap_first,buffer,state.scr_col);
9D005E6C  27A50018   ADDIU A1, SP, 24
998:                         memmove(&screen[state.scr_line],
9D005E78  82330010   LB S3, 16(S1)
9D005E80  00132100   SLL A0, S3, 4
999:                                 &screen[state.scr_line][state.scr_col],CHAR_PER_LINE-state.scr_col);
9D005E7C  82360011   LB S6, 17(S1)
1000:                        state.fsize-=state.scr_col;
9D005EA4  8E0249C4   LW V0, 18884(S0)
1001:                        state.scr_col=0;
9D005EB0  A2200011   SB ZERO, 17(S1)
1002:                        print_line(state.scr_line);
9D005EB4  0F400F00   JAL print_line
1003:                        state.flags.modified=true;
9D005EBC  92220012   LBU V0, 18(S1)
1004:                    }
1005:                }//f()
1006:                
1007:                static void insert_char(char c){
9D0046C4  27BDFFD8   ADDIU SP, SP, -40
9D0046C8  AFBF0024   SW RA, 36(SP)
9D0046CC  AFB30020   SW S3, 32(SP)
9D0046D0  AFB2001C   SW S2, 28(SP)
9D0046D4  AFB10018   SW S1, 24(SP)
9D0046D8  AFB00014   SW S0, 20(SP)
1008:                    if (state.fsize==MAX_SIZE){
9D0046DC  3C02A000   LUI V0, -24576
9D0046E0  8C4349C4   LW V1, 18884(V0)
9D0046E4  3402FFFE   ORI V0, ZERO, -2
9D0046E8  14620006   BNE V1, V0, 0x9D004704
9D0046EC  00809021   ADDU S2, A0, ZERO
1009:                        refused();
9D0046F0  240401F4   ADDIU A0, ZERO, 500
9D0046F4  0F404971   JAL tone
9D0046F8  24050064   ADDIU A1, ZERO, 100
1010:                        return;
9D0046FC  0B40121F   J 0x9D00487C
9D004700  8FBF0024   LW RA, 36(SP)
1011:                    }
1012:                    if (strlen((char*)&screen[state.scr_line])<LINE_MAX_LEN){
9D004704  3C02A000   LUI V0, -24576
9D004708  804249D4   LB V0, 18900(V0)
9D00470C  00021900   SLL V1, V0, 4
9D004710  00021180   SLL V0, V0, 6
9D004714  00621021   ADDU V0, V1, V0
9D004718  3C04A000   LUI A0, -24576
9D00471C  248438C8   ADDIU A0, A0, 14536
9D004720  0F405701   JAL strlen
9D004724  00822021   ADDU A0, A0, V0
9D004728  2C42004F   SLTIU V0, V0, 79
9D00472C  1040002B   BEQ V0, ZERO, 0x9D0047DC
9D004730  3C11A000   LUI S1, -24576
1013:                        sram_write_byte(state.gap_first++,c);
9D004734  263049C4   ADDIU S0, S1, 18884
9D004738  8E040008   LW A0, 8(S0)
9D00473C  24820001   ADDIU V0, A0, 1
9D004740  AE020008   SW V0, 8(S0)
9D004744  325200FF   ANDI S2, S2, 255
9D004748  0F403EFC   JAL sram_write_byte
9D00474C  02402821   ADDU A1, S2, ZERO
1014:                        state.fsize++;
9D004750  8E2249C4   LW V0, 18884(S1)
9D004754  24420001   ADDIU V0, V0, 1
9D004758  AE2249C4   SW V0, 18884(S1)
1015:                        memmove(&screen[state.scr_line][state.scr_col+1],
9D00475C  82110010   LB S1, 16(S0)
9D004760  82020011   LB V0, 17(S0)
9D004764  00119900   SLL S3, S1, 4
9D004768  00111980   SLL V1, S1, 6
9D00476C  02639821   ADDU S3, S3, V1
9D004770  24440001   ADDIU A0, V0, 1
9D004774  02642021   ADDU A0, S3, A0
9D004778  3C03A000   LUI V1, -24576
9D00477C  246338C8   ADDIU V1, V1, 14536
9D004780  02629821   ADDU S3, S3, V0
9D004784  00739821   ADDU S3, V1, S3
9D004788  00642021   ADDU A0, V1, A0
9D00478C  02602821   ADDU A1, S3, ZERO
9D004790  2406004F   ADDIU A2, ZERO, 79
9D004794  0F406324   JAL memmove
9D004798  00C23023   SUBU A2, A2, V0
1016:                                &screen[state.scr_line][state.scr_col],CHAR_PER_LINE-state.scr_col-1);
1017:                        screen[state.scr_line][state.scr_col]=c;
9D00479C  A2720000   SB S2, 0(S3)
1018:                        print_line(state.scr_line);
9D0047A0  0F400F00   JAL print_line
9D0047A4  322400FF   ANDI A0, S1, 255
1019:                        state.scr_col++;
9D0047A8  92040011   LBU A0, 17(S0)
9D0047AC  24840001   ADDIU A0, A0, 1
9D0047B0  7C042420   SEB A0, A0
9D0047B4  A2040011   SB A0, 17(S0)
1020:                        set_curpos(state.scr_col,state.scr_line);
9D0047B8  82050010   LB A1, 16(S0)
9D0047BC  3084FFFF   ANDI A0, A0, -1
9D0047C0  0F402CCF   JAL set_curpos
9D0047C4  30A5FFFF   ANDI A1, A1, -1
1021:                        state.flags.modified=true;
9D0047C8  92020012   LBU V0, 18(S0)
9D0047CC  24030001   ADDIU V1, ZERO, 1
9D0047D0  7C620844   INS V0, V1, 1, 1
9D0047D4  0B40121E   J 0x9D004878
9D0047D8  A2020012   SB V0, 18(S0)
1022:                    }else{
1023:                        sram_write_byte(state.gap_first++,0);
9D0047DC  263049C4   ADDIU S0, S1, 18884
9D0047E0  8E040008   LW A0, 8(S0)
9D0047E4  24820001   ADDIU V0, A0, 1
9D0047E8  AE020008   SW V0, 8(S0)
9D0047EC  0F403EFC   JAL sram_write_byte
9D0047F0  00002821   ADDU A1, ZERO, ZERO
1024:                        sram_write_byte(state.gap_first++,c);
9D0047F4  8E040008   LW A0, 8(S0)
9D0047F8  24820001   ADDIU V0, A0, 1
9D0047FC  AE020008   SW V0, 8(S0)
9D004800  0F403EFC   JAL sram_write_byte
9D004804  324500FF   ANDI A1, S2, 255
1025:                        state.fsize+=2;
9D004808  8E2249C4   LW V0, 18884(S1)
9D00480C  24420002   ADDIU V0, V0, 2
9D004810  AE2249C4   SW V0, 18884(S1)
1026:                        state.scr_col=1;
9D004814  24020001   ADDIU V0, ZERO, 1
9D004818  A2020011   SB V0, 17(S0)
1027:                        state.scr_line++;
9D00481C  92020010   LBU V0, 16(S0)
9D004820  24420001   ADDIU V0, V0, 1
9D004824  7C021420   SEB V0, V0
9D004828  A2020010   SB V0, 16(S0)
1028:                        if (state.scr_line>LAST_LINE){
9D00482C  2842001E   SLTI V0, V0, 30
9D004830  1440000B   BNE V0, ZERO, 0x9D004860
9D004834  3C02A000   LUI V0, -24576
1029:                            state.scr_first+=strlen((char*)&screen[0])+1;
9D004838  3C04A000   LUI A0, -24576
9D00483C  0F405701   JAL strlen
9D004840  248438C8   ADDIU A0, A0, 14536
9D004844  8E040004   LW A0, 4(S0)
9D004848  24840001   ADDIU A0, A0, 1
9D00484C  00821021   ADDU V0, A0, V0
9D004850  AE020004   SW V0, 4(S0)
1030:                            state.scr_line=LAST_LINE;
9D004854  2402001D   ADDIU V0, ZERO, 29
9D004858  A2020010   SB V0, 16(S0)
1031:                        }
1032:                        state.flags.modified=true;
9D00485C  3C02A000   LUI V0, -24576
9D004860  244249C4   ADDIU V0, V0, 18884
9D004864  90430012   LBU V1, 18(V0)
9D004868  24040001   ADDIU A0, ZERO, 1
9D00486C  7C830844   INS V1, A0, 1, 1
1033:                        update_display();
9D004870  0F40107A   JAL update_display
9D004874  A0430012   SB V1, 18(V0)
1034:                    }
1035:                }//f()
9D004878  8FBF0024   LW RA, 36(SP)
9D00487C  8FB30020   LW S3, 32(SP)
9D004880  8FB2001C   LW S2, 28(SP)
9D004884  8FB10018   LW S1, 24(SP)
9D004888  8FB00014   LW S0, 20(SP)
9D00488C  03E00008   JR RA
9D004890  27BD0028   ADDIU SP, SP, 40
1036:                
1037:                static void replace_char(char c){
1038:                    int llen;
1039:                    llen=strlen((char*)&screen[state.scr_line]);
9D005410  3C14A000   LUI S4, -24576
9D005414  269438C8   ADDIU S4, S4, 14536
9D006528  261349C4   ADDIU S3, S0, 18884
9D00652C  82620010   LB V0, 16(S3)
9D006530  00022100   SLL A0, V0, 4
9D006534  00021180   SLL V0, V0, 6
9D006538  00822021   ADDU A0, A0, V0
9D00653C  0F405701   JAL strlen
9D006540  02842021   ADDU A0, S4, A0
1040:                    if (state.scr_col<llen){
9D006544  82630011   LB V1, 17(S3)
9D006548  0062102A   SLT V0, V1, V0
9D00654C  10400022   BEQ V0, ZERO, 0x9D0065D8
9D006550  00000000   NOP
1041:                        sram_write_byte(state.gap_first++,c);
9D006554  8E640008   LW A0, 8(S3)
9D006558  24820001   ADDIU V0, A0, 1
9D00655C  AE620008   SW V0, 8(S3)
9D006560  0F403EFC   JAL sram_write_byte
9D006564  02202821   ADDU A1, S1, ZERO
1042:                        state.tail++;
9D006568  8E62000C   LW V0, 12(S3)
9D00656C  24420001   ADDIU V0, V0, 1
9D006570  AE62000C   SW V0, 12(S3)
1043:                        screen[state.scr_line][state.scr_col]=c;
9D006574  82620010   LB V0, 16(S3)
9D006578  82630011   LB V1, 17(S3)
9D00657C  00022100   SLL A0, V0, 4
9D006580  00021180   SLL V0, V0, 6
9D006584  00821021   ADDU V0, A0, V0
9D006588  00431021   ADDU V0, V0, V1
9D00658C  00541021   ADDU V0, V0, S4
9D006590  A0510000   SB S1, 0(V0)
1044:                        put_char(comm_channel,c);
9D006594  9784803C   LHU A0, -32708(GP)
9D006598  0F402B85   JAL put_char
9D00659C  02C02821   ADDU A1, S6, ZERO
1045:                        state.scr_col++;
9D0065A0  92640011   LBU A0, 17(S3)
9D0065A4  24840001   ADDIU A0, A0, 1
9D0065A8  7C042420   SEB A0, A0
9D0065AC  A2640011   SB A0, 17(S3)
1046:                        state.flags.modified=true;
9D0065B0  92620012   LBU V0, 18(S3)
9D0065B4  24030001   ADDIU V1, ZERO, 1
9D0065B8  7C620844   INS V0, V1, 1, 1
9D0065BC  A2620012   SB V0, 18(S3)
1047:                        set_curpos(state.scr_col,state.scr_line);
9D0065C0  82650010   LB A1, 16(S3)
9D0065C4  3084FFFF   ANDI A0, A0, -1
9D0065C8  0F402CCF   JAL set_curpos
9D0065CC  30A5FFFF   ANDI A1, A1, -1
1048:                    }else{
1049:                        insert_char(c);
9D0065D8  0F4011B1   JAL insert_char
9D0065DC  02C02021   ADDU A0, S6, ZERO
1050:                    }
1051:                }//f();
1052:                
1053:                static void line_home(){
9D0038C4  27BDFFE8   ADDIU SP, SP, -24
9D0038C8  AFBF0014   SW RA, 20(SP)
9D0038CC  AFB00010   SW S0, 16(SP)
1054:                    if (state.scr_col){
9D0038B4  3C02A000   LUI V0, -24576
9D0038B8  804649D5   LB A2, 18901(V0)
9D0038BC  10C0001E   BEQ A2, ZERO, 0x9D003938
9D0038C0  00000000   NOP
1055:                        state.tail-=state.scr_col;
9D0038D0  3C10A000   LUI S0, -24576
9D0038D4  261049C4   ADDIU S0, S0, 18884
9D0038D8  8E04000C   LW A0, 12(S0)
9D0038DC  00862023   SUBU A0, A0, A2
9D0038E0  AE04000C   SW A0, 12(S0)
1056:                        sram_write_block(state.tail,
9D0038F4  3C05A000   LUI A1, -24576
9D0038F8  24A538C8   ADDIU A1, A1, 14536
9D0038FC  0F403F31   JAL sram_write_block
9D003900  00A22821   ADDU A1, A1, V0
1057:                                (uint8_t*)&screen[state.scr_line],state.scr_col);
9D0038E4  82020010   LB V0, 16(S0)
9D0038E8  00021900   SLL V1, V0, 4
9D0038EC  00021180   SLL V0, V0, 6
9D0038F0  00621021   ADDU V0, V1, V0
1058:                        state.gap_first-=state.scr_col;
9D003904  82050011   LB A1, 17(S0)
9D003908  8E040008   LW A0, 8(S0)
9D00390C  00852023   SUBU A0, A0, A1
1059:                        sram_clear_block(state.gap_first,state.scr_col);
9D003910  0F403ED0   JAL sram_clear_block
9D003914  AE040008   SW A0, 8(S0)
1060:                        state.scr_col=0;
9D003918  A2000011   SB ZERO, 17(S0)
1061:                        set_curpos(0,state.scr_line);
9D00391C  82050010   LB A1, 16(S0)
9D003920  00002021   ADDU A0, ZERO, ZERO
9D003924  0F402CCF   JAL set_curpos
9D003928  30A5FFFF   ANDI A1, A1, -1
1062:                    }
1063:                }//f()
9D00392C  8FBF0014   LW RA, 20(SP)
9D003930  8FB00010   LW S0, 16(SP)
9D003934  27BD0018   ADDIU SP, SP, 24
9D003938  03E00008   JR RA
9D00393C  00000000   NOP
1064:                
1065:                static void line_end(){
9D003A58  27BDFFD8   ADDIU SP, SP, -40
9D003A5C  AFBF0024   SW RA, 36(SP)
9D003A60  AFB30020   SW S3, 32(SP)
9D003A64  AFB2001C   SW S2, 28(SP)
9D003A68  AFB10018   SW S1, 24(SP)
9D003A6C  AFB00014   SW S0, 20(SP)
1066:                    uint8_t llen,forward;
1067:                    
1068:                    llen=strlen((char*)&screen[state.scr_line]);
9D003A70  3C11A000   LUI S1, -24576
9D003A74  263149C4   ADDIU S1, S1, 18884
9D003A78  82300010   LB S0, 16(S1)
9D003A7C  00101900   SLL V1, S0, 4
9D003A80  00101180   SLL V0, S0, 6
9D003A84  00621021   ADDU V0, V1, V0
9D003A88  3C04A000   LUI A0, -24576
9D003A8C  248438C8   ADDIU A0, A0, 14536
9D003A90  0F405701   JAL strlen
9D003A94  00822021   ADDU A0, A0, V0
9D003A98  00409821   ADDU S3, V0, ZERO
1069:                    forward=llen-state.scr_col;
9D003A9C  82220011   LB V0, 17(S1)
9D003AA0  02628823   SUBU S1, S3, V0
9D003AA4  323100FF   ANDI S1, S1, 255
1070:                    if (forward){
9D003AA8  1220001D   BEQ S1, ZERO, 0x9D003B20
9D003AAC  8FBF0024   LW RA, 36(SP)
1071:                        sram_write_block(state.gap_first,(uint8_t*)&screen[state.scr_line][state.scr_col],forward);
9D003AB0  3C12A000   LUI S2, -24576
9D003AB4  265249C4   ADDIU S2, S2, 18884
9D003AB8  00101900   SLL V1, S0, 4
9D003ABC  00108180   SLL S0, S0, 6
9D003AC0  00708021   ADDU S0, V1, S0
9D003AC4  02021021   ADDU V0, S0, V0
9D003AC8  8E440008   LW A0, 8(S2)
9D003ACC  3C05A000   LUI A1, -24576
9D003AD0  24A538C8   ADDIU A1, A1, 14536
9D003AD4  00A22821   ADDU A1, A1, V0
9D003AD8  0F403F31   JAL sram_write_block
9D003ADC  02203021   ADDU A2, S1, ZERO
1072:                        state.gap_first+=forward;
9D003AE0  8E420008   LW V0, 8(S2)
9D003AE4  02221021   ADDU V0, S1, V0
9D003AE8  AE420008   SW V0, 8(S2)
1073:                        sram_clear_block(state.tail,forward);
9D003AEC  8E44000C   LW A0, 12(S2)
9D003AF0  0F403ED0   JAL sram_clear_block
9D003AF4  02202821   ADDU A1, S1, ZERO
1074:                        state.tail+=forward;
9D003AF8  8E42000C   LW V0, 12(S2)
9D003AFC  02228821   ADDU S1, S1, V0
9D003B00  AE51000C   SW S1, 12(S2)
1075:                        state.scr_col=llen;
9D003B04  7C132420   SEB A0, S3
9D003B08  A2440011   SB A0, 17(S2)
1076:                        set_curpos(state.scr_col,state.scr_line);
9D003B0C  82450010   LB A1, 16(S2)
9D003B10  3084FFFF   ANDI A0, A0, -1
9D003B14  0F402CCF   JAL set_curpos
9D003B18  30A5FFFF   ANDI A1, A1, -1
1077:                    }
1078:                }//f()
9D003B1C  8FBF0024   LW RA, 36(SP)
9D003B20  8FB30020   LW S3, 32(SP)
9D003B24  8FB2001C   LW S2, 28(SP)
9D003B28  8FB10018   LW S1, 24(SP)
9D003B2C  8FB00014   LW S0, 20(SP)
9D003B30  03E00008   JR RA
9D003B34  27BD0028   ADDIU SP, SP, 40
1079:                
1080:                 static void enter(){
1081:                    if ((state.flags.insert) && (state.fsize==MAX_SIZE)){
9D005ED0  260249C4   ADDIU V0, S0, 18884
9D005ED4  8C420010   LW V0, 16(V0)
9D005ED8  7C420400   EXT V0, V0, 16, 1
9D005EDC  1040000C   BEQ V0, ZERO, 0x9D005F10
9D005EE0  260249C4   ADDIU V0, S0, 18884
9D005EE4  8E0249C4   LW V0, 18884(S0)
9D005EE8  3403FFFE   ORI V1, ZERO, -2
9D005EEC  54430006   BNEL V0, V1, 0x9D005F08
9D005EF0  24420001   ADDIU V0, V0, 1
1082:                        refused();
9D005EF4  240401F4   ADDIU A0, ZERO, 500
9D005EF8  0F404971   JAL tone
9D005EFC  24050064   ADDIU A1, ZERO, 100
1083:                        return;
1084:                    }
1085:                    if (state.flags.insert){
1086:                        state.fsize++;
9D005F08  0B4017C9   J 0x9D005F24
9D005F0C  AE0249C4   SW V0, 18884(S0)
1087:                    }else{
1088:                        sram_write_byte(state.tail++,0);
9D005F10  8C44000C   LW A0, 12(V0)
9D005F14  24830001   ADDIU V1, A0, 1
9D005F18  AC43000C   SW V1, 12(V0)
9D005F1C  0F403EFC   JAL sram_write_byte
9D005F20  00002821   ADDU A1, ZERO, ZERO
1089:                    }
1090:                    sram_write_byte(state.gap_first++,0);
9D005F24  261149C4   ADDIU S1, S0, 18884
9D005F28  8E240008   LW A0, 8(S1)
9D005F2C  24820001   ADDIU V0, A0, 1
9D005F30  AE220008   SW V0, 8(S1)
9D005F34  0F403EFC   JAL sram_write_byte
9D005F38  00002821   ADDU A1, ZERO, ZERO
1091:                    state.scr_col=0;
9D005F3C  A2200011   SB ZERO, 17(S1)
1092:                    state.scr_line++;
9D005F40  82330010   LB S3, 16(S1)
9D005F44  26620001   ADDIU V0, S3, 1
9D005F48  7C021420   SEB V0, V0
1093:                    if (state.scr_line==LINE_PER_SCREEN){
9D005F4C  2403001E   ADDIU V1, ZERO, 30
9D005F50  14430008   BNE V0, V1, 0x9D005F74
9D005F54  A2220010   SB V0, 16(S1)
1094:                        state.scr_first+=strlen((char*)&screen[0])+1;
9D005F58  0F405701   JAL strlen
9D005F5C  02802021   ADDU A0, S4, ZERO
9D005F60  8E240004   LW A0, 4(S1)
9D005F64  24840001   ADDIU A0, A0, 1
9D005F68  00821021   ADDU V0, A0, V0
9D005F6C  AE220004   SW V0, 4(S1)
1095:                        state.scr_line--;
9D005F70  A2330010   SB S3, 16(S1)
1096:                    }
1097:                    update_display();
9D005F74  0F40107A   JAL update_display
9D005F78  00000000   NOP
1098:                }//f()
1099:                
1100:                static void file_home(){
9D004380  27BDFF88   ADDIU SP, SP, -120
9D004384  AFBF0074   SW RA, 116(SP)
9D004388  AFB30070   SW S3, 112(SP)
9D00438C  AFB2006C   SW S2, 108(SP)
9D004390  AFB10068   SW S1, 104(SP)
9D004394  AFB00064   SW S0, 100(SP)
1101:                    uint8_t size, maxlen, line[CHAR_PER_LINE];
1102:                    if (state.fsize==MAX_SIZE){
9D004398  3C02A000   LUI V0, -24576
9D00439C  8C4349C4   LW V1, 18884(V0)
9D0043A0  3402FFFE   ORI V0, ZERO, -2
9D0043A4  14620006   BNE V1, V0, 0x9D0043C0
9D0043A8  3C02A000   LUI V0, -24576
1103:                        state.scr_first=0;
9D0043AC  244249C4   ADDIU V0, V0, 18884
9D0043B0  AC400004   SW ZERO, 4(V0)
1104:                        state.gap_first=0;
9D0043B4  AC400008   SW ZERO, 8(V0)
9D0043B8  0B401112   J 0x9D004448
9D0043BC  AC40000C   SW ZERO, 12(V0)
1105:                        state.tail=0;
1106:                    }else{
1107:                        maxlen=min(CHAR_PER_LINE,state.tail - state.gap_first);
9D0043C0  244249C4   ADDIU V0, V0, 18884
9D0043C4  8C440008   LW A0, 8(V0)
9D0043C8  8C52000C   LW S2, 12(V0)
9D0043CC  02449023   SUBU S2, S2, A0
9D0043D0  2E430051   SLTIU V1, S2, 81
9D0043D4  24020050   ADDIU V0, ZERO, 80
1108:                        while (state.gap_first){
9D0043D8  10800019   BEQ A0, ZERO, 0x9D004440
9D0043DC  0043900A   MOVZ S2, V0, V1
9D004434  8E040008   LW A0, 8(S0)
9D004438  1480FFEC   BNE A0, ZERO, 0x9D0043EC
9D00443C  0244882B   SLTU S1, S2, A0
1109:                            size=min(maxlen,state.gap_first);
9D0043E0  325200FF   ANDI S2, S2, 255
9D0043E8  0244882B   SLTU S1, S2, A0
9D0043EC  02401021   ADDU V0, S2, ZERO
9D0043F0  0091100A   MOVZ V0, A0, S1
1110:                            state.gap_first-=size;
9D0043E4  3C13A000   LUI S3, -24576
9D0043F4  305100FF   ANDI S1, V0, 255
9D0043F8  00912023   SUBU A0, A0, S1
9D0043FC  267049C4   ADDIU S0, S3, 18884
9D004400  AE040008   SW A0, 8(S0)
1111:                            sram_read_block(state.gap_first,line,size);
9D004404  27A50010   ADDIU A1, SP, 16
9D004408  0F403F11   JAL sram_read_block
9D00440C  02203021   ADDU A2, S1, ZERO
1112:                            sram_clear_block(state.gap_first,size);
9D004410  8E040008   LW A0, 8(S0)
9D004414  0F403ED0   JAL sram_clear_block
9D004418  02202821   ADDU A1, S1, ZERO
1113:                            state.tail-=size;
9D00441C  8E04000C   LW A0, 12(S0)
9D004420  00912023   SUBU A0, A0, S1
9D004424  AE04000C   SW A0, 12(S0)
1114:                            sram_write_block(state.tail,line,size);
9D004428  27A50010   ADDIU A1, SP, 16
9D00442C  0F403F31   JAL sram_write_block
9D004430  02203021   ADDU A2, S1, ZERO
1115:                        }
1116:                        state.scr_first=0;
9D004440  3C02A000   LUI V0, -24576
9D004444  AC4049C8   SW ZERO, 18888(V0)
1117:                    }
1118:                    state.scr_col=0;
9D004448  3C02A000   LUI V0, -24576
9D00444C  244249C4   ADDIU V0, V0, 18884
9D004450  A0400011   SB ZERO, 17(V0)
1119:                    state.scr_line=0;
1120:                    update_display();
9D004454  0F40107A   JAL update_display
9D004458  A0400010   SB ZERO, 16(V0)
1121:                }//f()
9D00445C  8FBF0074   LW RA, 116(SP)
9D004460  8FB30070   LW S3, 112(SP)
9D004464  8FB2006C   LW S2, 108(SP)
9D004468  8FB10068   LW S1, 104(SP)
9D00446C  8FB00064   LW S0, 100(SP)
9D004470  03E00008   JR RA
9D004474  27BD0078   ADDIU SP, SP, 120
1122:                
1123:                static void file_end(){
1124:                    int size;
1125:                    uint8_t maxlen, line[CHAR_PER_LINE];
1126:                    
1127:                    if (state.gap_first==state.fsize) return;
9D005AF8  260249C4   ADDIU V0, S0, 18884
9D005AFC  8C530008   LW S3, 8(V0)
9D005B00  8E0249C4   LW V0, 18884(S0)
9D005B04  126202BB   BEQ S3, V0, 0x9D0065F4
9D005B08  3403FFFE   ORI V1, ZERO, -2
1128:                    if (state.fsize==MAX_SIZE){
9D005B0C  14430008   BNE V0, V1, 0x9D005B30
9D005B10  260349C4   ADDIU V1, S0, 18884
1129:                        state.scr_first=MAX_SIZE-1;
9D005B14  260249C4   ADDIU V0, S0, 18884
9D005B18  3403FFFD   ORI V1, ZERO, -3
9D005B1C  AC430004   SW V1, 4(V0)
1130:                        state.gap_first=MAX_SIZE-1;
9D005B20  AC430008   SW V1, 8(V0)
1131:                        state.tail=MAX_SIZE;
9D005B24  3403FFFE   ORI V1, ZERO, -2
9D005B28  0B4016F3   J 0x9D005BCC
9D005B2C  AC43000C   SW V1, 12(V0)
1132:                    }else{
1133:                        maxlen=min(CHAR_PER_LINE,state.tail - state.gap_first);
9D005B30  8C76000C   LW S6, 12(V1)
9D005B34  02D3B023   SUBU S6, S6, S3
9D005B38  2EC40051   SLTIU A0, S6, 81
9D005B3C  24030050   ADDIU V1, ZERO, 80
1134:                        while (state.gap_first < state.fsize){
9D005B40  0262102B   SLTU V0, S3, V0
9D005B44  1040001D   BEQ V0, ZERO, 0x9D005BBC
9D005B48  0064B00A   MOVZ S6, V1, A0
9D005BAC  8E0249C4   LW V0, 18884(S0)
9D005BB0  0262102B   SLTU V0, S3, V0
9D005BB4  1440FFE8   BNE V0, ZERO, 0x9D005B58
9D005BB8  261149C4   ADDIU S1, S0, 18884
1135:                            size=min(maxlen,MAX_SIZE-state.tail);
9D005B4C  32D600FF   ANDI S6, S6, 255
9D005B50  341EFFFE   ORI S8, ZERO, -2
9D005B54  261149C4   ADDIU S1, S0, 18884
9D005B58  8E24000C   LW A0, 12(S1)
9D005B5C  03C41023   SUBU V0, S8, A0
9D005B60  0056982B   SLTU S3, V0, S6
9D005B64  02D3100A   MOVZ V0, S6, S3
9D005B68  00409821   ADDU S3, V0, ZERO
1136:                            sram_read_block(state.tail,line,size);
9D005B6C  27A50018   ADDIU A1, SP, 24
9D005B70  0F403F11   JAL sram_read_block
9D005B74  00403021   ADDU A2, V0, ZERO
1137:                            sram_clear_block(state.tail,size);
9D005B78  8E24000C   LW A0, 12(S1)
9D005B7C  0F403ED0   JAL sram_clear_block
9D005B80  02602821   ADDU A1, S3, ZERO
1138:                            sram_write_block(state.gap_first,line,size);
9D005B84  8E240008   LW A0, 8(S1)
9D005B88  27A50018   ADDIU A1, SP, 24
9D005B8C  0F403F31   JAL sram_write_block
9D005B90  02603021   ADDU A2, S3, ZERO
1139:                            state.tail+=size;
9D005B94  8E22000C   LW V0, 12(S1)
9D005B98  02621021   ADDU V0, S3, V0
9D005B9C  AE22000C   SW V0, 12(S1)
1140:                            state.gap_first+=size;
9D005BA0  8E220008   LW V0, 8(S1)
9D005BA4  02629821   ADDU S3, S3, V0
9D005BA8  AE330008   SW S3, 8(S1)
1141:                        }
1142:                        state.scr_first=state.gap_first;
9D005BBC  260249C4   ADDIU V0, S0, 18884
9D005BC0  AC530004   SW S3, 4(V0)
1143:                        state.scr_col=0;
9D005BC4  A0400011   SB ZERO, 17(V0)
1144:                        state.scr_line=0;
9D005BC8  A0400010   SB ZERO, 16(V0)
1145:                    }
1146:                    update_display();
9D005BCC  0F40107A   JAL update_display
9D005BD0  00000000   NOP
1147:                }//f()
1148:                
1149:                static void page_up(){
1150:                    int i=0;
1151:                
1152:                    while (state.scr_line) line_up();
9D005780  260249C4   ADDIU V0, S0, 18884
9D005784  80420010   LB V0, 16(V0)
9D005788  14400114   BNE V0, ZERO, 0x9D005BDC
9D00578C  260249C4   ADDIU V0, S0, 18884
9D005BDC  0F400F15   JAL line_up
9D005BE0  00000000   NOP
9D005BE4  260249C4   ADDIU V0, S0, 18884
9D005BE8  80420010   LB V0, 16(V0)
9D005BEC  1440FFFB   BNE V0, ZERO, 0x9D005BDC
9D005BF0  260249C4   ADDIU V0, S0, 18884
1153:                    i=LINE_PER_SCREEN;
1154:                //    dis_video=true;
1155:                    while (state.scr_first && i){
9D005790  0B401988   J 0x9D006620
9D005794  8C420004   LW V0, 4(V0)
9D005BF4  0B401988   J 0x9D006620
9D005BF8  8C420004   LW V0, 4(V0)
9D005C04  260249C4   ADDIU V0, S0, 18884
9D005C08  8C420004   LW V0, 4(V0)
9D005C0C  10400279   BEQ V0, ZERO, 0x9D0065F4
9D005C10  2631FFFF   ADDIU S1, S1, -1
9D005C14  1620FFF9   BNE S1, ZERO, 0x9D005BFC
9D005C18  93828050   LBU V0, -32688(GP)
9D005C1C  0B40197E   J 0x9D0065F8
9D005C20  00000000   NOP
9D006620  1040FFF4   BEQ V0, ZERO, 0x9D0065F4
9D006624  2411001E   ADDIU S1, ZERO, 30
9D006628  0B4016FF   J 0x9D005BFC
9D00662C  00000000   NOP
1156:                        line_up();
9D005BFC  0F400F15   JAL line_up
9D005C00  00000000   NOP
1157:                        i--;
1158:                    }
1159:                //    dis_video=false;
1160:                }
1161:                
1162:                static void page_down(){
1163:                     while (state.gap_first<(state.fsize-1) && state.scr_line<LAST_LINE){
9D00574C  260249C4   ADDIU V0, S0, 18884
9D005750  8C420008   LW V0, 8(V0)
9D005754  8E0349C4   LW V1, 18884(S0)
9D005758  2463FFFF   ADDIU V1, V1, -1
9D00575C  0043182B   SLTU V1, V0, V1
9D005760  1060013D   BEQ V1, ZERO, 0x9D005C58
9D005764  260349C4   ADDIU V1, S0, 18884
9D005768  80630010   LB V1, 16(V1)
9D00576C  2863001D   SLTI V1, V1, 29
9D005770  1460012C   BNE V1, ZERO, 0x9D005C24
9D005774  260349C4   ADDIU V1, S0, 18884
9D005C2C  260249C4   ADDIU V0, S0, 18884
9D005C30  8C420008   LW V0, 8(V0)
9D005C34  8E0349C4   LW V1, 18884(S0)
9D005C38  2463FFFF   ADDIU V1, V1, -1
9D005C3C  0043182B   SLTU V1, V0, V1
9D005C40  10600005   BEQ V1, ZERO, 0x9D005C58
9D005C44  260349C4   ADDIU V1, S0, 18884
9D005C48  80630010   LB V1, 16(V1)
9D005C4C  2863001D   SLTI V1, V1, 29
9D005C50  1460FFF4   BNE V1, ZERO, 0x9D005C24
9D005C54  00000000   NOP
1164:                         line_down();
9D005C24  0F401005   JAL line_down
9D005C28  00000000   NOP
1165:                     }
1166:                    if ((state.scr_line==LAST_LINE) && (state.scr_col==0)){
9D005778  0B401718   J 0x9D005C60
9D00577C  94640010   LHU A0, 16(V1)
9D005C58  260349C4   ADDIU V1, S0, 18884
9D005C5C  94640010   LHU A0, 16(V1)
9D005C60  2403001D   ADDIU V1, ZERO, 29
9D005C64  14830003   BNE A0, V1, 0x9D005C74
9D005C68  260349C4   ADDIU V1, S0, 18884
1167:                        state.scr_first=state.gap_first;
9D005C6C  AC620004   SW V0, 4(V1)
1168:                        state.scr_line=0;
9D005C70  A0600010   SB ZERO, 16(V1)
1169:                    }
1170:                    update_display();
9D005C74  0F40107A   JAL update_display
9D005C78  00000000   NOP
1171:                }
1172:                
1173:                
1174:                static void word_right(){
1175:                    uint8_t c, scr_col;
1176:                    uint8_t line[CHAR_PER_LINE];
1177:                    
1178:                    if (state.scr_col==strlen((char*)&screen[state.scr_line])) return;
9D00593C  260249C4   ADDIU V0, S0, 18884
9D005940  80510011   LB S1, 17(V0)
9D005944  80530010   LB S3, 16(V0)
9D005948  00132100   SLL A0, S3, 4
9D00594C  00131180   SLL V0, S3, 6
9D005950  00822021   ADDU A0, A0, V0
9D005954  0F405701   JAL strlen
9D005958  02842021   ADDU A0, S4, A0
9D00595C  12220325   BEQ S1, V0, 0x9D0065F4
9D005960  322300FF   ANDI V1, S1, 255
1179:                    scr_col=state.scr_col;
1180:                    c=screen[state.scr_line][scr_col++];
9D005964  24620001   ADDIU V0, V1, 1
9D005968  00132100   SLL A0, S3, 4
9D00596C  00132980   SLL A1, S3, 6
9D005970  00852021   ADDU A0, A0, A1
9D005974  00831821   ADDU V1, A0, V1
9D005978  00741821   ADDU V1, V1, S4
9D00597C  90630000   LBU V1, 0(V1)
1181:                    if (!isalnum(c)){
9D005980  3C049D01   LUI A0, -25343
9D005984  24846C99   ADDIU A0, A0, 27801
9D005988  00642021   ADDU A0, V1, A0
9D00598C  90840000   LBU A0, 0(A0)
9D005990  30840007   ANDI A0, A0, 7
9D005994  10800005   BEQ A0, ZERO, 0x9D0059AC
9D005998  304200FF   ANDI V0, V0, 255
1182:                        while (c && !isalnum(c)){
9D0059AC  10600023   BEQ V1, ZERO, 0x9D005A3C
9D0059B0  00132100   SLL A0, S3, 4
9D0059BC  3C059D01   LUI A1, -25343
9D0059C0  24A56C99   ADDIU A1, A1, 27801
9D0059D4  1040001A   BEQ V0, ZERO, 0x9D005A40
9D0059D8  306300FF   ANDI V1, V1, 255
9D0059DC  00451021   ADDU V0, V0, A1
9D0059E0  90420000   LBU V0, 0(V0)
9D0059E4  30420007   ANDI V0, V0, 7
9D0059E8  14400015   BNE V0, ZERO, 0x9D005A40
9D0059EC  00601021   ADDU V0, V1, ZERO
9D005A3C  00401821   ADDU V1, V0, ZERO
1183:                            c=screen[state.scr_line][scr_col++];;
9D0059B4  00139980   SLL S3, S3, 6
9D0059B8  00932021   ADDU A0, A0, S3
9D0059C4  24430001   ADDIU V1, V0, 1
9D0059C8  00821021   ADDU V0, A0, V0
9D0059CC  00541021   ADDU V0, V0, S4
9D0059D0  90420000   LBU V0, 0(V0)
9D0059F0  0B401672   J 0x9D0059C8
9D0059F4  24430001   ADDIU V1, V0, 1
1184:                        }
1185:                    }else{
1186:                        while (c  && isalnum(c)){
9D00599C  14600016   BNE V1, ZERO, 0x9D0059F8
9D0059A0  00132100   SLL A0, S3, 4
9D0059A4  0B401690   J 0x9D005A40
9D0059A8  00401821   ADDU V1, V0, ZERO
9D005A00  3C059D01   LUI A1, -25343
9D005A04  24A56C99   ADDIU A1, A1, 27801
9D005A18  10400009   BEQ V0, ZERO, 0x9D005A40
9D005A1C  306300FF   ANDI V1, V1, 255
9D005A20  00451021   ADDU V0, V0, A1
9D005A24  90420000   LBU V0, 0(V0)
9D005A28  30420007   ANDI V0, V0, 7
9D005A2C  10400004   BEQ V0, ZERO, 0x9D005A40
9D005A30  00601021   ADDU V0, V1, ZERO
1187:                            c=screen[state.scr_line][scr_col++];
9D0059F8  00139980   SLL S3, S3, 6
9D0059FC  00932021   ADDU A0, A0, S3
9D005A08  24430001   ADDIU V1, V0, 1
9D005A0C  00821021   ADDU V0, A0, V0
9D005A10  00541021   ADDU V0, V0, S4
9D005A14  90420000   LBU V0, 0(V0)
9D005A34  0B401683   J 0x9D005A0C
9D005A38  24430001   ADDIU V1, V0, 1
1188:                        }    
1189:                    }
1190:                    scr_col--;
9D005A40  2463FFFF   ADDIU V1, V1, -1
9D005A44  307600FF   ANDI S6, V1, 255
1191:                    if (scr_col>state.scr_col){
9D005A48  0236102A   SLT V0, S1, S6
9D005A4C  504002EA   BEQL V0, ZERO, 0x9D0065F8
9D005A50  93828050   LBU V0, -32688(GP)
1192:                        sram_read_block(state.tail,line,scr_col-state.scr_col);
9D005A54  261349C4   ADDIU S3, S0, 18884
9D005A58  8E64000C   LW A0, 12(S3)
9D005A5C  27A50018   ADDIU A1, SP, 24
9D005A60  0F403F11   JAL sram_read_block
9D005A64  02D13023   SUBU A2, S6, S1
1193:                        sram_clear_block(state.tail,scr_col-state.scr_col);
9D005A68  82650011   LB A1, 17(S3)
9D005A6C  8E64000C   LW A0, 12(S3)
9D005A70  0F403ED0   JAL sram_clear_block
9D005A74  02C52823   SUBU A1, S6, A1
1194:                        state.tail+=scr_col-state.scr_col;
9D005A78  82660011   LB A2, 17(S3)
9D005A7C  02C63023   SUBU A2, S6, A2
9D005A80  8E62000C   LW V0, 12(S3)
9D005A84  00C21021   ADDU V0, A2, V0
9D005A88  AE62000C   SW V0, 12(S3)
1195:                        sram_write_block(state.gap_first,line,scr_col-state.scr_col);
9D005A8C  8E640008   LW A0, 8(S3)
9D005A90  0F403F31   JAL sram_write_block
9D005A94  27A50018   ADDIU A1, SP, 24
1196:                        state.gap_first+=scr_col-state.scr_col;
9D005A98  82630011   LB V1, 17(S3)
9D005A9C  02C31823   SUBU V1, S6, V1
9D005AA0  8E620008   LW V0, 8(S3)
9D005AA4  00621021   ADDU V0, V1, V0
9D005AA8  AE620008   SW V0, 8(S3)
1197:                        state.scr_col=scr_col;
9D005AAC  A2760011   SB S6, 17(S3)
1198:                        set_curpos(scr_col,state.scr_line);
9D005AB0  82650010   LB A1, 16(S3)
9D005AB4  02C02021   ADDU A0, S6, ZERO
9D005AB8  0F402CCF   JAL set_curpos
9D005ABC  30A5FFFF   ANDI A1, A1, -1
1199:                    }
1200:                }
1201:                
1202:                static void word_left(){
1203:                    uint8_t c, scr_col, diff;
1204:                    uint8_t line[CHAR_PER_LINE];
1205:                    
1206:                    if (!state.scr_col) return;
9D0057C8  260249C4   ADDIU V0, S0, 18884
9D0057CC  80430011   LB V1, 17(V0)
9D0057D0  50600389   BEQL V1, ZERO, 0x9D0065F8
9D0057D4  93828050   LBU V0, -32688(GP)
1207:                    scr_col=state.scr_col-1;
9D0057D8  306600FF   ANDI A2, V1, 255
9D0057DC  24D1FFFF   ADDIU S1, A2, -1
9D0057E0  323100FF   ANDI S1, S1, 255
1208:                    c=screen[state.scr_line][scr_col];
9D0057E4  80420010   LB V0, 16(V0)
9D0057E8  00022900   SLL A1, V0, 4
9D0057EC  00022180   SLL A0, V0, 6
9D0057F0  00A42021   ADDU A0, A1, A0
9D0057F4  00912021   ADDU A0, A0, S1
9D0057F8  00942021   ADDU A0, A0, S4
1209:                    if (!isalnum(c)){
9D0057FC  90850000   LBU A1, 0(A0)
9D005800  3C049D01   LUI A0, -25343
9D005804  24846C99   ADDIU A0, A0, 27801
9D005808  00A42021   ADDU A0, A1, A0
9D00580C  90840000   LBU A0, 0(A0)
9D005810  30840007   ANDI A0, A0, 7
9D005814  10800005   BEQ A0, ZERO, 0x9D00582C
9D005818  00000000   NOP
1210:                        while (scr_col && !isalnum(c)){
9D00582C  12200023   BEQ S1, ZERO, 0x9D0058BC
9D005830  00022100   SLL A0, V0, 4
9D00583C  3C059D01   LUI A1, -25343
9D005840  24A56C99   ADDIU A1, A1, 27801
9D005854  12200019   BEQ S1, ZERO, 0x9D0058BC
9D005858  90420000   LBU V0, 0(V0)
9D00585C  00451021   ADDU V0, V0, A1
9D005860  90420000   LBU V0, 0(V0)
9D005864  30420007   ANDI V0, V0, 7
9D005868  5040FFF7   BEQL V0, ZERO, 0x9D005848
9D00586C  2631FFFF   ADDIU S1, S1, -1
1211:                           --scr_col;
9D005844  2631FFFF   ADDIU S1, S1, -1
9D005848  323100FF   ANDI S1, S1, 255
1212:                           c=screen[state.scr_line][scr_col];
9D005834  00021180   SLL V0, V0, 6
9D005838  00822021   ADDU A0, A0, V0
9D00584C  00911021   ADDU V0, A0, S1
9D005850  00541021   ADDU V0, V0, S4
1213:                        }
1214:                    }else{
1215:                        while (scr_col && isalnum(c)){
9D00581C  16200016   BNE S1, ZERO, 0x9D005878
9D005820  00022100   SLL A0, V0, 4
9D005880  3C059D01   LUI A1, -25343
9D005884  24A56C99   ADDIU A1, A1, 27801
9D005898  12200008   BEQ S1, ZERO, 0x9D0058BC
9D00589C  90420000   LBU V0, 0(V0)
9D0058A0  00451021   ADDU V0, V0, A1
9D0058A4  90420000   LBU V0, 0(V0)
9D0058A8  30420007   ANDI V0, V0, 7
9D0058AC  5440FFF7   BNEL V0, ZERO, 0x9D00588C
9D0058B0  2631FFFF   ADDIU S1, S1, -1
1216:                           --scr_col;
9D005888  2631FFFF   ADDIU S1, S1, -1
9D00588C  323100FF   ANDI S1, S1, 255
1217:                           c=screen[state.scr_line][scr_col];
9D005878  00021180   SLL V0, V0, 6
9D00587C  00822021   ADDU A0, A0, V0
9D005890  00911021   ADDU V0, A0, S1
9D005894  00541021   ADDU V0, V0, S4
1218:                            
1219:                        }
1220:                    }
1221:                    if (scr_col) scr_col++;
9D005870  0B401986   J 0x9D006618
9D005874  26310001   ADDIU S1, S1, 1
9D0058B4  0B401986   J 0x9D006618
9D0058B8  26310001   ADDIU S1, S1, 1
9D006618  0B40162F   J 0x9D0058BC
9D00661C  323100FF   ANDI S1, S1, 255
1222:                    if (scr_col<state.scr_col){
9D005824  0B401630   J 0x9D0058C0
9D005828  0223182A   SLT V1, S1, V1
9D0058BC  0223182A   SLT V1, S1, V1
9D0058C0  5060034D   BEQL V1, ZERO, 0x9D0065F8
9D0058C4  93828050   LBU V0, -32688(GP)
1223:                        diff=state.scr_col-scr_col;
9D0058C8  00D13023   SUBU A2, A2, S1
1224:                        state.gap_first-=diff;
9D0058CC  30D600FF   ANDI S6, A2, 255
9D0058D0  261349C4   ADDIU S3, S0, 18884
9D0058D4  8E640008   LW A0, 8(S3)
9D0058D8  00962023   SUBU A0, A0, S6
9D0058DC  AE640008   SW A0, 8(S3)
1225:                        sram_read_block(state.gap_first,line,diff);
9D0058E0  27A50018   ADDIU A1, SP, 24
9D0058E4  0F403F11   JAL sram_read_block
9D0058E8  02C03021   ADDU A2, S6, ZERO
1226:                        sram_clear_block(state.gap_first,diff);
9D0058EC  8E640008   LW A0, 8(S3)
9D0058F0  0F403ED0   JAL sram_clear_block
9D0058F4  02C02821   ADDU A1, S6, ZERO
1227:                        state.tail-=diff;
9D0058F8  8E64000C   LW A0, 12(S3)
9D0058FC  00962023   SUBU A0, A0, S6
9D005900  AE64000C   SW A0, 12(S3)
1228:                        sram_write_block(state.tail,line,diff);
9D005904  27A50018   ADDIU A1, SP, 24
9D005908  0F403F31   JAL sram_write_block
9D00590C  02C03021   ADDU A2, S6, ZERO
1229:                        state.scr_col=scr_col;
9D005910  A2710011   SB S1, 17(S3)
1230:                        set_curpos(scr_col,state.scr_line);
9D005914  82650010   LB A1, 16(S3)
9D005918  02202021   ADDU A0, S1, ZERO
9D00591C  0F402CCF   JAL set_curpos
9D005920  30A5FFFF   ANDI A1, A1, -1
1231:                    }
1232:                }
1233:                
1234:                static void jump_to_line(uint16_t line_no){
9D004560  27BDFF80   ADDIU SP, SP, -128
9D004564  AFBF007C   SW RA, 124(SP)
9D004568  AFB60078   SW S6, 120(SP)
9D00456C  AFB50074   SW S5, 116(SP)
9D004570  AFB40070   SW S4, 112(SP)
9D004574  AFB3006C   SW S3, 108(SP)
9D004578  AFB20068   SW S2, 104(SP)
9D00457C  AFB10064   SW S1, 100(SP)
9D004580  AFB00060   SW S0, 96(SP)
1235:                    uint16_t llen,count;
1236:                    uint8_t line[CHAR_PER_LINE];
1237:                    
1238:                    file_home();
9D004584  0F4010E0   JAL file_home
9D004588  0080A021   ADDU S4, A0, ZERO
1239:                    if (!line_no) return;
9D00458C  12800044   BEQ S4, ZERO, 0x9D0046A0
9D004590  8FBF007C   LW RA, 124(SP)
1240:                    line_no--;
9D004594  2694FFFF   ADDIU S4, S4, -1
9D004598  3294FFFF   ANDI S4, S4, -1
1241:                    if (line_no<LINE_PER_SCREEN){
9D00459C  2E82001E   SLTIU V0, S4, 30
9D0045A0  5440000B   BNEL V0, ZERO, 0x9D0045D0
9D0045A4  02808021   ADDU S0, S4, ZERO
1242:                        while(state.scr_line<line_no) line_down();
9D0045D0  3C02A000   LUI V0, -24576
9D0045D4  804249D4   LB V0, 18900(V0)
9D0045D8  0054A02A   SLT S4, V0, S4
9D0045DC  1280002F   BEQ S4, ZERO, 0x9D00469C
9D0045E0  3C11A000   LUI S1, -24576
9D0045E4  0F401005   JAL line_down
9D0045E8  00000000   NOP
9D0045EC  262249C4   ADDIU V0, S1, 18884
9D0045F0  80420010   LB V0, 16(V0)
9D0045F4  0050102A   SLT V0, V0, S0
9D0045F8  1440FFFA   BNE V0, ZERO, 0x9D0045E4
9D0045FC  8FBF007C   LW RA, 124(SP)
9D004600  0B4011A9   J 0x9D0046A4
9D004604  8FB60078   LW S6, 120(SP)
1243:                        return;
1244:                    }
1245:                //    _disable_video();
1246:                    count=0;
1247:                    while ((state.tail<MAX_SIZE) && (count<line_no)){
9D0045A8  3C02A000   LUI V0, -24576
9D0045AC  8C4549D0   LW A1, 18896(V0)
9D0045B0  3402FFFE   ORI V0, ZERO, -2
9D0045B4  00A2102B   SLTU V0, A1, V0
9D0045B8  10400030   BEQ V0, ZERO, 0x9D00467C
9D0045BC  3C02A000   LUI V0, -24576
9D0045C0  16800011   BNE S4, ZERO, 0x9D004608
9D0045C4  00009021   ADDU S2, ZERO, ZERO
9D00460C  3415FFFE   ORI S5, ZERO, -2
9D004664  00B5102B   SLTU V0, A1, S5
9D004668  10400003   BEQ V0, ZERO, 0x9D004678
9D00466C  3252FFFF   ANDI S2, S2, -1
9D004670  1692FFE7   BNE S4, S2, 0x9D004610
9D004674  00000000   NOP
1248:                        llen=get_line_forward(line,state.tail);
9D004610  0F400E50   JAL get_line_forward
9D004614  27A40010   ADDIU A0, SP, 16
9D004618  00408821   ADDU S1, V0, ZERO
1249:                        sram_write_block(state.gap_first,line,llen+1);
9D004608  3C16A000   LUI S6, -24576
9D00461C  24530001   ADDIU S3, V0, 1
9D004620  26D049C4   ADDIU S0, S6, 18884
9D004624  8E040008   LW A0, 8(S0)
9D004628  27A50010   ADDIU A1, SP, 16
9D00462C  0F403F31   JAL sram_write_block
9D004630  02603021   ADDU A2, S3, ZERO
1250:                        state.gap_first+=llen+1;
9D004634  8E020008   LW V0, 8(S0)
9D004638  24420001   ADDIU V0, V0, 1
9D00463C  00511021   ADDU V0, V0, S1
9D004640  AE020008   SW V0, 8(S0)
1251:                        sram_clear_block(state.tail,llen+1);
9D004644  8E04000C   LW A0, 12(S0)
9D004648  0F403ED0   JAL sram_clear_block
9D00464C  02602821   ADDU A1, S3, ZERO
1252:                        state.tail+=llen+1;
9D004650  8E05000C   LW A1, 12(S0)
9D004654  24A50001   ADDIU A1, A1, 1
9D004658  00B12821   ADDU A1, A1, S1
9D00465C  AE05000C   SW A1, 12(S0)
1253:                        count++;
9D004660  26520001   ADDIU S2, S2, 1
1254:                    }
1255:                    state.scr_first=state.gap_first;
9D0045C8  0B4011A0   J 0x9D004680
9D0045CC  244249C4   ADDIU V0, V0, 18884
9D004678  3C02A000   LUI V0, -24576
9D00467C  244249C4   ADDIU V0, V0, 18884
9D004680  8C430008   LW V1, 8(V0)
9D004684  AC430004   SW V1, 4(V0)
1256:                    set_curpos(0,0);
9D004688  00002021   ADDU A0, ZERO, ZERO
9D00468C  0F402CCF   JAL set_curpos
9D004690  00002821   ADDU A1, ZERO, ZERO
1257:                    update_display();
9D004694  0F40107A   JAL update_display
9D004698  00000000   NOP
1258:                }//f
9D00469C  8FBF007C   LW RA, 124(SP)
9D0046A0  8FB60078   LW S6, 120(SP)
9D0046A4  8FB50074   LW S5, 116(SP)
9D0046A8  8FB40070   LW S4, 112(SP)
9D0046AC  8FB3006C   LW S3, 108(SP)
9D0046B0  8FB20068   LW S2, 104(SP)
9D0046B4  8FB10064   LW S1, 100(SP)
9D0046B8  8FB00060   LW S0, 96(SP)
9D0046BC  03E00008   JR RA
9D0046C0  27BD0080   ADDIU SP, SP, 128
1259:                
1260:                static void goto_line(){
1261:                    uint8_t llen;
1262:                    char line[16];
1263:                    uint16_t line_no=0;
1264:                    
1265:                    invert_video(true);
9D0062F8  0F402DE2   JAL invert_video
9D0062FC  24040001   ADDIU A0, ZERO, 1
1266:                    set_curpos(0,0);
9D006300  00002021   ADDU A0, ZERO, ZERO
9D006304  0F402CCF   JAL set_curpos
9D006308  00002821   ADDU A1, ZERO, ZERO
1267:                    clear_eol();
9D00630C  0F402C98   JAL clear_eol
9D006310  00000000   NOP
1268:                    print(comm_channel,"goto line: ");
9D006314  9784803C   LHU A0, -32708(GP)
9D006318  3C059D01   LUI A1, -25343
9D00631C  0F402C18   JAL print
9D006320  24A52CEC   ADDIU A1, A1, 11500
1269:                    llen=readline(comm_channel,line,16);
9D006324  9784803C   LHU A0, -32708(GP)
9D006328  27A50018   ADDIU A1, SP, 24
9D00632C  0F402D9D   JAL readline
9D006330  24060010   ADDIU A2, ZERO, 16
9D006334  00408821   ADDU S1, V0, ZERO
1270:                    invert_video(false);
9D006338  0F402DE2   JAL invert_video
9D00633C  00002021   ADDU A0, ZERO, ZERO
1271:                    if (llen){
9D006340  12200007   BEQ S1, ZERO, 0x9D006360
9D006344  00000000   NOP
1272:                        line_no=atoi((const char*)line);
9D006348  0F406080   JAL atoi
9D00634C  27A40018   ADDIU A0, SP, 24
1273:                        jump_to_line(line_no);
9D006350  0F401158   JAL jump_to_line
9D006354  3044FFFF   ANDI A0, V0, -1
1274:                    }else{
1275:                        print_line(0);
9D006360  0F400F00   JAL print_line
9D006364  00002021   ADDU A0, ZERO, ZERO
9D006368  0B40197E   J 0x9D0065F8
9D00636C  93828050   LBU V0, -32688(GP)
9D006370  0F402DE2   JAL invert_video
9D006374  24040001   ADDIU A0, ZERO, 1
9D006378  0F402B6F   JAL clear_screen
9D00637C  00000000   NOP
9D006380  3C02A000   LUI V0, -24576
9D006384  8C454AF4   LW A1, 19188(V0)
9D006388  80A20000   LB V0, 0(A1)
9D00638C  10400008   BEQ V0, ZERO, 0x9D0063B0
9D006390  3C11A000   LUI S1, -24576
9D006394  26314AF8   ADDIU S1, S1, 19192
9D006398  0F402C18   JAL print
9D00639C  9784803C   LHU A0, -32708(GP)
9D0063A0  8E250000   LW A1, 0(S1)
9D0063A4  80A20000   LB V0, 0(A1)
9D0063A8  1440FFFB   BNE V0, ZERO, 0x9D006398
9D0063AC  26310004   ADDIU S1, S1, 4
9D0063B0  0F402B60   JAL crlf
9D0063B4  00000000   NOP
9D0063B8  0F400E07   JAL prompt_continue
9D0063BC  00000000   NOP
9D0063C0  0F402DE2   JAL invert_video
9D0063C4  00002021   ADDU A0, ZERO, ZERO
9D0063C8  0F40107A   JAL update_display
9D0063CC  00000000   NOP
9D0063D0  0B40197E   J 0x9D0065F8
9D0063D4  93828050   LBU V0, -32688(GP)
9D0063D8  0F401225   JAL new_file
9D0063DC  00000000   NOP
9D0063E0  0B40197E   J 0x9D0065F8
9D0063E4  93828050   LBU V0, -32688(GP)
9D0063E8  0F400FA5   JAL ask_confirm
9D0063EC  00000000   NOP
9D0063F0  10400081   BEQ V0, ZERO, 0x9D0065F8
9D0063F4  93828050   LBU V0, -32688(GP)
9D0063F8  0F402DE2   JAL invert_video
9D0063FC  24040001   ADDIU A0, ZERO, 1
9D006400  0F402B6F   JAL clear_screen
9D006404  00000000   NOP
9D006408  9784803C   LHU A0, -32708(GP)
9D00640C  3C059D01   LUI A1, -25343
9D006410  0F402C18   JAL print
9D006414  24A52CF8   ADDIU A1, A1, 11512
9D006418  0F40141D   JAL get_file_name
9D00641C  27A40068   ADDIU A0, SP, 104
9D006420  1040000F   BEQ V0, ZERO, 0x9D006460
9D006424  27A40018   ADDIU A0, SP, 24
9D006428  27A50068   ADDIU A1, SP, 104
9D00642C  0F400664   JAL f_open
9D006430  24060001   ADDIU A2, ZERO, 1
9D006434  14400007   BNE V0, ZERO, 0x9D006454
9D006438  3C049D01   LUI A0, -25343
9D00643C  0F4008D2   JAL f_close
9D006440  27A40018   ADDIU A0, SP, 24
9D006444  0F401253   JAL load_file
9D006448  27A40068   ADDIU A0, SP, 104
9D00644C  0B40197E   J 0x9D0065F8
9D006450  93828050   LBU V0, -32688(GP)
9D006454  24842D04   ADDIU A0, A0, 11524
9D006458  0F400E12   JAL ed_error
9D00645C  00402821   ADDU A1, V0, ZERO
9D006460  0F402DE2   JAL invert_video
9D006464  00002021   ADDU A0, ZERO, ZERO
9D006468  0F402B6F   JAL clear_screen
9D00646C  00000000   NOP
9D006470  0F40107A   JAL update_display
9D006474  00000000   NOP
9D006478  0B40197E   J 0x9D0065F8
9D00647C  93828050   LBU V0, -32688(GP)
9D006480  0F400FA5   JAL ask_confirm
9D006484  00000000   NOP
9D006488  1040005B   BEQ V0, ZERO, 0x9D0065F8
9D00648C  93828050   LBU V0, -32688(GP)
9D006490  0F402D63   JAL set_cursor
9D006494  00002021   ADDU A0, ZERO, ZERO
9D006498  24020001   ADDIU V0, ZERO, 1
9D00649C  0B401980   J 0x9D006600
9D0064A0  A3828050   SB V0, -32688(GP)
9D0064A4  0F402DE2   JAL invert_video
9D0064A8  24040001   ADDIU A0, ZERO, 1
9D0064AC  0F402B6F   JAL clear_screen
9D0064B0  00000000   NOP
9D0064B4  3C03A000   LUI V1, -24576
9D0064B8  806249A4   LB V0, 18852(V1)
9D0064BC  10400005   BEQ V0, ZERO, 0x9D0064D4
9D0064C0  00000000   NOP
9D0064C4  0F40143A   JAL save_file
9D0064C8  00000000   NOP
9D0064CC  0B401937   J 0x9D0064DC
9D0064D0  00000000   NOP
9D0064D4  0F4014CC   JAL save_file_as
9D0064D8  00000000   NOP
9D0064DC  0F402DE2   JAL invert_video
9D0064E0  00002021   ADDU A0, ZERO, ZERO
9D0064E4  0F40107A   JAL update_display
9D0064E8  00000000   NOP
9D0064EC  0B40197E   J 0x9D0065F8
9D0064F0  93828050   LBU V0, -32688(GP)
9D0064F4  2622FFE0   ADDIU V0, S1, -32
9D0064F8  3042FFFF   ANDI V0, V0, -1
9D0064FC  2C420060   SLTIU V0, V0, 96
9D006500  10400039   BEQ V0, ZERO, 0x9D0065E8
9D006504  260249C4   ADDIU V0, S0, 18884
9D006508  8C420010   LW V0, 16(V0)
9D00650C  7C420400   EXT V0, V0, 16, 1
9D006510  10400005   BEQ V0, ZERO, 0x9D006528
9D006514  7C11B420   SEB S6, S1
9D006518  0F4011B1   JAL insert_char
9D00651C  7C112420   SEB A0, S1
9D006520  0B40197E   J 0x9D0065F8
9D006524  93828050   LBU V0, -32688(GP)
9D006528  261349C4   ADDIU S3, S0, 18884
9D00652C  82620010   LB V0, 16(S3)
9D006530  00022100   SLL A0, V0, 4
9D006534  00021180   SLL V0, V0, 6
9D006538  00822021   ADDU A0, A0, V0
9D00653C  0F405701   JAL strlen
9D006540  02842021   ADDU A0, S4, A0
9D006544  82630011   LB V1, 17(S3)
9D006548  0062102A   SLT V0, V1, V0
9D00654C  10400022   BEQ V0, ZERO, 0x9D0065D8
9D006550  00000000   NOP
9D006554  8E640008   LW A0, 8(S3)
9D006558  24820001   ADDIU V0, A0, 1
9D00655C  AE620008   SW V0, 8(S3)
9D006560  0F403EFC   JAL sram_write_byte
9D006564  02202821   ADDU A1, S1, ZERO
9D006568  8E62000C   LW V0, 12(S3)
9D00656C  24420001   ADDIU V0, V0, 1
9D006570  AE62000C   SW V0, 12(S3)
9D006574  82620010   LB V0, 16(S3)
9D006578  82630011   LB V1, 17(S3)
9D00657C  00022100   SLL A0, V0, 4
9D006580  00021180   SLL V0, V0, 6
9D006584  00821021   ADDU V0, A0, V0
9D006588  00431021   ADDU V0, V0, V1
9D00658C  00541021   ADDU V0, V0, S4
9D006590  A0510000   SB S1, 0(V0)
9D006594  9784803C   LHU A0, -32708(GP)
9D006598  0F402B85   JAL put_char
9D00659C  02C02821   ADDU A1, S6, ZERO
9D0065A0  92640011   LBU A0, 17(S3)
9D0065A4  24840001   ADDIU A0, A0, 1
9D0065A8  7C042420   SEB A0, A0
9D0065AC  A2640011   SB A0, 17(S3)
9D0065B0  92620012   LBU V0, 18(S3)
9D0065B4  24030001   ADDIU V1, ZERO, 1
9D0065B8  7C620844   INS V0, V1, 1, 1
9D0065BC  A2620012   SB V0, 18(S3)
9D0065C0  82650010   LB A1, 16(S3)
9D0065C4  3084FFFF   ANDI A0, A0, -1
9D0065C8  0F402CCF   JAL set_curpos
9D0065CC  30A5FFFF   ANDI A1, A1, -1
9D0065D0  0B40197E   J 0x9D0065F8
9D0065D4  93828050   LBU V0, -32688(GP)
9D0065D8  0F4011B1   JAL insert_char
9D0065DC  02C02021   ADDU A0, S6, ZERO
9D0065E0  0B40197E   J 0x9D0065F8
9D0065E4  93828050   LBU V0, -32688(GP)
9D0065E8  240401F4   ADDIU A0, ZERO, 500
9D0065EC  0F404971   JAL tone
9D0065F0  24050064   ADDIU A1, ZERO, 100
9D0065F4  93828050   LBU V0, -32688(GP)
9D0065F8  1040FB8B   BEQ V0, ZERO, 0x9D005428
9D0065FC  00000000   NOP
9D006600  0F402DE2   JAL invert_video
9D006604  00002021   ADDU A0, ZERO, ZERO
9D006608  0F402B6F   JAL clear_screen
9D00660C  00000000   NOP
9D006610  0B40198C   J 0x9D006630
9D006614  8FBF00B4   LW RA, 180(SP)
9D006618  0B40162F   J 0x9D0058BC
9D00661C  323100FF   ANDI S1, S1, 255
9D006620  1040FFF4   BEQ V0, ZERO, 0x9D0065F4
9D006624  2411001E   ADDIU S1, ZERO, 30
9D006628  0B4016FF   J 0x9D005BFC
9D00662C  00000000   NOP
9D006630  8FBE00B0   LW S8, 176(SP)
9D006634  8FB700AC   LW S7, 172(SP)
9D006638  8FB600A8   LW S6, 168(SP)
9D00663C  8FB500A4   LW S5, 164(SP)
9D006640  8FB400A0   LW S4, 160(SP)
9D006644  8FB3009C   LW S3, 156(SP)
9D006648  8FB20098   LW S2, 152(SP)
9D00664C  8FB10094   LW S1, 148(SP)
9D006650  8FB00090   LW S0, 144(SP)
9D006654  03E00008   JR RA
9D006658  27BD00B8   ADDIU SP, SP, 184
1276:                    }
1277:                    
1278:                }
---  /home/jacques/github/vpc-32vga/console.c  ----------------------------------------------------------
1:                   /*
2:                   * Copyright 2013,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   *  Name: console.c
21:                   *  Description: text console for NTSC video output
22:                   *  Author: Jacques Deschênes
23:                   *  Date Created: 2013-09-06
24:                   *  rev: 2017-08-02
25:                   */
26:                  
27:                  #include <string.h>
28:                  #include "console.h"
29:                  #include "hardware/HardwareProfile.h"
30:                  #include "hardware/serial_comm/serial_comm.h"
31:                  #include "hardware/ps2_kbd/keyboard.h"
32:                  
33:                  
34:                  // indicateurs booléens
35:                  #define CUR_SHOW 1  // curseur actif
36:                  #define CUR_VIS  2  // curseur visible
37:                  #define INV_VID  4  // inverse vidéo
38:                  
39:                  
40:                  static unsigned short cx=0, cy=0;  // coordonnée courante du curseur texte en pixels.
41:                  static unsigned char tab_width=TAB_WIDTH;
42:                  static cursor_t cur_shape=CR_UNDER;
43:                  static unsigned short flags=0;
44:                  
45:                  dev_t comm_channel=LOCAL_CON;
46:                  
47:                  
48:                  void scroll_up(void){
9D00ABDC  27BDFFE8   ADDIU SP, SP, -24
9D00ABE0  AFBF0014   SW RA, 20(SP)
49:                      char *src, *dst;
50:                      dst = (char*)video_bmp;
51:                      src = (char*)video_bmp +(CHAR_HEIGHT)*HRES/8;
52:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*HRES/8);
9D00ABE4  3C04A000   LUI A0, -24576
9D00ABE8  24840070   ADDIU A0, A0, 112
9D00ABEC  3C05A000   LUI A1, -24576
9D00ABF0  24A50250   ADDIU A1, A1, 592
9D00ABF4  0F406324   JAL memmove
9D00ABF8  24063660   ADDIU A2, ZERO, 13920
53:                      dst= (char*)video_bmp+(CHAR_HEIGHT*(LINE_PER_SCREEN-1))*HRES/8;
54:                      memset(dst,0,HRES/8*CHAR_HEIGHT);
9D00ABFC  3C04A000   LUI A0, -24576
9D00AC00  248436D0   ADDIU A0, A0, 14032
9D00AC04  00002821   ADDU A1, ZERO, ZERO
9D00AC08  0F406056   JAL memset
9D00AC0C  240601E0   ADDIU A2, ZERO, 480
55:                  }//scroll_up();
9D00AC10  8FBF0014   LW RA, 20(SP)
9D00AC14  03E00008   JR RA
9D00AC18  27BD0018   ADDIU SP, SP, 24
56:                  
57:                  void scroll_down(void){
9D00AC1C  27BDFFE8   ADDIU SP, SP, -24
9D00AC20  AFBF0014   SW RA, 20(SP)
9D00AC24  AFB00010   SW S0, 16(SP)
58:                      char *src, *dst;
59:                      src = (char*)video_bmp;
60:                      dst = (char*)video_bmp+(CHAR_HEIGHT)*HRES/8;
61:                      memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*HRES/8);
9D00AC28  3C04A000   LUI A0, -24576
9D00AC2C  24840250   ADDIU A0, A0, 592
9D00AC30  3C10A000   LUI S0, -24576
9D00AC34  26050070   ADDIU A1, S0, 112
9D00AC38  0F406324   JAL memmove
9D00AC3C  24063660   ADDIU A2, ZERO, 13920
62:                      dst=(char*)video_bmp;
63:                      memset(dst,0,HRES/8*CHAR_HEIGHT);
9D00AC40  26040070   ADDIU A0, S0, 112
9D00AC44  00002821   ADDU A1, ZERO, ZERO
9D00AC48  0F406056   JAL memset
9D00AC4C  240601E0   ADDIU A2, ZERO, 480
64:                  }//scroll_down()
9D00AC50  8FBF0014   LW RA, 20(SP)
9D00AC54  8FB00010   LW S0, 16(SP)
9D00AC58  03E00008   JR RA
9D00AC5C  27BD0018   ADDIU SP, SP, 24
65:                  
66:                  
67:                  void cursor_right(void){
9D00AC60  27BDFFE8   ADDIU SP, SP, -24
9D00AC64  AFBF0014   SW RA, 20(SP)
9D00AC68  AFB00010   SW S0, 16(SP)
68:                      cx += CHAR_WIDTH;
9D00AC6C  97828046   LHU V0, -32698(GP)
9D00AC70  24420006   ADDIU V0, V0, 6
9D00AC74  3042FFFF   ANDI V0, V0, -1
9D00AC84  0B402B2D   J 0x9D00ACB4
9D00AC88  A7828046   SH V0, -32698(GP)
69:                      if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
9D00AC78  2C4301E0   SLTIU V1, V0, 480
9D00AC7C  50600003   BEQL V1, ZERO, 0x9D00AC8C
9D00AC80  A7808046   SH ZERO, -32698(GP)
70:                          cx = 0;
71:                          cy += CHAR_HEIGHT;
9D00AC8C  97908044   LHU S0, -32700(GP)
9D00AC90  26020008   ADDIU V0, S0, 8
9D00AC94  3042FFFF   ANDI V0, V0, -1
9D00AC98  A7828044   SH V0, -32700(GP)
72:                          if (cy>=((LINE_PER_SCREEN-1)*CHAR_HEIGHT)){
9D00AC9C  2C4200E8   SLTIU V0, V0, 232
9D00ACA0  14400005   BNE V0, ZERO, 0x9D00ACB8
9D00ACA4  8FBF0014   LW RA, 20(SP)
73:                              scroll_up();
9D00ACA8  0F402AF7   JAL scroll_up
9D00ACAC  00000000   NOP
74:                              cy -= CHAR_HEIGHT;
9D00ACB0  A7908044   SH S0, -32700(GP)
75:                          }
76:                      }
77:                  } // cursor_right()
9D00ACB4  8FBF0014   LW RA, 20(SP)
9D00ACB8  8FB00010   LW S0, 16(SP)
9D00ACBC  03E00008   JR RA
9D00ACC0  27BD0018   ADDIU SP, SP, 24
78:                  
79:                  void cursor_left(void){
9D00ACC4  27BDFFE8   ADDIU SP, SP, -24
9D00ACC8  AFBF0014   SW RA, 20(SP)
80:                      if (cx>=(CHAR_WIDTH)){
9D00ACCC  97828046   LHU V0, -32698(GP)
9D00ACD0  2C430006   SLTIU V1, V0, 6
9D00ACD4  54600004   BNEL V1, ZERO, 0x9D00ACE8
9D00ACD8  2402004F   ADDIU V0, ZERO, 79
81:                          cx -= CHAR_WIDTH;
9D00ACDC  2442FFFA   ADDIU V0, V0, -6
9D00ACE0  0B402B43   J 0x9D00AD0C
9D00ACE4  A7828046   SH V0, -32698(GP)
82:                      }else{
83:                          cx = (CHAR_PER_LINE-1);
9D00ACE8  A7828046   SH V0, -32698(GP)
84:                          if (cy>=CHAR_HEIGHT){
9D00ACEC  97828044   LHU V0, -32700(GP)
9D00ACF0  2C430008   SLTIU V1, V0, 8
9D00ACF4  14600003   BNE V1, ZERO, 0x9D00AD04
9D00ACF8  2442FFF8   ADDIU V0, V0, -8
9D00ACFC  0B402B43   J 0x9D00AD0C
9D00AD00  A7828044   SH V0, -32700(GP)
85:                              cy -= CHAR_HEIGHT;
86:                          }else{
87:                              scroll_down();
9D00AD04  0F402B07   JAL scroll_down
9D00AD08  00000000   NOP
88:                          }
89:                      }
90:                  }// cursor_left()
9D00AD0C  8FBF0014   LW RA, 20(SP)
9D00AD10  03E00008   JR RA
9D00AD14  27BD0018   ADDIU SP, SP, 24
91:                  
92:                  void cursor_up(void){
9D00AD18  27BDFFE8   ADDIU SP, SP, -24
9D00AD1C  AFBF0014   SW RA, 20(SP)
93:                      if (cy>=CHAR_HEIGHT){
9D00AD20  97828044   LHU V0, -32700(GP)
9D00AD24  2C430008   SLTIU V1, V0, 8
9D00AD28  14600003   BNE V1, ZERO, 0x9D00AD38
9D00AD2C  2442FFF8   ADDIU V0, V0, -8
9D00AD30  0B402B50   J 0x9D00AD40
9D00AD34  A7828044   SH V0, -32700(GP)
94:                          cy -= CHAR_HEIGHT;
95:                      }else{
96:                          scroll_down();
9D00AD38  0F402B07   JAL scroll_down
9D00AD3C  00000000   NOP
97:                      }
98:                  }// cursor_up()
9D00AD40  8FBF0014   LW RA, 20(SP)
9D00AD44  03E00008   JR RA
9D00AD48  27BD0018   ADDIU SP, SP, 24
99:                  
100:                 void cursor_down(void){
9D00AD4C  27BDFFE8   ADDIU SP, SP, -24
9D00AD50  AFBF0014   SW RA, 20(SP)
101:                     if (cy<=((CHAR_HEIGHT*(LINE_PER_SCREEN-2)))){
9D00AD54  97828044   LHU V0, -32700(GP)
9D00AD58  2C4300E1   SLTIU V1, V0, 225
9D00AD5C  10600003   BEQ V1, ZERO, 0x9D00AD6C
9D00AD60  24420008   ADDIU V0, V0, 8
9D00AD64  0B402B5D   J 0x9D00AD74
9D00AD68  A7828044   SH V0, -32700(GP)
102:                         cy += CHAR_HEIGHT;
103:                     }else{
104:                         scroll_up();
9D00AD6C  0F402AF7   JAL scroll_up
9D00AD70  00000000   NOP
105:                     }
106:                 }//cursor_down()
9D00AD74  8FBF0014   LW RA, 20(SP)
9D00AD78  03E00008   JR RA
9D00AD7C  27BD0018   ADDIU SP, SP, 24
107:                 
108:                 void crlf(void){
9D00AD80  27BDFFE8   ADDIU SP, SP, -24
9D00AD84  AFBF0014   SW RA, 20(SP)
109:                     cx=0;
9D00AD88  A7808046   SH ZERO, -32698(GP)
110:                     if (cy==((LINE_PER_SCREEN-1)*CHAR_HEIGHT)){
9D00AD8C  97828044   LHU V0, -32700(GP)
9D00AD90  240300E8   ADDIU V1, ZERO, 232
9D00AD94  14430005   BNE V0, V1, 0x9D00ADAC
9D00AD98  24420008   ADDIU V0, V0, 8
111:                         scroll_up();
9D00AD9C  0F402AF7   JAL scroll_up
9D00ADA0  00000000   NOP
9D00ADA4  0B402B6D   J 0x9D00ADB4
9D00ADA8  8FBF0014   LW RA, 20(SP)
112:                     }else{
113:                         cy += CHAR_HEIGHT;
9D00ADAC  A7828044   SH V0, -32700(GP)
114:                     }
115:                 }//crlf()
9D00ADB0  8FBF0014   LW RA, 20(SP)
9D00ADB4  03E00008   JR RA
9D00ADB8  27BD0018   ADDIU SP, SP, 24
116:                 
117:                 void put_char(dev_t channel, char c){
9D00AE14  27BDFFE8   ADDIU SP, SP, -24
9D00AE18  AFBF0014   SW RA, 20(SP)
118:                     register int i,l,r,b,x,y;
119:                     x=cx;
9D00AE1C  97838046   LHU V1, -32698(GP)
120:                     y=cy;
121:                     if (channel==LOCAL_CON){
9D00AE20  1480008A   BNE A0, ZERO, 0x9D00B04C
9D00AE24  97868044   LHU A2, -32700(GP)
122:                         switch (c){
9D00AE28  24A2FFF8   ADDIU V0, A1, -8
9D00AE2C  304400FF   ANDI A0, V0, 255
9D00AE30  2C840006   SLTIU A0, A0, 6
9D00AE34  1080002E   BEQ A0, ZERO, 0x9D00AEF0
9D00AE38  304200FF   ANDI V0, V0, 255
9D00AE3C  00021080   SLL V0, V0, 2
9D00AE40  3C049D01   LUI A0, -25343
9D00AE44  2484AE58   ADDIU A0, A0, -20904
9D00AE48  00821021   ADDU V0, A0, V0
9D00AE4C  8C420000   LW V0, 0(V0)
9D00AE50  00400008   JR V0
9D00AE54  00000000   NOP
123:                             case CR:
124:                             case NL:
125:                                 crlf();
9D00AE70  0F402B60   JAL crlf
9D00AE74  00000000   NOP
126:                                 break;
9D00AE78  0B402C16   J 0x9D00B058
9D00AE7C  8FBF0014   LW RA, 20(SP)
127:                             case TAB:
128:                                 cx += (cx%tab_width);
9D00AE80  93828011   LBU V0, -32751(GP)
9D00AE84  0062001A   DIV V1, V0
9D00AE88  004001F4   TEQ V0, ZERO
9D00AE8C  00002010   MFHI A0
9D00AE90  00641821   ADDU V1, V1, A0
9D00AE94  3063FFFF   ANDI V1, V1, -1
9D00AEA4  0B402C15   J 0x9D00B054
9D00AEA8  A7838046   SH V1, -32698(GP)
129:                                 if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
9D00AE98  2C6201E0   SLTIU V0, V1, 480
9D00AE9C  10400003   BEQ V0, ZERO, 0x9D00AEAC
9D00AEA0  240200E8   ADDIU V0, ZERO, 232
130:                                     cx = 0;
131:                                     if (cy==((LINE_PER_SCREEN-1)*CHAR_HEIGHT)){
9D00AEAC  14C20005   BNE A2, V0, 0x9D00AEC4
9D00AEB0  A7808046   SH ZERO, -32698(GP)
132:                                         scroll_up();
9D00AEB4  0F402AF7   JAL scroll_up
9D00AEB8  00000000   NOP
9D00AEBC  0B402C16   J 0x9D00B058
9D00AEC0  8FBF0014   LW RA, 20(SP)
133:                                     }else{
134:                                         cy += CHAR_HEIGHT;
9D00AEC4  24C60008   ADDIU A2, A2, 8
9D00AEC8  0B402C15   J 0x9D00B054
9D00AECC  A7868044   SH A2, -32700(GP)
135:                                     }
136:                                 }
137:                                 break;
138:                             case FF:
139:                                 clear_screen();
9D00AED0  0F402B6F   JAL clear_screen
9D00AED4  00000000   NOP
140:                                 break;
9D00AED8  0B402C16   J 0x9D00B058
9D00AEDC  8FBF0014   LW RA, 20(SP)
141:                             case '\b':
142:                                 cursor_left();
9D00AEE0  0F402B31   JAL cursor_left
9D00AEE4  00000000   NOP
143:                                 break;
9D00AEE8  0B402C16   J 0x9D00B058
9D00AEEC  8FBF0014   LW RA, 20(SP)
144:                             default:
145:                                 if ((c<32) || (c>(FONT_SIZE+32))) break;
9D00AEF0  28A20020   SLTI V0, A1, 32
9D00AEF4  14400057   BNE V0, ZERO, 0x9D00B054
9D00AEF8  24A5FFE0   ADDIU A1, A1, -32
146:                                 c -=32;
9D00AEFC  7C052C20   SEB A1, A1
147:                                 b=x>>5; // position index ligne video_bmp
9D00AF00  00031143   SRA V0, V1, 5
148:                                 r=0;
149:                                 l=(32-CHAR_WIDTH)-(x&0x1f); // décalage  à l'intérieur de l'entier
9D00AF04  3063001F   ANDI V1, V1, 31
9D00AF08  2409001A   ADDIU T1, ZERO, 26
9D00AF0C  01234823   SUBU T1, T1, V1
150:                                 if (l<0){
151:                                     r=-l;
9D00AF10  00091823   SUBU V1, ZERO, T1
9D00AF14  29270000   SLTI A3, T1, 0
9D00AF18  0007180A   MOVZ V1, ZERO, A3
9D00AF1C  00603821   ADDU A3, V1, ZERO
152:                                 }
153:                                 for (i=0;i<8;i++){
9D00B034  1466FFD3   BNE V1, A2, 0x9D00AF84
9D00B038  24840001   ADDIU A0, A0, 1
154:                                     if (r){
9D00AF84  10E0001B   BEQ A3, ZERO, 0x9D00AFF4
9D00AF88  00000000   NOP
155:                                         if (flags & INV_VID){
9D00AF20  9788803E   LHU T0, -32706(GP)
9D00AF24  31080004   ANDI T0, T0, 4
9D00AF28  3108FFFF   ANDI T0, T0, -1
9D00AF8C  1100000E   BEQ T0, ZERO, 0x9D00AFC8
9D00AF90  90850000   LBU A1, 0(A0)
156:                                             video_bmp[y][b] |= (0x3f>>r);
9D00AF2C  240C003F   ADDIU T4, ZERO, 63
9D00AF30  006C7007   SRAV T6, T4, V1
9D00AF9C  8C4B0000   LW T3, 0(V0)
9D00AFA0  01CB5825   OR T3, T6, T3
157:                                             video_bmp[y][b] &=~(font6x8[c][i]>>r);
9D00AF94  00E5F807   SRAV RA, A1, A3
9D00AF98  001FF827   NOR RA, ZERO, RA
9D00AFA4  03EB5824   AND T3, RA, T3
9D00AFA8  AC4B0000   SW T3, 0(V0)
158:                                             video_bmp[y][b+1] |= (0x3f<<32-r);
9D00AF34  240A0020   ADDIU T2, ZERO, 32
9D00AF38  01435023   SUBU T2, T2, V1
9D00AF3C  014C6804   SLLV T5, T4, T2
9D00AFB4  8C4B0004   LW T3, 4(V0)
9D00AFB8  01AB5825   OR T3, T5, T3
159:                                             video_bmp[y][b+1] &= ~(font6x8[c][i]<<(32-r));
9D00AFAC  01452804   SLLV A1, A1, T2
9D00AFB0  00052827   NOR A1, ZERO, A1
9D00AFBC  00AB2824   AND A1, A1, T3
9D00AFC0  0B402C0B   J 0x9D00B02C
9D00AFC4  AC450004   SW A1, 4(V0)
160:                                         }else{
161:                                             video_bmp[y][b] &= ~(0x3f>>r);
9D00AF40  000EC827   NOR T9, ZERO, T6
9D00AFCC  8C4B0000   LW T3, 0(V0)
9D00AFD0  032B5824   AND T3, T9, T3
162:                                             video_bmp[y][b] |= font6x8[c][i]>>r;
9D00AFC8  00E5F807   SRAV RA, A1, A3
9D00AFD4  03EB5825   OR T3, RA, T3
9D00AFD8  AC4B0000   SW T3, 0(V0)
163:                                             video_bmp[y][b+1] &= ~(0x3f<<32-r);
9D00AF44  000DC027   NOR T8, ZERO, T5
9D00AFE0  8C4B0004   LW T3, 4(V0)
9D00AFE4  030B5824   AND T3, T8, T3
164:                                             video_bmp[y][b+1] |= font6x8[c][i]<<(32-r);
9D00AFDC  01452804   SLLV A1, A1, T2
9D00AFE8  00AB2825   OR A1, A1, T3
9D00AFEC  0B402C0B   J 0x9D00B02C
9D00AFF0  AC450004   SW A1, 4(V0)
165:                                         }
166:                                         y++;
167:                                     } else{
168:                                         if (flags & INV_VID){
9D00AFF4  11000008   BEQ T0, ZERO, 0x9D00B018
9D00AFF8  908B0000   LBU T3, 0(A0)
169:                                             video_bmp[y][b] |= (0x3f<<l);
9D00AF48  012C6004   SLLV T4, T4, T1
9D00B004  8C450000   LW A1, 0(V0)
9D00B008  01852825   OR A1, T4, A1
170:                                             video_bmp[y++][b] &=~(font6x8[c][i]<<l);
9D00AFFC  012B5804   SLLV T3, T3, T1
9D00B000  000B5827   NOR T3, ZERO, T3
9D00B00C  01652824   AND A1, T3, A1
9D00B010  0B402C0B   J 0x9D00B02C
9D00B014  AC450000   SW A1, 0(V0)
171:                                         }else{
172:                                             video_bmp[y][b] &= ~(0x3f<<l);
9D00AF4C  000C7827   NOR T7, ZERO, T4
9D00AF50  24C30001   ADDIU V1, A2, 1
9D00AF54  00062100   SLL A0, A2, 4
9D00AF58  00862023   SUBU A0, A0, A2
9D00AF5C  00822021   ADDU A0, A0, V0
9D00AF60  00042080   SLL A0, A0, 2
9D00AF64  3C02A000   LUI V0, -24576
9D00AF68  24420070   ADDIU V0, V0, 112
9D00AF6C  00441021   ADDU V0, V0, A0
9D00AF70  000528C0   SLL A1, A1, 3
9D00AF74  3C049D01   LUI A0, -25343
9D00AF78  248428C8   ADDIU A0, A0, 10440
9D00AF7C  00852021   ADDU A0, A0, A1
9D00AF80  24C60009   ADDIU A2, A2, 9
9D00B01C  8C450000   LW A1, 0(V0)
9D00B020  01E52824   AND A1, T7, A1
173:                                             video_bmp[y++][b] |= font6x8[c][i]<<l;
9D00B018  012B5804   SLLV T3, T3, T1
9D00B024  01652825   OR A1, T3, A1
9D00B028  AC450000   SW A1, 0(V0)
9D00B02C  24630001   ADDIU V1, V1, 1
9D00B030  2442003C   ADDIU V0, V0, 60
174:                                         }
175:                                     }
176:                                 }
177:                                 cursor_right();
9D00B03C  0F402B18   JAL cursor_right
9D00B040  00000000   NOP
178:                         }//switch(c)
179:                     }else{
180:                         UartPutch(channel,c);
9D00B04C  0F404618   JAL UartPutch
9D00B050  00000000   NOP
181:                     }
182:                 }//put_char()
9D00B044  0B402C16   J 0x9D00B058
9D00B048  8FBF0014   LW RA, 20(SP)
9D00B054  8FBF0014   LW RA, 20(SP)
9D00B058  03E00008   JR RA
9D00B05C  27BD0018   ADDIU SP, SP, 24
183:                 
184:                 void clear_screen(){
9D00ADBC  27BDFFE8   ADDIU SP, SP, -24
9D00ADC0  AFBF0014   SW RA, 20(SP)
185:                     if (flags&INV_VID){
9D00ADC4  9782803E   LHU V0, -32706(GP)
9D00ADC8  30420004   ANDI V0, V0, 4
9D00ADCC  3042FFFF   ANDI V0, V0, -1
9D00ADD0  10400007   BEQ V0, ZERO, 0x9D00ADF0
9D00ADD4  3C04A000   LUI A0, -24576
186:                         memset(video_bmp,255,HRES/8*VRES);
9D00ADD8  24840070   ADDIU A0, A0, 112
9D00ADDC  240500FF   ADDIU A1, ZERO, 255
9D00ADE0  0F406056   JAL memset
9D00ADE4  24063840   ADDIU A2, ZERO, 14400
9D00ADE8  0B402B81   J 0x9D00AE04
9D00ADEC  A7808046   SH ZERO, -32698(GP)
187:                     }else{
188:                         memset(video_bmp,0,HRES/8*VRES);
9D00ADF0  24840070   ADDIU A0, A0, 112
9D00ADF4  00002821   ADDU A1, ZERO, ZERO
9D00ADF8  0F406056   JAL memset
9D00ADFC  24063840   ADDIU A2, ZERO, 14400
189:                     }
190:                     cx=0;
9D00AE00  A7808046   SH ZERO, -32698(GP)
191:                     cy=0;
9D00AE04  A7808044   SH ZERO, -32700(GP)
192:                 } // clear_screen()
9D00AE08  8FBF0014   LW RA, 20(SP)
9D00AE0C  03E00008   JR RA
9D00AE10  27BD0018   ADDIU SP, SP, 24
193:                 
194:                 void print(dev_t channel, const char *text){
9D00B060  27BDFFE8   ADDIU SP, SP, -24
9D00B064  AFBF0014   SW RA, 20(SP)
9D00B068  AFB00010   SW S0, 16(SP)
195:                     if (channel==LOCAL_CON){
9D00B06C  1480000C   BNE A0, ZERO, 0x9D00B0A0
9D00B070  00A08021   ADDU S0, A1, ZERO
196:                         while (*text){
9D00B074  80A50000   LB A1, 0(A1)
9D00B078  10A0000C   BEQ A1, ZERO, 0x9D00B0AC
9D00B07C  8FBF0014   LW RA, 20(SP)
9D00B08C  82050000   LB A1, 0(S0)
9D00B090  14A0FFFC   BNE A1, ZERO, 0x9D00B084
9D00B094  26100001   ADDIU S0, S0, 1
9D00B098  0B402C2B   J 0x9D00B0AC
9D00B09C  8FBF0014   LW RA, 20(SP)
197:                             put_char(channel, *text++);
9D00B080  26100001   ADDIU S0, S0, 1
9D00B084  0F402B85   JAL put_char
9D00B088  00002021   ADDU A0, ZERO, ZERO
198:                         }
199:                     }else{
200:                         UartPrint(channel,text);
9D00B0A0  0F40466F   JAL UartPrint
9D00B0A4  00000000   NOP
201:                     }
202:                 }// print()
9D00B0A8  8FBF0014   LW RA, 20(SP)
9D00B0AC  8FB00010   LW S0, 16(SP)
9D00B0B0  03E00008   JR RA
9D00B0B4  27BD0018   ADDIU SP, SP, 24
203:                 
204:                 void println(dev_t channel, const char *str){
9D00B0B8  27BDFFE8   ADDIU SP, SP, -24
9D00B0BC  AFBF0014   SW RA, 20(SP)
9D00B0C0  AFB00010   SW S0, 16(SP)
205:                     print(channel, str);
9D00B0C4  0F402C18   JAL print
9D00B0C8  00808021   ADDU S0, A0, ZERO
206:                     if (channel==LOCAL_CON){
9D00B0CC  16000005   BNE S0, ZERO, 0x9D00B0E4
9D00B0D0  02002021   ADDU A0, S0, ZERO
207:                         crlf();
9D00B0D4  0F402B60   JAL crlf
9D00B0D8  00000000   NOP
9D00B0DC  0B402C3C   J 0x9D00B0F0
9D00B0E0  8FBF0014   LW RA, 20(SP)
208:                     }else{
209:                         UartPutch(channel,'\r');
9D00B0E4  0F404618   JAL UartPutch
9D00B0E8  2405000D   ADDIU A1, ZERO, 13
210:                     }
211:                 }
9D00B0EC  8FBF0014   LW RA, 20(SP)
9D00B0F0  8FB00010   LW S0, 16(SP)
9D00B0F4  03E00008   JR RA
9D00B0F8  27BD0018   ADDIU SP, SP, 24
212:                 
213:                 void print_hex(dev_t channel, unsigned int hex, unsigned char width){
9D00B0FC  27BDFFD8   ADDIU SP, SP, -40
9D00B100  AFBF0024   SW RA, 36(SP)
214:                     char c[12], *d;
215:                     int i;
216:                     c[11]=0;
9D00B104  A3A0001B   SB ZERO, 27(SP)
217:                     d= &c[10];
218:                     for(i=width;i>=0||hex;i--){
9D00B108  0B402C4F   J 0x9D00B13C
9D00B10C  27A2001A   ADDIU V0, SP, 26
9D00B138  24C6FFFF   ADDIU A2, A2, -1
9D00B13C  04C1FFF4   BGEZ A2, 0x9D00B110
9D00B140  30A3000F   ANDI V1, A1, 15
9D00B144  14A0FFF3   BNE A1, ZERO, 0x9D00B114
9D00B148  2867000A   SLTI A3, V1, 10
219:                         *d=(hex%16);
220:                         if (*d<10)
9D00B110  2867000A   SLTI A3, V1, 10
9D00B114  10E00004   BEQ A3, ZERO, 0x9D00B128
9D00B118  A0430000   SB V1, 0(V0)
221:                             *d += '0';
9D00B11C  24630030   ADDIU V1, V1, 48
9D00B120  0B402C4C   J 0x9D00B130
9D00B124  A0430000   SB V1, 0(V0)
222:                         else
223:                             *d += 'A'-10;
9D00B128  24630037   ADDIU V1, V1, 55
9D00B12C  A0430000   SB V1, 0(V0)
224:                         hex /=16;
9D00B130  00052902   SRL A1, A1, 4
225:                         d--;
9D00B134  2442FFFF   ADDIU V0, V0, -1
226:                     }
227:                     print(channel, ++d);
9D00B14C  0F402C18   JAL print
9D00B150  24450001   ADDIU A1, V0, 1
228:                 } // print_hex()
9D00B154  8FBF0024   LW RA, 36(SP)
9D00B158  03E00008   JR RA
9D00B15C  27BD0028   ADDIU SP, SP, 40
229:                 
230:                 void print_int(dev_t channel, int number, unsigned short width){ // imprime entier,width inclus le signe
9D00B160  27BDFFD8   ADDIU SP, SP, -40
9D00B164  AFBF0024   SW RA, 36(SP)
9D00B168  00A01021   ADDU V0, A1, ZERO
9D00B16C  00C01821   ADDU V1, A2, ZERO
9D00B170  2CC6000E   SLTIU A2, A2, 14
231:                     int sign=0, i;
232:                     char str[14], *d;
233:                     str[13]=0;
9D00B174  14C00002   BNE A2, ZERO, 0x9D00B180
9D00B178  A3A0001D   SB ZERO, 29(SP)
9D00B17C  2403000D   ADDIU V1, ZERO, 13
9D00B180  3066FFFF   ANDI A2, V1, -1
234:                     d=&str[12];
9D00B19C  27A5001C   ADDIU A1, SP, 28
9D00B1F4  27A5001C   ADDIU A1, SP, 28
235:                     if (width>13){width=13;}
236:                     if (number<0){
9D00B184  04410003   BGEZ V0, 0x9D00B194
9D00B188  00005021   ADDU T2, ZERO, ZERO
237:                         sign=1;
9D00B190  240A0001   ADDIU T2, ZERO, 1
238:                         number = -number;
9D00B18C  00021023   SUBU V0, ZERO, V0
239:                     }
240:                     //for (i=--width;i>=0||number;i--){
241:                     i=width;
242:                     while (number>0){
9D00B194  18400017   BLEZ V0, 0x9D00B1F4
9D00B198  00C05821   ADDU T3, A2, ZERO
9D00B1DC  1C60FFF2   BGTZ V1, 0x9D00B1A8
9D00B1E0  24C6FFFF   ADDIU A2, A2, -1
243:                        *d--=(number%10)+'0';
9D00B1A0  3C096666   LUI T1, 26214
9D00B1A4  25296667   ADDIU T1, T1, 26215
9D00B1A8  24A5FFFF   ADDIU A1, A1, -1
9D00B1AC  00490018   MULT 0, V0, T1
9D00B1B0  00001810   MFHI V1
9D00B1B4  00031883   SRA V1, V1, 2
9D00B1B8  00023FC3   SRA A3, V0, 31
9D00B1BC  00671823   SUBU V1, V1, A3
9D00B1C0  00034040   SLL T0, V1, 1
9D00B1C4  000338C0   SLL A3, V1, 3
9D00B1C8  01073821   ADDU A3, T0, A3
9D00B1CC  00471023   SUBU V0, V0, A3
9D00B1D0  24420030   ADDIU V0, V0, 48
9D00B1D4  A0A20001   SB V0, 1(A1)
244:                         number /= 10;
9D00B1D8  00601021   ADDU V0, V1, ZERO
245:                         i--;
246:                     }
247:                     if (i==width){
9D00B1E4  15660008   BNE T3, A2, 0x9D00B208
9D00B1E8  24020030   ADDIU V0, ZERO, 48
248:                         *d--='0';
9D00B1EC  0B402C80   J 0x9D00B200
9D00B1F0  A0A20000   SB V0, 0(A1)
9D00B1F8  24020030   ADDIU V0, ZERO, 48
9D00B1FC  A0A20000   SB V0, 0(A1)
9D00B204  24A5FFFF   ADDIU A1, A1, -1
249:                         i--;
9D00B200  24C6FFFF   ADDIU A2, A2, -1
250:                     }
251:                     while (i>0){
9D00B208  18C00009   BLEZ A2, 0x9D00B230
9D00B20C  00A01021   ADDU V0, A1, ZERO
9D00B210  00C03821   ADDU A3, A2, ZERO
9D00B214  00A63023   SUBU A2, A1, A2
9D00B224  5446FFFE   BNEL V0, A2, 0x9D00B220
9D00B228  A0430000   SB V1, 0(V0)
9D00B22C  00A72823   SUBU A1, A1, A3
252:                         *d--=' ';
9D00B218  24030020   ADDIU V1, ZERO, 32
9D00B21C  A0430000   SB V1, 0(V0)
9D00B220  2442FFFF   ADDIU V0, V0, -1
253:                         i--;
254:                     }
255:                     if (sign){*d--='-';}
9D00B230  11400003   BEQ T2, ZERO, 0x9D00B240
9D00B234  2402002D   ADDIU V0, ZERO, 45
9D00B238  A0A20000   SB V0, 0(A1)
9D00B23C  24A5FFFF   ADDIU A1, A1, -1
256:                     *d=' ';
9D00B240  24020020   ADDIU V0, ZERO, 32
257:                     
258:                     print(channel, d);
9D00B244  0F402C18   JAL print
9D00B248  A0A20000   SB V0, 0(A1)
259:                 }// print_int()
9D00B24C  8FBF0024   LW RA, 36(SP)
9D00B250  03E00008   JR RA
9D00B254  27BD0028   ADDIU SP, SP, 40
260:                 
261:                 void set_tab_width(unsigned char width){
262:                     tab_width=width;
9D00B258  03E00008   JR RA
9D00B25C  A3848011   SB A0, -32751(GP)
263:                 }// set_tab_width()
264:                 
265:                 void clear_eol(void){
9D00B260  27BDFFE0   ADDIU SP, SP, -32
9D00B264  AFBF001C   SW RA, 28(SP)
9D00B268  AFB20018   SW S2, 24(SP)
9D00B26C  AFB10014   SW S1, 20(SP)
9D00B270  AFB00010   SW S0, 16(SP)
266:                     int x,y;
267:                     
268:                     y=cy;
9D00B274  97928044   LHU S2, -32700(GP)
269:                     while (y<(cy+CHAR_HEIGHT)){
9D00B278  26420008   ADDIU V0, S2, 8
9D00B27C  0242102A   SLT V0, S2, V0
9D00B280  1040001D   BEQ V0, ZERO, 0x9D00B2F8
9D00B284  8FBF001C   LW RA, 28(SP)
9D00B2E0  97828044   LHU V0, -32700(GP)
9D00B2E4  24420008   ADDIU V0, V0, 8
9D00B2E8  0242102A   SLT V0, S2, V0
9D00B2EC  1440FFE7   BNE V0, ZERO, 0x9D00B28C
9D00B2F0  97908046   LHU S0, -32698(GP)
270:                         x=cx;
9D00B288  97908046   LHU S0, -32698(GP)
271:                         while (x<HRES){
9D00B28C  2A0201E0   SLTI V0, S0, 480
9D00B290  10400012   BEQ V0, ZERO, 0x9D00B2DC
9D00B294  26100001   ADDIU S0, S0, 1
9D00B2D0  2A3101E0   SLTI S1, S1, 480
9D00B2D4  1620FFF1   BNE S1, ZERO, 0x9D00B29C
9D00B2D8  9782803E   LHU V0, -32706(GP)
272:                             if (flags & INV_VID)
9D00B298  9782803E   LHU V0, -32706(GP)
9D00B29C  30420004   ANDI V0, V0, 4
9D00B2A0  3042FFFF   ANDI V0, V0, -1
9D00B2A4  10400006   BEQ V0, ZERO, 0x9D00B2C0
9D00B2A8  2604FFFF   ADDIU A0, S0, -1
273:                                 setPixel(x++,y);
9D00B2AC  02008821   ADDU S1, S0, ZERO
9D00B2B0  0F403380   JAL setPixel
9D00B2B4  02402821   ADDU A1, S2, ZERO
9D00B2B8  0B402CB4   J 0x9D00B2D0
9D00B2BC  26100001   ADDIU S0, S0, 1
274:                             else
275:                                 clearPixel(x++,y);
9D00B2C0  02008821   ADDU S1, S0, ZERO
9D00B2C4  0F40339C   JAL clearPixel
9D00B2C8  02402821   ADDU A1, S2, ZERO
9D00B2CC  26100001   ADDIU S0, S0, 1
276:                         }
277:                         y++;
9D00B2DC  26520001   ADDIU S2, S2, 1
278:                     }
279:                 }// clear_eol()
9D00B2F4  8FBF001C   LW RA, 28(SP)
9D00B2F8  8FB20018   LW S2, 24(SP)
9D00B2FC  8FB10014   LW S1, 20(SP)
9D00B300  8FB00010   LW S0, 16(SP)
9D00B304  03E00008   JR RA
9D00B308  27BD0020   ADDIU SP, SP, 32
280:                 
281:                 text_coord_t get_curpos(){
9D00B30C  00801021   ADDU V0, A0, ZERO
282:                     text_coord_t cpos;
283:                     cpos.x = cx/CHAR_WIDTH;
9D00B318  97858046   LHU A1, -32698(GP)
9D00B31C  3C04AAAA   LUI A0, -21846
9D00B320  3484AAAB   ORI A0, A0, -21845
9D00B324  00A40019   MULTU 0, A1, A0
9D00B328  00002010   MFHI A0
9D00B32C  00042082   SRL A0, A0, 2
284:                     cpos.y = cy/CHAR_HEIGHT;
9D00B310  97838044   LHU V1, -32700(GP)
9D00B314  000318C2   SRL V1, V1, 3
285:                     return cpos;
9D00B330  A4440000   SH A0, 0(V0)
286:                 } // get_cursor_pos()
9D00B334  03E00008   JR RA
9D00B338  A4430002   SH V1, 2(V0)
287:                 
288:                 void set_curpos(unsigned short x, unsigned short y){// {x,y} coordonnée caractère
289:                     if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1))
9D00B33C  2C820050   SLTIU V0, A0, 80
9D00B340  10400008   BEQ V0, ZERO, 0x9D00B364
9D00B344  2CA2001E   SLTIU V0, A1, 30
9D00B348  10400006   BEQ V0, ZERO, 0x9D00B364
9D00B34C  00042040   SLL A0, A0, 1
290:                         return;
291:                     cx=x*CHAR_WIDTH;
9D00B350  00041080   SLL V0, A0, 2
9D00B354  00442023   SUBU A0, V0, A0
9D00B358  A7848046   SH A0, -32698(GP)
292:                     cy=y*CHAR_HEIGHT;
9D00B35C  000528C0   SLL A1, A1, 3
9D00B360  A7858044   SH A1, -32700(GP)
9D00B364  03E00008   JR RA
9D00B368  00000000   NOP
293:                 }//set_curpos()
294:                 
295:                 void invert_char(void){// inverse vidéo du caractère à la position courante
296:                     register int i,l,r,b,x,y;
297:                     x=cx;
9D00B36C  97878046   LHU A3, -32698(GP)
298:                     y=cy;
9D00B370  97858044   LHU A1, -32700(GP)
299:                     b=x>>5;
9D00B374  00071143   SRA V0, A3, 5
300:                     r=0;
301:                     l=(32-CHAR_WIDTH)-(x&0x1f);
9D00B378  30E7001F   ANDI A3, A3, 31
9D00B37C  2403001A   ADDIU V1, ZERO, 26
9D00B380  00673823   SUBU A3, V1, A3
302:                     if (l<0){
303:                         r=-l;
9D00B384  00071823   SUBU V1, ZERO, A3
9D00B388  28E40000   SLTI A0, A3, 0
9D00B38C  0004180A   MOVZ V1, ZERO, A0
9D00B390  00602021   ADDU A0, V1, ZERO
304:                     }
305:                     for (i=9;i;i--){
9D00B3F8  1465FFF4   BNE V1, A1, 0x9D00B3CC
9D00B3FC  2442003C   ADDIU V0, V0, 60
306:                         if (r){
9D00B3CC  10800007   BEQ A0, ZERO, 0x9D00B3EC
9D00B3D0  8C460000   LW A2, 0(V0)
307:                             video_bmp[y][b] ^= (0x3f>>r);
9D00B394  2403003F   ADDIU V1, ZERO, 63
9D00B398  00834807   SRAV T1, V1, A0
9D00B3D4  00C93026   XOR A2, A2, T1
9D00B3D8  AC460000   SW A2, 0(V0)
308:                             video_bmp[y][b+1] ^= (0x3f<<32-r);
9D00B39C  00044023   SUBU T0, ZERO, A0
9D00B3A0  01034004   SLLV T0, V1, T0
9D00B3DC  8C460004   LW A2, 4(V0)
9D00B3E0  00C83026   XOR A2, A2, T0
9D00B3E4  0B402CFD   J 0x9D00B3F4
9D00B3E8  AC460004   SW A2, 4(V0)
309:                             y++;
310:                         } else{
311:                             video_bmp[y++][b] ^= (0x3f<<l);
9D00B3A4  00E33804   SLLV A3, V1, A3
9D00B3A8  24A30001   ADDIU V1, A1, 1
9D00B3AC  00053100   SLL A2, A1, 4
9D00B3B0  00C53023   SUBU A2, A2, A1
9D00B3B4  00C23021   ADDU A2, A2, V0
9D00B3B8  00063080   SLL A2, A2, 2
9D00B3BC  3C02A000   LUI V0, -24576
9D00B3C0  24420070   ADDIU V0, V0, 112
9D00B3C4  00461021   ADDU V0, V0, A2
9D00B3C8  24A5000A   ADDIU A1, A1, 10
9D00B3EC  00C73026   XOR A2, A2, A3
9D00B3F0  AC460000   SW A2, 0(V0)
9D00B3F4  24630001   ADDIU V1, V1, 1
312:                         }
313:                     }
314:                 }//invert_char()
9D00B400  03E00008   JR RA
9D00B404  00000000   NOP
315:                 
316:                 static void toggle_underscore(void){
317:                     register int l,r,b,x;
318:                     x=cx;
319:                     b=x>>5;
9D00B430  00022143   SRA A0, V0, 5
320:                     r=0;
321:                     l=(32-CHAR_WIDTH)-(x&0x1f);
9D00B434  3042001F   ANDI V0, V0, 31
9D00B438  2403001A   ADDIU V1, ZERO, 26
9D00B43C  00621823   SUBU V1, V1, V0
322:                     if (l<0){
9D00B440  0463001D   BGEZL V1, 0x9D00B4B8
9D00B444  97828044   LHU V0, -32700(GP)
323:                         r=-l;
9D00B448  00034023   SUBU T0, ZERO, V1
324:                     }
325:                     if (r){
9D00B44C  11000019   BEQ T0, ZERO, 0x9D00B4B4
9D00B450  97868044   LHU A2, -32700(GP)
326:                         video_bmp[cy+CHAR_HEIGHT-1][b] ^= (0x3f>>r);
9D00B454  24C60007   ADDIU A2, A2, 7
9D00B458  00061900   SLL V1, A2, 4
9D00B45C  00663023   SUBU A2, V1, A2
9D00B460  00C43821   ADDU A3, A2, A0
9D00B464  00073880   SLL A3, A3, 2
9D00B468  3C05A000   LUI A1, -24576
9D00B46C  24A50070   ADDIU A1, A1, 112
9D00B470  00E53821   ADDU A3, A3, A1
9D00B474  2403003F   ADDIU V1, ZERO, 63
9D00B478  01034007   SRAV T0, V1, T0
9D00B47C  8CE90000   LW T1, 0(A3)
9D00B480  01094026   XOR T0, T0, T1
9D00B484  ACE80000   SW T0, 0(A3)
327:                         video_bmp[cy+CHAR_HEIGHT-1][b+1] ^= (0x3f<<32-r);
9D00B488  24840001   ADDIU A0, A0, 1
9D00B48C  00C42021   ADDU A0, A2, A0
9D00B490  00042080   SLL A0, A0, 2
9D00B494  00852021   ADDU A0, A0, A1
9D00B498  2405003A   ADDIU A1, ZERO, 58
9D00B49C  00A21023   SUBU V0, A1, V0
9D00B4A0  00431804   SLLV V1, V1, V0
9D00B4A4  8C850000   LW A1, 0(A0)
9D00B4A8  00651826   XOR V1, V1, A1
9D00B4AC  0B402D3B   J 0x9D00B4EC
9D00B4B0  AC830000   SW V1, 0(A0)
328:                     } else{
329:                         video_bmp[cy+CHAR_HEIGHT-1][b] ^= (0x3f<<l);
9D00B4B4  97828044   LHU V0, -32700(GP)
9D00B4B8  24420007   ADDIU V0, V0, 7
9D00B4BC  00022900   SLL A1, V0, 4
9D00B4C0  00A21023   SUBU V0, A1, V0
9D00B4C4  00442021   ADDU A0, V0, A0
9D00B4C8  00042080   SLL A0, A0, 2
9D00B4CC  3C05A000   LUI A1, -24576
9D00B4D0  24A50070   ADDIU A1, A1, 112
9D00B4D4  00852021   ADDU A0, A0, A1
9D00B4D8  2402003F   ADDIU V0, ZERO, 63
9D00B4DC  00621804   SLLV V1, V0, V1
9D00B4E0  8C820000   LW V0, 0(A0)
9D00B4E4  00621826   XOR V1, V1, V0
9D00B4E8  AC830000   SW V1, 0(A0)
330:                     }
331:                 }//toggle_underscore()
332:                 
333:                 // cette fonction ne doit-être appellée
334:                 // que par l'interruption du TIMER2 lorsque le cursor est actif.
335:                 void toggle_cursor(){
9D00B408  27BDFFE8   ADDIU SP, SP, -24
9D00B40C  AFBF0014   SW RA, 20(SP)
336:                     if (cur_shape==CR_BLOCK){
9D00B410  24020001   ADDIU V0, ZERO, 1
9D00B414  8F838040   LW V1, -32704(GP)
9D00B418  54620005   BNEL V1, V0, 0x9D00B430
9D00B41C  97828046   LHU V0, -32698(GP)
337:                         invert_char();
9D00B420  0F402CDB   JAL invert_char
9D00B424  00000000   NOP
9D00B428  0B402D3C   J 0x9D00B4F0
9D00B42C  9782803E   LHU V0, -32706(GP)
338:                     }else{
339:                         toggle_underscore();
340:                     }
341:                     flags ^=CUR_VIS;
9D00B4EC  9782803E   LHU V0, -32706(GP)
9D00B4F0  38420002   XORI V0, V0, 2
9D00B4F4  A782803E   SH V0, -32706(GP)
342:                 }
9D00B4F8  8FBF0014   LW RA, 20(SP)
9D00B4FC  03E00008   JR RA
9D00B500  27BD0018   ADDIU SP, SP, 24
343:                 
344:                 
345:                 void show_cursor(BOOL show){
9D00B504  27BDFFE8   ADDIU SP, SP, -24
346:                     if (show){
9D00B508  1080000B   BEQ A0, ZERO, 0x9D00B538
9D00B50C  AFBF0014   SW RA, 20(SP)
347:                         flags |= CUR_SHOW;
348:                         flags &= ~CUR_VIS;
9D00B510  9782803E   LHU V0, -32706(GP)
9D00B514  7C020844   INS V0, ZERO, 1, 1
9D00B518  34420001   ORI V0, V0, 1
9D00B51C  A782803E   SH V0, -32706(GP)
349:                         enable_cursor_timer(TRUE,(cursor_tmr_callback_f)toggle_cursor);
9D00B520  24040001   ADDIU A0, ZERO, 1
9D00B524  3C059D01   LUI A1, -25343
9D00B528  0F403B5B   JAL enable_cursor_timer
9D00B52C  24A5B408   ADDIU A1, A1, -19448
9D00B530  0B402D5E   J 0x9D00B578
9D00B534  8FBF0014   LW RA, 20(SP)
350:                     }else{
351:                         enable_cursor_timer(FALSE,NULL);
9D00B538  00002021   ADDU A0, ZERO, ZERO
9D00B53C  0F403B5B   JAL enable_cursor_timer
9D00B540  00002821   ADDU A1, ZERO, ZERO
352:                         flags &= ~CUR_SHOW;
9D00B544  9782803E   LHU V0, -32706(GP)
9D00B548  2404FFFE   ADDIU A0, ZERO, -2
9D00B54C  00441824   AND V1, V0, A0
353:                         if (flags & CUR_VIS){
9D00B550  30420002   ANDI V0, V0, 2
9D00B554  3042FFFF   ANDI V0, V0, -1
9D00B558  10400006   BEQ V0, ZERO, 0x9D00B574
9D00B55C  A783803E   SH V1, -32706(GP)
354:                             toggle_cursor();
9D00B560  0F402D02   JAL toggle_cursor
9D00B564  00000000   NOP
355:                             flags &= ~CUR_VIS;
9D00B568  9782803E   LHU V0, -32706(GP)
9D00B56C  7C020844   INS V0, ZERO, 1, 1
9D00B570  A782803E   SH V0, -32706(GP)
356:                         }
357:                     }
358:                 }// show_cursor()
9D00B574  8FBF0014   LW RA, 20(SP)
9D00B578  03E00008   JR RA
9D00B57C  27BD0018   ADDIU SP, SP, 24
359:                 
360:                 
361:                 BOOL is_cursor_active(){
362:                     return flags&CUR_SHOW;
9D00B580  9782803E   LHU V0, -32706(GP)
363:                 }
9D00B584  03E00008   JR RA
9D00B588  30420001   ANDI V0, V0, 1
364:                 
365:                 void set_cursor(cursor_t shape){
9D00B58C  27BDFFE8   ADDIU SP, SP, -24
9D00B590  AFBF0014   SW RA, 20(SP)
9D00B594  AFB00010   SW S0, 16(SP)
366:                     if (flags & CUR_VIS){
9D00B598  9782803E   LHU V0, -32706(GP)
9D00B59C  30420002   ANDI V0, V0, 2
9D00B5A0  3042FFFF   ANDI V0, V0, -1
9D00B5A4  10400008   BEQ V0, ZERO, 0x9D00B5C8
9D00B5A8  00808021   ADDU S0, A0, ZERO
367:                         show_cursor(FALSE);
9D00B5AC  0F402D41   JAL show_cursor
9D00B5B0  00002021   ADDU A0, ZERO, ZERO
368:                         cur_shape=shape;
9D00B5B4  AF908040   SW S0, -32704(GP)
369:                         show_cursor(TRUE);
9D00B5B8  0F402D41   JAL show_cursor
9D00B5BC  24040001   ADDIU A0, ZERO, 1
9D00B5C0  0B402D74   J 0x9D00B5D0
9D00B5C4  8FBF0014   LW RA, 20(SP)
370:                     }else{
371:                         cur_shape=shape;
9D00B5C8  AF848040   SW A0, -32704(GP)
372:                     }
373:                 }// set_cursor()
9D00B5CC  8FBF0014   LW RA, 20(SP)
9D00B5D0  8FB00010   LW S0, 16(SP)
9D00B5D4  03E00008   JR RA
9D00B5D8  27BD0018   ADDIU SP, SP, 24
374:                 
375:                 unsigned char get_key(dev_t channel){ // lecture touche clavier, retourne 0 s'il n'y a pas de touche ou touche relâchée.
9D00B5DC  27BDFFE8   ADDIU SP, SP, -24
376:                     char key;
377:                     if (channel==LOCAL_CON){
9D00B5E0  14800005   BNE A0, ZERO, 0x9D00B5F8
9D00B5E4  AFBF0014   SW RA, 20(SP)
378:                         key=KbdKey();
9D00B5E8  0F4054D2   JAL KbdKey
9D00B5EC  00000000   NOP
9D00B5F0  0B402D82   J 0x9D00B608
9D00B5F4  7C021420   SEB V0, V0
379:                     }else{
380:                         key=UartGetch(STDIN);
9D00B5F8  0F40460B   JAL UartGetch
9D00B5FC  24040001   ADDIU A0, ZERO, 1
381:                         if (key==-1){
382:                             key=0;
9D00B600  00021827   NOR V1, ZERO, V0
9D00B604  0003100A   MOVZ V0, ZERO, V1
383:                         }
384:                     }
385:                     return key;
386:                 }//get_key()
9D00B608  304200FF   ANDI V0, V0, 255
9D00B60C  8FBF0014   LW RA, 20(SP)
9D00B610  03E00008   JR RA
9D00B614  27BD0018   ADDIU SP, SP, 24
387:                 
388:                 unsigned char wait_key(dev_t channel){ // attend qu'une touche soit enfoncée et retourne sa valeur.
9D00B618  27BDFFE8   ADDIU SP, SP, -24
9D00B61C  AFBF0014   SW RA, 20(SP)
389:                     unsigned short key;
390:                     
391:                     if (channel==LOCAL_CON){
9D00B620  1480000B   BNE A0, ZERO, 0x9D00B650
9D00B624  AFB00010   SW S0, 16(SP)
392:                         show_cursor(TRUE);
9D00B628  0F402D41   JAL show_cursor
9D00B62C  24040001   ADDIU A0, ZERO, 1
393:                         while (!(key=get_key(channel))){
9D00B630  0F402D77   JAL get_key
9D00B634  00002021   ADDU A0, ZERO, ZERO
9D00B638  1040FFFD   BEQ V0, ZERO, 0x9D00B630
9D00B63C  00408021   ADDU S0, V0, ZERO
394:                         }//while
395:                         show_cursor(FALSE);
9D00B640  0F402D41   JAL show_cursor
9D00B644  00002021   ADDU A0, ZERO, ZERO
9D00B648  0B402D99   J 0x9D00B664
9D00B64C  320200FF   ANDI V0, S0, 255
396:                     }else{
397:                         key=UartWaitch(STDIN,0);
9D00B650  24040001   ADDIU A0, ZERO, 1
9D00B654  0F404645   JAL UartWaitch
9D00B658  00002821   ADDU A1, ZERO, ZERO
9D00B65C  3050FFFF   ANDI S0, V0, -1
398:                     }
399:                     return key;
400:                 }//wait_key()
9D00B660  320200FF   ANDI V0, S0, 255
9D00B664  8FBF0014   LW RA, 20(SP)
9D00B668  8FB00010   LW S0, 16(SP)
9D00B66C  03E00008   JR RA
9D00B670  27BD0018   ADDIU SP, SP, 24
401:                 
402:                  // lit une ligne au clavier, retourne la longueur du texte.
403:                 unsigned char readline(dev_t channel, unsigned char *ibuff,unsigned char max_char){
9D00B674  27BDFFD0   ADDIU SP, SP, -48
9D00B678  AFBF002C   SW RA, 44(SP)
9D00B67C  AFB60028   SW S6, 40(SP)
9D00B680  AFB50024   SW S5, 36(SP)
9D00B684  AFB40020   SW S4, 32(SP)
9D00B688  AFB3001C   SW S3, 28(SP)
9D00B68C  AFB20018   SW S2, 24(SP)
9D00B690  AFB10014   SW S1, 20(SP)
9D00B694  AFB00010   SW S0, 16(SP)
9D00B698  00A09821   ADDU S3, A1, ZERO
404:                     unsigned char c=0, count=0;
405:                     if (channel==LOCAL_CON){
9D00B69C  14800026   BNE A0, ZERO, 0x9D00B738
9D00B6A0  00C0A021   ADDU S4, A2, ZERO
9D00B6A4  00008021   ADDU S0, ZERO, ZERO
406:                         while ((c!='\r') && (count<=max_char)){
9D00B6FC  0B402DD3   J 0x9D00B74C
9D00B700  0290102B   SLTU V0, S4, S0
9D00B748  0290102B   SLTU V0, S4, S0
9D00B74C  1040FFDA   BEQ V0, ZERO, 0x9D00B6B8
9D00B750  00000000   NOP
9D00B754  0B402DD7   J 0x9D00B75C
9D00B758  A2600000   SB ZERO, 0(S3)
407:                             c=wait_key(channel);
9D00B6B8  0F402D86   JAL wait_key
9D00B6BC  00002021   ADDU A0, ZERO, ZERO
408:                             if (c==CR){
9D00B6A8  2411000D   ADDIU S1, ZERO, 13
9D00B6C0  14510005   BNE V0, S1, 0x9D00B6D8
9D00B6C4  00002021   ADDU A0, ZERO, ZERO
409:                                 put_char(channel,'\r');
9D00B6C8  0F402B85   JAL put_char
9D00B6CC  2405000D   ADDIU A1, ZERO, 13
410:                                 break;
9D00B6D0  0B402DD7   J 0x9D00B75C
9D00B6D4  A2600000   SB ZERO, 0(S3)
411:                             }else if (c==BS){
9D00B6AC  24120008   ADDIU S2, ZERO, 8
9D00B6D8  1452000A   BNE V0, S2, 0x9D00B704
9D00B6DC  2443FFE0   ADDIU V1, V0, -32
412:                                 if (count){
9D00B6E0  1200FFF5   BEQ S0, ZERO, 0x9D00B6B8
9D00B6E4  00002021   ADDU A0, ZERO, ZERO
413:                                     ibuff--;
9D00B6E8  2673FFFF   ADDIU S3, S3, -1
414:                                     count--;
9D00B6EC  2610FFFF   ADDIU S0, S0, -1
9D00B6F0  321000FF   ANDI S0, S0, 255
415:                                     print(channel,"\b \b");
9D00B6B0  3C159D01   LUI S5, -25343
9D00B6B4  26B577A4   ADDIU S5, S5, 30628
9D00B6F4  0F402C18   JAL print
9D00B6F8  02A02821   ADDU A1, S5, ZERO
416:                                 }
417:                             }else if (c >=32 && c<=127){
9D00B704  306300FF   ANDI V1, V1, 255
9D00B708  2C630060   SLTIU V1, V1, 96
9D00B70C  5060000F   BEQL V1, ZERO, 0x9D00B74C
9D00B710  0290102B   SLTU V0, S4, S0
418:                                 *ibuff++=c;
9D00B714  26760001   ADDIU S6, S3, 1
9D00B718  A2620000   SB V0, 0(S3)
9D00B730  0B402DD2   J 0x9D00B748
9D00B734  02C09821   ADDU S3, S6, ZERO
419:                                 count++;
9D00B71C  26100001   ADDIU S0, S0, 1
9D00B720  321000FF   ANDI S0, S0, 255
420:                                 put_char(channel, c);
9D00B724  00002021   ADDU A0, ZERO, ZERO
9D00B728  0F402B85   JAL put_char
9D00B72C  7C022C20   SEB A1, V0
421:                             }
422:                         }// while
423:                         *ibuff=(char)0;
424:                     }else{
425:                         count=UartReadln(STDIN,ibuff,max_char);
9D00B738  0F40468B   JAL UartReadln
9D00B73C  24040001   ADDIU A0, ZERO, 1
9D00B740  0B402DD7   J 0x9D00B75C
9D00B744  305000FF   ANDI S0, V0, 255
426:                     }
427:                     return count;
428:                 } // readline()
9D00B75C  02001021   ADDU V0, S0, ZERO
9D00B760  8FBF002C   LW RA, 44(SP)
9D00B764  8FB60028   LW S6, 40(SP)
9D00B768  8FB50024   LW S5, 36(SP)
9D00B76C  8FB40020   LW S4, 32(SP)
9D00B770  8FB3001C   LW S3, 28(SP)
9D00B774  8FB20018   LW S2, 24(SP)
9D00B778  8FB10014   LW S1, 20(SP)
9D00B77C  8FB00010   LW S0, 16(SP)
9D00B780  03E00008   JR RA
9D00B784  27BD0030   ADDIU SP, SP, 48
429:                 
430:                 void invert_video(unsigned char invert){
431:                     if (invert){
9D00B788  10800004   BEQ A0, ZERO, 0x9D00B79C
9D00B78C  9782803E   LHU V0, -32706(GP)
432:                         flags |= INV_VID;
9D00B790  34420004   ORI V0, V0, 4
9D00B794  03E00008   JR RA
9D00B798  A782803E   SH V0, -32706(GP)
433:                     }else{
434:                         flags &= ~INV_VID;
9D00B79C  7C021084   INS V0, ZERO, 2, 1
9D00B7A0  03E00008   JR RA
9D00B7A4  A782803E   SH V0, -32706(GP)
435:                     }
436:                 }//invert_video()
437:                 
438:                 
439:                 void uppercase(char *str){// in situ uppercase
440:                     while (*str){
9D00B7A8  80820000   LB V0, 0(A0)
9D00B7AC  1040000C   BEQ V0, ZERO, 0x9D00B7E0
9D00B7B0  304200FF   ANDI V0, V0, 255
9D00B7D4  80820000   LB V0, 0(A0)
441:                         if (*str>='a' && *str<='z') *str-=32;
9D00B7B4  2443FF9F   ADDIU V1, V0, -97
9D00B7B8  306300FF   ANDI V1, V1, 255
9D00B7BC  2C63001A   SLTIU V1, V1, 26
9D00B7C0  50600004   BEQL V1, ZERO, 0x9D00B7D4
9D00B7C4  24840001   ADDIU A0, A0, 1
9D00B7C8  2442FFE0   ADDIU V0, V0, -32
9D00B7CC  A0820000   SB V0, 0(A0)
442:                         str++;
9D00B7D0  24840001   ADDIU A0, A0, 1
9D00B7D4  80820000   LB V0, 0(A0)
9D00B7D8  1440FFF6   BNE V0, ZERO, 0x9D00B7B4
9D00B7DC  304200FF   ANDI V0, V0, 255
9D00B7E0  03E00008   JR RA
9D00B7E4  00000000   NOP
443:                     }
444:                 }
---  /build/bamboo/xml-data/build-dir/XC32-CYIMG-BLD/xc32-XC32-release-1_44/src48x/gcc/libgcc/libgcc2.c  
9D0102FC  00C04021   ADDU T0, A2, ZERO
9D010760  00C04021   ADDU T0, A2, ZERO
9D010300  00804821   ADDU T1, A0, ZERO
9D010764  00801021   ADDU V0, A0, ZERO
9D010304  14E0003B   BNE A3, ZERO, 0x9D0103F4
9D010308  00A01821   ADDU V1, A1, ZERO
9D010768  14E0003F   BNE A3, ZERO, 0x9D010868
9D01076C  00A04821   ADDU T1, A1, ZERO
9D01030C  00A6102B   SLTU V0, A1, A2
9D010310  10400048   BEQ V0, ZERO, 0x9D010434
9D010314  70C21020   CLZ V0, A2
9D010770  00A6182B   SLTU V1, A1, A2
9D010774  10600047   BEQ V1, ZERO, 0x9D010894
9D010778  70C31820   CLZ V1, A2
9D010318  50400008   BEQL V0, ZERO, 0x9D01033C
9D01031C  00083402   SRL A2, T0, 16
9D01077C  50600008   BEQL V1, ZERO, 0x9D0107A0
9D010780  00081C02   SRL V1, T0, 16
9D01032C  00464004   SLLV T0, A2, V0
9D010790  00664004   SLLV T0, A2, V1
9D010320  00021823   SUBU V1, ZERO, V0
9D010324  00452804   SLLV A1, A1, V0
9D010328  00641806   SRLV V1, A0, V1
9D010330  00651825   OR V1, V1, A1
9D010784  00034823   SUBU T1, ZERO, V1
9D010788  00652804   SLLV A1, A1, V1
9D01078C  01244806   SRLV T1, A0, T1
9D010794  01254825   OR T1, T1, A1
9D010334  00444804   SLLV T1, A0, V0
9D010798  00641004   SLLV V0, A0, V1
9D010338  00083402   SRL A2, T0, 16
9D01033C  0066001B   DIVU V1, A2
9D010340  00C001F4   TEQ A2, ZERO
9D010344  00002010   MFHI A0
9D010348  00005812   MFLO T3
9D01034C  310CFFFF   ANDI T4, T0, -1
9D010350  00095402   SRL T2, T1, 16
9D010354  716C5802   MUL T3, T3, T4
9D010358  00042400   SLL A0, A0, 16
9D01035C  008A5025   OR T2, A0, T2
9D010360  014B682B   SLTU T5, T2, T3
9D010364  0066001B   DIVU V1, A2
9D010368  00C001F4   TEQ A2, ZERO
9D01036C  51A00009   BEQL T5, ZERO, 0x9D010394
9D010370  014B5023   SUBU T2, T2, T3
9D010374  01485021   ADDU T2, T2, T0
9D010378  0148182B   SLTU V1, T2, T0
9D01037C  54600005   BNEL V1, ZERO, 0x9D010394
9D010380  014B5023   SUBU T2, T2, T3
9D010384  014B202B   SLTU A0, T2, T3
9D010388  01481821   ADDU V1, T2, T0
9D01038C  0064500B   MOVN T2, V1, A0
9D010390  014B5023   SUBU T2, T2, T3
9D010394  3123FFFF   ANDI V1, T1, -1
9D010398  0146001B   DIVU T2, A2
9D01039C  00C001F4   TEQ A2, ZERO
9D0103A0  00004810   MFHI T1
9D0103A4  00002012   MFLO A0
9D0103A8  708C2002   MUL A0, A0, T4
9D0103AC  00094C00   SLL T1, T1, 16
9D0103B0  01234825   OR T1, T1, V1
9D0103B4  0124182B   SLTU V1, T1, A0
9D0103B8  0146001B   DIVU T2, A2
9D0103BC  00C001F4   TEQ A2, ZERO
9D0103C0  50600009   BEQL V1, ZERO, 0x9D0103E8
9D0103C4  01244823   SUBU T1, T1, A0
9D0103C8  01284821   ADDU T1, T1, T0
9D0103CC  0128182B   SLTU V1, T1, T0
9D0103D0  54600005   BNEL V1, ZERO, 0x9D0103E8
9D0103D4  01244823   SUBU T1, T1, A0
9D0103D8  0124182B   SLTU V1, T1, A0
9D0103DC  01284021   ADDU T0, T1, T0
9D0103E0  0103480B   MOVN T1, T0, V1
9D0103E4  01244823   SUBU T1, T1, A0
9D01079C  00081C02   SRL V1, T0, 16
9D0107A0  0123001B   DIVU T1, V1
9D0107A4  006001F4   TEQ V1, ZERO
9D0107A8  00006010   MFHI T4
9D0107AC  00005812   MFLO T3
9D0107B0  310AFFFF   ANDI T2, T0, -1
9D0107B4  00022402   SRL A0, V0, 16
9D0107B8  00003012   MFLO A2
9D0107BC  716A3802   MUL A3, T3, T2
9D0107C0  000C6400   SLL T4, T4, 16
9D0107C4  01842025   OR A0, T4, A0
9D0107C8  0087602B   SLTU T4, A0, A3
9D0107CC  0123001B   DIVU T1, V1
9D0107D0  006001F4   TEQ V1, ZERO
9D0107D4  1180000B   BEQ T4, ZERO, 0x9D010804
9D0107D8  00872823   SUBU A1, A0, A3
9D0107DC  00882021   ADDU A0, A0, T0
9D0107E0  0088282B   SLTU A1, A0, T0
9D0107E4  14A00006   BNE A1, ZERO, 0x9D010800
9D0107E8  2566FFFF   ADDIU A2, T3, -1
9D0107EC  0087282B   SLTU A1, A0, A3
9D0107F0  10A00004   BEQ A1, ZERO, 0x9D010804
9D0107F4  00872823   SUBU A1, A0, A3
9D0107F8  2566FFFE   ADDIU A2, T3, -2
9D0107FC  00882021   ADDU A0, A0, T0
9D010800  00872823   SUBU A1, A0, A3
9D010804  3042FFFF   ANDI V0, V0, -1
9D010808  00A3001B   DIVU A1, V1
9D01080C  006001F4   TEQ V1, ZERO
9D010810  00004810   MFHI T1
9D010814  00003812   MFLO A3
9D010818  00002012   MFLO A0
9D01081C  70EA5002   MUL T2, A3, T2
9D010820  00094C00   SLL T1, T1, 16
9D010824  01221025   OR V0, T1, V0
9D010828  004A482B   SLTU T1, V0, T2
9D01082C  00A3001B   DIVU A1, V1
9D010830  006001F4   TEQ V1, ZERO
9D010834  51200009   BEQL T1, ZERO, 0x9D01085C
9D010838  00061400   SLL V0, A2, 16
9D01083C  00481021   ADDU V0, V0, T0
9D010840  0048402B   SLTU T0, V0, T0
9D010844  15000004   BNE T0, ZERO, 0x9D010858
9D010848  24E4FFFF   ADDIU A0, A3, -1
9D01084C  004A502B   SLTU T2, V0, T2
9D010850  24E7FFFE   ADDIU A3, A3, -2
9D010854  00EA200B   MOVN A0, A3, T2
9D010858  00061400   SLL V0, A2, 16
9D01085C  00821025   OR V0, A0, V0
9D010860  03E00008   JR RA
9D010864  00001821   ADDU V1, ZERO, ZERO
9D010434  14C00006   BNE A2, ZERO, 0x9D010450
9D010438  71021020   CLZ V0, T0
9D010894  14C00006   BNE A2, ZERO, 0x9D0108B0
9D010898  71031820   CLZ V1, T0
9D01043C  24020001   ADDIU V0, ZERO, 1
9D010440  0046001B   DIVU V0, A2
9D010444  00C001F4   TEQ A2, ZERO
9D010448  00004012   MFLO T0
9D01089C  24030001   ADDIU V1, ZERO, 1
9D0108A0  0066001B   DIVU V1, A2
9D0108A4  00C001F4   TEQ A2, ZERO
9D0108A8  00004012   MFLO T0
9D01044C  71021020   CLZ V0, T0
9D0108AC  71031820   CLZ V1, T0
9D010450  5440007D   BNEL V0, ZERO, 0x9D010648
9D010454  00484004   SLLV T0, T0, V0
9D0108B0  5460007B   BNEL V1, ZERO, 0x9D010AA0
9D0108B4  00684004   SLLV T0, T0, V1
9D010458  00A82823   SUBU A1, A1, T0
9D01045C  00081C02   SRL V1, T0, 16
9D010460  3107FFFF   ANDI A3, T0, -1
9D0108B8  00A82023   SUBU A0, A1, T0
9D0108BC  00083C02   SRL A3, T0, 16
9D0108C0  310BFFFF   ANDI T3, T0, -1
9D0108C4  24030001   ADDIU V1, ZERO, 1
9D010648  24090020   ADDIU T1, ZERO, 32
9D01064C  01224823   SUBU T1, T1, V0
9D010AA0  24020020   ADDIU V0, ZERO, 32
9D010AA4  00431023   SUBU V0, V0, V1
9D010650  01255006   SRLV T2, A1, T1
9D010AA8  00454806   SRLV T1, A1, V0
9D01066C  00452804   SLLV A1, A1, V0
9D010670  01244806   SRLV T1, A0, T1
9D010674  01252825   OR A1, T1, A1
9D010AC4  00652804   SLLV A1, A1, V1
9D010AC8  00441006   SRLV V0, A0, V0
9D010ACC  00452825   OR A1, V0, A1
9D01067C  00444804   SLLV T1, A0, V0
9D010AD4  00641004   SLLV V0, A0, V1
9D010654  00081C02   SRL V1, T0, 16
9D010658  0143001B   DIVU T2, V1
9D01065C  006001F4   TEQ V1, ZERO
9D010660  00003010   MFHI A2
9D010664  00005812   MFLO T3
9D010668  3107FFFF   ANDI A3, T0, -1
9D010678  00056402   SRL T4, A1, 16
9D010680  71675802   MUL T3, T3, A3
9D010684  00063400   SLL A2, A2, 16
9D010688  01863025   OR A2, T4, A2
9D01068C  00CB202B   SLTU A0, A2, T3
9D010690  0143001B   DIVU T2, V1
9D010694  006001F4   TEQ V1, ZERO
9D010698  50800006   BEQL A0, ZERO, 0x9D0106B4
9D01069C  00CB3023   SUBU A2, A2, T3
9D0106A0  00C83021   ADDU A2, A2, T0
9D0106A4  00C8202B   SLTU A0, A2, T0
9D0106A8  10800024   BEQ A0, ZERO, 0x9D01073C
9D0106AC  00CB502B   SLTU T2, A2, T3
9D0106B0  00CB3023   SUBU A2, A2, T3
9D0106B4  30AAFFFF   ANDI T2, A1, -1
9D0106B8  00C3001B   DIVU A2, V1
9D0106BC  006001F4   TEQ V1, ZERO
9D0106C0  00002010   MFHI A0
9D0106C4  00002812   MFLO A1
9D0106C8  70A72802   MUL A1, A1, A3
9D0106CC  00042400   SLL A0, A0, 16
9D0106D0  008A2025   OR A0, A0, T2
9D0106D4  0085502B   SLTU T2, A0, A1
9D0106D8  00C3001B   DIVU A2, V1
9D0106DC  006001F4   TEQ V1, ZERO
9D0106E0  5140FF60   BEQL T2, ZERO, 0x9D010464
9D0106E4  00852823   SUBU A1, A0, A1
9D0106E8  00882021   ADDU A0, A0, T0
9D0106EC  0088302B   SLTU A2, A0, T0
9D0106F0  54C0FF5C   BNEL A2, ZERO, 0x9D010464
9D0106F4  00852823   SUBU A1, A0, A1
9D0106F8  0085502B   SLTU T2, A0, A1
9D0106FC  00883021   ADDU A2, A0, T0
9D010700  00CA200B   MOVN A0, A2, T2
9D010704  0B404119   J 0x9D010464
9D010708  00852823   SUBU A1, A0, A1
9D01073C  00C82021   ADDU A0, A2, T0
9D010740  0B4041AC   J 0x9D0106B0
9D010744  008A300B   MOVN A2, A0, T2
9D010AAC  00083C02   SRL A3, T0, 16
9D010AB0  0127001B   DIVU T1, A3
9D010AB4  00E001F4   TEQ A3, ZERO
9D010AB8  00003010   MFHI A2
9D010ABC  00006012   MFLO T4
9D010AC0  310BFFFF   ANDI T3, T0, -1
9D010AD0  00056C02   SRL T5, A1, 16
9D010AD8  00001812   MFLO V1
9D010ADC  718B5002   MUL T2, T4, T3
9D010AE0  00063400   SLL A2, A2, 16
9D010AE4  01A63025   OR A2, T5, A2
9D010AE8  00CA202B   SLTU A0, A2, T2
9D010AEC  0127001B   DIVU T1, A3
9D010AF0  00E001F4   TEQ A3, ZERO
9D010AF4  5080000B   BEQL A0, ZERO, 0x9D010B24
9D010AF8  00CA3023   SUBU A2, A2, T2
9D010AFC  00C83021   ADDU A2, A2, T0
9D010B00  00C8202B   SLTU A0, A2, T0
9D010B04  14800006   BNE A0, ZERO, 0x9D010B20
9D010B08  2583FFFF   ADDIU V1, T4, -1
9D010B0C  00CA202B   SLTU A0, A2, T2
9D010B10  50800004   BEQL A0, ZERO, 0x9D010B24
9D010B14  00CA3023   SUBU A2, A2, T2
9D010B18  2583FFFE   ADDIU V1, T4, -2
9D010B1C  00C83021   ADDU A2, A2, T0
9D010B20  00CA3023   SUBU A2, A2, T2
9D010B24  30ACFFFF   ANDI T4, A1, -1
9D010B28  00C7001B   DIVU A2, A3
9D010B2C  00E001F4   TEQ A3, ZERO
9D010B30  00002010   MFHI A0
9D010B34  00005012   MFLO T2
9D010B38  00004812   MFLO T1
9D010B3C  714B2802   MUL A1, T2, T3
9D010B40  00042400   SLL A0, A0, 16
9D010B44  008C2025   OR A0, A0, T4
9D010B48  0085602B   SLTU T4, A0, A1
9D010B4C  00C7001B   DIVU A2, A3
9D010B50  00E001F4   TEQ A3, ZERO
9D010B54  5180000B   BEQL T4, ZERO, 0x9D010B84
9D010B58  00031C00   SLL V1, V1, 16
9D010B5C  00882021   ADDU A0, A0, T0
9D010B60  0088302B   SLTU A2, A0, T0
9D010B64  14C00006   BNE A2, ZERO, 0x9D010B80
9D010B68  2549FFFF   ADDIU T1, T2, -1
9D010B6C  0085302B   SLTU A2, A0, A1
9D010B70  50C00004   BEQL A2, ZERO, 0x9D010B84
9D010B74  00031C00   SLL V1, V1, 16
9D010B78  2549FFFE   ADDIU T1, T2, -2
9D010B7C  00882021   ADDU A0, A0, T0
9D010B80  00031C00   SLL V1, V1, 16
9D010B84  00852023   SUBU A0, A0, A1
9D010B88  0B404232   J 0x9D0108C8
9D010B8C  01231825   OR V1, T1, V1
9D010464  00092402   SRL A0, T1, 16
9D010468  00A3001B   DIVU A1, V1
9D01046C  006001F4   TEQ V1, ZERO
9D010470  00005010   MFHI T2
9D010474  00003012   MFLO A2
9D010478  70C73002   MUL A2, A2, A3
9D01047C  000A5400   SLL T2, T2, 16
9D010480  01442025   OR A0, T2, A0
9D010484  0086502B   SLTU T2, A0, A2
9D010488  00A3001B   DIVU A1, V1
9D01048C  006001F4   TEQ V1, ZERO
9D010490  51400009   BEQL T2, ZERO, 0x9D0104B8
9D010494  00862023   SUBU A0, A0, A2
9D010498  00882021   ADDU A0, A0, T0
9D01049C  0088282B   SLTU A1, A0, T0
9D0104A0  54A00005   BNEL A1, ZERO, 0x9D0104B8
9D0104A4  00862023   SUBU A0, A0, A2
9D0104A8  0086502B   SLTU T2, A0, A2
9D0104AC  00882821   ADDU A1, A0, T0
9D0104B0  00AA200B   MOVN A0, A1, T2
9D0104B4  00862023   SUBU A0, A0, A2
9D0104B8  3126FFFF   ANDI A2, T1, -1
9D0104BC  0083001B   DIVU A0, V1
9D0104C0  006001F4   TEQ V1, ZERO
9D0104C4  00004810   MFHI T1
9D0104C8  00002812   MFLO A1
9D0104CC  70A72802   MUL A1, A1, A3
9D0104D0  00094C00   SLL T1, T1, 16
9D0104D4  01264825   OR T1, T1, A2
9D0104D8  0125302B   SLTU A2, T1, A1
9D0104DC  0083001B   DIVU A0, V1
9D0104E0  006001F4   TEQ V1, ZERO
9D0104E4  50C00009   BEQL A2, ZERO, 0x9D01050C
9D0104E8  01254823   SUBU T1, T1, A1
9D0104EC  01284821   ADDU T1, T1, T0
9D0104F0  0128182B   SLTU V1, T1, T0
9D0104F4  54600005   BNEL V1, ZERO, 0x9D01050C
9D0104F8  01254823   SUBU T1, T1, A1
9D0104FC  0125182B   SLTU V1, T1, A1
9D010500  01284021   ADDU T0, T1, T0
9D010504  0103480B   MOVN T1, T0, V1
9D010508  01254823   SUBU T1, T1, A1
9D0108C8  00023402   SRL A2, V0, 16
9D0108CC  0087001B   DIVU A0, A3
9D0108D0  00E001F4   TEQ A3, ZERO
9D0108D4  00006810   MFHI T5
9D0108D8  00006012   MFLO T4
9D0108DC  00004812   MFLO T1
9D0108E0  718B5002   MUL T2, T4, T3
9D0108E4  000D6C00   SLL T5, T5, 16
9D0108E8  01A63025   OR A2, T5, A2
9D0108EC  00CA682B   SLTU T5, A2, T2
9D0108F0  0087001B   DIVU A0, A3
9D0108F4  00E001F4   TEQ A3, ZERO
9D0108F8  11A00009   BEQ T5, ZERO, 0x9D010920
9D0108FC  00CA2823   SUBU A1, A2, T2
9D010900  00C83021   ADDU A2, A2, T0
9D010904  00C8202B   SLTU A0, A2, T0
9D010908  14800004   BNE A0, ZERO, 0x9D01091C
9D01090C  2589FFFF   ADDIU T1, T4, -1
9D010910  00CA202B   SLTU A0, A2, T2
9D010914  548000A6   BNEL A0, ZERO, 0x9D010BB0
9D010918  2589FFFE   ADDIU T1, T4, -2
9D01091C  00CA2823   SUBU A1, A2, T2
9D010920  3042FFFF   ANDI V0, V0, -1
9D010924  00A7001B   DIVU A1, A3
9D010928  00E001F4   TEQ A3, ZERO
9D01092C  00005010   MFHI T2
9D010930  00003012   MFLO A2
9D010934  00002012   MFLO A0
9D010938  70CB5802   MUL T3, A2, T3
9D01093C  000A5400   SLL T2, T2, 16
9D010940  01421025   OR V0, T2, V0
9D010944  004B502B   SLTU T2, V0, T3
9D010948  00A7001B   DIVU A1, A3
9D01094C  00E001F4   TEQ A3, ZERO
9D010950  51400009   BEQL T2, ZERO, 0x9D010978
9D010954  00091400   SLL V0, T1, 16
9D010958  00481021   ADDU V0, V0, T0
9D01095C  0048402B   SLTU T0, V0, T0
9D010960  15000004   BNE T0, ZERO, 0x9D010974
9D010964  24C4FFFF   ADDIU A0, A2, -1
9D010968  004B582B   SLTU T3, V0, T3
9D01096C  24C6FFFE   ADDIU A2, A2, -2
9D010970  00CB200B   MOVN A0, A2, T3
9D010974  00091400   SLL V0, T1, 16
9D010978  03E00008   JR RA
9D01097C  00821025   OR V0, A0, V0
9D010BB0  0B404247   J 0x9D01091C
9D0103E8  00491006   SRLV V0, T1, V0
9D01050C  00491006   SRLV V0, T1, V0
9D0103EC  03E00008   JR RA
9D0103F0  00001821   ADDU V1, ZERO, ZERO
9D010510  03E00008   JR RA
9D010514  00001821   ADDU V1, ZERO, ZERO
9D0103F4  00A7102B   SLTU V0, A1, A3
9D0103F8  14400047   BNE V0, ZERO, 0x9D010518
9D0103FC  70EA5020   CLZ T2, A3
9D010868  00A7102B   SLTU V0, A1, A3
9D01086C  14400044   BNE V0, ZERO, 0x9D010980
9D010870  70E84020   CLZ T0, A3
9D010980  00001821   ADDU V1, ZERO, ZERO
9D010984  03E00008   JR RA
9D010988  00001021   ADDU V0, ZERO, ZERO
9D010518  00801021   ADDU V0, A0, ZERO
9D01051C  03E00008   JR RA
9D010520  00A01821   ADDU V1, A1, ZERO
9D010400  15400048   BNE T2, ZERO, 0x9D010524
9D010404  240B0020   ADDIU T3, ZERO, 32
9D010874  55000045   BNEL T0, ZERO, 0x9D01098C
9D010878  24020020   ADDIU V0, ZERO, 32
9D010408  00E5102B   SLTU V0, A3, A1
9D01040C  14400005   BNE V0, ZERO, 0x9D010424
9D010410  00861023   SUBU V0, A0, A2
9D010414  0086402B   SLTU T0, A0, A2
9D010418  15000089   BNE T0, ZERO, 0x9D010640
9D01041C  00801021   ADDU V0, A0, ZERO
9D01087C  00E5282B   SLTU A1, A3, A1
9D010880  14A000C8   BNE A1, ZERO, 0x9D010BA4
9D010884  0086302B   SLTU A2, A0, A2
9D010888  38C20001   XORI V0, A2, 1
9D01088C  03E00008   JR RA
9D010890  00001821   ADDU V1, ZERO, ZERO
9D010BA4  00001821   ADDU V1, ZERO, ZERO
9D010420  00861023   SUBU V0, A0, A2
9D010424  00A72823   SUBU A1, A1, A3
9D010428  0082202B   SLTU A0, A0, V0
9D01042C  03E00008   JR RA
9D010430  00A41823   SUBU V1, A1, A0
9D010524  016A5823   SUBU T3, T3, T2
9D01098C  00481023   SUBU V0, V0, T0
9D010528  01473804   SLLV A3, A3, T2
9D01052C  01661006   SRLV V0, A2, T3
9D010530  00473825   OR A3, V0, A3
9D010990  01073804   SLLV A3, A3, T0
9D010994  00461806   SRLV V1, A2, V0
9D010998  00673825   OR A3, V1, A3
9D010560  01463004   SLLV A2, A2, T2
9D010534  01656806   SRLV T5, A1, T3
9D01099C  00455006   SRLV T2, A1, V0
9D010550  01452804   SLLV A1, A1, T2
9D010554  01641006   SRLV V0, A0, T3
9D010558  00451025   OR V0, V0, A1
9D0109B8  01052804   SLLV A1, A1, T0
9D0109BC  00441006   SRLV V0, A0, V0
9D0109C0  00452825   OR A1, V0, A1
9D010538  00074C02   SRL T1, A3, 16
9D01053C  01A9001B   DIVU T5, T1
9D010540  012001F4   TEQ T1, ZERO
9D010544  00006010   MFHI T4
9D010548  00001812   MFLO V1
9D01054C  30EEFFFF   ANDI T6, A3, -1
9D01055C  00022C02   SRL A1, V0, 16
9D010564  00004012   MFLO T0
9D010568  706E7802   MUL T7, V1, T6
9D01056C  000C6400   SLL T4, T4, 16
9D010570  01856025   OR T4, T4, A1
9D010574  018F282B   SLTU A1, T4, T7
9D010578  01A9001B   DIVU T5, T1
9D01057C  012001F4   TEQ T1, ZERO
9D010580  10A0000A   BEQ A1, ZERO, 0x9D0105AC
9D010584  01442004   SLLV A0, A0, T2
9D010588  01876021   ADDU T4, T4, A3
9D01058C  0187282B   SLTU A1, T4, A3
9D010590  14A00006   BNE A1, ZERO, 0x9D0105AC
9D010594  2468FFFF   ADDIU T0, V1, -1
9D010598  018F282B   SLTU A1, T4, T7
9D01059C  50A00004   BEQL A1, ZERO, 0x9D0105B0
9D0105A0  018F6023   SUBU T4, T4, T7
9D0105A4  2468FFFE   ADDIU T0, V1, -2
9D0105A8  01876021   ADDU T4, T4, A3
9D0105AC  018F6023   SUBU T4, T4, T7
9D0105B0  3042FFFF   ANDI V0, V0, -1
9D0105B4  0189001B   DIVU T4, T1
9D0105B8  012001F4   TEQ T1, ZERO
9D0105BC  00002810   MFHI A1
9D0105C0  00001812   MFLO V1
9D0105C4  00006812   MFLO T5
9D0105C8  706E7002   MUL T6, V1, T6
9D0105CC  00052C00   SLL A1, A1, 16
9D0105D0  00A21025   OR V0, A1, V0
9D0105D4  004E282B   SLTU A1, V0, T6
9D0105D8  0189001B   DIVU T4, T1
9D0105DC  012001F4   TEQ T1, ZERO
9D0105E0  50A00006   BEQL A1, ZERO, 0x9D0105FC
9D0105E4  00084400   SLL T0, T0, 16
9D0105E8  00471021   ADDU V0, V0, A3
9D0105EC  0047282B   SLTU A1, V0, A3
9D0105F0  10A0004C   BEQ A1, ZERO, 0x9D010724
9D0105F4  246DFFFF   ADDIU T5, V1, -1
9D0105F8  00084400   SLL T0, T0, 16
9D0105FC  01A84025   OR T0, T5, T0
9D010600  004E1023   SUBU V0, V0, T6
9D010724  004E282B   SLTU A1, V0, T6
9D010728  50A0FFB4   BEQL A1, ZERO, 0x9D0105FC
9D01072C  00084400   SLL T0, T0, 16
9D010730  246DFFFE   ADDIU T5, V1, -2
9D010734  0B40417E   J 0x9D0105F8
9D010738  00471021   ADDU V0, V0, A3
9D0109A0  00071C02   SRL V1, A3, 16
9D0109A4  0143001B   DIVU T2, V1
9D0109A8  006001F4   TEQ V1, ZERO
9D0109AC  00004810   MFHI T1
9D0109B0  00006812   MFLO T5
9D0109B4  30EBFFFF   ANDI T3, A3, -1
9D0109C4  00057402   SRL T6, A1, 16
9D0109C8  00001012   MFLO V0
9D0109CC  71AB6002   MUL T4, T5, T3
9D0109D0  00094C00   SLL T1, T1, 16
9D0109D4  012E4825   OR T1, T1, T6
9D0109D8  012C702B   SLTU T6, T1, T4
9D0109DC  0143001B   DIVU T2, V1
9D0109E0  006001F4   TEQ V1, ZERO
9D0109E4  11C0000A   BEQ T6, ZERO, 0x9D010A10
9D0109E8  01063004   SLLV A2, A2, T0
9D0109EC  01274821   ADDU T1, T1, A3
9D0109F0  0127502B   SLTU T2, T1, A3
9D0109F4  15400006   BNE T2, ZERO, 0x9D010A10
9D0109F8  25A2FFFF   ADDIU V0, T5, -1
9D0109FC  012C502B   SLTU T2, T1, T4
9D010A00  51400004   BEQL T2, ZERO, 0x9D010A14
9D010A04  012C4823   SUBU T1, T1, T4
9D010A08  25A2FFFE   ADDIU V0, T5, -2
9D010A0C  01274821   ADDU T1, T1, A3
9D010A10  012C4823   SUBU T1, T1, T4
9D010A14  30A5FFFF   ANDI A1, A1, -1
9D010A18  0123001B   DIVU T1, V1
9D010A1C  006001F4   TEQ V1, ZERO
9D010A20  00006810   MFHI T5
9D010A24  00006012   MFLO T4
9D010A28  00005012   MFLO T2
9D010A2C  718B5802   MUL T3, T4, T3
9D010A30  000D6C00   SLL T5, T5, 16
9D010A34  01A52825   OR A1, T5, A1
9D010A38  00AB682B   SLTU T5, A1, T3
9D010A3C  0123001B   DIVU T1, V1
9D010A40  006001F4   TEQ V1, ZERO
9D010A44  51A0000B   BEQL T5, ZERO, 0x9D010A74
9D010A48  00021400   SLL V0, V0, 16
9D010A4C  00A72821   ADDU A1, A1, A3
9D010A50  00A7182B   SLTU V1, A1, A3
9D010A54  14600006   BNE V1, ZERO, 0x9D010A70
9D010A58  258AFFFF   ADDIU T2, T4, -1
9D010A5C  00AB182B   SLTU V1, A1, T3
9D010A60  50600004   BEQL V1, ZERO, 0x9D010A74
9D010A64  00021400   SLL V0, V0, 16
9D010A68  258AFFFE   ADDIU T2, T4, -2
9D010A6C  00A72821   ADDU A1, A1, A3
9D010A70  00021400   SLL V0, V0, 16
9D010A74  01421025   OR V0, T2, V0
9D010A78  00AB2823   SUBU A1, A1, T3
9D010604  01060019   MULTU 0, T0, A2
9D010608  00004810   MFHI T1
9D010620  00003012   MFLO A2
9D010A7C  00460019   MULTU 0, V0, A2
9D010A80  00003810   MFHI A3
9D01060C  0049182B   SLTU V1, V0, T1
9D010610  1460003E   BNE V1, ZERO, 0x9D01070C
9D010614  00004012   MFLO T0
9D010618  1049004B   BEQ V0, T1, 0x9D010748
9D01061C  00491823   SUBU V1, V0, T1
9D010748  0088182B   SLTU V1, A0, T0
9D010A84  00A7182B   SLTU V1, A1, A3
9D010A88  14600044   BNE V1, ZERO, 0x9D010B9C
9D010A8C  00003012   MFLO A2
9D010A90  10A7003F   BEQ A1, A3, 0x9D010B90
9D010A94  01042004   SLLV A0, A0, T0
9D010B90  0086302B   SLTU A2, A0, A2
9D010B94  10C0FFC0   BEQ A2, ZERO, 0x9D010A98
9D010B98  00000000   NOP
9D010A98  03E00008   JR RA
9D010A9C  00001821   ADDU V1, ZERO, ZERO
9D010B9C  0B4042A6   J 0x9D010A98
9D010BA0  2442FFFF   ADDIU V0, V0, -1
9D01070C  01063023   SUBU A2, T0, A2
9D010710  01271823   SUBU V1, T1, A3
9D010714  0106402B   SLTU T0, T0, A2
9D010718  00681823   SUBU V1, V1, T0
9D01071C  0B404189   J 0x9D010624
9D010720  00431823   SUBU V1, V0, V1
9D010624  00863023   SUBU A2, A0, A2
9D010628  0086202B   SLTU A0, A0, A2
9D01062C  00641823   SUBU V1, V1, A0
9D010630  01631004   SLLV V0, V1, T3
9D010634  01463006   SRLV A2, A2, T2
9D010638  00461025   OR V0, V0, A2
9D01063C  01431806   SRLV V1, V1, T2
9D010640  03E00008   JR RA
9D010644  00000000   NOP
9D010648  24090020   ADDIU T1, ZERO, 32
9D01064C  01224823   SUBU T1, T1, V0
9D010650  01255006   SRLV T2, A1, T1
9D010654  00081C02   SRL V1, T0, 16
9D010658  0143001B   DIVU T2, V1
9D01065C  006001F4   TEQ V1, ZERO
9D010660  00003010   MFHI A2
9D010664  00005812   MFLO T3
9D010668  3107FFFF   ANDI A3, T0, -1
9D01066C  00452804   SLLV A1, A1, V0
9D010670  01244806   SRLV T1, A0, T1
9D010674  01252825   OR A1, T1, A1
9D010678  00056402   SRL T4, A1, 16
9D01067C  00444804   SLLV T1, A0, V0
9D010680  71675802   MUL T3, T3, A3
9D010684  00063400   SLL A2, A2, 16
9D010688  01863025   OR A2, T4, A2
9D01068C  00CB202B   SLTU A0, A2, T3
9D010690  0143001B   DIVU T2, V1
9D010694  006001F4   TEQ V1, ZERO
9D010698  50800006   BEQL A0, ZERO, 0x9D0106B4
9D01069C  00CB3023   SUBU A2, A2, T3
9D0106A0  00C83021   ADDU A2, A2, T0
9D0106A4  00C8202B   SLTU A0, A2, T0
9D0106A8  10800024   BEQ A0, ZERO, 0x9D01073C
9D0106AC  00CB502B   SLTU T2, A2, T3
9D0106B0  00CB3023   SUBU A2, A2, T3
9D0106B4  30AAFFFF   ANDI T2, A1, -1
9D0106B8  00C3001B   DIVU A2, V1
9D0106BC  006001F4   TEQ V1, ZERO
9D0106C0  00002010   MFHI A0
9D0106C4  00002812   MFLO A1
9D0106C8  70A72802   MUL A1, A1, A3
9D0106CC  00042400   SLL A0, A0, 16
9D0106D0  008A2025   OR A0, A0, T2
9D0106D4  0085502B   SLTU T2, A0, A1
9D0106D8  00C3001B   DIVU A2, V1
9D0106DC  006001F4   TEQ V1, ZERO
9D0106E0  5140FF60   BEQL T2, ZERO, 0x9D010464
9D0106E4  00852823   SUBU A1, A0, A1
9D0106E8  00882021   ADDU A0, A0, T0
9D0106EC  0088302B   SLTU A2, A0, T0
9D0106F0  54C0FF5C   BNEL A2, ZERO, 0x9D010464
9D0106F4  00852823   SUBU A1, A0, A1
9D0106F8  0085502B   SLTU T2, A0, A1
9D0106FC  00883021   ADDU A2, A0, T0
9D010700  00CA200B   MOVN A0, A2, T2
9D010704  0B404119   J 0x9D010464
9D010708  00852823   SUBU A1, A0, A1
9D01070C  01063023   SUBU A2, T0, A2
9D010710  01271823   SUBU V1, T1, A3
9D010714  0106402B   SLTU T0, T0, A2
9D010718  00681823   SUBU V1, V1, T0
9D01071C  0B404189   J 0x9D010624
9D010720  00431823   SUBU V1, V0, V1
9D010724  004E282B   SLTU A1, V0, T6
9D010728  50A0FFB4   BEQL A1, ZERO, 0x9D0105FC
9D01072C  00084400   SLL T0, T0, 16
9D010730  246DFFFE   ADDIU T5, V1, -2
9D010734  0B40417E   J 0x9D0105F8
9D010738  00471021   ADDU V0, V0, A3
9D01073C  00C82021   ADDU A0, A2, T0
9D010740  0B4041AC   J 0x9D0106B0
9D010744  008A300B   MOVN A2, A0, T2
9D010748  0088182B   SLTU V1, A0, T0
9D01074C  5460FFF0   BNEL V1, ZERO, 0x9D010710
9D010750  01063023   SUBU A2, T0, A2
9D010754  00003012   MFLO A2
9D010758  0B404189   J 0x9D010624
9D01075C  00001821   ADDU V1, ZERO, ZERO
9D010BA8  03E00008   JR RA
9D010BAC  24020001   ADDIU V0, ZERO, 1
9D010BB0  0B404247   J 0x9D01091C
9D010BB4  00C83021   ADDU A2, A2, T0
9D018CF4  27BDFFE0   ADDIU SP, SP, -32
9D018CF8  AFBF001C   SW RA, 28(SP)
9D018CFC  AFB00018   SW S0, 24(SP)
9D018D00  00808021   ADDU S0, A0, ZERO
9D018D04  0F406456   JAL __floatunsidf
9D018D08  00A02021   ADDU A0, A1, ZERO
9D018D0C  3C049D02   LUI A0, -25342
9D018D10  8C869980   LW A2, -26240(A0)
9D018D14  8C879984   LW A3, -26236(A0)
9D018D18  00402021   ADDU A0, V0, ZERO
9D018D1C  0F4048A6   JAL dpmul
9D018D20  00602821   ADDU A1, V1, ZERO
9D018D24  02002021   ADDU A0, S0, ZERO
9D018D28  AFA20010   SW V0, 16(SP)
9D018D2C  0F406456   JAL __floatunsidf
9D018D30  AFA30014   SW V1, 20(SP)
9D018D34  00402021   ADDU A0, V0, ZERO
9D018D38  00602821   ADDU A1, V1, ZERO
9D018D3C  8FA60010   LW A2, 16(SP)
9D018D40  0F4043FF   JAL __adddf3
9D018D44  8FA70014   LW A3, 20(SP)
9D018D48  8FBF001C   LW RA, 28(SP)
9D018D4C  8FB00018   LW S0, 24(SP)
9D018D50  03E00008   JR RA
9D018D54  27BD0020   ADDIU SP, SP, 32
---  /build/bamboo/xml-data/build-dir/XC32-CYIMG-BLD/xc32-XC32-release-1_44/src48x/gcc/libgcc/floatunsidf.c
9D019158  27BDFFE8   ADDIU SP, SP, -24
9D01915C  AFBF0014   SW RA, 20(SP)
9D019160  AFB00010   SW S0, 16(SP)
9D019164  0F40629E   JAL __floatsidf
9D019168  00808021   ADDU S0, A0, ZERO
9D01916C  06010008   BGEZ S0, 0x9D019190
9D019170  8FBF0014   LW RA, 20(SP)
9D019174  3C049D02   LUI A0, -25342
9D019178  8C869988   LW A2, -26232(A0)
9D01917C  8C87998C   LW A3, -26228(A0)
9D019180  00402021   ADDU A0, V0, ZERO
9D019184  0F4043FF   JAL __adddf3
9D019188  00602821   ADDU A1, V1, ZERO
9D01918C  8FBF0014   LW RA, 20(SP)
9D019190  8FB00010   LW S0, 16(SP)
9D019194  03E00008   JR RA
9D019198  27BD0018   ADDIU SP, SP, 24
