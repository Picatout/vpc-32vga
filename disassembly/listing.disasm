Disassembly Listing for vpc-32vga
Generated From:
/home/jacques/github/vpc-32vga/dist/default/production/vpc-32vga.production.elf
2018-03-20 11:35:49

---  /opt/microchip/xc32/v1.44/pic32mx/include/peripheral/uart.h  ---------------------------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright © 2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  // Section: Constants & Data Types
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  
84:                  //DOM-IGNORE-BEGIN
85:                  /****
86:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
87:                         the device file.  Also the UART register set could also be placed there
88:                  *****/
89:                  typedef struct
90:                  {
91:                      volatile UINT   reg;
92:                      volatile UINT   clr;
93:                      volatile UINT   set;
94:                      volatile UINT   inv;
95:                  }REG_SET;
96:                  
97:                  typedef struct
98:                  {
99:                      volatile REG_SET    mode;
100:                     volatile REG_SET    sta;
101:                     volatile REG_SET    tx;
102:                     volatile REG_SET    rx;
103:                     volatile REG_SET    brg;
104:                 }UART_REGS;
105:                 
106:                 extern UART_REGS * const uartReg[];
107:                 //DOM-IGNORE-END
108:                 
109:                 // *****************************************************************************
110:                 /* UART Module
111:                 
112:                   Summary:
113:                     UART modules supported.
114:                 
115:                   Description:
116:                     This enumeration identifies the available UART modules.
117:                 */
118:                 
119:                 typedef enum
120:                 {
121:                 #if defined _UART1
122:                     // UART1 Module ID.
123:                     UART1 = 0,
124:                 #endif
125:                 #if defined _UART2
126:                     // UART2 Module ID.
127:                     UART2,
128:                 #endif
129:                 #ifdef _UART3
130:                     // UART3 Module ID.
131:                     UART3,
132:                 #endif
133:                 #ifdef _UART4
134:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
135:                     UART4,
136:                 #endif
137:                 #ifdef _UART5
138:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
139:                     UART5,
140:                 #endif
141:                 #ifdef _UART6
142:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
143:                     UART6,
144:                 #endif
145:                     // Number of available UART modules.
146:                     UART_NUMBER_OF_MODULES
147:                 
148:                 } UART_MODULE;
149:                 
150:                 
151:                 // *****************************************************************************
152:                 /* UART Enable Modes
153:                 
154:                   Summary:
155:                     Operating modes of UART.
156:                 
157:                   Description:
158:                     This enumeration defines the supported modes in which the UART may be
159:                     enabled or disbled.
160:                 
161:                   Remarks:
162:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
163:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
164:                     has been pre-loaded with data.
165:                 
166:                     The caller should not rely on the specific numbers assigned to any of these
167:                     values as they may change from one processor to the next.
168:                 */
169:                 
170:                 typedef enum
171:                 {
172:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
173:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
174:                 
175:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
176:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
177:                 
178:                 
179:                     // UART Module, receiver and transmitter functionality is not.
180:                     // enabled or disabled
181:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
182:                 
183:                     // UART Module receiver.
184:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
185:                 
186:                     // UART Module transmitter.
187:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
188:                 
189:                 
190:                 } UART_ENABLE_MODE;
191:                 
192:                 // *****************************************************************************
193:                 /* UART Enable Helper Macro
194:                 
195:                   Summary:
196:                     Macro for enabling module operating modes.
197:                 
198:                   Description:
199:                     This macro creates the proper flags for enabling operating modes of the UART module.
200:                 
201:                   Example:
202:                     <code>
203:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
204:                     </code>
205:                 
206:                   Remarks:
207:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
208:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
209:                     has been pre-loaded with data.
210:                 */
211:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
212:                 
213:                 // *****************************************************************************
214:                 /* UART Disable Helper Macro
215:                 
216:                   Summary:
217:                     Macro for disabling module operating modes.
218:                 
219:                   Description:
220:                     This macro creates the proper flags for disabling operating modes of the UART module.
221:                 
222:                   Example:
223:                     <code>
224:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
225:                     </code>
226:                 
227:                 */
228:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
229:                 
230:                 // *****************************************************************************
231:                 /* UART Configuration Settings
232:                 
233:                   Summary:
234:                     Supported configuration flags for the UART module.
235:                 
236:                   Description:
237:                     This enumeration defines the various configuration options for the UART
238:                     module.  These values can be OR'd together to create a configuration mask
239:                     passed to the UARTConfigure routine.
240:                 
241:                   Remarks:
242:                     Several of the configuration options are mutually exclusive:
243:                     * Only one of the "ENABLE_PINS" modes can be used at a time
244:                     * Only one of the "RTS_WHEN" modes can be used at a time
245:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
246:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
247:                 
248:                     The caller should not rely on the specific numbers assigned to any of these
249:                     values as they may change from one processor ot the next.
250:                 */
251:                 
252:                 typedef enum
253:                 {
254:                     // Enables high-speed range of the UART (see UARTSetBitRate).
255:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
256:                 
257:                     // Inverts polarity of data interpretation the received (RX) pin.
258:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
259:                 
260:                     // Enables UART TX-to-RX Loop-back mode.
261:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
262:                 
263:                     // Enables Wake-up of the part when a start bit is received.
264:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
265:                 
266:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
267:                     // cannot be used in bit-clock/IrDA mode).
268:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
269:                 
270:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
271:                     // cannot be used in CTS/RTS mode).
272:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
273:                 
274:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
275:                     // be used in RTS-Only mode).
276:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
277:                 
278:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
279:                     // the default mode and this parameter can be left out if it is desired).
280:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
281:                 
282:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
283:                     // is not full (i.e., the UART is ready to receive data).  This is also known
284:                     // as "RTS Flow-Control Mode".
285:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
286:                 
287:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
288:                     // is not empty (i.e., when the UART has data ready to send).  This is also
289:                     // known as "RTS Simplex Mode".
290:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
291:                 
292:                     // Enable the IrDA encoder/decoder.
293:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
294:                 
295:                     // Enables stopping of the UART operation to save power when the core has
296:                     // been put in idle mode.
297:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
298:                 
299:                     // Inverts the polarity of data sent on the transmit (TX) pin.
300:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
301:                 
302:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
303:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
304:                     // Note:  The address must still be set using UARTEnableAddressDetect
305:                     // to support IEEE-485 protocol.
306:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
307:                 
308:                 } UART_CONFIGURATION;
309:                 
310:                 
311:                 // *****************************************************************************
312:                 /* UART FIFO Modes
313:                 
314:                   Summary:
315:                     Supported FIFO modes for the UART module.
316:                 
317:                   Description:
318:                     This enumeration defines supported FIFO modes that determine when the Tx
319:                     and Rx interrupts will occur.
320:                 
321:                   Remarks:
322:                     These modes consist of two sets of mutially exclusive modes:
323:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
324:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
325:                 
326:                     The caller should not rely on the specific numbers assigned to any of these
327:                     values as they may change from one processor ot the next.
328:                 
329:                 */
330:                 
331:                 typedef enum
332:                 {
333:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
334:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
337:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
338:                 
339:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
340:                     // full (i.e. there is space available for more data)  This is the default.
341:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
342:                 
343:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
344:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
345:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
346:                 
347:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
348:                     // (three-quarter) full.
349:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
350:                 
351:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
352:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
353:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
354:                 
355:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
356:                     // data.
357:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
358:                 
359:                 } UART_FIFO_MODE;
360:                 
361:                 
362:                 // *****************************************************************************
363:                 /* UART Line Control Mode
364:                 
365:                   Summary:
366:                     UART line control mode.
367:                 
368:                   Description:
369:                     This data type defines the supported line control modes for the UART.
370:                 
371:                   Remarks:
372:                     Some of the line-control options are mutually exclusive:
373:                     * Only one of the "DATA_SIZE" options can be used at a time
374:                     * Only one of the "PARITY" options can be used at a time
375:                     * Only one of the "STOP_BITS" options can be used at a time
376:                 
377:                     The caller should not rely on the specific numbers assigned to any of these
378:                     values as they may change from one processor ot the next.
379:                 */
380:                 
381:                 typedef enum
382:                 {
383:                     // Sets the data transfer size to 8-bits per frame.
384:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
385:                 
386:                     // Sets the data transfer size to 9-bits per frame.
387:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
388:                 
389:                     // Enables parity bit generation for odd parity.
390:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
391:                 
392:                     // Enables parity bit generation for even parity.
393:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
394:                 
395:                     // Disables parity bit generation.
396:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
397:                 
398:                     // Enables generation of 2 stop bits per frame.
399:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
400:                 
401:                     // Enables generation of 1 stop bit per frame (default).
402:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
403:                 
404:                 } UART_LINE_CONTROL_MODE;
405:                 
406:                 
407:                 // *****************************************************************************
408:                 /* UART Line Status Flags
409:                 
410:                   Summary:
411:                     UART line-status bitmask flags.
412:                 
413:                   Description:
414:                     This enumeration defines the UART line-status bits.  These values are
415:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
416:                 
417:                   Remarks:
418:                     The caller should not rely on the specific numbers assigned to any of these
419:                     values as they may change from one processor ot the next.
420:                 */
421:                 
422:                 typedef enum
423:                 {
424:                     // The transmitter is able to accept data to transmit.
425:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
426:                 
427:                     // The transmitter is empty (no data is available to transmit).
428:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
429:                 
430:                     // The receiver is currently idle.
431:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
432:                 
433:                     // A received data parity error was detected.
434:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
435:                 
436:                     // Data was received that violated the framing protocol (the data word did
437:                     // not start or stop at the appropriate place).  Note:  A break condition
438:                     // will always indicate a framing error.
439:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
440:                 
441:                     // The UART has received more data than it can buffer.  Data has been lost.
442:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
443:                 
444:                     // UART data has been received and is avaiable in the FIFO.
445:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
446:                 
447:                 } UART_LINE_STATUS;
448:                 
449:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
450:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
451:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
452:                 
453:                 
454:                 
455:                 // *****************************************************************************
456:                 /* UART Data
457:                 
458:                   Summary:
459:                     UART data.
460:                 
461:                   Description:
462:                     This data type defines the supported data sizes for the UART.
463:                 */
464:                 
465:                 typedef union
466:                 {
467:                     // 8-bit data
468:                     struct
469:                     {
470:                         UINT16  data8bit    : 8;
471:                     };
472:                 
473:                     // 9-bit data
474:                     struct
475:                     {
476:                         UINT16  data9bit    : 9;
477:                     };
478:                 
479:                     UINT16 __data;
480:                 } UART_DATA;
481:                 
482:                 
483:                 // *****************************************************************************
484:                 // *****************************************************************************
485:                 // Section: UART Peripheral Library Interface Routines
486:                 // *****************************************************************************
487:                 // *****************************************************************************
488:                 
489:                 
490:                 /*******************************************************************************
491:                   Function:
492:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
493:                 
494:                   Summary:
495:                     Enables or disables the given UART module in the desired mode.
496:                 
497:                   Description:
498:                     This routine enables or disables the given UART module in the desired mode.
499:                 
500:                   Precondition:
501:                     The UART module should be appropriately configured before being enabled.
502:                 
503:                   Parameters:
504:                     id    - Identifies the desired UART module.
505:                 
506:                     mode  - Identifies the desired mode of UART operation.
507:                 
508:                   Returns:
509:                     None
510:                 
511:                   Example:
512:                     <code>
513:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
514:                     </code>
515:                 
516:                   Remarks:
517:                     Enabling UART transmissions will immediately cause a TX interrupt to
518:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
519:                     was pre-loaded with data.
520:                   *****************************************************************************/
521:                 
522:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
523:                 
524:                 
525:                 /*******************************************************************************
526:                   Function:
527:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
528:                 
529:                   Summary:
530:                     UART module configuration routine.
531:                 
532:                   Description:
533:                     This routine allows the caller to configure various features of the UART
534:                     module for desired operation.
535:                 
536:                   Precondition:
537:                     None
538:                 
539:                   Parameters:
540:                     id      - Identifies the desired UART module.
541:                 
542:                     flags   - Bit-wise OR of the desired module configuration settings.
543:                 
544:                   Returns:
545:                     None
546:                 
547:                   Example:
548:                     <code>
549:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
550:                     </code>
551:                 
552:                   Remarks:
553:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
554:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
555:                     of these values will result in a value that is not explicitly defined in
556:                     the enumeration.
557:                   *****************************************************************************/
558:                 
559:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
560:                 
561:                 
562:                 /*******************************************************************************
563:                   Function:
564:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
565:                 
566:                   Summary:
567:                     Controls UART module TX and RX FIFO operation.
568:                 
569:                   Description:
570:                     This routine allows the caller to configure when interrupts occur relative
571:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
572:                     or empty the FIFOs are).
573:                 
574:                   Precondition:
575:                     None
576:                 
577:                   Parameters:
578:                     id      - Identifies the desired UART module.
579:                 
580:                     mode    - Bit-wise OR of the desired FIFO mode values.
581:                 
582:                   Returns:
583:                     None
584:                 
585:                   Example:
586:                     <code>
587:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
588:                     </code>
589:                 
590:                   Remarks:
591:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
592:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
593:                     of these values will result in a value that is not explicitly defined in
594:                     the enumeration.
595:                   *****************************************************************************/
596:                 
597:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
598:                 
599:                 
600:                 /*******************************************************************************
601:                   Function:
602:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
603:                 
604:                   Summary:
605:                     Routine to set the UART module's desired data data rate.
606:                 
607:                   Description:
608:                     This routine allows the caller to set the desired data rate for the UART.
609:                 
610:                   Precondition:
611:                     The source clock's frequency must be operating at the frequency passed in the
612:                     "sourceClock" parameter.
613:                 
614:                   Parameters:
615:                     id          - Identifies the desired UART module.
616:                 
617:                     sourceClock - Frequency (Hz) of the source clock being provided to the
618:                                   UART module.
619:                 
620:                     dataRate     - Desired data rate (bits per second).
621:                 
622:                   Returns:
623:                     Actual bit rate selected
624:                 
625:                   Example:
626:                     <code>
627:                     #define PERIPHERAL_CLOCK    10000000
628:                     #define DESIRED_DATA_RATE   19200
629:                 
630:                     UINT32    actualDataRate;
631:                 
632:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
633:                     </code>
634:                 
635:                   Remarks:
636:                     Actual data rate selected may be slightly different than the data rate
637:                     requested due to truncation error.
638:                 
639:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
640:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
641:                     the maximum data rate is sourceClock/4.
642:                   *****************************************************************************/
643:                 
644:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
645:                 
646:                 
647:                 /*******************************************************************************
648:                   Function:
649:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
650:                 
651:                   Summary:
652:                     Routine to get the UART module's current data data rate.
653:                 
654:                   Description:
655:                     This routine allows the caller to get the current data rate for the UART module.
656:                 
657:                   Precondition:
658:                     The source clock's frequency must be operating at the frequency passed in the
659:                     "sourceClock" parameter.
660:                 
661:                   Parameters:
662:                     id          - Identifies the desired UART module.
663:                 
664:                     sourceClock - Frequency (Hz) of the source clock being provided to the
665:                                   UART module.
666:                 
667:                   Returns:
668:                     The UART's current data rate (bits per second).
669:                 
670:                   Example:
671:                     <code>
672:                     #define PERIPHERAL_CLOCK    10000000
673:                 
674:                     UINT32    currentDataRate;
675:                 
676:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
677:                     </code>
678:                 
679:                   Remarks:
680:                     The current (actual) data rate returned may be slightly different than bit
681:                     rate requested due to truncation error.
682:                   *****************************************************************************/
683:                 
684:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
685:                 
686:                 
687:                 /*******************************************************************************
688:                   Function:
689:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
690:                 
691:                   Summary:
692:                     Routine to set the UART module's desired line control parameters.
693:                 
694:                   Description:
695:                     This routine allows the caller to select the desired size of the UART data
696:                     frame, the generation of parity and framing parameters (collectively
697:                     referred to as the "line control" mode).
698:                 
699:                   Precondition:
700:                 
701:                   Parameters:
702:                     id      - Identifies the desired UART module.
703:                 
704:                     mode    - This is a bit-wise OR of the desired line control mode flags.
705:                 
706:                   Returns:
707:                     None
708:                 
709:                   Example:
710:                     <code>
711:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
712:                     </code>
713:                 
714:                   Remarks:
715:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
716:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
717:                     of these values will result in a value that is not explicitly defined in
718:                     the enumeration.
719:                   *****************************************************************************/
720:                 
721:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
722:                 
723:                 
724:                 /*******************************************************************************
725:                   Function:
726:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
727:                 
728:                   Summary:
729:                     Provides current UART line status.
730:                 
731:                   Description:
732:                     This routine allows the caller to get the current line status of the UART,
733:                     indicating the current state of the transmitter and receiver buffers, and
734:                     if any errors have occurred.
735:                 
736:                   Precondition:
737:                     None
738:                 
739:                   Parameters:
740:                     id      - Identifies the desired UART module.
741:                 
742:                   Returns:
743:                     A bit-wise OR of the current line status flags.
744:                 
745:                   Example:
746:                     <code>
747:                     UART_LINE_STATUS lineStatus;
748:                 
749:                     lineStatus = UARTGetLineStatus(UART1);
750:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
751:                     {
752:                         // Handle receiver error
753:                     }
754:                     </code>
755:                 
756:                   Remarks:
757:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
758:                     status flag.
759:                 
760:                     The receiver line status flags are only valid when data has been received
761:                     and for the data at the top of the RX FIFO.
762:                 
763:                     Note that the bitmask resulting from the bit-wise OR of these values will
764:                     result in a value that is not explicitly defined in the enumeration.
765:                   *****************************************************************************/
766:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
767:                 {
768:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
769:                 }
770:                 
771:                 
772:                 /*******************************************************************************
773:                   Function:
774:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
775:                 
776:                   Summary:
777:                     Routine to detect if the transmitter is ready to accept data to transmit.
778:                 
779:                   Description:
780:                     This routine determines if the transmitter is ready to accept more data to
781:                     be transmitted.
782:                 
783:                   Precondition:
784:                     The UART module should have been appropriately configured and enabled.
785:                 
786:                   Parameters:
787:                     id      - Identifies the desired UART module.
788:                 
789:                   Returns:
790:                     Boolean identifying whether or not the transmitter is ready:
791:                     * TRUE    - If the transmitter is ready to accept more data
792:                     * FALSE   - If the transmitter is not ready to accept more data
793:                 
794:                   Example:
795:                     <code>
796:                     unsigned char data;
797:                 
798:                     data = 'a';
799:                 
800:                     if (UARTTransmitterIsReady(UART1))
801:                     {
802:                         UARTSendDataByte(UART1, data);
803:                     }
804:                     </code>
805:                 
806:                   Remarks:
807:                   *****************************************************************************/
808:                 
809:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
810:                 {
811:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D0153E8  3C029D02   LUI V0, -25342
9D0153EC  8C43F448   LW V1, -3000(V0)
9D0153F0  8C620010   LW V0, 16(V1)
9D0153F4  30420200   ANDI V0, V0, 512
9D01541C  8C43F448   LW V1, -3000(V0)
9D015420  8C620010   LW V0, 16(V1)
9D015424  30420200   ANDI V0, V0, 512
812:                 }
813:                 
814:                 
815:                 /*******************************************************************************
816:                   Function:
817:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
818:                 
819:                   Summary:
820:                     Routine to send a byte of data.
821:                 
822:                   Description:
823:                     This routine allows the caller to send a byte of data.
824:                 
825:                   Precondition:
826:                     The UART should have been appropriately configured.  The configuration must
827:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
828:                     have been ready, although not necessarily enabled yet.
829:                 
830:                   Parameters:
831:                     id      - Identifies the desired UART module.
832:                 
833:                     data    - Data byte to be sent.
834:                 
835:                   Returns:
836:                     None
837:                 
838:                   Example:
839:                     <code>
840:                     unsigned char data;
841:                 
842:                     data = 'a';
843:                 
844:                     if (UARTTransmitterIsReady(UART1))
845:                     {
846:                         UARTSendDataByte(UART1, data);
847:                     }
848:                     </code>
849:                 
850:                   Remarks:
851:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
852:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
853:                     data.
854:                   *****************************************************************************/
855:                 
856:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
857:                 {
858:                     uartReg[id]->tx.reg = data;
9D015300  3C029D02   LUI V0, -25342
9D015304  8C42F448   LW V0, -3000(V0)
9D015308  2403000C   ADDIU V1, ZERO, 12
9D01530C  AC430020   SW V1, 32(V0)
9D015398  3C029D02   LUI V0, -25342
9D01539C  8C42F448   LW V0, -3000(V0)
9D0153A0  24030011   ADDIU V1, ZERO, 17
9D0153A4  AC430020   SW V1, 32(V0)
9D015400  308400FF   ANDI A0, A0, 255
9D015404  AC640020   SW A0, 32(V1)
9D015408  03E00008   JR RA
9D01540C  00000000   NOP
9D015434  30A500FF   ANDI A1, A1, 255
9D015438  AC650020   SW A1, 32(V1)
9D015668  3C029D02   LUI V0, -25342
9D01566C  8C42F448   LW V0, -3000(V0)
9D015670  24030013   ADDIU V1, ZERO, 19
9D015674  AC430020   SW V1, 32(V0)
859:                 }
860:                 
861:                 
862:                 /*******************************************************************************
863:                   Function:
864:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
865:                 
866:                   Summary:
867:                     Routine to send data through the UART.
868:                 
869:                   Description:
870:                     This routine allows the caller to send data of any permitted size through
871:                     the UART.
872:                 
873:                   Precondition:
874:                     The UART module should have been appropriately configured.  The configuration must
875:                     have been for desired data size.  The transmitter must have been ready,
876:                     although not necessarily enabled yet.
877:                 
878:                   Parameters:
879:                     id      - Identifies the desired UART module.
880:                 
881:                     data    - Data to be sent.
882:                 
883:                   Returns:
884:                     None
885:                 
886:                   Example:
887:                     <code>
888:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
889:                 
890:                     if (UARTTransmitterIsReady(UART1))
891:                     {
892:                         UARTSendData(UART1, data);
893:                     }
894:                     </code>
895:                 
896:                   Remarks:
897:                     Size of the data word size depends on the current configuration (see
898:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
899:                   *****************************************************************************/
900:                 
901:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
902:                 {
903:                     uartReg[id]->tx.reg = data.__data;
904:                 }
905:                 
906:                 /*******************************************************************************
907:                   Function:
908:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
909:                 
910:                   Summary:
911:                     Routine to detect if the UART module has finshed transmitting the most recent
912:                     data.
913:                 
914:                   Description:
915:                     This routine determines if the transmitter has finished sending all
916:                     available data.
917:                 
918:                   Preconditions:
919:                     The UART module should have been appropriately configured and enabled and data
920:                     sent to the UART TX buffer.
921:                 
922:                   Parameters:
923:                     id      - Identifies the desired UART module.
924:                 
925:                   Returns:
926:                     Boolean identifying if the transmission has completed:
927:                     * TRUE    - If the transmitter has completed sending the data
928:                     * FALSE   - If the transmitter is still busy sending the data
929:                 
930:                   Example:
931:                     <code>
932:                     if (UARTTransmissionHasCompleted(UART1))
933:                     {
934:                         // Perform any tasks necessary when all data has been sent
935:                     }
936:                     </code>
937:                 
938:                   Remarks:
939:                   *****************************************************************************/
940:                 
941:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
942:                 {
943:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
9D015448  3C029D02   LUI V0, -25342
9D01544C  8C43F448   LW V1, -3000(V0)
9D015450  8C620010   LW V0, 16(V1)
9D015454  30420100   ANDI V0, V0, 256
944:                 }
945:                 
946:                 
947:                 /*******************************************************************************
948:                   Function:
949:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
950:                 
951:                   Summary:
952:                     Routine to detect if the receiver has data available.
953:                 
954:                   Description:
955:                     This routine determines if the receiver has data available to be read.
956:                 
957:                   Precondition:
958:                     The UART module must have been configured appropriately and enabled. A complete
959:                     data frame must have been sent to the UART before it will return a TRUE.
960:                 
961:                   Parameters:
962:                     id      - Identifies the desired UART module.
963:                 
964:                   Returns:
965:                     Boolean identifying whether or not data is available:
966:                     * TRUE    - If the receiver has data available
967:                     * FALSE   - If the receiver does not have data availble
968:                 
969:                   Example:
970:                     <code>
971:                     UART_DATA data;
972:                 
973:                     if (UARTReceivedDataIsAvailable(UART1))
974:                     {
975:                         data = UARTGetData(UART1);
976:                     }
977:                     </code>
978:                 
979:                   Remarks:
980:                     This routine provides the same information as the UART_DATA_READY line
981:                     status flag.
982:                   *****************************************************************************/
983:                 
984:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
985:                 {
986:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
987:                 }
988:                 
989:                 
990:                 /*******************************************************************************
991:                   Function:
992:                     BYTE UARTGetDataByte ( UART_MODULE id )
993:                 
994:                   Summary:
995:                     Routine to get a byte of data received by the UART.
996:                 
997:                   Description:
998:                     This routine allows the caller to read a byte of data received by the UART.
999:                 
1000:                  Precondition:
1001:                    The UART module must have been appropriately configured, the configuration must
1002:                    have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
1003:                    been enabled.  Also, a complete data frame must have been received by the UART.
1004:                
1005:                  Parameters:
1006:                    id      - Identifies the desired UART module.
1007:                
1008:                  Returns:
1009:                    A byte of data received by the UART.
1010:                
1011:                  Example:
1012:                    <code>
1013:                    unsigned char data;
1014:                
1015:                    if (UARTReceivedDataIsAvailable(UART1))
1016:                    {
1017:                        data = UARTGetDataByte(UART1);
1018:                    }
1019:                    </code>
1020:                
1021:                  Remarks:
1022:                    This routine is optimized for receiving 8-bit data through the UART.
1023:                  *****************************************************************************/
1024:                
1025:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1026:                {
1027:                    return (BYTE)uartReg[id]->rx.reg;
1028:                }
1029:                
1030:                
1031:                /*******************************************************************************
1032:                  Function:
1033:                    UART_DATA UARTGetData ( UART_MODULE id )
1034:                
1035:                  Summary:
1036:                    Routine to get data received by the UART.
1037:                
1038:                  Description:
1039:                    This routine allows the caller to read a data word received by the UART.
1040:                
1041:                  Precondition:
1042:                    The module must have been appropriately configured, the UART module must have been
1043:                    enabled, and a complete data frame must have been received by the UART.
1044:                
1045:                  Parameters:
1046:                    id      - Identifies the desired UART module.
1047:                
1048:                  Returns:
1049:                    Data received by the UART.
1050:                
1051:                  Example:
1052:                    <code>
1053:                    UART_DATA data;
1054:                
1055:                    if (UARTReceivedDataIsAvailable(UART1))
1056:                    {
1057:                        data = UARTGetData(UART1);
1058:                    }
1059:                    </code>
1060:                
1061:                  Remarks:
1062:                    Size of the data word depends on the current configuration (see
1063:                    UARTSetLineControl).
1064:                  *****************************************************************************/
1065:                
1066:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1067:                {
1068:                    UART_DATA data;
1069:                
1070:                    data.__data = uartReg[id]->rx.reg;
1071:                
1072:                    return data;
1073:                }
1074:                
1075:                
1076:                /*******************************************************************************
1077:                  Function:
1078:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1079:                
1080:                  Summary:
1081:                    Routine to program the address for which the UART module may watch.
1082:                
1083:                  Description:
1084:                    This routine programs the 8-bit address for which the module may watch.
1085:                
1086:                  Precondition:
1087:                    None
1088:                
1089:                  Parameters:
1090:                    id      - Identifies the desired UART module.
1091:                
1092:                    address - 8-bit address for which the module will watch.
1093:                
1094:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1095:                              * TRUE - Enable address watch mode
1096:                              * FALSE - Disable address watch mode
1097:                
1098:                  Returns:
1099:                    None.
1100:                
1101:                  Example:
1102:                    <code>
1103:                    #define SLAVE_ADDRESS  0x42
1104:                
1105:                    UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1106:                    </code>
1107:                
1108:                  Remarks:
1109:                    The module can be placed into a mode where it will ignore all data received
1110:                    until it identifies the programmed adress.  After the programmed address
1111:                    has been identified, it will begin receiving data normally.  This mode is
1112:                    particularly useful for supporting the IEEE-485 protocol.
1113:                  *****************************************************************************/
1114:                
1115:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1116:                
1117:                
1118:                /*******************************************************************************
1119:                  Function:
1120:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1121:                
1122:                  Summary:
1123:                    Routine to enable or disable recognition of the programmed address byte.
1124:                
1125:                  Description:
1126:                    This routine can enable or disable the "address watch" mode.  In this mode,
1127:                    the UART module will ignore all data until it recognizes the programmed address.
1128:                
1129:                  Precondition:
1130:                    UART should have already been enabled and set with watch address.
1131:                
1132:                  Parameters:
1133:                    id      - Identifies the desired UART module.
1134:                
1135:                    watch   - Determines if the "address watch" mode will be enabled or
1136:                              disabled.
1137:                              * TRUE - Enable address watch mode
1138:                              * FALSE - Disable address watch mode
1139:                
1140:                  Returns:
1141:                    None.
1142:                
1143:                  Example:
1144:                    <code>
1145:                    #define SLAVE_ADDRESS 0x42
1146:                
1147:                    // Set the address, but don't enable the watch until later,
1148:                    // UART continues to receive data normally
1149:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1150:                
1151:                    // ...
1152:                
1153:                    // Now begin to ignore all UART traffic until we are addressed
1154:                    UARTWatchForAddress(UART1, TRUE);
1155:                    </code>
1156:                
1157:                  Remarks:
1158:                    The UART module can be placed into a mode where it will ignore all data received
1159:                    until it identifies the programmed address.  After the programmed address
1160:                    has been identified, it will begin receiving data normally.  This mode is
1161:                    particularly useful for supporting the IEEE-485 protocol.
1162:                  *****************************************************************************/
1163:                
1164:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1165:                
1166:                
1167:                /*******************************************************************************
1168:                  Function:
1169:                    void UARTSendBreak ( UART_MODULE id )
1170:                
1171:                  Summary:
1172:                    Routine to send a break signal from the UART.
1173:                
1174:                  Description:
1175:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1176:                
1177:                  Precondition:
1178:                    The UART should have been appropriately configured.  The transmitter should
1179:                    be idle, although not necessarily enabled yet.
1180:                
1181:                  Parameters:
1182:                    id      - Identifies the desired UART module.
1183:                
1184:                  Returns:
1185:                    None
1186:                
1187:                  Example:
1188:                    <code>
1189:                    if (UARTTransmissionHasCompleted(UART1))
1190:                    {
1191:                        UARTSendBreak(UART1);
1192:                    }
1193:                    </code>
1194:                
1195:                  Remarks:
1196:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1197:                    data may be pre-loaded into the FIFO and it will be send immediately
1198:                    following the break signal.
1199:                  *****************************************************************************/
1200:                
1201:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1202:                {
1203:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1204:                }
1205:                
1206:                
1207:                /*******************************************************************************
1208:                  Function:
1209:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1210:                
1211:                  Summary:
1212:                    Routine to automatically determine the data rate (bits-per-second) of an
1213:                    external transmitter to the UART.
1214:                
1215:                  Description:
1216:                    This routine initiates the process of automatically determining the data
1217:                    rate (bits-per-second) of an external transmitter to the UART.
1218:                
1219:                  Precondition:
1220:                    The UART should have been appropriately configured.  The transmitter should
1221:                    be idle, although not necessarily enabled yet.
1222:                
1223:                  Parameters:
1224:                    id      - Identifies the desired UART module.
1225:                
1226:                  Returns:
1227:                    None
1228:                
1229:                  Example:
1230:                    <code>
1231:                    // See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1232:                    // methods to detect a Break.
1233:                
1234:                    if (breakDetected && useAutoRateDetect)
1235:                    {
1236:                        UARTStartAutoDataRateDetect (UART1);
1237:                    }
1238:                    </code>
1239:                
1240:                  Remarks:
1241:                    The UART module begins measuring the data rate beginning at the next start
1242:                    bit.  The external transmitter should send an alternating pattern (0x55)
1243:                    for the byte to be measured for an effective rate detection.  To ensure
1244:                    an effective measurement sequence, this can be done immediately following
1245:                    a break reception. It is important that this UART module is not
1246:                    transmitting data while it is trying to detect RX baud rate, see the
1247:                    "PIC32 Family Reference Manual, Sect. 21 UART".
1248:                  *****************************************************************************/
1249:                
1250:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1251:                {
1252:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1253:                }
1254:                
1255:                
1256:                
1257:                /*******************************************************************************
1258:                  Function:
1259:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1260:                
1261:                  Summary:
1262:                    Routine to identify when automatic data rate detection has completed.
1263:                
1264:                  Description:
1265:                    This routine checks to see if automatic data rate detection has completed.
1266:                
1267:                  Precondition:
1268:                    Automatic rate detection should have been previously started.
1269:                
1270:                  Parameters:
1271:                    id      - Identifies the desired UART module.
1272:                
1273:                  Returns:
1274:                    * TRUE    - Indicates that automatic rate detection has completed.
1275:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1276:                
1277:                  Example:
1278:                    <code>
1279:                    #define PERIPHERAL_CLOCK    10000000
1280:                
1281:                    UINT32 currentRate;
1282:                
1283:                    if (UARTDataRateDetected(UART1))
1284:                    {
1285:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1286:                    }
1287:                    </code>
1288:                
1289:                  Remarks:
1290:                    This routine returns FALSE after automatic rate detection
1291:                    has been started but before rate is detectdd, it will return TRUE
1292:                    at any other time.
1293:                  *****************************************************************************/
1294:                
1295:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1296:                {
1297:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1298:                }
1299:                
1300:                #ifdef __cplusplus
1301:                  }
1302:                #endif
1303:                
1304:                #endif // _UART_h_
1305:                
---  /opt/microchip/xc32/v1.44/pic32mx/include/peripheral/system.h  -------------------------------------
1:                   /********************************************************************
2:                   
3:                       System Library Interface Definition
4:                   
5:                       Summary:
6:                           This file contains the interface definition for the System
7:                           peripheral library.
8:                   
9:                       Description:
10:                          This library provides functions for configuring the peripheral
11:                          clock, cache settings, and wait states.  For details on the
12:                          register and bit settings used by these functions, refer to the
13:                          PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:        System.h
20:                   * Dependencies:
21:                   * Processor:       PIC32
22:                   * Hardware:        N/A
23:                   * Assembler:       N/A
24:                   * Linker:          N/A
25:                   * Company:         Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the “Company”) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company’s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:
92:                      unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                  
94:                   Description:
95:                      The function sets the PB divider to the optimum value.
96:                  
97:                   PreCondition:
98:                      None
99:                  
100:                  Parameters:
101:                     sys_clock - system clock in Hz
102:                 
103:                  Returns:
104:                     the PB clock frequency in Hz
105:                 
106:                  Side Effects:
107:                     The PB clock may be changed
108:                 
109:                  Overview:
110:                     The function sets the PB divider to the optimum value.
111:                 
112:                  Remarks:
113:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                 
116:                  Example:
117:                     <code>
118:                     SYSTEMConfigPB(72000000);
119:                     </code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
131:                         pb_clock >>= 1;
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:
146:                     void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                 
148:                   Description:
149:                     The function sets the Flash Wait states to the optimum value.
150:                 
151:                   PreCondition:
152:                     None
153:                 
154:                   Parameters:
155:                     sys_clock - system clock in Hz
156:                 
157:                   Returns:
158:                     None
159:                 
160:                   Side Effects:
161:                     The Wait States may be changed
162:                 
163:                   Remarks:
164:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                 
167:                   Example:
168:                     <code>
169:                     SYSTEMConfigWaitStates(72000000);
170:                     </code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:
197:                         unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                 
199:                   Description:
200:                     The function sets the PB divider and the Flash Wait states to the optimum value.
201:                 
202:                   PreCondition:
203:                     None
204:                 
205:                   Parameters:
206:                     sys_clock - system clock in Hz
207:                 
208:                   Returns:
209:                     the PB clock frequency in Hz
210:                 
211:                   Side Effects:
212:                     The PB clock and wait states may be changed
213:                 
214:                   Remarks:
215:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                 
218:                   Example:
219:                     <code>
220:                     SYSTEMConfigWaitStatesAndPB(72000000);
221:                     </code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
246:                     mCheConfigure(wait_states);
247:                     INTRestoreInterrupts(int_status);
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:
255:                     unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                 
257:                   Description:
258:                     The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 
261:                   PreCondition:
262:                     None
263:                 
264:                   Parameters:
265:                     sys_clock - system clock in Hz
266:                 
267:                   Output:
268:                     the PB clock frequency in Hz
269:                 
270:                   Side Effects:
271:                     Sets the PB and Flash Wait states
272:                 
273:                   Remarks:
274:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                 
277:                   Example:
278:                     <code>
279:                     SYSTEMConfigPerformance(72000000);
280:                     </code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:
311:                     unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                 
313:                   Description:
314:                     The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value,
315:                     based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 
318:                   PreCondition:
319:                     None
320:                 
321:                   Parameters:
322:                     sys_clock - system clock frequency in Hz
323:                     flags -
324:                         *    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                 
329:                   Returns:
330:                     the PB clock frequency in Hz
331:                 
332:                   Side Effects:
333:                     Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                 
336:                 
337:                   Remarks:
338:                     The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                 
341:                   Example:
342:                     <code>
343:                     SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                     </code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
9D014820  0F407D0F   JAL INTDisableInterrupts
9D014824  AFB00010   SW S0, 16(SP)
355:                 
356:                     mBMXDisableDRMWaitState();
9D014828  24100040   ADDIU S0, ZERO, 64
9D01482C  3C03BF88   LUI V1, -16504
9D014830  AC702004   SW S0, 8196(V1)
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
9D014834  3C03BF81   LUI V1, -16511
9D014838  8C63F000   LW V1, -4096(V1)
381:                 
382:                     INTRestoreInterrupts(int_status);
9D01483C  0F407CA0   JAL INTRestoreInterrupts
9D014840  00402021   ADDU A0, V0, ZERO
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  /home/jacques/github/vpc-32vga/vt100.c  ------------------------------------------------------------
1:                   /*
2:                   * Copyright 2013,2017,2018 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * REF: https://vt100.net/docs/vt102-ug/contents.html
21:                  */
22:                  
23:                  #include <stdlib.h>
24:                  #include <stdio.h>
25:                  #include <stdint.h>
26:                  #include <stdbool.h>
27:                  
28:                  #include "vt100.h"
29:                  #include "hardware/ps2_kbd/keyboard.h"
30:                  
31:                  // longueur du tampon pour réception d'une séquence de contrôle
32:                  #define CS_SIZE  (32)
33:                  
34:                  // séquence pour sélectionné le mode 80 colonnes  par lignes
35:                  static const char cols_80[]="\0x1b[?3l";
36:                  // séquence pour le mode auto-wrap
37:                  static const char auto_wrap[]="\0x1b[?7h";
38:                  // séquence pour mode lnm, i.e. '\n' produit un lf et un cr.
39:                  static const char ln_mode[]="\0x1b[20h";
40:                  
41:                  static char vt_col;
42:                  static char vt_line;
43:                  static char tab_width=4;
44:                  
45:                  static void send_esc_seq(){
9D016C60  27BDFFE8   ADDIU SP, SP, -24
9D016C64  AFBF0014   SW RA, 20(SP)
46:                      ser_put_char(ESC);
9D016C68  0F4054FA   JAL ser_put_char
9D016C6C  2404001B   ADDIU A0, ZERO, 27
47:                      ser_put_char(LBRACKET);
9D016C70  0F4054FA   JAL ser_put_char
9D016C74  2404005B   ADDIU A0, ZERO, 91
48:                  }
9D016C78  8FBF0014   LW RA, 20(SP)
9D016C7C  03E00008   JR RA
9D016C80  27BD0018   ADDIU SP, SP, 24
49:                  
50:                  static BOOL wait_esc(){
51:                      char c;
52:                      
53:                      c=ser_wait_char();
54:                      if (c==ESC){
55:                          c=ser_wait_char();
56:                          if (c==LBRACKET){
57:                              return TRUE;
58:                          }else{
59:                              return FALSE;
60:                          }
61:                      }else{
62:                          return FALSE;
63:                      }
64:                  }
65:                  
66:                  // attend un paramètre numérique
67:                  // terminé par la caractère c.
68:                  static int get_param(char c){
69:                      int n=0;
70:                      char rx;
71:                      rx=ser_wait_char();
72:                      while ((rx!=c) && (rx>='0') && (rx<='9')){
73:                          n*=10;
74:                          n+=rx-'0';
75:                          rx=ser_wait_char();
76:                      }
77:                      return n;
78:                  }
79:                  
80:                  void vt_clear_screen(){
9D016C84  27BDFFE8   ADDIU SP, SP, -24
9D016C88  AFBF0014   SW RA, 20(SP)
81:                      ser_put_char( FF);
9D016C8C  0F4054FA   JAL ser_put_char
9D016C90  2404000C   ADDIU A0, ZERO, 12
82:                  }
9D016C94  8FBF0014   LW RA, 20(SP)
9D016C98  03E00008   JR RA
9D016C9C  27BD0018   ADDIU SP, SP, 24
83:                  
84:                  void vt_clear_eol(){
9D016CA0  27BDFFE8   ADDIU SP, SP, -24
9D016CA4  AFBF0014   SW RA, 20(SP)
85:                      send_esc_seq();
9D016CA8  0F405B18   JAL send_esc_seq
9D016CAC  00000000   NOP
86:                      ser_put_char('K');
9D016CB0  0F4054FA   JAL ser_put_char
9D016CB4  2404004B   ADDIU A0, ZERO, 75
87:                  }
9D016CB8  8FBF0014   LW RA, 20(SP)
9D016CBC  03E00008   JR RA
9D016CC0  27BD0018   ADDIU SP, SP, 24
88:                  
89:                  void vt_clear_line(unsigned line){
9D016E30  27BDFFE8   ADDIU SP, SP, -24
9D016E34  AFBF0014   SW RA, 20(SP)
9D016E38  AFB00010   SW S0, 16(SP)
9D016E3C  00808021   ADDU S0, A0, ZERO
90:                      vt_set_curpos(0,line);
9D016E40  00002021   ADDU A0, ZERO, ZERO
9D016E44  0F405B33   JAL vt_set_curpos
9D016E48  02002821   ADDU A1, S0, ZERO
91:                      send_esc_seq();
9D016E4C  0F405B18   JAL send_esc_seq
9D016E50  00000000   NOP
92:                      ser_print("?7l"); // auto-wrap off
9D016E54  3C049D02   LUI A0, -25342
9D016E58  0F405504   JAL ser_print
9D016E5C  24849A18   ADDIU A0, A0, -26088
93:                      vt_spaces(CHAR_PER_LINE);
9D016E60  0F405B7D   JAL vt_spaces
9D016E64  24040050   ADDIU A0, ZERO, 80
94:                      send_esc_seq();
9D016E68  0F405B18   JAL send_esc_seq
9D016E6C  00000000   NOP
95:                      ser_print("?7h"); // auto-wrap on
9D016E70  3C049D02   LUI A0, -25342
9D016E74  0F405504   JAL ser_print
9D016E78  24849A1C   ADDIU A0, A0, -26084
96:                      vt_set_curpos(0,line);
9D016E7C  00002021   ADDU A0, ZERO, ZERO
9D016E80  0F405B33   JAL vt_set_curpos
9D016E84  02002821   ADDU A1, S0, ZERO
97:                  }
9D016E88  8FBF0014   LW RA, 20(SP)
9D016E8C  8FB00010   LW S0, 16(SP)
9D016E90  03E00008   JR RA
9D016E94  27BD0018   ADDIU SP, SP, 24
98:                  
99:                  // envoie une séquence ESC [ 6 n
100:                 // attend la réponse
101:                 text_coord_t vt_get_curpos(){
102:                 //    char c;
103:                     text_coord_t coord;
104:                 //    coord.x=0;
105:                 //    coord.y=0;
106:                 //    send_esc_seq();
107:                 //    ser_print("6n");
108:                 //    if (wait_esc()){
109:                 //        vt_col=get_param(';');
110:                 //        vt_line=get_param('R');
111:                 //        coord.x=vt_col-1;
112:                 //        coord.y=vt_line-1;
113:                 //    }
114:                 }
9D016CC4  03E00008   JR RA
9D016CC8  00801021   ADDU V0, A0, ZERO
115:                 
116:                 void vt_set_curpos(int x, int y){
9D016CCC  27BDFFC8   ADDIU SP, SP, -56
9D016CD0  AFBF0034   SW RA, 52(SP)
117:                     char fmt[32];
118:                     vt_col=x+1;
9D016CD4  24840001   ADDIU A0, A0, 1
9D016CD8  7C043C20   SEB A3, A0
9D016CDC  A3878061   SB A3, -32671(GP)
119:                     vt_line=y+1;
9D016CE0  24A50001   ADDIU A1, A1, 1
9D016CE4  7C053420   SEB A2, A1
9D016CE8  A3868060   SB A2, -32672(GP)
120:                     sprintf(fmt,"\033[%d;%df",vt_line,vt_col);
9D016CEC  27A40010   ADDIU A0, SP, 16
9D016CF0  3C059D02   LUI A1, -25342
9D016CF4  0F407973   JAL _sprintf_cdnopsuxX
9D016CF8  24A59A0C   ADDIU A1, A1, -26100
121:                     ser_print(fmt);
9D016CFC  0F405504   JAL ser_print
9D016D00  27A40010   ADDIU A0, SP, 16
122:                 }
9D016D04  8FBF0034   LW RA, 52(SP)
9D016D08  03E00008   JR RA
9D016D0C  27BD0038   ADDIU SP, SP, 56
123:                 
124:                 typedef struct ansi_to_vk{
125:                     unsigned char vk;
126:                     unsigned char *ansi;
127:                 }ansi_to_vk_t;
128:                 
129:                 static const ansi_to_vk_t ansi_table[]={
130:                     {VK_UP,"[A"},
131:                     {VK_DOWN,"[B"},
132:                     {VK_RIGHT,"[C"},
133:                     {VK_LEFT,"[D"},
134:                     {VK_HOME,"[1~"},
135:                     {VK_END,"OF"},
136:                     {VK_DELETE,"[3~"},
137:                     {VK_PGUP,"[5~"},
138:                     {VK_PGDN,"[6~"},
139:                     {VK_INSERT,"[2~"},
140:                     {VK_F2,"OQ"},
141:                     {VK_F3,"OR"},
142:                     {VK_F4,"OS"},
143:                     {VK_F5,"[16~"},
144:                     {VK_F6,"[17~"},
145:                     {VK_F7,"[18~"},
146:                     {VK_F8,"[19~"},
147:                     {VK_F9,"[20~"},
148:                     {VK_F10,"[21~"},
149:                     {VK_F12,"[24~"},
150:                     {VK_CUP,"[1;5A"}, 
151:                     {VK_CDOWN,"[1;5B"},
152:                     {VK_CRIGHT,"[1;5C"},
153:                     {VK_CLEFT,"[1;5D"},
154:                     {VK_CHOME,"[1;5H"},
155:                     {VK_CEND,"[1;5F"},
156:                     {VK_CDEL,"[3;5~"},
157:                     {VK_CPGUP,"[5;5~"},
158:                     {VK_CPGDN,"[6;5~"},
159:                     {VK_CDEL,"[3;5~"},
160:                     {VK_SUP,"[1;2A"},
161:                     {VK_SDOWN,"[1;2B"},
162:                     {VK_SLEFT,"[1;2D"},
163:                     {VK_SRIGHT,"[1;2C"},
164:                     {VK_SDEL,"[3;2~"},
165:                     {0,""}
166:                 };
167:                 
168:                 
169:                 static unsigned char get_vk(char *ansi){
170:                     int i=0;
171:                 
172:                     while (ansi_table[i].vk && strcmp(ansi_table[i].ansi,ansi)){
9D016D84  0B405B66   J 0x9D016D98
9D016D88  2411008D   ADDIU S1, ZERO, 141
9D016D8C  9211FFFC   LBU S1, -4(S0)
9D016D90  1220000B   BEQ S1, ZERO, 0x9D016DC0
9D016D94  02201021   ADDU V0, S1, ZERO
9D016D98  8E040000   LW A0, 0(S0)
9D016D9C  0F407138   JAL 0x9D01C4E0
9D016DA0  27A50010   ADDIU A1, SP, 16
9D016DA4  1440FFF9   BNE V0, ZERO, vt_get_char::get_vk
9D016DA8  26100008   ADDIU S0, S0, 8
173:                         i++; 
174:                     }
175:                     return ansi_table[i].vk;
176:                 }// get_l1_vk()
177:                 
178:                 static int get_control_sequence(char *buf,int size){
179:                     int len=0;
180:                     unsigned char c;
181:                     size--;
182:                     buf[len++]=ser_wait_char();
9D016D34  0F4054F2   JAL ser_wait_char
9D016D38  24100001   ADDIU S0, ZERO, 1
9D016D3C  A3A20010   SB V0, 16(SP)
183:                     while ((len<size) && ((buf[len++]=ser_wait_char())<'@'));
9D016D40  0B405B54   J 0x9D016D50
9D016D44  2411001F   ADDIU S1, ZERO, 31
9D016D48  5211001A   BEQL S0, S1, 0x9D016DB4
9D016D4C  03B08021   ADDU S0, SP, S0
9D016D50  0F4054F2   JAL ser_wait_char
9D016D54  26100001   ADDIU S0, S0, 1
9D016D58  27A40010   ADDIU A0, SP, 16
9D016D5C  00901821   ADDU V1, A0, S0
9D016D60  A062FFFF   SB V0, -1(V1)
9D016D64  28420040   SLTI V0, V0, 64
9D016D68  1440FFF7   BNE V0, ZERO, 0x9D016D48
9D016D6C  03B01021   ADDU V0, SP, S0
184:                     buf[len]=0;
9D016D70  A0400010   SB ZERO, 16(V0)
9D016DB4  0B405B5F   J 0x9D016D7C
9D016DB8  A2000010   SB ZERO, 16(S0)
185:                     return len;    
186:                 }// get_control_sequence()
187:                 
188:                 unsigned char vt_get_char(){
9D016D10  27BDFFC0   ADDIU SP, SP, -64
9D016D14  AFBF003C   SW RA, 60(SP)
9D016D18  AFB10038   SW S1, 56(SP)
189:                     unsigned char c;
190:                     unsigned char buf[CS_SIZE];
191:                     int len;
192:                 
193:                     c=(unsigned char)ser_get_char();
9D016D1C  0F4054C8   JAL ser_get_char
9D016D20  AFB00034   SW S0, 52(SP)
9D016D24  305100FF   ANDI S1, V0, 255
194:                     switch(c){
9D016D28  2402001B   ADDIU V0, ZERO, 27
9D016D2C  16220024   BNE S1, V0, 0x9D016DC0
9D016D30  02201021   ADDU V0, S1, ZERO
195:                         case A_ESC:
196:                             len=get_control_sequence(buf,CS_SIZE);
197:                             if (len) c=get_vk(buf); else c=0;
9D016D74  12000011   BEQ S0, ZERO, 0x9D016DBC
9D016D78  00008821   ADDU S1, ZERO, ZERO
9D016D7C  3C109D02   LUI S0, -25342
9D016D80  26109B0C   ADDIU S0, S0, -25844
198:                             break;
199:                         default:;
200:                     }//switch
201:                     return c;
202:                 }//vt_get_char()
9D016DAC  0B405B70   J 0x9D016DC0
9D016DB0  02201021   ADDU V0, S1, ZERO
9D016DBC  02201021   ADDU V0, S1, ZERO
9D016DC0  8FBF003C   LW RA, 60(SP)
9D016DC4  8FB10038   LW S1, 56(SP)
9D016DC8  8FB00034   LW S0, 52(SP)
9D016DCC  03E00008   JR RA
9D016DD0  27BD0040   ADDIU SP, SP, 64
203:                 
204:                 unsigned char vt_wait_char(){
9D016DD4  27BDFFE8   ADDIU SP, SP, -24
9D016DD8  AFBF0014   SW RA, 20(SP)
205:                     unsigned char c;
206:                     while (!(c=vt_get_char()));
9D016DDC  0F405B44   JAL vt_get_char
9D016DE0  00000000   NOP
9D016DE4  1040FFFD   BEQ V0, ZERO, 0x9D016DDC
9D016DE8  8FBF0014   LW RA, 20(SP)
207:                     return c;
208:                 }//vt_wait_char()
9D016DEC  03E00008   JR RA
9D016DF0  27BD0018   ADDIU SP, SP, 24
209:                 
210:                 void vt_put_char(char c){
9D016E98  27BDFFE8   ADDIU SP, SP, -24
9D016E9C  AFBF0014   SW RA, 20(SP)
211:                     unsigned char spaces;
212:                     
213:                     switch(c){
9D016EA0  24020008   ADDIU V0, ZERO, 8
9D016EA4  10820006   BEQ A0, V0, 0x9D016EC0
9D016EA8  AFB00010   SW S0, 16(SP)
9D016EAC  24020009   ADDIU V0, ZERO, 9
9D016EB0  1082000A   BEQ A0, V0, 0x9D016EDC
9D016EB4  83828012   LB V0, -32750(GP)
9D016EB8  0B405BC4   J 0x9D016F10
9D016EBC  00000000   NOP
214:                         case '\b':
215:                             vt_col--;
9D016EC0  93828061   LBU V0, -32671(GP)
9D016EC4  2442FFFF   ADDIU V0, V0, -1
9D016EC8  A3828061   SB V0, -32671(GP)
216:                             ser_put_char(c);
9D016ECC  0F4054FA   JAL ser_put_char
9D016ED0  24040008   ADDIU A0, ZERO, 8
217:                             break;
9D016ED4  0B405BC7   J 0x9D016F1C
9D016ED8  8FBF0014   LW RA, 20(SP)
218:                         case '\t':
219:                             spaces=tab_width+vt_col%tab_width-1;
9D016EDC  2450FFFF   ADDIU S0, V0, -1
9D016EE0  83838061   LB V1, -32671(GP)
9D016EE4  0062001A   DIV V1, V0
9D016EE8  004001F4   TEQ V0, ZERO
9D016EEC  00002010   MFHI A0
9D016EF0  02048021   ADDU S0, S0, A0
9D016EF4  321000FF   ANDI S0, S0, 255
220:                             vt_spaces(spaces);
9D016EF8  0F405B7D   JAL vt_spaces
9D016EFC  02002021   ADDU A0, S0, ZERO
221:                             vt_col+=spaces;
9D016F00  93828061   LBU V0, -32671(GP)
9D016F04  02028021   ADDU S0, S0, V0
222:                             break;
9D016F08  0B405BC6   J 0x9D016F18
9D016F0C  A3908061   SB S0, -32671(GP)
223:                         default:
224:                             ser_put_char(c);
9D016F10  0F4054FA   JAL ser_put_char
9D016F14  00000000   NOP
225:                             break;
226:                     }//switch
227:                 }
9D016F18  8FBF0014   LW RA, 20(SP)
9D016F1C  8FB00010   LW S0, 16(SP)
9D016F20  03E00008   JR RA
9D016F24  27BD0018   ADDIU SP, SP, 24
228:                 
229:                 void vt_print(const char *str){
9D016F28  27BDFFE8   ADDIU SP, SP, -24
9D016F2C  AFBF0014   SW RA, 20(SP)
9D016F30  AFB00010   SW S0, 16(SP)
9D016F34  00808021   ADDU S0, A0, ZERO
230:                     while(*str){
9D016F38  80840000   LB A0, 0(A0)
9D016F3C  10800006   BEQ A0, ZERO, 0x9D016F58
9D016F40  8FBF0014   LW RA, 20(SP)
9D016F4C  82040000   LB A0, 0(S0)
9D016F50  1480FFFC   BNE A0, ZERO, 0x9D016F44
9D016F54  8FBF0014   LW RA, 20(SP)
231:                         vt_put_char(*str++);
9D016F44  0F405BA6   JAL vt_put_char
9D016F48  26100001   ADDIU S0, S0, 1
232:                     } 
233:                 }
9D016F58  8FB00010   LW S0, 16(SP)
9D016F5C  03E00008   JR RA
9D016F60  27BD0018   ADDIU SP, SP, 24
234:                 
235:                 void vt_println(const char *str){
9D016FC8  27BDFFE8   ADDIU SP, SP, -24
9D016FCC  AFBF0014   SW RA, 20(SP)
236:                     vt_print(str);
9D016FD0  0F405BCA   JAL vt_print
9D016FD4  00000000   NOP
237:                     vt_crlf();
9D016FD8  0F405BEB   JAL vt_crlf
9D016FDC  00000000   NOP
238:                 }
9D016FE0  8FBF0014   LW RA, 20(SP)
9D016FE4  03E00008   JR RA
9D016FE8  27BD0018   ADDIU SP, SP, 24
239:                 
240:                 void vt_spaces(unsigned char count){
9D016DF4  27BDFFE8   ADDIU SP, SP, -24
9D016DF8  AFBF0014   SW RA, 20(SP)
9D016DFC  AFB00010   SW S0, 16(SP)
241:                     while (count){
9D016E00  10800007   BEQ A0, ZERO, 0x9D016E20
9D016E04  00808021   ADDU S0, A0, ZERO
9D016E18  1600FFFB   BNE S0, ZERO, 0x9D016E08
9D016E1C  00000000   NOP
242:                         ser_put_char(A_SPACE);
9D016E08  0F4054FA   JAL ser_put_char
9D016E0C  24040020   ADDIU A0, ZERO, 32
243:                         count--;
9D016E10  2610FFFF   ADDIU S0, S0, -1
9D016E14  321000FF   ANDI S0, S0, 255
244:                     }
245:                 }
9D016E20  8FBF0014   LW RA, 20(SP)
9D016E24  8FB00010   LW S0, 16(SP)
9D016E28  03E00008   JR RA
9D016E2C  27BD0018   ADDIU SP, SP, 24
246:                 
247:                 void vt_invert_video(BOOL yes){
9D016F64  27BDFFE8   ADDIU SP, SP, -24
9D016F68  AFBF0014   SW RA, 20(SP)
9D016F6C  AFB00010   SW S0, 16(SP)
248:                     send_esc_seq();
9D016F70  0F405B18   JAL send_esc_seq
9D016F74  00808021   ADDU S0, A0, ZERO
249:                     if (yes){
9D016F78  52000006   BEQL S0, ZERO, 0x9D016F94
9D016F7C  3C049D02   LUI A0, -25342
250:                         ser_print("7m");
9D016F80  3C049D02   LUI A0, -25342
9D016F84  0F405504   JAL ser_print
9D016F88  24849A20   ADDIU A0, A0, -26080
9D016F8C  0B405BE8   J 0x9D016FA0
9D016F90  8FBF0014   LW RA, 20(SP)
251:                     }else{
252:                         ser_print("0m");
9D016F94  0F405504   JAL ser_print
9D016F98  24849A24   ADDIU A0, A0, -26076
253:                     }
254:                 }
9D016F9C  8FBF0014   LW RA, 20(SP)
9D016FA0  8FB00010   LW S0, 16(SP)
9D016FA4  03E00008   JR RA
9D016FA8  27BD0018   ADDIU SP, SP, 24
255:                 
256:                 void vt_crlf(){
9D016FAC  27BDFFE8   ADDIU SP, SP, -24
9D016FB0  AFBF0014   SW RA, 20(SP)
257:                     ser_put_char('\n');
9D016FB4  0F4054FA   JAL ser_put_char
9D016FB8  2404000A   ADDIU A0, ZERO, 10
258:                 }
9D016FBC  8FBF0014   LW RA, 20(SP)
9D016FC0  03E00008   JR RA
9D016FC4  27BD0018   ADDIU SP, SP, 24
259:                 
260:                 void vt_scroll_up(){
9D016FEC  27BDFFE8   ADDIU SP, SP, -24
9D016FF0  AFBF0014   SW RA, 20(SP)
261:                     vt_set_curpos(79,29);
9D016FF4  2404004F   ADDIU A0, ZERO, 79
9D016FF8  0F405B33   JAL vt_set_curpos
9D016FFC  2405001D   ADDIU A1, ZERO, 29
262:                     vt_put_char('\n');
9D017000  0F405BA6   JAL vt_put_char
9D017004  2404000A   ADDIU A0, ZERO, 10
263:                     vt_set_curpos(vt_col+1,vt_line+1);
9D017008  83848061   LB A0, -32671(GP)
9D01700C  83858060   LB A1, -32672(GP)
9D017010  24840001   ADDIU A0, A0, 1
9D017014  0F405B33   JAL vt_set_curpos
9D017018  24A50001   ADDIU A1, A1, 1
264:                 }
9D01701C  8FBF0014   LW RA, 20(SP)
9D017020  03E00008   JR RA
9D017024  27BD0018   ADDIU SP, SP, 24
265:                 
266:                 void vt_scroll_down(){
9D017028  03E00008   JR RA
9D01702C  00000000   NOP
267:                     
268:                 }
269:                 
270:                 void vt_set_tab_width(int width){
271:                     tab_width=width;
9D017030  03E00008   JR RA
9D017034  A3848012   SB A0, -32750(GP)
272:                 }
273:                 
274:                 int vt_get_tab_width(){
275:                     return tab_width;
276:                 }
9D017038  03E00008   JR RA
9D01703C  83828012   LB V0, -32750(GP)
277:                 
278:                 static bool terminal_ready(){
279:                     bool result=false;
280:                     unsigned char buf[CS_SIZE];
281:                     ser_flush_queue();
282:                     send_esc_seq();
283:                     ser_print("5n");
284:                     if (wait_esc()){
285:                         get_control_sequence(buf,CS_SIZE);
286:                         if (!strcmp(buf,"0n")){result=true;}
287:                     }
288:                     return result;
289:                 }//terminal_ready()
290:                 
291:                 //initialisation du terminal vt100.
292:                 // 80 colonnes
293:                 // retour à la ligne automatique
294:                 // mode LNM  i.e. '\n' produit aussi un '\r'
295:                 // 30 lignes
296:                 int vt_init(){
9D017040  27BDFFE8   ADDIU SP, SP, -24
9D017044  AFBF0014   SW RA, 20(SP)
297:                     int code=0;
298:                     if (terminal_ready){
299:                         ser_flush_queue();
9D017048  0F405555   JAL ser_flush_queue
9D01704C  00000000   NOP
300:                         vt_print(cols_80);
9D017050  3C049D02   LUI A0, -25342
9D017054  0F405BCA   JAL vt_print
9D017058  24849C34   ADDIU A0, A0, -25548
301:                         vt_print(auto_wrap);
9D01705C  3C049D02   LUI A0, -25342
9D017060  0F405BCA   JAL vt_print
9D017064  24849C28   ADDIU A0, A0, -25560
302:                         vt_clear_screen();
9D017068  0F405B21   JAL vt_clear_screen
9D01706C  00000000   NOP
303:                         vt_col=1;
9D017070  24020001   ADDIU V0, ZERO, 1
9D017074  A3828061   SB V0, -32671(GP)
304:                         vt_line=1;
9D017078  A3828060   SB V0, -32672(GP)
305:                         code=1;
306:                     }
307:                     return code;
308:                 }
9D01707C  24020001   ADDIU V0, ZERO, 1
9D017080  8FBF0014   LW RA, 20(SP)
9D017084  03E00008   JR RA
9D017088  27BD0018   ADDIU SP, SP, 24
309:                 
310:                 
---  /home/jacques/github/vpc-32vga/vpcBASIC/vm.S  ------------------------------------------------------
                                                  1:     /*  Nom: vm.S
                                                  2:      *  Auteur: Jacques Deschênes
                                                  3:      *  Description:
                                                  4:      *      machine viruelle à piles qui exécute du bytecode.
                                                  5:      *      le programme utilisant la VM doit l'appellé en utilisant le prototype de
                                                  6:      *      fonction suivant: void StackVM( char *ip);
                                                  7:      *         ip pointe vers le bytecode à exécuter
                                                  8:      *  rev: 2018-03-20
                                                  9:      */
                                                  10:    
                                                  11:    #define _ASM_CODE_
                                                  12:        
                                                  13:    #include <p32xxxx.h>
                                                  14:    
                                                  15:    // fonction en C    
                                                  16:    .extern sys_ticks
                                                  17:    .extern con  
                                                  18:    .extern uppercase
                                                  19:    .extern clear_screen
                                                  20:    .extern clear_line
                                                  21:    .extern clear_eol
                                                  22:    .extern get_key
                                                  23:    .extern wait_key
                                                  24:    .extern read_line
                                                  25:    .extern get_curpos
                                                  26:    .extern set_curpos
                                                  27:    .extern put_char
                                                  28:    .extern print
                                                  29:    .extern spaces
                                                  30:    .extern invert_video
                                                  31:    .extern crlf
                                                  32:    .extern print_int
                                                  33:    .extern print_hex
                                                  34:    .extern println
                                                  35:    .extern scroll_down
                                                  36:    .extern scroll_up
                                                  37:    .extern set_tab_witdh
                                                  38:    .extern get_tab_width
                                                  39:    //math fonctions
                                                  40:    .extern print_float
                                                  41:    .extern rnd
                                                  42:    .extern sinf
                                                  43:    .extern cosf
                                                  44:    .extern tanf
                                                  45:    .extern acosf
                                                  46:    .extern asinf
                                                  47:    .extern atanf
                                                  48:    .extern sqrtf
                                                  49:    .extern fabsf
                                                  50:    .extern powf
                                                  51:    .extern expf
                                                  52:    .extern logf
                                                  53:    .extern log10f
                                                  54:    .extern rintf
                                                  55:    .extern floorf
                                                  56:    .extern ceilf
                                                  57:    
                                                  58:    
                                                  59:    /*************** macros *************/
                                                  60:    
                                                  61:    .macro _tpush
                                                  62:    addiu dp,dp, CELL_SIZE
                                                  63:    sw T, 0(dp)
                                                  64:    .endm
                                                  65:    
                                                  66:    .macro _tpop
                                                  67:    lw T, 0(dp)
                                                  68:    addiu dp,dp,-CELL_SIZE
                                                  69:    .endm
                                                  70:    
                                                  71:    .macro _rpush
                                                  72:    addiu rp,rp,CELL_SIZE
                                                  73:    sw R, 0(rp)
                                                  74:    .endm
                                                  75:    
                                                  76:    .macro _rpop
                                                  77:    lw R, 0(rp)
                                                  78:    addiu rp,rp,-CELL_SIZE
                                                  79:    .endm
                                                  80:    
                                                  81:    .macro _inc_ip
                                                  82:    addiu ip,ip,1
                                                  83:    .endm
                                                  84:    
                                                  85:    .macro _back_jump
                                                  86:        lbu t0,0(ip)
                                                  87:        b next
                                                  88:        sub ip,ip,t0
                                                  89:    .endm
                                                  90:        
                                                  91:    .macro _fore_jump
                                                  92:        lbu t0,0(ip)
                                                  93:        b next
                                                  94:        add ip,ip,t0
                                                  95:    .endm
                                                  96:        
                                                  97:    /* utilisation des regitres MIPS */
                                                  98:    ip=s0  /* pointeur d'instruction VM */
                                                  99:    dp=s1  /* pointeur pile de données */
                                                  100:   rp=s2  /* pointeur pile de contrôle */
                                                  101:   w=s3  /* pointeur de travail */
                                                  102:   T=s4  /* sommet de la pile des données */
                                                  103:   R=s5  /* sommet de la pile des retours */
                                                  104:   L=s6  /* limite boucle do...loop */
                                                  105:   I=s7  /* compteur boucle do...looop */ 
                                                  106:   
                                                  107:   
                                                  108:   
                                                  109:   RAM_SEG=0xA000
                                                  110:   CODE_SEG=0x9D00
                                                  111:   SFR_SEG=0xBF80
                                                  112:   CFG_SEG=0xBFC0
                                                  113:       
                                                  114:   CELL_SIZE=4
                                                  115:       
                                                  116:   DSTACK_SIZE=128
                                                  117:   RSTACK_SIZE=128
                                                  118:   TIB_SIZE=80
                                                  119:   PAD_SIZE=80
                                                  120:       
                                                  121:   SFR_CLEAR=4
                                                  122:   SFR_SET=8
                                                  123:   SFR_INV=12
                                                  124:   
                                                  125:       
                                                  126:   .bss
                                                  127:   .global dstack,rstack,rsp,dsp,endmark,dptr
                                                  128:   // piles
                                                  129:   dstack: .space DSTACK_SIZE
                                                  130:   rstack: .space RSTACK_SIZE
                                                  131:   dsp: .space 4
                                                  132:   rsp: .space 4
                                                  133:   endmark: .space 4
                                                  134:   dptr: .space 4    
                                                  135:       
                                                  136:       
                                                  137:   .text
                                                  138:   .align 2, 0xff
                                                  139:   .set noreorder
                                                  140:   .set macro
                                                  141:   
                                                  142:   
                                                  143:   .global StackVM
                                                  144:   .ent StackVM
                                                  145:   StackVM:  // VM initialization
9D010B5C  27BDFFD8   ADDIU SP, SP, -40            146:       addiu sp, sp, -40 // save registers
9D010B60  AFB00000   SW S0, 0(SP)                 147:       sw  s0, 0(sp)
9D010B64  AFB10004   SW S1, 4(SP)                 148:       sw  s1, 4(sp)
9D010B68  AFB20008   SW S2, 8(SP)                 149:       sw  s2, 8(sp)
9D010B6C  AFB3000C   SW S3, 12(SP)                150:       sw  s3,12(sp)
9D010B70  AFB40010   SW S4, 16(SP)                151:       sw  s4,16(sp)
9D010B74  AFB50014   SW S5, 20(SP)                152:       sw  s5,20(sp)
9D010B78  AFB60018   SW S6, 24(SP)                153:       sw  s6,24(sp)
9D010B7C  AFB7001C   SW S7, 28(SP)                154:       sw  s7,28(sp)
9D010B80  AFBE0020   SW S8, 32(SP)                155:       sw  s8,32(sp)
9D010B84  AFBF0024   SW RA, 36(SP)                156:       sw  ra,36(sp)
9D010B88  00808021   ADDU S0, A0, ZERO            157:       move ip, a0   // pointeur bytecode à exécuter
9D010B8C  3C13A000   LUI S3, -24576               158:       lui w, RAM_SEG
9D010B90  36714000   ORI S1, S3, 16384            159:       ori dp, w, dstack
9D010B94  36724080   ORI S2, S3, 16512            160:       ori rp, w, rstack
                                                  161:       
                                                  162:   // VM instruction loop
                                                  163:   next:
9D010B98  92080000   LBU T0, 0(S0)                164:       lbu   t0, 0(ip)
9D010B9C  00084080   SLL T0, T0, 2                165:       sll   t0, t0, 2   
9D010BA0  3C099D01   LUI T1, -25343               166:       la t1,opcodes_table
9D010BA8  01284821   ADDU T1, T1, T0              167:       addu t1,t1,t0
9D010BAC  3C089D01   LUI T0, -25343               168:       la t0, bad_op
9D010BB4  01094023   SUBU T0, T0, T1              169:       subu t0,t0,t1
9D010BB8  19000003   BLEZ T0, 0x9D010BC8          170:       blez t0,vm_bad_op
9D010BBC  8D290000   LW T1, 0(T1)                 171:       lw    t1, 0(t1)
9D010BC0  01200008   JR T1                        172:       jr    t1
9D010BC4  26100001   ADDIU S0, S0, 1              173:       _inc_ip
                                                  174:   
                                                  175:   vm_bad_op:
9D010BC8  10000002   BEQ ZERO, ZERO, 0x9D010BD4   176:       b 1f
9D010BCC  24140001   ADDIU S4, ZERO, 1            177:       addiu T,zero,1
                                                  178:       
                                                  179:   bye:   // 'bye' ( -- ) exit virtual machine
9D010BD0  0000A021   ADDU S4, ZERO, ZERO          180:       move T,zero
9D010BD4  8FB00000   LW S0, 0(SP)                 181:   1:  lw  s0,0(sp)
9D010BD8  8FB10004   LW S1, 4(SP)                 182:       lw  s1,4(sp)
9D010BDC  8FB20008   LW S2, 8(SP)                 183:       lw  s2,8(sp)
9D010BE0  8FB3000C   LW S3, 12(SP)                184:       lw  s3,12(sp)
9D010BE4  8FB40010   LW S4, 16(SP)                185:       lw  s4,16(sp)
9D010BE8  8FB50014   LW S5, 20(SP)                186:       lw  s5,20(sp)
9D010BEC  8FB60018   LW S6, 24(SP)                187:       lw  s6,24(sp)
9D010BF0  8FB7001C   LW S7, 28(SP)                188:       lw  s7,28(sp)
9D010BF4  8FBE0020   LW S8, 32(SP)                189:       lw  s8,32(sp)
9D010BF8  8FBF0024   LW RA, 36(SP)                190:       lw  ra,36(sp)
9D010BFC  02801021   ADDU V0, S4, ZERO            191:       move v0,T
9D010C00  03E00008   JR RA                        192:       jr  ra
9D010C04  27BD0028   ADDIU SP, SP, 40             193:       addiu sp,sp,40
                                                  194:   
                                                  195:   qrx: // '?key' ( -- ch -1 | 0 )
9D010C08  3C04A000   LUI A0, -24576               196:       la a0,con
9D010C10  0F404F7B   JAL 0x9D013DEC               197:       jal get_key
9D010C14  90840000   LBU A0, 0(A0)                198:       lbu a0,0(a0)
9D010C18  26310004   ADDIU S1, S1, 4              199:       _tpush
9D010C20  1040FFDD   BEQ V0, ZERO, 0x9D010B98     200:       beqz v0, next
9D010C24  0040A021   ADDU S4, V0, ZERO            201:       addu T,v0,zero 
9D010C28  2408FFFF   ADDIU T0, ZERO, -1           202:       addiu t0,zero,-1
9D010C2C  26310004   ADDIU S1, S1, 4              203:       _tpush
                                                  204:   qrx_exit:
9D010C34  1000FFD8   BEQ ZERO, ZERO, 0x9D010B98   205:       b next
9D010C38  0100A021   ADDU S4, T0, ZERO            206:       move T, t0
                                                  207:   
                                                  208:   emit:   // 'emit' ( ch -- ) transmet charactère au terminal
9D010C3C  3C04A000   LUI A0, -24576               209:       la a0,con
9D010C44  90840000   LBU A0, 0(A0)                210:       lbu a0,0(a0)
9D010C48  0F404FC0   JAL 0x9D013F00               211:       jal put_char
9D010C4C  02802821   ADDU A1, S4, ZERO            212:       move  a1, T
9D010C50  8E340000   LW S4, 0(S1)                 213:       lw T, 0(dp)
9D010C54  1000FFD0   BEQ ZERO, ZERO, 0x9D010B98   214:       b next
9D010C58  2631FFFC   ADDIU S1, S1, -4             215:       addiu dp,dp,-CELL_SIZE
                                                  216:   
                                                  217:   cr: // 'cr' ( -- ) émet un carriage return line feed
9D010C5C  3C04A000   LUI A0, -24576               218:       la a0,con
9D010C64  0F404FF3   JAL 0x9D013FCC               219:       jal crlf
9D010C68  90840000   LBU A0, 0(A0)                220:       lbu a0,0(a0)
9D010C6C  1000FFCA   BEQ ZERO, ZERO, 0x9D010B98   221:       b next
9D010C70  00000000   NOP                          222:       nop
                                                  223:       
                                                  224:       
                                                  225:   lit:    // 'lit' ( -- n) empile un entier
9D010C74  26310004   ADDIU S1, S1, 4              226:       _tpush
9D010C7C  8A140003   LWL S4, 3(S0)                227:       ulw T,0(ip)
9D010C84  1000FFC4   BEQ ZERO, ZERO, 0x9D010B98   228:       b next
9D010C88  26100004   ADDIU S0, S0, 4              229:       addiu ip,ip,CELL_SIZE
                                                  230:   
                                                  231:   clit:   // 'clit' ( -- byte ) empile un octet signe étendu sur 32 bits
9D010C8C  26310004   ADDIU S1, S1, 4              232:       _tpush
9D010C94  92140000   LBU S4, 0(S0)                233:       lbu T, 0(ip)
9D010C98  1000FFBF   BEQ ZERO, ZERO, 0x9D010B98   234:       b next
9D010C9C  26100001   ADDIU S0, S0, 1              235:       _inc_ip
                                                  236:   
                                                  237:   wlit:  // 'wlit' ( -- w16  ) empile un mot de 16 bits
9D010CA0  26310004   ADDIU S1, S1, 4              238:       _tpush
9D010CA8  9A140000   LWR S4, 0(S0)                239:       lwr T,0(ip)
9D010CAC  3294FFFF   ANDI S4, S4, -1              240:       andi T,T,0xffff
9D010CB0  1000FFB9   BEQ ZERO, ZERO, 0x9D010B98   241:       b next
9D010CB4  26100002   ADDIU S0, S0, 2              242:       addiu ip,ip,2
                                                  243:   
                                                  244:   lits: // 's"' ( -- addr) empile l'adresse d'une chaîne litérale
9D010CB8  26310004   ADDIU S1, S1, 4              245:       _tpush
9D010CC0  0200A021   ADDU S4, S0, ZERO            246:       move T,ip
9D010CC4  92930000   LBU S3, 0(S4)                247:       lbu w,0(T)
9D010CC8  02138021   ADDU S0, S0, S3              248:       addu ip,ip,w
9D010CCC  1000FFB2   BEQ ZERO, ZERO, 0x9D010B98   249:       b next
9D010CD0  26100001   ADDIU S0, S0, 1              250:       _inc_ip
                                                  251:       
                                                  252:   docol:   // 'call' (R: -- addr_ret ) appelle mot de haut niveau
9D010CD4  8A080003   LWL T0, 3(S0)                253:       ulw t0,0(ip)
9D010CDC  26520004   ADDIU S2, S2, 4              254:       _rpush
9D010CE4  0200A821   ADDU S5, S0, ZERO            255:       move R, ip
9D010CE8  1000FFAB   BEQ ZERO, ZERO, 0x9D010B98   256:       b next
9D010CEC  01008021   ADDU S0, T0, ZERO            257:       move ip, t0
                                                  258:   
                                                  259:   //rcall:  # 'rcall' (R: -- addr_ret ) appelle sous-routine VM en mémoire RAM
                                                  260:   //    lui t2, RAM_SEG
                                                  261:   //    b fcall_1
                                                  262:   //    lbu t0, 0(ip)
                                                  263:   
                                                  264:   exit:  // ';' (R: addr_ret -- ) sortie d'un mot de haut niveau
9D010CF0  02A08021   ADDU S0, S5, ZERO            265:       move ip, R
9D010CF4  8E550000   LW S5, 0(S2)                 266:       lw R, 0(rp)
9D010CF8  1000FFA7   BEQ ZERO, ZERO, 0x9D010B98   267:       b next
9D010CFC  2652FFFC   ADDIU S2, S2, -4             268:       addiu rp,rp, -CELL_SIZE
                                                  269:   
                                                  270:   bra:   // 'branch' ( -- ) branchement incondionnnel (adresse relative +127,-128)
9D010D00  82080000   LB T0, 0(S0)                 271:       lb t0, 0(ip)
                                                  272:   //    _inc_ip
9D010D04  1000FFA4   BEQ ZERO, ZERO, 0x9D010B98   273:       b next
9D010D08  02088021   ADDU S0, S0, T0              274:       addu ip, ip, t0  // branchement relatif à ip, intervale -128 à +127
                                                  275:   
                                                  276:   qbra: // '?bra' ( t|f -- ) branche si sommet pile est vrai (tos!=0)
9D010D0C  02804021   ADDU T0, S4, ZERO            277:       move t0, T
9D010D10  8E340000   LW S4, 0(S1)                 278:       _tpop
9D010D18  1100FF9F   BEQ T0, ZERO, 0x9D010B98     279:       beqz t0, next
9D010D1C  26100001   ADDIU S0, S0, 1              280:       _inc_ip
9D010D20  8208FFFF   LB T0, -1(S0)                281:       lb t0, -1(ip)
9D010D24  1000FF9C   BEQ ZERO, ZERO, 0x9D010B98   282:       b next
9D010D28  02088021   ADDU S0, S0, T0              283:       addu ip,ip,t0
                                                  284:   
                                                  285:   qbraz:  // '?braz' ( t|f -- ) branche si sommet pile est faux (tos==0)
9D010D2C  02804021   ADDU T0, S4, ZERO            286:       move t0, T
9D010D30  8E340000   LW S4, 0(S1)                 287:       _tpop
9D010D38  1500FF97   BNE T0, ZERO, 0x9D010B98     288:       bne t0, zero, next
9D010D3C  26100001   ADDIU S0, S0, 1              289:       _inc_ip
9D010D40  8208FFFF   LB T0, -1(S0)                290:       lb t0, -1(ip)
9D010D44  1000FF94   BEQ ZERO, ZERO, 0x9D010B98   291:       b next
9D010D48  02088021   ADDU S0, S0, T0              292:       addu ip,ip,t0
                                                  293:   
                                                  294:   exec:  // 'exec' ( addr -- ) appelle sous-routine à partir de la pile
9D010D4C  26520004   ADDIU S2, S2, 4              295:       _rpush
9D010D54  0200A821   ADDU S5, S0, ZERO            296:       move R, ip
9D010D58  02808021   ADDU S0, S4, ZERO            297:       move  ip, T
9D010D5C  8E340000   LW S4, 0(S1)                 298:       lw T,0(dp)
9D010D60  1000FF8D   BEQ ZERO, ZERO, 0x9D010B98   299:       b next
9D010D64  2631FFFC   ADDIU S1, S1, -4             300:       addiu dp,dp,-CELL_SIZE
                                                  301:   
                                                  302:   store:  // '!' ( n addr -- )  variable = n
9D010D68  8E280000   LW T0, 0(S1)                 303:       lw t0, 0(dp)
9D010D6C  AA880003   SWL T0, 3(S4)                304:       usw t0,0(T)
9D010D74  8E34FFFC   LW S4, -4(S1)                305:       lw T,-CELL_SIZE(dp)
9D010D78  1000FF87   BEQ ZERO, ZERO, 0x9D010B98   306:       b next
9D010D7C  2631FFF8   ADDIU S1, S1, -8             307:       addiu dp,dp,-2*CELL_SIZE
                                                  308:       
                                                  309:   // load variable in T
                                                  310:   fetch:  // '@' ( addr -- n ) T= *addr
9D010D80  02804021   ADDU T0, S4, ZERO            311:       move t0, T
9D010D84  89140003   LWL S4, 3(T0)                312:       ulw T,0(t0)
9D010D8C  1000FF82   BEQ ZERO, ZERO, 0x9D010B98   313:       b next
9D010D90  00000000   NOP                          314:       nop
                                                  315:   
                                                  316:   cstore:  // 'c!' ( char addr --  ) *addr = char
9D010D94  8E280000   LW T0, 0(S1)                 317:       lw t0, 0(dp)
9D010D98  A2880000   SB T0, 0(S4)                 318:       sb t0, 0(T)
9D010D9C  8E34FFFC   LW S4, -4(S1)                319:       lw T, -CELL_SIZE(dp)
9D010DA0  1000FF7D   BEQ ZERO, ZERO, 0x9D010B98   320:       b next
9D010DA4  2631FFF8   ADDIU S1, S1, -8             321:       addiu dp,dp,-2*CELL_SIZE
                                                  322:   
                                                  323:   cfetch:  // 'c@' ( addr -- char )  T = (char)*addr
9D010DA8  1000FF7B   BEQ ZERO, ZERO, 0x9D010B98   324:       b next
9D010DAC  82940000   LB S4, 0(S4)                 325:       lb T, 0(T)
                                                  326:   
                                                  327:   rfetch:   // 'r@'  ( -- n R: n -- n )  empile le sommet de la pile des retours
9D010DB0  26310004   ADDIU S1, S1, 4              328:       _tpush
9D010DB8  1000FF77   BEQ ZERO, ZERO, 0x9D010B98   329:       b next
9D010DBC  02A0A021   ADDU S4, S5, ZERO            330:       move T, R
                                                  331:   
                                                  332:   tor:  // '>r' ( n -- ) (R: -- n ) envoie T sur pile retour
9D010DC0  26520004   ADDIU S2, S2, 4              333:       _rpush
9D010DC8  0280A821   ADDU S5, S4, ZERO            334:       move R, T
9D010DCC  8E340000   LW S4, 0(S1)                 335:       lw T, 0(dp)
9D010DD0  1000FF71   BEQ ZERO, ZERO, 0x9D010B98   336:       b next
9D010DD4  2631FFFC   ADDIU S1, S1, -4             337:       addiu dp, dp, -CELL_SIZE
                                                  338:   
                                                  339:   rfrom:  // 'r>' ( -- n ) (R: n -- )  envoie R dans T
9D010DD8  26310004   ADDIU S1, S1, 4              340:       _tpush
9D010DE0  02A0A021   ADDU S4, S5, ZERO            341:       move T, R
9D010DE4  8E550000   LW S5, 0(S2)                 342:       lw  R, 0(rp)
9D010DE8  1000FF6B   BEQ ZERO, ZERO, 0x9D010B98   343:       b next
9D010DEC  2652FFFC   ADDIU S2, S2, -4             344:       addiu rp,rp, -CELL_SIZE
                                                  345:   
                                                  346:   
                                                  347:   dcnt:  // 'dcnt' ( -- n) nombre d'éléments sur la pile de données
9D010DF0  3C08A000   LUI T0, -24576               348:       la t0,dstack
9D010DF8  02284023   SUBU T0, S1, T0              349:       subu t0,dp,t0
9D010DFC  26310004   ADDIU S1, S1, 4              350:       _tpush
9D010E04  1000FF64   BEQ ZERO, ZERO, 0x9D010B98   351:       b next
9D010E08  0008A083   SRA S4, T0, 2                352:       sra T, t0,2
                                                  353:   
                                                  354:   rcnt:  // 'rcnt' ( -- n ) nombre d'éléments sur la pile des retours
9D010E0C  26310004   ADDIU S1, S1, 4              355:       _tpush
9D010E14  3C08A000   LUI T0, -24576               356:       la t0,rstack
9D010E1C  0248A023   SUBU S4, S2, T0              357:       subu T,rp,t0
9D010E20  1000FF5D   BEQ ZERO, ZERO, 0x9D010B98   358:       b next
9D010E24  0014A083   SRA S4, S4, 2                359:       sra T,T,2
                                                  360:   
                                                  361:   ipfetch: // 'ip@' ( -- ip ) empile la valeur courante du pointeur d''instructions
9D010E28  26310004   ADDIU S1, S1, 4              362:       _tpush
9D010E30  1000FF59   BEQ ZERO, ZERO, 0x9D010B98   363:       b next
9D010E34  0200A021   ADDU S4, S0, ZERO            364:       move T, ip
                                                  365:   
                                                  366:   ipstore: // 'ip!' ( ip -- ) initialise le pointeur d''insturctions
9D010E38  02808021   ADDU S0, S4, ZERO            367:       move ip, T
9D010E3C  8E340000   LW S4, 0(S1)                 368:       lw T, 0(dp)
9D010E40  1000FF55   BEQ ZERO, ZERO, 0x9D010B98   369:       b next
9D010E44  2631FFFC   ADDIU S1, S1, -4             370:       addiu dp,dp, -CELL_SIZE
                                                  371:   
                                                  372:   drop:  // 'drop' ( n -- )
9D010E48  8E340000   LW S4, 0(S1)                 373:       lw T, 0(dp)
9D010E4C  1000FF52   BEQ ZERO, ZERO, 0x9D010B98   374:       b next
9D010E50  2631FFFC   ADDIU S1, S1, -4             375:       addiu dp,dp,-CELL_SIZE
                                                  376:   
                                                  377:   twodrop: // '2drop' ( n1 n2 -- )
9D010E54  8E34FFFC   LW S4, -4(S1)                378:       lw T, -CELL_SIZE(dp)
9D010E58  1000FF4F   BEQ ZERO, ZERO, 0x9D010B98   379:       b next
9D010E5C  2631FFF8   ADDIU S1, S1, -8             380:       addiu dp,dp,-2*CELL_SIZE
                                                  381:   
                                                  382:   dup:  // 'dup' ( n -- n n )
9D010E60  26310004   ADDIU S1, S1, 4              383:       addiu dp,dp,CELL_SIZE
9D010E64  1000FF4C   BEQ ZERO, ZERO, 0x9D010B98   384:       b next
9D010E68  AE340000   SW S4, 0(S1)                 385:       sw T, 0(dp)
                                                  386:   
                                                  387:   twodup: // (n2 n1 -- n2 n1 n2 n1)
9D010E6C  8E280000   LW T0, 0(S1)                 388:       lw t0, 0(dp)
9D010E70  26310008   ADDIU S1, S1, 8              389:       addiu dp,dp,2*CELL_SIZE
9D010E74  AE34FFFC   SW S4, -4(S1)                390:       sw T, -CELL_SIZE(dp)
9D010E78  1000FF47   BEQ ZERO, ZERO, 0x9D010B98   391:       b next
9D010E7C  AE280000   SW T0, 0(S1)                 392:       sw t0, 0(dp)
                                                  393:   
                                                  394:   qdup:   // ?dup ( n -- n n | n ) duplique n si n!=0
9D010E80  1280FF45   BEQ S4, ZERO, 0x9D010B98     395:       beq T,zero, next
9D010E84  00000000   NOP                          396:       nop
9D010E88  26310004   ADDIU S1, S1, 4              397:       addiu dp,dp,CELL_SIZE
9D010E8C  1000FF42   BEQ ZERO, ZERO, 0x9D010B98   398:       b next
9D010E90  AE340000   SW S4, 0(S1)                 399:       sw T, 0(dp)
                                                  400:   
                                                  401:   swap: // 'swap' (n2 n1 -- n1 n2 )
9D010E94  02804021   ADDU T0, S4, ZERO            402:       move t0, T
9D010E98  8E340000   LW S4, 0(S1)                 403:       lw T, 0(dp)
9D010E9C  1000FF3E   BEQ ZERO, ZERO, 0x9D010B98   404:       b next
9D010EA0  AE280000   SW T0, 0(S1)                 405:       sw t0, 0(dp)
                                                  406:   
                                                  407:   over:   // 'over' ( n2 n1 -- n2 n1 n2 )
9D010EA4  26310004   ADDIU S1, S1, 4              408:       _tpush
9D010EAC  1000FF3A   BEQ ZERO, ZERO, 0x9D010B98   409:       b next
9D010EB0  8E34FFFC   LW S4, -4(S1)                410:       lw T, -CELL_SIZE(dp)
                                                  411:   
                                                  412:   rot: // ( n3 n2 n1 -- n2 n1 n3)
9D010EB4  02804021   ADDU T0, S4, ZERO            413:       move t0, T
9D010EB8  8E290000   LW T1, 0(S1)                 414:       lw t1, 0(dp)
9D010EBC  8E34FFFC   LW S4, -4(S1)                415:       lw T, -CELL_SIZE(dp)
9D010EC0  AE280000   SW T0, 0(S1)                 416:       sw t0, 0(dp)
9D010EC4  1000FF34   BEQ ZERO, ZERO, 0x9D010B98   417:       b next
9D010EC8  AE29FFFC   SW T1, -4(S1)                418:       sw t1, -CELL_SIZE(dp)
                                                  419:   
                                                  420:   plus:  // '+'   ( n1 n2 -- n1+n2 )
9D010ECC  8E280000   LW T0, 0(S1)                 421:       lw t0,0(dp)
9D010ED0  0288A021   ADDU S4, S4, T0              422:       addu T,T,t0
9D010ED4  1000FF30   BEQ ZERO, ZERO, 0x9D010B98   423:       b next
9D010ED8  2631FFFC   ADDIU S1, S1, -4             424:       addiu dp,dp,-CELL_SIZE
                                                  425:   
                                                  426:   oneplus:  // '1+'  (n -- n+1 )
9D010EDC  1000FF2E   BEQ ZERO, ZERO, 0x9D010B98   427:       b next
9D010EE0  26940001   ADDIU S4, S4, 1              428:       addiu T, T, 1
                                                  429:   
                                                  430:   plusstore:  // '+!'  ( n addr -- ) *addr  = *addr+n
9D010EE4  8A880003   LWL T0, 3(S4)                431:       ulw t0,0(T)
9D010EEC  8E290000   LW T1, 0(S1)                 432:       lw t1,0(dp)
9D010EF0  01284020   ADD T0, T1, T0               433:       add t0,t1,t0
9D010EF4  AA880003   SWL T0, 3(S4)                434:       usw t0,0(T)
9D010EFC  8E34FFFC   LW S4, -4(S1)                435:       lw T,-CELL_SIZE(dp)
9D010F00  1000FF25   BEQ ZERO, ZERO, 0x9D010B98   436:       b next
9D010F04  2631FFF8   ADDIU S1, S1, -8             437:       addiu dp,dp,-2*CELL_SIZE
                                                  438:   
                                                  439:   minus:   //  '-' ( n1 n2 -- n1-n2 )
9D010F08  8E280000   LW T0, 0(S1)                 440:       lw t0,0(dp)
9D010F0C  0114A023   SUBU S4, T0, S4              441:       subu T,t0,T
9D010F10  1000FF21   BEQ ZERO, ZERO, 0x9D010B98   442:       b next
9D010F14  2631FFFC   ADDIU S1, S1, -4             443:       addiu dp,dp,-CELL_SIZE
                                                  444:   
                                                  445:   oneminus:   // '1-' ( n -- n-1 )
9D010F18  1000FF1F   BEQ ZERO, ZERO, 0x9D010B98   446:       b next
9D010F1C  2694FFFF   ADDIU S4, S4, -1             447:       addiu T, T, -1
                                                  448:   
                                                  449:   star:   // '*' ( n1 n2 -- n1*n2 ) multiplication signé, résultat simple précision.
9D010F20  8E280000   LW T0, 0(S1)                 450:       lw t0,0(dp) 
9D010F24  7114A002   MUL S4, T0, S4               451:       mul T,t0,T
9D010F28  1000FF1B   BEQ ZERO, ZERO, 0x9D010B98   452:       b next
9D010F2C  2631FFFC   ADDIU S1, S1, -4             453:       addiu dp,dp,-CELL_SIZE
                                                  454:   
                                                  455:   ustar:   // 'U*' ( u1 u2 -- u3 ) multiplication non signe, résultat simple précision
9D010F30  8E280000   LW T0, 0(S1)                 456:       lw t0,0(dp)
9D010F34  01140019   MULTU 0, T0, S4              457:       multu  t0, T
9D010F38  0000A012   MFLO S4                      458:       mflo T
9D010F3C  1000FF16   BEQ ZERO, ZERO, 0x9D010B98   459:       b next
9D010F40  2631FFFC   ADDIU S1, S1, -4             460:       addiu dp,dp,-CELL_SIZE
                                                  461:   
                                                  462:   mstar:  // 'M*' ( n1 n2 -- d) multiplication signée avec résultat double précision.
9D010F44  8E280000   LW T0, 0(S1)                 463:       lw t0, 0(dp)
9D010F48  01140018   MULT 0, T0, S4               464:       mult t0,T
9D010F4C  00004012   MFLO T0                      465:       mflo t0
9D010F50  0000A010   MFHI S4                      466:       mfhi T
9D010F54  1000FF10   BEQ ZERO, ZERO, 0x9D010B98   467:       b next
9D010F58  AE280000   SW T0, 0(S1)                 468:       sw t0, 0(dp)
                                                  469:   
                                                  470:   umstar: // 'UM*' ( u1 u2 -- ud ) multiplication non signé avec résultat double précision.
9D010F5C  8E280000   LW T0, 0(S1)                 471:       lw t0, 0(dp)
9D010F60  01140019   MULTU 0, T0, S4              472:       multu t0,T
9D010F64  00004012   MFLO T0                      473:       mflo t0
9D010F68  0000A010   MFHI S4                      474:       mfhi T
9D010F6C  1000FF0A   BEQ ZERO, ZERO, 0x9D010B98   475:       b next
9D010F70  AE280000   SW T0, 0(S1)                 476:       sw t0, 0(dp)
                                                  477:   
                                                  478:   slash:  // '/' ( n1 n2 -- n1/n2 )  division signée
9D010F74  8E280000   LW T0, 0(S1)                 479:       lw t0, 0(dp)
9D010F78  028001F4   TEQ S4, ZERO                 480:       div t0,T
9D010F94  0000A012   MFLO S4                      481:       mflo T
9D010F98  1000FEFF   BEQ ZERO, ZERO, 0x9D010B98   482:       b next
9D010F9C  2631FFFC   ADDIU S1, S1, -4             483:       addiu dp,dp,-CELL_SIZE
                                                  484:   
                                                  485:   uslash:  // 'U/'  (u1 u2 -- u3)  division non signée
9D010FA0  8E280000   LW T0, 0(S1)                 486:       lw t0,0(dp)
9D010FA4  028001F4   TEQ S4, ZERO                 487:       divu t0,T
9D010FB0  0000A012   MFLO S4                      488:       mflo T
9D010FB4  1000FEF8   BEQ ZERO, ZERO, 0x9D010B98   489:       b next
9D010FB8  2631FFFC   ADDIU S1, S1, -4             490:       addiu dp,dp,-CELL_SIZE
                                                  491:   
                                                  492:   twostar:  # '2*'  ( n  -- 2*n ) multiply by 2 (shift left 1 bit)
9D010FBC  1000FEF6   BEQ ZERO, ZERO, 0x9D010B98   493:       b next
9D010FC0  0014A040   SLL S4, S4, 1                494:       sll T,T,1
                                                  495:   
                                                  496:   twoslash: // '2/'  ( n -- n/2 )  divide by 2 ( arithmetic shift right 1 bit)
9D010FC4  1000FEF4   BEQ ZERO, ZERO, 0x9D010B98   497:       b next
9D010FC8  0014A043   SRA S4, S4, 1                498:       sra T,T,1
                                                  499:   
                                                  500:   divmod:  // '/mod'  ( n1 n2 -- n1%n2 n1/n2 )
9D010FCC  8E280000   LW T0, 0(S1)                 501:       lw t0, 0(dp)
9D010FD0  028001F4   TEQ S4, ZERO                 502:       div t0, T  # n1/n2
9D010FEC  00004010   MFHI T0                      503:       mfhi t0    #  remainder
9D010FF0  AE280000   SW T0, 0(S1)                 504:       sw t0, 0(dp)
9D010FF4  1000FEE8   BEQ ZERO, ZERO, 0x9D010B98   505:       b next
9D010FF8  0000A012   MFLO S4                      506:       mflo T     # quotient
                                                  507:   
                                                  508:   lshift:  // '<<' ( n1 u -- n1<<u )
9D010FFC  8E280000   LW T0, 0(S1)                 509:       lw t0, 0(dp)
9D011000  0288A004   SLLV S4, T0, S4              510:       sllv T,t0,T
9D011004  1000FEE4   BEQ ZERO, ZERO, 0x9D010B98   511:       b next
9D011008  2631FFFC   ADDIU S1, S1, -4             512:       addiu dp,dp,-CELL_SIZE
                                                  513:   
                                                  514:   rshift:  // '>>'  ( n1 u -- n1>>u )
9D01100C  8E280000   LW T0, 0(S1)                 515:       lw t0,0(dp)
9D011010  0288A006   SRLV S4, T0, S4              516:       srlv T,t0,T
9D011014  1000FEE0   BEQ ZERO, ZERO, 0x9D010B98   517:       b next
9D011018  2631FFFC   ADDIU S1, S1, -4             518:       addiu dp,dp,-CELL_SIZE
                                                  519:   
                                                  520:   modulo:  // 'mod' ( n1 n2 -- n1%n2 )
9D01101C  8E280000   LW T0, 0(S1)                 521:       lw t0, 0(dp)
9D011020  028001F4   TEQ S4, ZERO                 522:       div t0,T
9D01103C  0000A010   MFHI S4                      523:       mfhi T
9D011040  1000FED5   BEQ ZERO, ZERO, 0x9D010B98   524:       b next
9D011044  2631FFFC   ADDIU S1, S1, -4             525:       addiu dp,dp,-CELL_SIZE
                                                  526:   
                                                  527:   // division non signée d'un double précision par un simple, retourne quotient et reste
                                                  528:   umsmod: // UM/MOD (ud1 u1 -- u2 u3) u2=reste, u3=quotient
9D011048  8E28FFFC   LW T0, -4(S1)                529:           lw      t0, -CELL_SIZE(dp)  # 32 bits poids faible
9D01104C  8E290000   LW T1, 0(S1)                 530:           lw      t1, 0(dp)           # 32 bits poids fort
9D011050  1D20000D   BGTZ T1, 0x9D011088          531:           bgtz    t1, long_div
9D011054  00000000   NOP                          532:           nop
9D011058  028001F4   TEQ S4, ZERO                 533:           divu    t0, T
9D011064  00004010   MFHI T0                      534:           mfhi    t0              # reste
9D011068  0000A012   MFLO S4                      535:           mflo    T               # quotient
9D01106C  AE28FFFC   SW T0, -4(S1)                536:           sw      t0, -CELL_SIZE(dp)
9D011070  1000FEC9   BEQ ZERO, ZERO, 0x9D010B98   537:           b       next
9D011074  2631FFFC   ADDIU S1, S1, -4             538:           addiu   dp, dp, -CELL_SIZE
9D011078  2414FFFF   ADDIU S4, ZERO, -1           539:   1:      li      T, -1             # quotient > 32 bits
9D01107C  AE34FFFC   SW S4, -4(S1)                540:           sw      T, -CELL_SIZE(dp)
9D011080  1000FEC5   BEQ ZERO, ZERO, 0x9D010B98   541:           b       next
9D011084  2631FFFC   ADDIU S1, S1, -4             542:           addiu   dp,dp,-CELL_SIZE
                                                  543:   long_div:
9D011088  028001F4   TEQ S4, ZERO                 544:           divu    t1,T
9D011094  00005812   MFLO T3                      545:           mflo    t3      #quotient
9D011098  1D60FFF7   BGTZ T3, 0x9D011078          546:           bgtz    t3, 1b
9D01109C  00004810   MFHI T1                      547:           mfhi    t1      #reste
9D0110A0  240A0020   ADDIU T2, ZERO, 32           548:           li      t2, 32  # compteur de boucle
9D0110A4  0560FFF4   BLTZ T3, 0x9D011078          549:   2:      bltz    t3, 1b  # overflow
9D0110A8  000B5840   SLL T3, T3, 1                550:           sll     t3,t3,1
9D0110AC  01346023   SUBU T4, T1, S4              551:           subu    t4,t1,T
9D0110B0  05800003   BLTZ T4, 0x9D0110C0          552:           bltz    t4,3f
9D0110B4  00000000   NOP                          553:           nop
9D0110B8  01804821   ADDU T1, T4, ZERO            554:           move    t1, t4
9D0110BC  356B0001   ORI T3, T3, 1                555:           ori     t3,t3,1
9D0110C0  254AFFFF   ADDIU T2, T2, -1             556:   3:      addiu   t2,t2,-1  # décrémente le compteur de boucle
9D0110C4  11400007   BEQ T2, ZERO, 0x9D0110E4     557:           beqz    t2, 5f    # division terminée si 0
9D0110C8  00000000   NOP                          558:           nop
9D0110CC  00094840   SLL T1, T1, 1                559:           sll     t1,t1,1   # décale à gauche t1:t0
9D0110D0  05010002   BGEZ T0, 0x9D0110DC          560:           bgez    t0, 4f
9D0110D4  00000000   NOP                          561:           nop
9D0110D8  35290001   ORI T1, T1, 1                562:           ori     t1,t1,1
9D0110DC  1000FFF1   BEQ ZERO, ZERO, 0x9D0110A4   563:   4:      b 2b
9D0110E0  00084040   SLL T0, T0, 1                564:           sll     t0,t0,1
9D0110E4  0160A021   ADDU S4, T3, ZERO            565:   5:      move    T, t3                 # quotient
9D0110E8  AE29FFFC   SW T1, -4(S1)                566:           sw      t1, -CELL_SIZE(dp)    # reste
9D0110EC  1000FEAA   BEQ ZERO, ZERO, 0x9D010B98   567:           b       next
9D0110F0  2631FFFC   ADDIU S1, S1, -4             568:           addiu   dp,dp,-CELL_SIZE
                                                  569:   
                                                  570:   
                                                  571:     // division signée d'un double par un simple, retourne quotient et reste
                                                  572:     // les 32 bits les plus significatifs du double sont ignorés.
                                                  573:     //  Il s'agit dans les fait d'une division simple/simple.
                                                  574:   msmod:   # M/MOD  (d1 n1 - n2 n3 )  n2=reste, n3=quotient
9D0110F4  8E28FFFC   LW T0, -4(S1)                575:           lw      t0, -CELL_SIZE(dp)
9D0110F8  028001F4   TEQ S4, ZERO                 576:           div     t0, T
9D011114  00004010   MFHI T0                      577:           mfhi    t0
9D011118  0000A012   MFLO S4                      578:           mflo    T
9D01111C  AE28FFFC   SW T0, -4(S1)                579:           sw      t0, -CELL_SIZE(dp)
9D011120  1000FE9D   BEQ ZERO, ZERO, 0x9D010B98   580:           b       next
9D011124  2631FFFC   ADDIU S1, S1, -4             581:           addiu   dp,dp,-CELL_SIZE
                                                  582:   
                                                  583:   
                                                  584:   min:  // min (n1 n2 -- min )  conserve le plus petit
9D011128  8E280000   LW T0, 0(S1)                 585:       lw t0, 0(dp)
9D01112C  01144823   SUBU T1, T0, S4              586:       subu t1,t0,T
9D011130  0520FE99   BLTZ T1, 0x9D010B98          587:       bltz t1, next
9D011134  2631FFFC   ADDIU S1, S1, -4             588:       addiu dp,dp,-CELL_SIZE
9D011138  0100A021   ADDU S4, T0, ZERO            589:       move T,t0
9D01113C  1000FE96   BEQ ZERO, ZERO, 0x9D010B98   590:       b next
9D011140  00000000   NOP                          591:       nop
                                                  592:   
                                                  593:   max:  // max (n1 n2 -- max ) conserve le plus grand
9D011144  8E280000   LW T0, 0(S1)                 594:       lw t0,0(dp)
9D011148  02884823   SUBU T1, S4, T0              595:       subu t1,T,t0
9D01114C  0520FE92   BLTZ T1, 0x9D010B98          596:       bltz t1, next
9D011150  2631FFFC   ADDIU S1, S1, -4             597:       addiu dp,dp,-CELL_SIZE
9D011154  0100A021   ADDU S4, T0, ZERO            598:       move T,t0
9D011158  1000FE8F   BEQ ZERO, ZERO, 0x9D010B98   599:       b next
9D01115C  00000000   NOP                          600:       nop
                                                  601:   
                                                  602:   abs:  // 'abs' ( n -- abs(n) )
9D011160  0681FE8D   BGEZ S4, 0x9D010B98          603:       bgez T, next
9D011164  00000000   NOP                          604:       nop
9D011168  1000FE8B   BEQ ZERO, ZERO, 0x9D010B98   605:       b next
9D01116C  0014A023   SUBU S4, ZERO, S4            606:       negu T
                                                  607:   
                                                  608:   ltz:  // '0<'  ( n -- t|f )
9D011170  1000FE89   BEQ ZERO, ZERO, 0x9D010B98   609:       b next
9D011174  0280A02A   SLT S4, S4, ZERO             610:       slt T,T,zero
                                                  611:   
                                                  612:   zequal: // '0=' ( n -- t|f ) vrai si n == 0 sinon faux
9D011178  1000FE87   BEQ ZERO, ZERO, 0x9D010B98   613:       b next
9D01117C  2E940001   SLTIU S4, S4, 1              614:       sltiu T,1
                                                  615:   
                                                  616:   bitand: // 'and' ( n1 n2 -- n1&n2)
9D011180  8E280000   LW T0, 0(S1)                 617:       lw t0, 0(dp)
9D011184  0288A024   AND S4, S4, T0               618:       and T,T,t0
9D011188  1000FE83   BEQ ZERO, ZERO, 0x9D010B98   619:       b next
9D01118C  2631FFFC   ADDIU S1, S1, -4             620:       addiu dp,dp,-CELL_SIZE
                                                  621:   
                                                  622:   bitor:  // 'or' ( n1 n2 -- n1|n2)
9D011190  8E280000   LW T0, 0(S1)                 623:       lw t0, 0(dp)
9D011194  0288A025   OR S4, S4, T0                624:       or T,T,t0
9D011198  1000FE7F   BEQ ZERO, ZERO, 0x9D010B98   625:       b next
9D01119C  2631FFFC   ADDIU S1, S1, -4             626:       addiu dp,dp,-CELL_SIZE
                                                  627:   
                                                  628:   bitxor: // 'xor' ( n1 n2 -- n1^n2)
9D0111A0  8E280000   LW T0, 0(S1)                 629:       lw t0, 0(dp)
9D0111A4  0288A026   XOR S4, S4, T0               630:       xor T,T,t0
9D0111A8  1000FE7B   BEQ ZERO, ZERO, 0x9D010B98   631:       b next
9D0111AC  2631FFFC   ADDIU S1, S1, -4             632:       addiu dp,dp,-CELL_SIZE
                                                  633:   
                                                  634:   bitnot: // 'not' ( n1 -- ~n1 )
9D0111B0  1000FE79   BEQ ZERO, ZERO, 0x9D010B98   635:       b next
9D0111B4  0280A027   NOR S4, S4, ZERO             636:       not T,T
                                                  637:   
                                                  638:   equal:  // '='  ( n1 n2 -- t|f ) n1==n2?
9D0111B8  8E280000   LW T0, 0(S1)                 639:       lw t0,0(dp)
9D0111BC  2631FFFC   ADDIU S1, S1, -4             640:       addiu dp,dp,-CELL_SIZE
9D0111C0  1288FE75   BEQ S4, T0, 0x9D010B98       641:       beq T,t0,next
9D0111C4  2414FFFF   ADDIU S4, ZERO, -1           642:       li T, -1
9D0111C8  1000FE73   BEQ ZERO, ZERO, 0x9D010B98   643:       b next
9D0111CC  24140000   ADDIU S4, ZERO, 0            644:       li T, 0
                                                  645:   
                                                  646:   nequal: // '<>' ( n1 n2 -- t|f ) n1<>n2?
9D0111D0  8E280000   LW T0, 0(S1)                 647:       lw t0,0(dp)
9D0111D4  2631FFFC   ADDIU S1, S1, -4             648:       addiu dp,dp,-CELL_SIZE
9D0111D8  1514FE6F   BNE T0, S4, 0x9D010B98       649:       bne t0,T, next
9D0111DC  2414FFFF   ADDIU S4, ZERO, -1           650:       li T, -1
9D0111E0  1000FE6D   BEQ ZERO, ZERO, 0x9D010B98   651:       b next
9D0111E4  24140000   ADDIU S4, ZERO, 0            652:       li T, 0
                                                  653:   
                                                  654:   less:  //  '<'  ( n1 n2 -- t|f ) n1<n2?
9D0111E8  8E280000   LW T0, 0(S1)                 655:       lw t0,0(dp)
9D0111EC  2631FFFC   ADDIU S1, S1, -4             656:       addiu dp,dp,-CELL_SIZE
9D0111F0  01144023   SUBU T0, T0, S4              657:       subu t0,t0,T
9D0111F4  0500FE68   BLTZ T0, 0x9D010B98          658:       bltz t0, next
9D0111F8  2414FFFF   ADDIU S4, ZERO, -1           659:       li T, -1
9D0111FC  1000FE66   BEQ ZERO, ZERO, 0x9D010B98   660:       b next
9D011200  24140000   ADDIU S4, ZERO, 0            661:       li T, 0
                                                  662:   
                                                  663:   greater:  // '>'  ( n1 n2 -- t|f ) n1>n2?
9D011204  8E280000   LW T0, 0(S1)                 664:       lw t0,0(dp)
9D011208  2631FFFC   ADDIU S1, S1, -4             665:       addiu dp,dp,-CELL_SIZE
9D01120C  01144023   SUBU T0, T0, S4              666:       subu t0,t0,T
9D011210  1D00FE61   BGTZ T0, 0x9D010B98          667:       bgtz t0, next
9D011214  2414FFFF   ADDIU S4, ZERO, -1           668:       li T, -1
9D011218  1000FE5F   BEQ ZERO, ZERO, 0x9D010B98   669:       b next
9D01121C  24140000   ADDIU S4, ZERO, 0            670:       li T, 0
                                                  671:   
                                                  672:   lteq:  // '<=' ( n1 n2 -- t|f ) n1<=n2?
9D011220  8E280000   LW T0, 0(S1)                 673:       lw t0,0(dp)
9D011224  2631FFFC   ADDIU S1, S1, -4             674:       addiu dp,dp,-CELL_SIZE
9D011228  01144023   SUBU T0, T0, S4              675:       subu t0,t0,T
9D01122C  1900FE5A   BLEZ T0, 0x9D010B98          676:       blez t0, next
9D011230  2414FFFF   ADDIU S4, ZERO, -1           677:       li T,-1
9D011234  1000FE58   BEQ ZERO, ZERO, 0x9D010B98   678:       b next
9D011238  24140000   ADDIU S4, ZERO, 0            679:       li T, 0
                                                  680:   
                                                  681:   gteq:  // '>=' ( n1 n2 -- t|f ) n1>=n2?
9D01123C  8E280000   LW T0, 0(S1)                 682:       lw t0,0(dp)
9D011240  2631FFFC   ADDIU S1, S1, -4             683:       addiu dp,dp,-CELL_SIZE
9D011244  01144023   SUBU T0, T0, S4              684:       subu t0,t0,T
9D011248  0501FE53   BGEZ T0, 0x9D010B98          685:       bgez t0, next
9D01124C  2414FFFF   ADDIU S4, ZERO, -1           686:       li T, -1
9D011250  1000FE51   BEQ ZERO, ZERO, 0x9D010B98   687:       b next
9D011254  24140000   ADDIU S4, ZERO, 0            688:       li T, 0
                                                  689:   
                                                  690:   key:  // ( -- char ) attend réception caractère de la console
9D011258  3C04A000   LUI A0, -24576               691:       la a0,con
9D011260  0F404F87   JAL 0x9D013E1C               692:       jal wait_key
9D011264  90840000   LBU A0, 0(A0)                693:       lbu a0,0(a0)
9D011268  26310004   ADDIU S1, S1, 4              694:       _tpush
9D011270  1000FE49   BEQ ZERO, ZERO, 0x9D010B98   695:       b next
9D011274  0040A021   ADDU S4, V0, ZERO            696:       move T, v0  // T=v0
                                                  697:   
                                                  698:   
                                                  699:   dotq: // '."' ( -- ) ip pointe vers le texte, le premier octet est le compte.
9D011278  92130000   LBU S3, 0(S0)                700:       lbu w, 0(ip)
9D01127C  26100001   ADDIU S0, S0, 1              701:       _inc_ip
                                                  702:   1:
9D011280  1260FE45   BEQ S3, ZERO, 0x9D010B98     703:       beqz w, next
9D011284  2673FFFF   ADDIU S3, S3, -1             704:       addiu w,w,-1
9D011288  3C04A000   LUI A0, -24576               705:       la a0,con
9D011290  90840000   LBU A0, 0(A0)                706:       lbu a0,0(a0)
9D011294  82050000   LB A1, 0(S0)                 707:       lb a1, 0(ip)
9D011298  0F404FC0   JAL 0x9D013F00               708:       jal put_char
9D01129C  26100001   ADDIU S0, S0, 1              709:       _inc_ip
9D0112A0  1000FFF7   BEQ ZERO, ZERO, 0x9D011280   710:       b 1b
9D0112A4  00000000   NOP                          711:       nop
                                                  712:   
                                                  713:   dot: // "." ( n -- ) imprime un entier en format libre
9D0112A8  3C04A000   LUI A0, -24576               714:       la a0,con
9D0112B0  90840000   LBU A0, 0(A0)                715:       lbu a0,0(a0)
9D0112B4  02802821   ADDU A1, S4, ZERO            716:       move a1,T
9D0112B8  0F404FFF   JAL 0x9D013FFC               717:       jal print_int
9D0112BC  00003021   ADDU A2, ZERO, ZERO          718:       move a2,zero
9D0112C0  8E340000   LW S4, 0(S1)                 719:       lw T,0(dp)
9D0112C4  1000FE34   BEQ ZERO, ZERO, 0x9D010B98   720:       b next
9D0112C8  2631FFFC   ADDIU S1, S1, -4             721:       addiu dp,dp,-CELL_SIZE
                                                  722:       
                                                  723:       
                                                  724:   delay: // 'delay' ( msec -- ) delais en millisecondes
9D0112CC  3C13A000   LUI S3, -24576               725:       la w,sys_ticks
9D0112D4  8E680000   LW T0, 0(S3)                 726:       lw t0, 0(w)
9D0112D8  02884021   ADDU T0, S4, T0              727:       addu t0, T,t0
9D0112DC  8E340000   LW S4, 0(S1)                 728:       lw T, 0(dp)
9D0112E0  8E690000   LW T1, 0(S3)                 729:   1:  lw t1, 0(w)
9D0112E4  1528FFFE   BNE T1, T0, 0x9D0112E0       730:       bne t1, t0, 1b
9D0112E8  00000000   NOP                          731:       nop
9D0112EC  1000FE2A   BEQ ZERO, ZERO, 0x9D010B98   732:       b next
9D0112F0  2631FFFC   ADDIU S1, S1, -4             733:       addiu dp, dp, -CELL_SIZE
                                                  734:   
                                                  735:   ticks:  // 'ticks'  ( -- n ) empile le compteur sys_tick
9D0112F4  26310004   ADDIU S1, S1, 4              736:       _tpush
9D0112FC  3C13A000   LUI S3, -24576               737:       la w,sys_ticks
9D011304  1000FE24   BEQ ZERO, ZERO, 0x9D010B98   738:       b next
9D011308  8E740000   LW S4, 0(S3)                 739:       lw T, 0(w)
                                                  740:   
                                                  741:   dodo: // 'do' ( n1 n2 -- R: -- L J ) initialise une boucle do...loop 
9D01130C  26520004   ADDIU S2, S2, 4              742:       _rpush
9D011314  02C0A821   ADDU S5, S6, ZERO            743:       move R, L  // R: -- L
9D011318  8E360000   LW S6, 0(S1)                 744:       lw L, 0(dp) // L=n1
9D01131C  2631FFFC   ADDIU S1, S1, -4             745:       addiu dp,dp,-CELL_SIZE
9D011320  26520004   ADDIU S2, S2, 4              746:       _rpush
9D011328  02E0A821   ADDU S5, S7, ZERO            747:       move R,I // R: -- L J
9D01132C  0280B821   ADDU S7, S4, ZERO            748:       move I,T
9D011330  8E340000   LW S4, 0(S1)                 749:       lw T, 0(dp)
9D011334  1000FE18   BEQ ZERO, ZERO, 0x9D010B98   750:       b next
9D011338  2631FFFC   ADDIU S1, S1, -4             751:       addiu dp,dp,-CELL_SIZE
                                                  752:   
                                                  753:   unloop: // ( R: L J -- ) restitue les valeurs originales de L et I
9D01133C  02A0B821   ADDU S7, S5, ZERO            754:       move I,R
9D011340  8E550000   LW S5, 0(S2)                 755:       _rpop
9D011348  02A0B021   ADDU S6, S5, ZERO            756:       move L,R
9D01134C  8E550000   LW S5, 0(S2)                 757:       lw R,0(rp)
9D011350  1000FE11   BEQ ZERO, ZERO, 0x9D010B98   758:       b next
9D011354  2652FFFC   ADDIU S2, S2, -4             759:       addiu rp,rp,-CELL_SIZE
                                                  760:       
                                                  761:   ifetch: // 'I' ( -- n ) empile le compteur de boucle I
9D011358  26310004   ADDIU S1, S1, 4              762:       _tpush
9D011360  1000FE0D   BEQ ZERO, ZERO, 0x9D010B98   763:       b next
9D011364  02E0A021   ADDU S4, S7, ZERO            764:       move T, I
                                                  765:   
                                                  766:   jfetch: // 'J' ( -- n ) empile la valeur J
9D011368  26310004   ADDIU S1, S1, 4              767:       _tpush
9D011370  02A0A021   ADDU S4, S5, ZERO            768:       move T,R
9D011374  8E550000   LW S5, 0(S2)                 769:       lw R,0(rp)
9D011378  1000FE07   BEQ ZERO, ZERO, 0x9D010B98   770:       b next
9D01137C  2652FFFC   ADDIU S2, S2, -4             771:       addiu rp,rp,-CELL_SIZE
                                                  772:       
                                                  773:       
                                                  774:   loop: //  'loop'  incrémente I et si I==L quittte la boucle
9D011380  26F70001   ADDIU S7, S7, 1              775:       addiu I,I,1  
9D011384  12F60003   BEQ S7, S6, 0x9D011394       776:       beq  I, L, 1f
9D011388  92080000   LBU T0, 0(S0)                777:       _back_jump
9D011394  1000FFE9   BEQ ZERO, ZERO, 0x9D01133C   778:   1:  b unloop
9D011398  26100001   ADDIU S0, S0, 1              779:       addiu ip,ip,1
                                                  780:   
                                                  781:   ploop: // '+loop' ( n -- ) soustrait n à X, si X>0 boucle sinon quitte la boucle
9D01139C  02E04021   ADDU T0, S7, ZERO            782:       move t0,I
9D0113A0  02F4B821   ADDU S7, S7, S4              783:       addu I,I,T
9D0113A4  8E340000   LW S4, 0(S1)                 784:       _tpop
9D0113AC  01164023   SUBU T0, T0, S6              785:      subu t0,t0,L
9D0113B0  05000006   BLTZ T0, 0x9D0113CC          786:      bltz t0, 3f
9D0113B4  26C8FFFF   ADDIU T0, S6, -1             787:      addiu t0,L,-1
9D0113B8  01174023   SUBU T0, T0, S7              788:      subu t0,t0,I
9D0113BC  0501FFF5   BGEZ T0, 0x9D011394          789:      bgez t0,1b
9D0113C0  92080000   LBU T0, 0(S0)                790:      _back_jump
9D0113CC  02F64023   SUBU T0, S7, S6              791:   3: subu t0,I,L
9D0113D0  0501FFF0   BGEZ T0, 0x9D011394          792:      bgez t0,1b
9D0113D4  92080000   LBU T0, 0(S0)                793:      _back_jump
                                                  794:      
                                                  795:      
                                                  796:   pick: // ( xu...,x1,x0,u -- xu...,x1,x0,xu ) empile une copie du Uième élément de la pile
9D0113E0  0014A080   SLL S4, S4, 2                797:       sll  T, T, 2
9D0113E4  02349823   SUBU S3, S1, S4              798:       subu w, dp,T
9D0113E8  1000FDEB   BEQ ZERO, ZERO, 0x9D010B98   799:       b next
9D0113EC  8E740000   LW S4, 0(S3)                 800:       lw T, 0(w)
                                                  801:   
                                                  802:   sine: // (angle -- sine)
9D0113F0  02802021   ADDU A0, S4, ZERO            803:       move a0, T
9D0113F4  0F407180   JAL 0x9D01C600               804:       jal sinf
9D0113F8  1000FDE7   BEQ ZERO, ZERO, 0x9D010B98   805:       b next
9D0113FC  0040A021   ADDU S4, V0, ZERO            806:       move T, v0
                                                  807:   
                                                  808:   acos: // (angle -- cos)
9D011400  02802021   ADDU A0, S4, ZERO            809:       move a0, T
9D011404  0F4071C7   JAL 0x9D01C71C               810:       jal cosf
9D011408  1000FDE3   BEQ ZERO, ZERO, 0x9D010B98   811:       b next
9D01140C  0040A021   ADDU S4, V0, ZERO            812:       move T, v0
                                                  813:   
                                                  814:   asin: // (sine -- angle)
9D011410  02802021   ADDU A0, S4, ZERO            815:       move a0, T
9D011414  0F40791A   JAL 0x9D01E468               816:       jal asinf
9D011418  1000FDDF   BEQ ZERO, ZERO, 0x9D010B98   817:       b next
9D01141C  0040A021   ADDU S4, V0, ZERO            818:       move T, v0
                                                  819:   
                                                  820:   random: //
9D011420  0F407872   JAL 0x9D01E1C8               821:       jal rand
9D011424  26310004   ADDIU S1, S1, 4              822:       _tpush
9D01142C  1000FDDA   BEQ ZERO, ZERO, 0x9D010B98   823:       b next
9D011430  0040A021   ADDU S4, V0, ZERO            824:       move T, v0
                                                  825:   
                                                  826:   trunc: // ( f -- i)
9D011434  02802021   ADDU A0, S4, ZERO            827:       move a0, T
9D011438  0F407C37   JAL 0x9D01F0DC               828:       jal rintf
9D01143C  1000FDD6   BEQ ZERO, ZERO, 0x9D010B98   829:       b next
9D011440  0040A021   ADDU S4, V0, ZERO            830:       move T, v0
                                                  831:   
                                                  832:   num: //
                                                  833:   
9D011444  1000FDD4   BEQ ZERO, ZERO, 0x9D010B98   834:       b next
9D011448  00000000   NOP                          835:       nop
                                                  836:   
                                                  837:   
                                                  838:   
                                                  839:   .end StackVM
                                                  840:   
                                                  841:   //.ent fetch_int
                                                  842:   //fetch_int:  // empile un entier little indian dans espace code VM, retourne dans v0
                                                  843:   //    lbu v0, 0(ip)
                                                  844:   //    lbu t0, 1(ip)
                                                  845:   //    ins v0,t0,8,8
                                                  846:   //    lbu t0, 2(ip)
                                                  847:   //    ins v0,t0,16,8
                                                  848:   //    lbu t0,3(ip)
                                                  849:   //    ins v0,t0,24,8
                                                  850:   //    j ra
                                                  851:   //    addiu ip,ip,CELL_SIZE
                                                  852:   //    
                                                  853:   //
                                                  854:   //.end fetch_int
                                                  855:   
                                                  856:   
                                                  857:   
                                                  858:   // routines names must be in same order as OP_CODES enum in vm.h    
                                                  859:   opcodes_table:
                                                  860:   .word bye,lit,wlit,clit,docol,exit,bra,qbra,exec,store,fetch,cstore
                                                  861:   .word cfetch,rfetch,tor,rfrom,drop,dup,swap,over,pick
                                                  862:   .word plus,minus,star,ustar,mstar,umstar,slash,uslash,modulo,umsmod,msmod,ltz
                                                  863:   .word zequal, bitand,bitor
                                                  864:   .word bitxor,bitnot,ticks, delay
                                                  865:   .word qdup, oneplus, oneminus,plusstore, twostar, twoslash, twodrop, rot, twodup
                                                  866:   .word  min, max, abs, lshift, rshift, divmod, qbraz, dcnt, rcnt
                                                  867:   .word equal,nequal, less, greater,lteq,gteq, dodo,unloop,ifetch,jfetch,loop, ploop
                                                  868:   .word sine, cos, tan, atan, acos, asin,random,trunc,num
                                                  869:   .word key,qrx,emit,dotq,cr,dot,lits
                                                  870:   
                                                  871:   bad_op:
                                                  872:       
                                                  873:   #undef _ASM_CODE_
---  /home/jacques/github/vpc-32vga/vpcBASIC/testVM.c  --------------------------------------------------
1:                   /*  StackVM test
2:                    */
3:                   
4:                   #if defined _VM_TEST_
5:                   
6:                   #include <string.h>
7:                   #include <plib.h>
8:                   
9:                   #include "vm.h"
10:                  #include "../console.h"
11:                  
12:                  
13:                  
14:                  
15:                  
16:                  
17:                  //const char* vm_words[]={
18:                  //    "BYE","LITERAL","DOCOL","RET","BRA","?BRA","EXEC","!","@","C!","C@",
19:                  //};
20:                  
21:                  const unsigned char test_code[]={INOP,
22:                      ICLIT,-1,ICLIT,2,IDO,IIFETCH,IDOT,ICLIT,-1,IPLOOP,5,ICR,
23:                      ICLIT,8,ICLIT,0,IDO,IIFETCH,IDOT,ICLIT,1,IPLOOP,5,ICR,
24:                      ITYPE,5,'H','E','L','L','O',ICR,
25:                      IWLIT,24,0,IDUP,IDOT,ICLIT,4,IDUP,IDOT,ISTAR,IDUP,IDOT,ILIT,6,0,0,0,ISLASH,
26:                      IDUP,IDOT,IBYE};
27:                  
28:                  //void compile(char *line,int size,int dp){
29:                  //    
30:                  //}
31:                  
32:                  int test_vm(){
9D01F23C  27BDFFE8   ADDIU SP, SP, -24
9D01F240  AFBF0014   SW RA, 20(SP)
33:                      int dp=0,size;
34:                  //    unsigned char* code;
35:                  //    char line[80];
36:                  //    code=malloc(8192);
37:                      return StackVM(test_code);
9D01F244  3C049D02   LUI A0, -25342
9D01F248  0F4042D7   JAL StackVM
9D01F24C  2484ECF8   ADDIU A0, A0, -4872
38:                  //    while (1){
39:                  //        if (!(size=readline(LOCAL_CON,line,80))) break;
40:                  //        upper(line);
41:                  //        if (!strcmp(line,"RUN")){
42:                  //            print_hex(LOCAL_CON,StackVM(code,variables),0);
43:                  //            print(LOCAL_CON," ok\r");
44:                  //            dp=0;
45:                  //            memset(code,0,8192);
46:                  //        }else{
47:                  //            compile(line,size,dp);
48:                  //        }
49:                  //    }
50:                  }
9D01F250  8FBF0014   LW RA, 20(SP)
9D01F254  03E00008   JR RA
9D01F258  27BD0018   ADDIU SP, SP, 24
51:                  
52:                  #endif
---  /home/jacques/github/vpc-32vga/vpcBASIC/BASIC.c  ---------------------------------------------------
1:                   /*
2:                    * Interpréteur BASIC compilant du bytecode pour la machine à piles définie dans vm.S 
3:                    */
4:                   
5:                   #include <stdio.h>
6:                   #include <string.h>
7:                   #include <stdlib.h>
8:                   #include <stdbool.h>
9:                   #include <stdint.h>
10:                  #include <setjmp.h>
11:                  #include <string.h>
12:                  #include <ctype.h>
13:                  
14:                  #include "../hardware/Pinguino/fileio.h"
15:                  #include "../hardware/HardwareProfile.h"
16:                  #include "../hardware/tvout/vga.h"
17:                  #include "../hardware/serial_comm/serial_comm.h"
18:                  #include "../hardware/ps2_kbd/keyboard.h"
19:                  #include "../hardware/Pinguino/diskio.h"
20:                  #include "../hardware/Pinguino/fileio.h"
21:                  #include "../console.h"
22:                  #include "../hardware/Pinguino/ff.h"
23:                  #include "../hardware/sound/sound.h"
24:                  #include "../hardware/syscall.h"
25:                  #include "../hardware/rtcc/rtcc.h"
26:                  #include "../reader.h"
27:                  #include "vm.h"
28:                  
29:                  /* macros utilisées par le compilateur BASIC*/
30:                  
31:                  #define _byte0(n) ((uint32_t)(n)&0xff)
32:                  #define _byte1(n)((uint32_t)(n>>8)&0xff)
33:                  #define _byte2(n)(((uint32_t)(n)>>16)&0xff)
34:                  #define _byte3(n)(((uint32_t)(n)>>24)&0xff)
35:                  #define _splitn(n)  _byte0(n),_byte1(n),_byte2(n),_byte3(n)
36:                  
37:                  
38:                  #define _lit(n) bytecode(ILIT);\
39:                                 _splitn(n)
40:                  
41:                  #define _litw(w) bytecode(IWLIT);\
42:                                  _byte0(w);_byte1(w)
43:                  
44:                  #define _litc(c)  bytecode(ICLIT);\
45:                                   _byte0(c)
46:                  
47:                  
48:                  #define _prt_varname(v) _lit((uint32_t)v->name);\
49:                                        bytecode(ITYPE)
50:                  
51:                  
52:                  static bool exit_basic;
53:                  
54:                  static uint8_t *progspace; // espace programme.
55:                  extern unsigned dptr; //data pointer
56:                  extern void* endmark;
57:                  extern volatile uint32_t pause_timer;
58:                  extern int dstack[DSTACK_SIZE];
59:                  extern int rstack[RSTACK_SIZE];
60:                  extern int8_t dsp;
61:                  extern int8_t rsp;
62:                  
63:                  static jmp_buf failed; // utilisé par setjmp() et lngjmp()
64:                  
65:                  static reader_t std_reader; // source clavier
66:                  static reader_t file_reader; // source fichier
67:                  static reader_t *activ_reader=NULL; // source active
68:                  //static void *endmark;
69:                  static uint32_t prog_size;
70:                  static uint32_t line_count;
71:                  static bool program_loaded;
72:                  static bool run_it=false;
73:                  static uint32_t program_end;
74:                  
75:                  #define NAME_MAX 32 //longueur maximale nom incluant zéro terminal
76:                  #define LEN_MASK 0x1F   // masque longueur nom.
77:                  #define HIDDEN 0x20 // mot caché
78:                  #define FUNCTION 0x40 // ce mot est une fonction
79:                  #define AS_HELP 0x80 //commande avec aide
80:                  #define ADR  (void *)
81:                  
82:                  typedef void (*fnptr)();
83:                  
84:                  //entrée de commande dans liste
85:                  typedef struct{
86:                      fnptr cfn; // pointeur fonction commande
87:                      uint8_t len; // longueur nom commande, flags IMMED, HIDDEN
88:                      char *name; // nom de la commande
89:                  } dict_entry_t;
90:                  
91:                  
92:                  
93:                  typedef enum {eVAR_INT,eVAR_STR,eVAR_INTARRAY,eVAR_BYTEARRAY,eVAR_STRARRAY,
94:                                eVAR_SUB,eVAR_FUNC,eVAR_LOCAL,eVAR_CONST,eVAR_BYTE}var_type_e;
95:                  
96:                  typedef struct _var{
97:                      struct _var* next;
98:                      uint8_t len;
99:                      uint8_t vtype;
100:                     char *name;
101:                     union{
102:                         uint8_t byte;
103:                         int32_t n;
104:                         int32_t *nbr;
105:                         char *str;
106:                         void *adr;
107:                     };
108:                 }var_t;
109:                 
110:                 // type d'unité lexicales
111:                 typedef enum {eNONE,eSTOP,eCOLON,eIDENT,eNUMBER,eSTRING,ePLUS,eMINUS,eMUL,eDIV,
112:                               eMOD,eCOMMA,eLPAREN,eRPAREN,eSEMICOL,eEQUAL,eNOTEQUAL,eGT,eGE,eLT,eLE,
113:                               eEND, eELSE,eCMD,eKWORD,eCHAR} tok_id_t;
114:                 
115:                 // longueur maximale d'une ligne de texte source.
116:                 #define MAX_LINE_LEN 128
117:                 
118:                 // unité lexicale.              
119:                 typedef struct _token{
120:                     tok_id_t id;
121:                     union{
122:                         char str[MAX_LINE_LEN];
123:                         int n;
124:                     };
125:                 }token_t;
126:                 
127:                 
128:                 
129:                 static token_t token;
130:                 static bool unget_token=false;
131:                 
132:                 static void kw_abs();
133:                 static void bad_syntax();
134:                 static void kw_beep();
135:                 static void kw_box();
136:                 static void kw_btest();
137:                 static void kw_bye();
138:                 static void kw_case();
139:                 static void kw_circle();
140:                 static void kw_cls();
141:                 static void kw_color();
142:                 static void kw_const();
143:                 static void kw_curcol();
144:                 static void kw_curline();
145:                 static void kw_dim();
146:                 static void kw_do();
147:                 static void kw_ellipse();
148:                 static void kw_else();
149:                 static void kw_end();
150:                 static void kw_exit();
151:                 static void kw_for();
152:                 static void kw_func();
153:                 static void kw_getpixel();
154:                 static void kw_if();
155:                 static void kw_input();
156:                 static void kw_key();
157:                 static void kw_len();
158:                 static void kw_let();
159:                 static void kw_line();
160:                 static void kw_local();
161:                 static void kw_locate();
162:                 static void kw_loop();
163:                 static void kw_max();
164:                 static void kw_mdiv();
165:                 static void kw_min();
166:                 static void kw_next();
167:                 static void kw_noise();
168:                 static void kw_pause();
169:                 static void kw_print();
170:                 static void kw_putc();
171:                 static void kw_randomize();
172:                 static void kw_read_jstick();
173:                 static void kw_rect();
174:                 static void kw_ref();
175:                 static void kw_rem();
176:                 static void kw_remove_sprite();
177:                 static void kw_restore_screen();
178:                 static void kw_return();
179:                 static void kw_rnd();
180:                 static void kw_save_screen();
181:                 static void kw_scrlup();
182:                 static void kw_scrldown();
183:                 static void kw_scrlright();
184:                 static void kw_scrlleft();
185:                 static void kw_select();
186:                 static void kw_setpixel();
187:                 static void kw_set_timer();
188:                 static void kw_shl();
189:                 static void kw_shr();
190:                 static void kw_sprite();
191:                 static void kw_srclear();
192:                 static void kw_srload();
193:                 static void kw_srread();
194:                 static void kw_srsave();
195:                 static void kw_srwrite();
196:                 static void kw_sub();
197:                 static void kw_then();
198:                 static void kw_ticks();
199:                 static void kw_timeout();
200:                 static void kw_tone();
201:                 static void kw_trace();
202:                 static void kw_ubound();
203:                 static void kw_use();
204:                 static void kw_video();
205:                 static void kw_waitkey();
206:                 static void kw_wend();
207:                 static void kw_while();
208:                 static void kw_xorpixel();
209:                 
210:                 //identifiant KEYWORD doit-être dans le même ordre que
211:                 //dans la liste KEYWORD
212:                 enum {eKW_ABS,eKW_AND,eKW_BEEP,eKW_BOX,eKW_BTEST,eKW_BYE,eKW_CASE,eKW_CIRCLE,eKW_CLS,eKW_COLOR,
213:                       eKW_CONST,eKW_CURCOL,eKW_CURLINE,eKW_DIM,eKW_DO,eKW_ELLIPSE,eKW_ELSE,eKW_END,eKW_EXIT,
214:                       eKW_FOR,eKW_FUNC,eKW_GETPIXEL,eKW_IF,eKW_INPUT,eKW_KEY,eKW_LEN,
215:                       eKW_LET,eKW_LINE,eKW_LOCAL,eKW_LOCATE,eKW_LOOP,eKW_MAX,eKW_MDIV,eKW_MIN,eKW_NEXT,
216:                       eKW_NOISE,eKW_NOT,eKW_OR,eKW_PAUSE,
217:                       eKW_PRINT,eKW_PUTC,eKW_RANDOMISIZE,eKW_JSTICK,eKW_RECT,eKW_REF,eKW_REM,eKW_REMSPR,eKW_RESTSCR,
218:                       eKW_RETURN,eKW_RND,eKW_SAVESCR,eKW_SCRLUP,eKW_SCRLDN,
219:                       eKW_SCRLRT,eKW_SCRLFT,eKW_SELECT,eKW_SETPIXEL,eKW_SETTMR,eKW_SHL,eKW_SHR,
220:                       eKW_SPRITE,eKW_SRCLEAR,eKW_SRLOAD,eKW_SRREAD,eKW_SRSSAVE,eKW_SRWRITE,eKW_SUB,eKW_THEN,eKW_TICKS,
221:                       eKW_TIMEOUT,eKW_TONE,eKW_TRACE,eKW_UBOUND,eKW_UNTIL,eKW_USE,eKW_VIDEO,
222:                       eKW_WAITKEY,eKW_WEND,eKW_WHILE,eKW_XORPIXEL
223:                 };
224:                 
225:                 //mots réservés BASIC
226:                 static const dict_entry_t KEYWORD[]={
227:                     {kw_abs,3+FUNCTION,"ABS"},
228:                     {bad_syntax,3,"AND"},
229:                     {kw_beep,4,"BEEP"},
230:                     {kw_box,3,"BOX"},
231:                     {kw_btest,5+FUNCTION,"BTEST"},
232:                     {kw_bye,3,"BYE"},
233:                     {kw_case,4,"CASE"},
234:                     {kw_circle,6,"CIRCLE"},
235:                     {kw_cls,3+AS_HELP,"CLS"},
236:                     {kw_color,5+AS_HELP,"COLOR"},
237:                     {kw_const,5,"CONST"},
238:                     {kw_curcol,6+FUNCTION,"CURCOL"},
239:                     {kw_curline,7+FUNCTION,"CURLINE"},
240:                     {kw_dim,3,"DIM"},
241:                     {kw_do,2,"DO"},
242:                     {kw_ellipse,7,"ELLIPSE"},
243:                     {kw_else,4,"ELSE"},
244:                     {kw_end,3,"END"},
245:                     {kw_exit,4,"EXIT"},
246:                     {kw_for,3,"FOR"},
247:                     {kw_func,4,"FUNC"},
248:                     {kw_getpixel,8+FUNCTION,"GETPIXEL"},
249:                     {kw_if,2,"IF"},
250:                     {kw_input,5,"INPUT"},
251:                     {kw_key,3+FUNCTION,"KEY"},
252:                     {kw_len,3+FUNCTION,"LEN"},
253:                     {kw_let,3,"LET"},
254:                     {kw_line,4,"LINE"},
255:                     {kw_local,5,"LOCAL"},
256:                     {kw_locate,6,"LOCATE"},
257:                     {kw_loop,4,"LOOP"},
258:                     {kw_max,3+FUNCTION,"MAX"},
259:                     {kw_mdiv,4+FUNCTION,"MDIV"},
260:                     {kw_min,3+FUNCTION,"MIN"},
261:                     {kw_next,4,"NEXT"},
262:                     {kw_noise,5,"NOISE"},
263:                     {bad_syntax,3,"NOT"},
264:                     {bad_syntax,2,"OR"},
265:                     {kw_pause,5,"PAUSE"},
266:                     {kw_print,5,"PRINT"},
267:                     {kw_putc,4,"PUTC"},
268:                     {kw_randomize,9,"RANDOMIZE"},
269:                     {kw_read_jstick,6+FUNCTION,"JSTICK"},
270:                     {kw_rect,4,"RECT"},
271:                     {kw_ref,1+FUNCTION,"@"},
272:                     {kw_rem,3,"REM"},
273:                     {kw_remove_sprite,6,"REMSPR"},
274:                     {kw_restore_screen,7,"RESTSCR"},
275:                     {kw_return,6,"RETURN"},
276:                     {kw_rnd,3+FUNCTION,"RND"},
277:                     {kw_save_screen,7,"SAVESCR"},
278:                     {kw_scrlup,6,"SCRLUP"},
279:                     {kw_scrldown,6,"SCRLDN"},
280:                     {kw_scrlright,6,"SCRLRT"},
281:                     {kw_scrlleft,6,"SCRLLT"},
282:                     {kw_select,6,"SELECT"},
283:                     {kw_setpixel,8,"SETPIXEL"},
284:                     {kw_set_timer,6,"SETTMR"},
285:                     {kw_shl,3+FUNCTION,"SHL"},
286:                     {kw_shr,3+FUNCTION,"SHR"},
287:                     {kw_sprite,6,"SPRITE"},
288:                     {kw_srclear,7,"SRCLEAR"},
289:                     {kw_srload,6+FUNCTION,"SRLOAD"},
290:                     {kw_srread,6,"SRREAD"},
291:                     {kw_srsave,6,"SRSAVE"},
292:                     {kw_srwrite,7,"SRWRITE"},
293:                     {kw_sub,3,"SUB"},
294:                     {kw_then,4,"THEN"},
295:                     {kw_ticks,5+FUNCTION,"TICKS"},
296:                     {kw_timeout,7+FUNCTION,"TIMEOUT"},
297:                     {kw_tone,4,"TONE"},
298:                     {kw_trace,5,"TRACE"},
299:                     {kw_ubound,6+FUNCTION,"UBOUND"},
300:                     {bad_syntax,5,"UNTIL"},
301:                     {kw_use,3,"USE"},
302:                     {kw_video,5,"VIDEO"},
303:                     {kw_waitkey,7+FUNCTION,"WAITKEY"},
304:                     {kw_wend,4,"WEND"},
305:                     {kw_while,5,"WHILE"},
306:                     {kw_xorpixel,8,"XORPIXEL"},
307:                     {NULL,0,""}
308:                 };
309:                 
310:                 
311:                 //recherche la commande dans
312:                 //le dictionnaire système
313:                 // ( uaddr -- n)
314:                 static int dict_search(const  dict_entry_t *dict){
315:                     int i=0, len;
316:                     
317:                     len=strlen(token.str);
9D000810  3C04A000   LUI A0, -24576
9D000814  0F406EC2   JAL strlen
9D000818  2484391C   ADDIU A0, A0, 14620
9D00081C  0B4003AD   J 0x9D000EB4
9D000820  00409821   ADDU S3, V0, ZERO
9D000EA4  3C04A000   LUI A0, -24576
9D000EA8  0F406EC2   JAL strlen
9D000EAC  2484391C   ADDIU A0, A0, 14620
9D000EB0  00409821   ADDU S3, V0, ZERO
9D000EB4  3C109D01   LUI S0, -25343
9D000EB8  26102C78   ADDIU S0, S0, 11384
318:                     while (dict[i].len){
9D000848  9211FFF8   LBU S1, -8(S0)
9D00084C  1620FFF5   BNE S1, ZERO, 0x9D000824
9D000850  26520001   ADDIU S2, S2, 1
319:                         if (((dict[i].len&LEN_MASK)==len) && 
9D000824  3223001F   ANDI V1, S1, 31
9D000828  54730006   BNEL V1, S3, 0x9D000844
9D00082C  02002821   ADDU A1, S0, ZERO
9D00083C  10400007   BEQ V0, ZERO, 0x9D00085C
9D000840  02002821   ADDU A1, S0, ZERO
9D000844  2610000C   ADDIU S0, S0, 12
320:                                 !strcmp((const unsigned char*)token.str,dict[i].name)){
9D000830  02802021   ADDU A0, S4, ZERO
9D000834  0F407138   JAL 0x9D01C4E0
9D000838  8CA50008   LW A1, 8(A1)
9D000ECC  3C14A000   LUI S4, -24576
9D000ED0  0B400209   J 0x9D000824
9D000ED4  2694391C   ADDIU S4, S4, 14620
321:                             break;
322:                         }
323:                         i++;
324:                     }
325:                     return dict[i].len?i:-1;
9D00085C  12200008   BEQ S1, ZERO, 0x9D000880
9D000860  24030003   ADDIU V1, ZERO, 3
326:                 }//cmd_search()
327:                 
328:                 
329:                 //code d'erreurs
330:                 //NOTE: eERR_DSTACK et eERR_RSTACK sont redéfinie dans stackvm.h
331:                 //      si leur valeur change elles doivent aussi l'être dans stackvm.h
332:                 enum {eERROR_NONE,eERR_BADOP,eERR_DSTACK,eERR_RSTACK,eERR_MISSING_ARG,eERR_EXTRA_ARG,
333:                       eERR_BAD_ARG,eERR_SYNTAX,eERR_ALLOC,eERR_REDEF,eERR_ASSIGN,
334:                       eERR_NOTDIM,eERR_CMDONLY,eERR_BOUND,eERR_PROGSPACE
335:                       };
336:                 
337:                  static  const char* error_msg[]={
338:                     "no error\n",
339:                     "bad virtual machine operating code\n"
340:                     "data stack out of bound\n",
341:                     "control stack out of bound\n",
342:                     "missing argument\n",
343:                     "too much arguments\n",
344:                     "bad argument\n",
345:                     "syntax error\n",
346:                     "memory allocation error\n",
347:                     "can't be redefined\n",
348:                     "can't be reassigned\n",
349:                     "undefined array variable\n",
350:                     "command line only directive\n",
351:                     "array index out of range\n",
352:                     "program space full\n",
353:                  };
354:                  
355:                  
356:                 static void throw(int error){
9D000200  27BDFFA0   ADDIU SP, SP, -96
9D000204  AFBF005C   SW RA, 92(SP)
9D000208  AFB10058   SW S1, 88(SP)
9D00020C  AFB00054   SW S0, 84(SP)
9D000210  00808021   ADDU S0, A0, ZERO
357:                     char message[64];
358:                     
359:                 //    fat_close_all_files();
360:                     crlf(con);
9D000214  0F404FF3   JAL crlf
9D000218  97848062   LHU A0, -32670(GP)
361:                     if (activ_reader->device==eDEV_SDCARD){
9D00021C  8F828098   LW V0, -32616(GP)
9D000220  8C430000   LW V1, 0(V0)
9D000224  24020002   ADDIU V0, ZERO, 2
9D000228  1462000C   BNE V1, V0, 0x9D00025C
9D00022C  00101880   SLL V1, S0, 2
362:                         print(con,"line: ");
9D000230  97848062   LHU A0, -32670(GP)
9D000234  3C059D01   LUI A1, -25343
9D000238  0F404FCC   JAL print
9D00023C  24A527F4   ADDIU A1, A1, 10228
363:                         print_int(con,line_count,0);
9D000240  97848062   LHU A0, -32670(GP)
9D000244  8F858090   LW A1, -32624(GP)
9D000248  0F404FFF   JAL print_int
9D00024C  00003021   ADDU A2, ZERO, ZERO
364:                         crlf(con);
9D000250  0F404FF3   JAL crlf
9D000254  97848062   LHU A0, -32670(GP)
365:                     }
366:                     strcpy(message,error_msg[error]);
9D000258  00101880   SLL V1, S0, 2
9D00025C  3C029D01   LUI V0, -25343
9D000260  24422A00   ADDIU V0, V0, 10752
9D000264  00621021   ADDU V0, V1, V0
9D000268  27A40010   ADDIU A0, SP, 16
9D00026C  0F406D40   JAL strcpy
9D000270  8C450000   LW A1, 0(V0)
367:                     print(con,message);
9D000274  97848062   LHU A0, -32670(GP)
9D000278  0F404FCC   JAL print
9D00027C  27A50010   ADDIU A1, SP, 16
368:                     print(con,"\ntok_id: ");
9D000280  97848062   LHU A0, -32670(GP)
9D000284  3C059D01   LUI A1, -25343
9D000288  0F404FCC   JAL print
9D00028C  24A527FC   ADDIU A1, A1, 10236
369:                     print_int(con,token.id,0);
9D000290  3C11A000   LUI S1, -24576
9D000294  97848062   LHU A0, -32670(GP)
9D000298  8E253918   LW A1, 14616(S1)
9D00029C  0F404FFF   JAL print_int
9D0002A0  00003021   ADDU A2, ZERO, ZERO
370:                     print(con,"\ntok_value: ");
9D0002A4  97848062   LHU A0, -32670(GP)
9D0002A8  3C059D01   LUI A1, -25343
9D0002AC  0F404FCC   JAL print
9D0002B0  24A52808   ADDIU A1, A1, 10248
371:                     switch(token.id){
9D0002B4  8E223918   LW V0, 14616(S1)
9D0002B8  2C420019   SLTIU V0, V0, 25
9D0002BC  10400043   BEQ V0, ZERO, 0x9D0003CC
9D0002C0  8E233918   LW V1, 14616(S1)
9D0002C4  00031880   SLL V1, V1, 2
9D0002C8  3C029D00   LUI V0, -25344
9D0002CC  244202E0   ADDIU V0, V0, 736
9D0002D0  00431021   ADDU V0, V0, V1
9D0002D4  8C420000   LW V0, 0(V0)
9D0002D8  00400008   JR V0
9D0002DC  00000000   NOP
372:                         case eKWORD:
373:                             strcpy(message,(const char*)KEYWORD[token.n].name);
9D000344  3C02A000   LUI V0, -24576
9D000348  8C44391C   LW A0, 14620(V0)
9D00034C  3C029D01   LUI V0, -25343
9D000350  24422C6C   ADDIU V0, V0, 11372
9D000354  2403000C   ADDIU V1, ZERO, 12
9D000358  70832802   MUL A1, A0, V1
9D00035C  00A21021   ADDU V0, A1, V0
9D000360  27A40010   ADDIU A0, SP, 16
9D000364  0F406D40   JAL strcpy
9D000368  8C450008   LW A1, 8(V0)
374:                             print(con,message);
9D00036C  97848062   LHU A0, -32670(GP)
9D000370  0F404FCC   JAL print
9D000374  27A50010   ADDIU A1, SP, 16
375:                             break;
9D000378  0B4000FB   J 0x9D0003EC
9D00037C  00000000   NOP
376:                         case eNUMBER:
377:                             print_int(con,token.n,0);
9D000380  97848062   LHU A0, -32670(GP)
9D000384  3C02A000   LUI V0, -24576
9D000388  8C45391C   LW A1, 14620(V0)
9D00038C  0F404FFF   JAL print_int
9D000390  00003021   ADDU A2, ZERO, ZERO
378:                             break;
9D000394  0B4000FB   J 0x9D0003EC
9D000398  00000000   NOP
379:                         case eSTOP:
380:                             print(con,"unspected end of command.");
9D00039C  97848062   LHU A0, -32670(GP)
9D0003A0  3C059D01   LUI A1, -25343
9D0003A4  0F404FCC   JAL print
9D0003A8  24A52818   ADDIU A1, A1, 10264
381:                             break;
9D0003AC  0B4000FB   J 0x9D0003EC
9D0003B0  00000000   NOP
382:                         case eSTRING:
383:                         case eIDENT:
384:                             print(con,token.str);
9D0003B4  97848062   LHU A0, -32670(GP)
9D0003B8  3C05A000   LUI A1, -24576
9D0003BC  0F404FCC   JAL print
9D0003C0  24A5391C   ADDIU A1, A1, 14620
385:                             break;
9D0003C4  0B4000FB   J 0x9D0003EC
9D0003C8  00000000   NOP
386:                         default:
387:                             if (token.str[0]>=32 && token.str[0]<=127)
9D0003CC  3C02A000   LUI V0, -24576
9D0003D0  8042391C   LB V0, 14620(V0)
9D0003D4  28420020   SLTI V0, V0, 32
9D0003D8  14400004   BNE V0, ZERO, 0x9D0003EC
9D0003DC  97848062   LHU A0, -32670(GP)
388:                                 print(con,token.str);
9D0003E0  3C05A000   LUI A1, -24576
9D0003E4  0F404FCC   JAL print
9D0003E8  24A5391C   ADDIU A1, A1, 14620
389:                     }//switch
390:                     crlf(con);
9D0003EC  0F404FF3   JAL crlf
9D0003F0  97848062   LHU A0, -32670(GP)
391:                     activ_reader->eof=true;
9D0003F4  24030001   ADDIU V1, ZERO, 1
9D0003F8  8F828098   LW V0, -32616(GP)
9D0003FC  AC43010C   SW V1, 268(V0)
392:                     longjmp(failed,error);
9D000400  3C04A000   LUI A0, -24576
9D000404  24843BC4   ADDIU A0, A0, 15300
9D000408  0F407964   JAL longjmp
9D00040C  02002821   ADDU A1, S0, ZERO
393:                 }
394:                 
395:                 
396:                 static var_t *varlist=NULL;
397:                 static var_t *globals=NULL;
398:                 static bool var_local=false;
399:                 
400:                 
401:                 // déclenche une exeption en cas d'échec.
402:                 static void *alloc_var_space(int size){
9D000410  27BDFFE8   ADDIU SP, SP, -24
9D000414  AFBF0014   SW RA, 20(SP)
403:                     void *newmark;
404:                     
405:                     if (size&1) size++;//alignement
9D000418  30820001   ANDI V0, A0, 1
9D00041C  00442021   ADDU A0, V0, A0
406:                     newmark=endmark-size;
9D000420  8F83C118   LW V1, -16104(GP)
9D000424  00641023   SUBU V0, V1, A0
407:                     if (newmark<=(void*)&progspace[dptr]){
9D000428  8F83C11C   LW V1, -16100(GP)
9D00042C  8F84809C   LW A0, -32612(GP)
9D000430  00831821   ADDU V1, A0, V1
9D000434  0062182B   SLTU V1, V1, V0
9D000438  54600003   BNEL V1, ZERO, 0x9D000448
9D00043C  AF82C118   SW V0, -16104(GP)
408:                         throw(eERR_ALLOC);
9D000440  0F400080   JAL throw
9D000444  24040008   ADDIU A0, ZERO, 8
409:                     }
410:                     endmark=newmark;
411:                     return endmark;
412:                 }//f
9D000448  8FBF0014   LW RA, 20(SP)
9D00044C  03E00008   JR RA
9D000450  27BD0018   ADDIU SP, SP, 24
413:                 
414:                 // les variables sont allouées à la fin
415:                 // de progspace en allant vers le bas.
416:                 // lorsque endmark<=&progrspace[dptr] la mémoire est pleine
417:                 static var_t *var_create(char *name, char *value){
9D000454  27BDFFD8   ADDIU SP, SP, -40
9D000458  AFBF0024   SW RA, 36(SP)
9D00045C  AFB40020   SW S4, 32(SP)
9D000460  AFB3001C   SW S3, 28(SP)
9D000464  AFB20018   SW S2, 24(SP)
9D000468  AFB10014   SW S1, 20(SP)
9D00046C  AFB00010   SW S0, 16(SP)
9D000470  00808821   ADDU S1, A0, ZERO
418:                     int len;
419:                     void *newend;
420:                     var_t *newvar=NULL;
421:                     void *varname=NULL;
422:                     
423:                     len=min(31,strlen(name));
9D000474  0F406EC2   JAL strlen
9D000478  00A0A021   ADDU S4, A1, ZERO
9D00047C  2C530020   SLTIU S3, V0, 32
9D000480  2403001F   ADDIU V1, ZERO, 31
9D000484  0053180B   MOVN V1, V0, S3
9D000488  00609821   ADDU S3, V1, ZERO
424:                     
425:                     newend=endmark;
426:                     newvar=alloc_var_space(sizeof(var_t));
9D00048C  0F400104   JAL alloc_var_space
9D000490  24040010   ADDIU A0, ZERO, 16
9D000494  00408021   ADDU S0, V0, ZERO
427:                     newend=newvar;
428:                     varname=alloc_var_space(len+1);
9D000498  0F400104   JAL alloc_var_space
9D00049C  26640001   ADDIU A0, S3, 1
9D0004A0  00409021   ADDU S2, V0, ZERO
429:                     newend=varname;
9D000500  02408821   ADDU S1, S2, ZERO
9D000548  02408821   ADDU S1, S2, ZERO
430:                     strcpy(varname,name);
9D0004A4  00402021   ADDU A0, V0, ZERO
9D0004A8  0F406D40   JAL strcpy
9D0004AC  02202821   ADDU A1, S1, ZERO
431:                     if (name[strlen(name)-1]=='$'){ // variable chaine
9D0004B0  0F406EC2   JAL strlen
9D0004B4  02202021   ADDU A0, S1, ZERO
9D0004B8  02221021   ADDU V0, S1, V0
9D0004BC  8042FFFF   LB V0, -1(V0)
9D0004C0  24030024   ADDIU V1, ZERO, 36
9D0004C4  14430012   BNE V0, V1, 0x9D000510
9D0004C8  24030023   ADDIU V1, ZERO, 35
432:                         if (value){
9D0004CC  5280000C   BEQL S4, ZERO, 0x9D000500
9D0004D0  AE00000C   SW ZERO, 12(S0)
433:                             newvar->str=alloc_var_space(strlen(value)+1);
9D0004D4  0F406EC2   JAL strlen
9D0004D8  02802021   ADDU A0, S4, ZERO
9D0004DC  0F400104   JAL alloc_var_space
9D0004E0  24440001   ADDIU A0, V0, 1
9D0004E4  00408821   ADDU S1, V0, ZERO
9D0004E8  AE02000C   SW V0, 12(S0)
434:                             newend=newvar->adr;
435:                             strcpy(newvar->str,value);
9D0004EC  00402021   ADDU A0, V0, ZERO
9D0004F0  0F406D40   JAL strcpy
9D0004F4  02802821   ADDU A1, S4, ZERO
9D0004F8  0B400142   J 0x9D000508
9D0004FC  24020001   ADDIU V0, ZERO, 1
436:                         }
437:                         else{
438:                             newvar->str=NULL;
439:                         }
440:                         newvar->vtype=eVAR_STR;
9D000504  24020001   ADDIU V0, ZERO, 1
9D000508  0B400153   J 0x9D00054C
9D00050C  A2020005   SB V0, 5(S0)
441:                     }else if (name[strlen(name)-1]=='#'){ // variable octet
9D000510  14430007   BNE V0, V1, 0x9D000530
9D000514  93828078   LBU V0, -32648(GP)
442:                         newvar->vtype=eVAR_BYTE;
9D000518  24020009   ADDIU V0, ZERO, 9
9D00051C  A2020005   SB V0, 5(S0)
443:                         newvar->byte=*((uint8_t*)value);
9D000520  92820000   LBU V0, 0(S4)
9D000524  A202000C   SB V0, 12(S0)
9D000528  0B400153   J 0x9D00054C
9D00052C  02408821   ADDU S1, S2, ZERO
444:                     }else{// entier 16 bits
445:                         if (var_local){ 
9D000530  50400003   BEQL V0, ZERO, 0x9D000540
9D000534  A2000005   SB ZERO, 5(S0)
446:                             newvar->vtype=eVAR_LOCAL;
9D000538  24020007   ADDIU V0, ZERO, 7
9D00053C  A2020005   SB V0, 5(S0)
447:                         }else{ 
448:                             newvar->vtype=eVAR_INT;
449:                         }
450:                         newvar->n=*((int*)value);
9D000540  8E820000   LW V0, 0(S4)
9D000544  AE02000C   SW V0, 12(S0)
451:                     }
452:                     endmark=newend;
9D00054C  AF91C118   SW S1, -16104(GP)
453:                     newvar->len=len;
9D000550  A2130004   SB S3, 4(S0)
454:                     newvar->name=varname;
9D000554  AE120008   SW S2, 8(S0)
455:                     newvar->next=varlist;
9D000558  8F828080   LW V0, -32640(GP)
9D00055C  AE020000   SW V0, 0(S0)
456:                     varlist=newvar;
9D000560  AF908080   SW S0, -32640(GP)
457:                     return varlist;
458:                 }//f()
9D000564  02001021   ADDU V0, S0, ZERO
9D000568  8FBF0024   LW RA, 36(SP)
9D00056C  8FB40020   LW S4, 32(SP)
9D000570  8FB3001C   LW S3, 28(SP)
9D000574  8FB20018   LW S2, 24(SP)
9D000578  8FB10014   LW S1, 20(SP)
9D00057C  8FB00010   LW S0, 16(SP)
9D000580  03E00008   JR RA
9D000584  27BD0028   ADDIU SP, SP, 40
459:                 
460:                 static var_t *var_search(const char* name){
9D0001AC  27BDFFE0   ADDIU SP, SP, -32
9D0001B0  AFBF001C   SW RA, 28(SP)
9D0001B4  AFB10018   SW S1, 24(SP)
9D0001B8  AFB00014   SW S0, 20(SP)
461:                     var_t* link;
462:                     
463:                     link=varlist;
9D0001BC  8F908080   LW S0, -32640(GP)
464:                     while (link){
9D0001C0  12000009   BEQ S0, ZERO, 0x9D0001E8
9D0001C4  00808821   ADDU S1, A0, ZERO
9D0001E0  5600FFFA   BNEL S0, ZERO, 0x9D0001CC
9D0001E4  8E040008   LW A0, 8(S0)
465:                         if (!strcmp(link->name,name)) break;
9D0001C8  8E040008   LW A0, 8(S0)
9D0001CC  0F407138   JAL 0x9D01C4E0
9D0001D0  02202821   ADDU A1, S1, ZERO
9D0001D4  10400005   BEQ V0, ZERO, 0x9D0001EC
9D0001D8  02001021   ADDU V0, S0, ZERO
466:                         link=link->next;
9D0001DC  8E100000   LW S0, 0(S0)
467:                     }//while
468:                     return link;
469:                 }//f()
9D0001E8  02001021   ADDU V0, S0, ZERO
9D0001EC  8FBF001C   LW RA, 28(SP)
9D0001F0  8FB10018   LW S1, 24(SP)
9D0001F4  8FB00014   LW S0, 20(SP)
9D0001F8  03E00008   JR RA
9D0001FC  27BD0020   ADDIU SP, SP, 32
470:                 
471:                 static void bytecode(uint8_t bc){
9D001114  27BDFFE8   ADDIU SP, SP, -24
9D001118  AFBF0014   SW RA, 20(SP)
472:                     if ((void*)&progspace[dptr]>=endmark) throw(eERR_PROGSPACE);
9D00111C  8F83C11C   LW V1, -16100(GP)
9D001120  8F82809C   LW V0, -32612(GP)
9D001124  00431021   ADDU V0, V0, V1
9D001128  8F85C118   LW A1, -16104(GP)
9D00112C  0045282B   SLTU A1, V0, A1
9D001130  14A00003   BNE A1, ZERO, 0x9D001140
9D001134  24630001   ADDIU V1, V1, 1
9D001138  0F400080   JAL throw
9D00113C  2404000E   ADDIU A0, ZERO, 14
473:                     progspace[dptr++]=bc;
9D001140  AF83C11C   SW V1, -16100(GP)
9D001144  A0440000   SB A0, 0(V0)
474:                 }//f
9D001148  8FBF0014   LW RA, 20(SP)
9D00114C  03E00008   JR RA
9D001150  27BD0018   ADDIU SP, SP, 24
475:                 
476:                 
477:                 //caractères qui séparent les unitées lexicale
478:                 //static bool separator(char c){
479:                 //	return strchr("()+-*/%,<>=':\"",c);
480:                 //}
481:                 
482:                 //saute les espaces
483:                 static void skip_space(){
484:                     char c=0;
485:                     while ((c=reader_getc(activ_reader)==' ') || (c=='\t'));
9D0006E8  24100020   ADDIU S0, ZERO, 32
486:                     if (!activ_reader->eof) reader_ungetc(activ_reader);
9D0006FC  8C82010C   LW V0, 268(A0)
9D000700  14400003   BNE V0, ZERO, 0x9D000710
9D000704  00000000   NOP
9D000708  0F4068A0   JAL reader_ungetc
9D00070C  00000000   NOP
487:                 }//f()
488:                 
489:                 static void parse_string(){
490:                 	bool quote=false;
491:                 	bool escape=false;
492:                 	unsigned i=0;
493:                 	char c;
494:                     
495:                     c=reader_getc(activ_reader);
9D000A84  0F40684F   JAL reader_getc
9D000A88  8F848098   LW A0, -32616(GP)
496:                 	while (!activ_reader->eof && !quote && (c>0)){
9D000A8C  8F848098   LW A0, -32616(GP)
9D000A90  8C83010C   LW V1, 268(A0)
9D000A94  1460011A   BNE V1, ZERO, 0x9D000F00
9D000A98  00008021   ADDU S0, ZERO, ZERO
9D000A9C  18400118   BLEZ V0, 0x9D000F00
9D000AA0  00008821   ADDU S1, ZERO, ZERO
9D000B64  8F848098   LW A0, -32616(GP)
9D000B68  8C83010C   LW V1, 268(A0)
9D000B6C  546000E9   BNEL V1, ZERO, 0x9D000F14
9D000B70  3C02A000   LUI V0, -24576
9D000B74  1C40FFD0   BGTZ V0, 0x9D000AB8
9D000B78  00000000   NOP
497:                         if (!escape){
9D000AB8  16200009   BNE S1, ZERO, 0x9D000AE0
9D000ABC  24030022   ADDIU V1, ZERO, 34
498:                             switch (c){
9D000AC0  10430105   BEQ V0, V1, 0x9D000ED8
9D000AC4  2403005C   ADDIU V1, ZERO, 92
9D000AC8  50430024   BEQL V0, V1, 0x9D000B5C
9D000ACC  24110001   ADDIU S1, ZERO, 1
499:                             case '\\':
500:                                 escape=true;
501:                                 break;
502:                             case '"':
503:                                 quote=true;
504:                                 break;
505:                             default:
506:                                 token.str[i++]=c;
9D000AD0  02131821   ADDU V1, S0, S3
9D000AD4  A0620004   SB V0, 4(V1)
9D000AD8  0B4002D7   J 0x9D000B5C
9D000ADC  26100001   ADDIU S0, S0, 1
507:                             }
508:                         }else{
509:                             switch (c){
9D000AA4  2412006E   ADDIU S2, ZERO, 110
9D000AB4  24140072   ADDIU S4, ZERO, 114
9D000AE0  10520017   BEQ V0, S2, 0x9D000B40
9D000AE4  2843006F   SLTI V1, V0, 111
9D000AE8  10600005   BEQ V1, ZERO, 0x9D000B00
9D000AEC  24030022   ADDIU V1, ZERO, 34
9D000AF0  10430009   BEQ V0, V1, 0x9D000B18
9D000AF4  02131021   ADDU V0, S0, S3
9D000AF8  0B4002D5   J 0x9D000B54
9D000AFC  00000000   NOP
9D000B00  1054000F   BEQ V0, S4, 0x9D000B40
9D000B04  24030074   ADDIU V1, ZERO, 116
9D000B08  10430008   BEQ V0, V1, 0x9D000B2C
9D000B0C  02131021   ADDU V0, S0, S3
9D000B10  0B4002D5   J 0x9D000B54
9D000B14  00000000   NOP
510:                                 case '"':
511:                                     token.str[i++]=c;
9D000B18  24030022   ADDIU V1, ZERO, 34
9D000B1C  A0430004   SB V1, 4(V0)
9D000B20  26100001   ADDIU S0, S0, 1
512:                                     break;
513:                                 case 't':
514:                                     token.str[i++]='\t';
9D000B2C  24030009   ADDIU V1, ZERO, 9
9D000B30  A0430004   SB V1, 4(V0)
9D000B34  26100001   ADDIU S0, S0, 1
515:                                     break;
516:                                 case 'n':
517:                                 case 'r':
518:                                     token.str[i++]='\n';
9D000AA8  3C13A000   LUI S3, -24576
9D000AAC  26733918   ADDIU S3, S3, 14616
9D000AB0  2415000A   ADDIU S5, ZERO, 10
9D000B40  02131021   ADDU V0, S0, S3
9D000B44  A0550004   SB S5, 4(V0)
9D000B48  26100001   ADDIU S0, S0, 1
519:                                     break;
520:                                 default:
521:                                     throw(eERR_SYNTAX);
9D000B54  0F400080   JAL throw
9D000B58  24040007   ADDIU A0, ZERO, 7
522:                                     //return i;
523:                             }
524:                             escape=false;
9D000B24  0B4002D7   J 0x9D000B5C
9D000B28  00008821   ADDU S1, ZERO, ZERO
9D000B38  0B4002D7   J 0x9D000B5C
9D000B3C  00008821   ADDU S1, ZERO, ZERO
9D000B4C  0B4002D7   J 0x9D000B5C
9D000B50  00008821   ADDU S1, ZERO, ZERO
525:                         }
526:                 		c=reader_getc(activ_reader);
9D000B5C  0F40684F   JAL reader_getc
9D000B60  00000000   NOP
9D000ED8  0F40684F   JAL reader_getc
9D000EDC  3C11A000   LUI S1, -24576
527:                 	}//while
528:                     token.str[i++]=0;
9D000B7C  0B4003C1   J 0x9D000F04
9D000B80  3C02A000   LUI V0, -24576
9D000EE0  26223918   ADDIU V0, S1, 14616
9D000EE4  02028021   ADDU S0, S0, V0
9D000EE8  A2000004   SB ZERO, 4(S0)
9D000F00  3C02A000   LUI V0, -24576
9D000F04  24423918   ADDIU V0, V0, 14616
9D000F08  02028021   ADDU S0, S0, V0
9D000F0C  0B4002E1   J 0x9D000B84
9D000F10  A2000004   SB ZERO, 4(S0)
9D000F14  24423918   ADDIU V0, V0, 14616
9D000F18  02028021   ADDU S0, S0, V0
9D000F1C  0B4002E1   J 0x9D000B84
9D000F20  A2000004   SB ZERO, 4(S0)
529:                 	if (quote){
530:                         reader_ungetc(activ_reader);
9D000EEC  0F4068A0   JAL reader_ungetc
9D000EF0  8F848098   LW A0, -32616(GP)
531:                     } else{
532:                         throw(eERR_SYNTAX);
9D000B84  0F400080   JAL throw
9D000B88  24040007   ADDIU A0, ZERO, 7
533:                     }
534:                 	token.id=eSTRING;
9D000EF4  24020005   ADDIU V0, ZERO, 5
9D000EF8  0B4003C9   J 0x9D000F24
9D000EFC  AE223918   SW V0, 14616(S1)
535:                 }//f()
536:                 
537:                 
538:                 static void parse_identifier(){
539:                     char c;
540:                     int i=1;
541:                     while (!activ_reader->eof){
9D0007DC  8F848098   LW A0, -32616(GP)
9D0007E0  8C82010C   LW V0, 268(A0)
9D0007E4  1040FFE2   BEQ V0, ZERO, 0x9D000770
9D0007E8  2633FFFF   ADDIU S3, S1, -1
9D0007EC  0B4003A3   J 0x9D000E8C
9D0007F0  2A630021   SLTI V1, S3, 33
9D0007F4  2A630021   SLTI V1, S3, 33
9D0007F8  24020020   ADDIU V0, ZERO, 32
9D0007FC  0043980A   MOVZ S3, V0, V1
542:                         c=reader_getc(activ_reader);
9D000770  0F40684F   JAL reader_getc
9D000774  00000000   NOP
9D000778  00408021   ADDU S0, V0, ZERO
543:                         if (!(isalnum(c) || c=='_'  || c=='$' || c=='#')){
9D000760  3C149D02   LUI S4, -25342
9D000764  2694CB59   ADDIU S4, S4, -13479
9D000768  0B4001F7   J 0x9D0007DC
9D00076C  2415005F   ADDIU S5, ZERO, 95
9D00077C  00541021   ADDU V0, V0, S4
9D000780  90420000   LBU V0, 0(V0)
9D000784  30420007   ANDI V0, V0, 7
9D000788  5440000B   BNEL V0, ZERO, 0x9D0007B8
9D00078C  02209821   ADDU S3, S1, ZERO
9D000790  121501B2   BEQ S0, S5, 0x9D000E5C
9D000794  2602FFDD   ADDIU V0, S0, -35
9D000798  304200FF   ANDI V0, V0, 255
9D00079C  2C420002   SLTIU V0, V0, 2
9D0007A0  144001B2   BNE V0, ZERO, 0x9D000E6C
9D0007A4  02608821   ADDU S1, S3, ZERO
544:                             reader_ungetc(activ_reader);
9D0007A8  0F4068A0   JAL reader_ungetc
9D0007AC  8F848098   LW A0, -32616(GP)
9D0007B0  0B4001FE   J 0x9D0007F8
9D0007B4  2A630021   SLTI V1, S3, 33
545:                             break;
546:                         }
547:                         token.str[i++]=toupper(c);
9D0007B8  0F407C86   JAL toupper
9D0007BC  02002021   ADDU A0, S0, ZERO
9D000E5C  0F407C86   JAL toupper
9D000E60  02A02021   ADDU A0, S5, ZERO
9D000E64  0B4001F5   J 0x9D0007D4
9D000E68  A2420005   SB V0, 5(S2)
9D000E6C  26730001   ADDIU S3, S3, 1
9D000E70  0F407C86   JAL toupper
9D000E74  02002021   ADDU A0, S0, ZERO
9D000E78  3C03A000   LUI V1, -24576
9D000E7C  24633918   ADDIU V1, V1, 14616
9D000E80  02231821   ADDU V1, S1, V1
9D000E84  0B4001FD   J 0x9D0007F4
9D000E88  A0620004   SB V0, 4(V1)
9D000E8C  24020020   ADDIU V0, ZERO, 32
9D000E90  0043980A   MOVZ S3, V0, V1
548:                         if (c=='$' || c=='#') break;
9D0007C0  2610FFDD   ADDIU S0, S0, -35
9D0007C4  321000FF   ANDI S0, S0, 255
9D0007C8  2E100002   SLTIU S0, S0, 2
9D0007CC  16000009   BNE S0, ZERO, 0x9D0007F4
9D0007D0  A2420005   SB V0, 5(S2)
9D0007D4  26310001   ADDIU S1, S1, 1
9D0007D8  26520001   ADDIU S2, S2, 1
549:                     }
550:                     if (i>32) i=32;
551:                     token.str[i]=0;                  
9D000800  3C02A000   LUI V0, -24576
9D000804  24423918   ADDIU V0, V0, 14616
9D000808  02621021   ADDU V0, S3, V0
9D00080C  A0400004   SB ZERO, 4(V0)
9D000E94  3C02A000   LUI V0, -24576
9D000E98  24423918   ADDIU V0, V0, 14616
9D000E9C  02621021   ADDU V0, S3, V0
9D000EA0  A0400004   SB ZERO, 4(V0)
552:                     if ((i=dict_search(KEYWORD))>-1){
9D000864  06400006   BLTZ S2, 0x9D000880
9D000868  3C02A000   LUI V0, -24576
553:                         token.id=eKWORD;
9D00086C  24030018   ADDIU V1, ZERO, 24
9D000870  AC433918   SW V1, 14616(V0)
554:                         token.n=i;
9D000874  24423918   ADDIU V0, V0, 14616
9D000878  0B4003C9   J 0x9D000F24
9D00087C  AC520004   SW S2, 4(V0)
555:                     }else{
556:                         token.id=eIDENT;
9D000854  0B400220   J 0x9D000880
9D000858  24030003   ADDIU V1, ZERO, 3
9D000880  3C02A000   LUI V0, -24576
9D000884  0B4003C9   J 0x9D000F24
9D000888  AC433918   SW V1, 14616(V0)
557:                     }
558:                 }//f()
559:                 
560:                 static void parse_integer(int base){
9D000598  27BDFFD8   ADDIU SP, SP, -40
9D00059C  AFBF0024   SW RA, 36(SP)
9D0005A0  AFB40020   SW S4, 32(SP)
9D0005A4  AFB3001C   SW S3, 28(SP)
9D0005A8  AFB20018   SW S2, 24(SP)
9D0005AC  AFB10014   SW S1, 20(SP)
9D0005B0  AFB00010   SW S0, 16(SP)
9D0005B4  00809021   ADDU S2, A0, ZERO
561:                     char c;
562:                     int n=0,d;
563:                     
564:                     c=reader_getc(activ_reader);
9D0005B8  0F40684F   JAL reader_getc
9D0005BC  8F848098   LW A0, -32616(GP)
565:                     while (!activ_reader->eof){
9D0005C0  8F908098   LW S0, -32616(GP)
9D0005C4  8E03010C   LW V1, 268(S0)
9D0005C8  14600026   BNE V1, ZERO, 0x9D000664
9D0005CC  00008821   ADDU S1, ZERO, ZERO
9D00064C  8F908098   LW S0, -32616(GP)
9D000650  8E03010C   LW V1, 268(S0)
9D000654  1060FFE2   BEQ V1, ZERO, 0x9D0005E0
9D000658  00531821   ADDU V1, V0, S3
9D00065C  0B40019A   J 0x9D000668
9D000660  3C02A000   LUI V0, -24576
566:                         if (isdigit(c)){
9D0005D0  3C139D02   LUI S3, -25342
9D0005D4  2673CB59   ADDIU S3, S3, -13479
9D0005DC  00531821   ADDU V1, V0, S3
9D0005E0  90630000   LBU V1, 0(V1)
9D0005E4  30640004   ANDI A0, V1, 4
9D0005E8  308400FF   ANDI A0, A0, 255
9D0005EC  10800007   BEQ A0, ZERO, 0x9D00060C
9D0005F0  00000000   NOP
567:                             d=c-'0';
9D0005F4  2442FFD0   ADDIU V0, V0, -48
568:                             if (d>=base) throw(eERR_BAD_ARG);
9D0005F8  0052182A   SLT V1, V0, S2
9D0005FC  14600010   BNE V1, ZERO, 0x9D000640
9D000600  72321802   MUL V1, S1, S2
9D000604  0F400080   JAL throw
9D000608  24040006   ADDIU A0, ZERO, 6
569:                         }else if (base==16 && isxdigit(c)){
9D0005D8  24140010   ADDIU S4, ZERO, 16
9D00060C  16540007   BNE S2, S4, 0x9D00062C
9D000610  30630044   ANDI V1, V1, 68
9D000614  10600005   BEQ V1, ZERO, 0x9D00062C
9D000618  00000000   NOP
570:                             d=toupper(c)-'A'+10;
9D00061C  0F407C86   JAL toupper
9D000620  00402021   ADDU A0, V0, ZERO
9D000624  0B40018F   J 0x9D00063C
9D000628  2442FFC9   ADDIU V0, V0, -55
571:                         }else{
572:                             reader_ungetc(activ_reader);
9D00062C  0F4068A0   JAL reader_ungetc
9D000630  02002021   ADDU A0, S0, ZERO
573:                             break;
9D000634  0B40019A   J 0x9D000668
9D000638  3C02A000   LUI V0, -24576
574:                         }
575:                         n= n*base+d;
9D00063C  72321802   MUL V1, S1, S2
9D000640  00628821   ADDU S1, V1, V0
576:                         c=reader_getc(activ_reader);
9D000644  0F40684F   JAL reader_getc
9D000648  02002021   ADDU A0, S0, ZERO
577:                     }//while
578:                     token.id=eNUMBER;
9D000664  3C02A000   LUI V0, -24576
9D000668  24030004   ADDIU V1, ZERO, 4
9D00066C  AC433918   SW V1, 14616(V0)
579:                     token.n=n;
9D000670  24423918   ADDIU V0, V0, 14616
9D000674  AC510004   SW S1, 4(V0)
580:                 }//f()
9D000678  8FBF0024   LW RA, 36(SP)
9D00067C  8FB40020   LW S4, 32(SP)
9D000680  8FB3001C   LW S3, 28(SP)
9D000684  8FB20018   LW S2, 24(SP)
9D000688  8FB10014   LW S1, 20(SP)
9D00068C  8FB00010   LW S0, 16(SP)
9D000690  03E00008   JR RA
9D000694  27BD0028   ADDIU SP, SP, 40
581:                 
582:                 
583:                 static void next_token(){
9D000698  27BDFFD0   ADDIU SP, SP, -48
9D00069C  AFBF002C   SW RA, 44(SP)
9D0006A0  AFB50028   SW S5, 40(SP)
9D0006A4  AFB40024   SW S4, 36(SP)
9D0006A8  AFB30020   SW S3, 32(SP)
9D0006AC  AFB2001C   SW S2, 28(SP)
9D0006B0  AFB10018   SW S1, 24(SP)
9D0006B4  AFB00014   SW S0, 20(SP)
584:                     char c;
585:                     
586:                     if (unget_token){
9D0006B8  93828084   LBU V0, -32636(GP)
9D0006BC  10400003   BEQ V0, ZERO, 0x9D0006CC
9D0006C0  3C02A000   LUI V0, -24576
587:                         unget_token=false;
588:                         return;
9D0006C4  0B4003C9   J 0x9D000F24
9D0006C8  A3808084   SB ZERO, -32636(GP)
589:                     }
590:                     token.id=eNONE;
9D0006CC  AC403918   SW ZERO, 14616(V0)
591:                     token.str[0]=0;
9D0006D0  24423918   ADDIU V0, V0, 14616
9D0006D4  A0400004   SB ZERO, 4(V0)
592:                     if (activ_reader->eof){
9D0006D8  8F828098   LW V0, -32616(GP)
9D0006DC  8C42010C   LW V0, 268(V0)
9D0006E0  14400211   BNE V0, ZERO, 0x9D000F28
9D0006E4  8FBF002C   LW RA, 44(SP)
593:                         return;
594:                     }
595:                     skip_space();
596:                     c=reader_getc(activ_reader);
9D000710  0F40684F   JAL reader_getc
9D000714  8F848098   LW A0, -32616(GP)
597:                     if (c==-1){
9D000718  2403FFFF   ADDIU V1, ZERO, -1
9D00071C  14430004   BNE V0, V1, 0x9D000730
9D000720  3C039D02   LUI V1, -25342
598:                         token.id=eNONE;
9D000724  3C03A000   LUI V1, -24576
9D000728  AC603918   SW ZERO, 14616(V1)
599:                     }
600:                     if (isalpha(c)){
9D00072C  3C039D02   LUI V1, -25342
9D000730  2463CB59   ADDIU V1, V1, -13479
9D000734  00431821   ADDU V1, V0, V1
9D000738  90630000   LBU V1, 0(V1)
9D00073C  30640003   ANDI A0, V1, 3
9D000740  10800052   BEQ A0, ZERO, 0x9D00088C
9D000744  30630004   ANDI V1, V1, 4
601:                         token.str[0]=toupper(c);
9D000748  0F407C86   JAL toupper
9D00074C  00402021   ADDU A0, V0, ZERO
9D000750  3C12A000   LUI S2, -24576
9D000754  26523918   ADDIU S2, S2, 14616
9D000758  A2420004   SB V0, 4(S2)
9D00075C  24110002   ADDIU S1, ZERO, 2
9D000EBC  00009021   ADDU S2, ZERO, ZERO
9D000EC0  3C059D01   LUI A1, -25343
9D000EC4  24A52C6C   ADDIU A1, A1, 11372
9D000EC8  24110043   ADDIU S1, ZERO, 67
602:                         parse_identifier();
603:                     }else if (isdigit(c)){
9D00088C  306300FF   ANDI V1, V1, 255
9D000890  10600007   BEQ V1, ZERO, 0x9D0008B0
9D000894  2442FFF6   ADDIU V0, V0, -10
604:                         reader_ungetc(activ_reader);
9D000898  0F4068A0   JAL reader_ungetc
9D00089C  8F848098   LW A0, -32616(GP)
605:                         parse_integer(10);
9D0008A0  0F400166   JAL parse_integer
9D0008A4  2404000A   ADDIU A0, ZERO, 10
9D0008A8  0B4003CA   J 0x9D000F28
9D0008AC  8FBF002C   LW RA, 44(SP)
606:                     }else{
607:                         switch(c){
9D0008B0  304300FF   ANDI V1, V0, 255
9D0008B4  2C630053   SLTIU V1, V1, 83
9D0008B8  1060019A   BEQ V1, ZERO, 0x9D000F24
9D0008BC  304200FF   ANDI V0, V0, 255
9D0008C0  00021080   SLL V0, V0, 2
9D0008C4  3C039D00   LUI V1, -25344
9D0008C8  246308DC   ADDIU V1, V1, 2268
9D0008CC  00621021   ADDU V0, V1, V0
9D0008D0  8C420000   LW V0, 0(V0)
9D0008D4  00400008   JR V0
9D0008D8  00000000   NOP
608:                             case '$': // nombre hexadecimal
609:                                 parse_integer(16);
9D000A28  0F400166   JAL parse_integer
9D000A2C  24040010   ADDIU A0, ZERO, 16
610:                                 break;
9D000A30  0B4003CA   J 0x9D000F28
9D000A34  8FBF002C   LW RA, 44(SP)
611:                             case '#': // nombre binaire
612:                                 parse_integer(2);
9D000A38  0F400166   JAL parse_integer
9D000A3C  24040002   ADDIU A0, ZERO, 2
613:                                 break;
9D000A40  0B4003CA   J 0x9D000F28
9D000A44  8FBF002C   LW RA, 44(SP)
614:                             case '\'': // commentaire
615:                                 token.id=eKWORD;
9D000A48  3C02A000   LUI V0, -24576
9D000A4C  24030018   ADDIU V1, ZERO, 24
9D000A50  AC433918   SW V1, 14616(V0)
616:                                 token.n=eKW_REM;
9D000A54  24423918   ADDIU V0, V0, 14616
9D000A58  2403002D   ADDIU V1, ZERO, 45
617:                                 break;
9D000A5C  0B4003C9   J 0x9D000F24
9D000A60  AC430004   SW V1, 4(V0)
618:                             case '\\':
619:                                 token.id=eCHAR;
9D000A64  3C10A000   LUI S0, -24576
9D000A68  24020019   ADDIU V0, ZERO, 25
9D000A6C  AE023918   SW V0, 14616(S0)
620:                                 token.n=reader_getc(activ_reader);
9D000A70  0F40684F   JAL reader_getc
9D000A74  8F848098   LW A0, -32616(GP)
9D000A78  26103918   ADDIU S0, S0, 14616
621:                                 break;
9D000A7C  0B4003C9   J 0x9D000F24
9D000A80  AE020004   SW V0, 4(S0)
622:                             case '"': // chaîne de caractères
623:                                 parse_string();
624:                                 break;
625:                             case '+':
626:                                 token.id=ePLUS;
9D000B8C  3C02A000   LUI V0, -24576
9D000B90  24030006   ADDIU V1, ZERO, 6
9D000B94  AC433918   SW V1, 14616(V0)
627:                                 token.str[0]='+';
9D000B98  24423918   ADDIU V0, V0, 14616
9D000B9C  2403002B   ADDIU V1, ZERO, 43
9D000BA0  A0430004   SB V1, 4(V0)
628:                                 token.str[1]=0;
629:                                 break;
9D000BA4  0B4003C9   J 0x9D000F24
9D000BA8  A0400005   SB ZERO, 5(V0)
630:                             case '-':
631:                                 token.id=eMINUS;
9D000BAC  3C02A000   LUI V0, -24576
9D000BB0  24030007   ADDIU V1, ZERO, 7
9D000BB4  AC433918   SW V1, 14616(V0)
632:                                 token.str[0]='-';
9D000BB8  24423918   ADDIU V0, V0, 14616
9D000BBC  2403002D   ADDIU V1, ZERO, 45
9D000BC0  A0430004   SB V1, 4(V0)
633:                                 token.str[1]=0;
634:                                 break;
9D000BC4  0B4003C9   J 0x9D000F24
9D000BC8  A0400005   SB ZERO, 5(V0)
635:                             case '*':
636:                                 token.id=eMUL;
9D000BCC  3C02A000   LUI V0, -24576
9D000BD0  24030008   ADDIU V1, ZERO, 8
9D000BD4  AC433918   SW V1, 14616(V0)
637:                                 token.str[0]='*';
9D000BD8  24423918   ADDIU V0, V0, 14616
9D000BDC  2403002A   ADDIU V1, ZERO, 42
9D000BE0  A0430004   SB V1, 4(V0)
638:                                 token.str[1]=0;
639:                                 break;
9D000BE4  0B4003C9   J 0x9D000F24
9D000BE8  A0400005   SB ZERO, 5(V0)
640:                             case '/':
641:                                 token.id=eDIV;
9D000BEC  3C02A000   LUI V0, -24576
9D000BF0  24030009   ADDIU V1, ZERO, 9
9D000BF4  AC433918   SW V1, 14616(V0)
642:                                 token.str[0]='/';
9D000BF8  24423918   ADDIU V0, V0, 14616
9D000BFC  2403002F   ADDIU V1, ZERO, 47
9D000C00  A0430004   SB V1, 4(V0)
643:                                 token.str[1]=0;
644:                                 break;
9D000C04  0B4003C9   J 0x9D000F24
9D000C08  A0400005   SB ZERO, 5(V0)
645:                             case '%':
646:                                 token.id=eMOD;
9D000C0C  3C02A000   LUI V0, -24576
9D000C10  2403000A   ADDIU V1, ZERO, 10
9D000C14  AC433918   SW V1, 14616(V0)
647:                                 token.str[0]='%';
9D000C18  24423918   ADDIU V0, V0, 14616
9D000C1C  24030025   ADDIU V1, ZERO, 37
9D000C20  A0430004   SB V1, 4(V0)
648:                                 token.str[1]=0;
649:                                 break;
9D000C24  0B4003C9   J 0x9D000F24
9D000C28  A0400005   SB ZERO, 5(V0)
650:                             case '=':
651:                                 token.id=eEQUAL;
9D000C2C  3C02A000   LUI V0, -24576
9D000C30  2403000F   ADDIU V1, ZERO, 15
9D000C34  AC433918   SW V1, 14616(V0)
652:                                 token.str[0]='=';
9D000C38  24423918   ADDIU V0, V0, 14616
9D000C3C  2403003D   ADDIU V1, ZERO, 61
9D000C40  A0430004   SB V1, 4(V0)
653:                                 token.str[1]=0;
654:                                 break;
9D000C44  0B4003C9   J 0x9D000F24
9D000C48  A0400005   SB ZERO, 5(V0)
655:                             case '>':
656:                                 token.str[0]='>';
9D000C4C  2403003E   ADDIU V1, ZERO, 62
9D000C50  3C02A000   LUI V0, -24576
9D000C54  A043391C   SB V1, 14620(V0)
657:                                 c=reader_getc(activ_reader);
9D000C58  0F40684F   JAL reader_getc
9D000C5C  8F848098   LW A0, -32616(GP)
658:                                 if (c=='='){
9D000C60  2403003D   ADDIU V1, ZERO, 61
9D000C64  14430009   BNE V0, V1, 0x9D000C8C
9D000C68  2403003C   ADDIU V1, ZERO, 60
659:                                     token.id=eGE;
9D000C6C  3C02A000   LUI V0, -24576
9D000C70  24030012   ADDIU V1, ZERO, 18
9D000C74  AC433918   SW V1, 14616(V0)
660:                                 token.str[1]='=';
9D000C78  24423918   ADDIU V0, V0, 14616
9D000C7C  2403003D   ADDIU V1, ZERO, 61
9D000C80  A0430005   SB V1, 5(V0)
9D000C84  0B4003C9   J 0x9D000F24
9D000C88  A0400006   SB ZERO, 6(V0)
661:                                 token.str[2]=0;
662:                                 }else if (c=='<'){
9D000C8C  14430008   BNE V0, V1, 0x9D000CB0
9D000C90  3C02A000   LUI V0, -24576
663:                                     token.id=eNOTEQUAL;
9D000C94  24030010   ADDIU V1, ZERO, 16
9D000C98  AC433918   SW V1, 14616(V0)
664:                                     token.str[1]='<';
9D000C9C  24423918   ADDIU V0, V0, 14616
9D000CA0  2403003C   ADDIU V1, ZERO, 60
9D000CA4  A0430005   SB V1, 5(V0)
9D000CA8  0B4003C9   J 0x9D000F24
9D000CAC  A0400006   SB ZERO, 6(V0)
665:                                     token.str[2]=0;
666:                                 }else{
667:                                     token.id=eGT;
9D000CB0  24030011   ADDIU V1, ZERO, 17
9D000CB4  AC433918   SW V1, 14616(V0)
668:                                     token.str[1]=0;
9D000CB8  24423918   ADDIU V0, V0, 14616
9D000CBC  A0400005   SB ZERO, 5(V0)
669:                                     reader_ungetc(activ_reader);
9D000CC0  0F4068A0   JAL reader_ungetc
9D000CC4  8F848098   LW A0, -32616(GP)
670:                                 }
671:                                 break;
672:                             case '<':
673:                                 token.str[0]='<';
9D000CD0  2403003C   ADDIU V1, ZERO, 60
9D000CD4  3C02A000   LUI V0, -24576
9D000CD8  A043391C   SB V1, 14620(V0)
674:                                 c=reader_getc(activ_reader);
9D000CDC  0F40684F   JAL reader_getc
9D000CE0  8F848098   LW A0, -32616(GP)
675:                                 if (c=='='){
9D000CE4  2403003D   ADDIU V1, ZERO, 61
9D000CE8  14430009   BNE V0, V1, 0x9D000D10
9D000CEC  2403003E   ADDIU V1, ZERO, 62
676:                                     token.id=eLE;
9D000CF0  3C02A000   LUI V0, -24576
9D000CF4  24030014   ADDIU V1, ZERO, 20
9D000CF8  AC433918   SW V1, 14616(V0)
677:                                 token.str[1]='=';
9D000CFC  24423918   ADDIU V0, V0, 14616
9D000D00  2403003D   ADDIU V1, ZERO, 61
9D000D04  A0430005   SB V1, 5(V0)
9D000D08  0B4003C9   J 0x9D000F24
9D000D0C  A0400006   SB ZERO, 6(V0)
678:                                 token.str[2]=0;
679:                                 }else if (c=='>'){
9D000D10  14430008   BNE V0, V1, 0x9D000D34
9D000D14  3C02A000   LUI V0, -24576
680:                                     token.id=eNOTEQUAL;
9D000D18  24030010   ADDIU V1, ZERO, 16
9D000D1C  AC433918   SW V1, 14616(V0)
681:                                     token.str[1]='<';
9D000D20  24423918   ADDIU V0, V0, 14616
9D000D24  2403003C   ADDIU V1, ZERO, 60
9D000D28  A0430005   SB V1, 5(V0)
9D000D2C  0B4003C9   J 0x9D000F24
9D000D30  A0400006   SB ZERO, 6(V0)
682:                                     token.str[2]=0;
683:                                 }else{
684:                                     token.id=eLT;
9D000D34  24030013   ADDIU V1, ZERO, 19
9D000D38  AC433918   SW V1, 14616(V0)
685:                                     token.str[1]=0;
9D000D3C  24423918   ADDIU V0, V0, 14616
9D000D40  A0400005   SB ZERO, 5(V0)
686:                                     reader_ungetc(activ_reader);
9D000D44  0F4068A0   JAL reader_ungetc
9D000D48  8F848098   LW A0, -32616(GP)
687:                                 }
688:                                 break;
689:                             case '(':
690:                                 token.id=eLPAREN;
9D000D54  3C02A000   LUI V0, -24576
9D000D58  2403000C   ADDIU V1, ZERO, 12
9D000D5C  AC433918   SW V1, 14616(V0)
691:                                 token.str[0]='(';
9D000D60  24423918   ADDIU V0, V0, 14616
9D000D64  24030028   ADDIU V1, ZERO, 40
9D000D68  A0430004   SB V1, 4(V0)
692:                                 token.str[1]=0;
693:                                 break;
9D000D6C  0B4003C9   J 0x9D000F24
9D000D70  A0400005   SB ZERO, 5(V0)
694:                             case ')':
695:                                 token.id=eRPAREN;
9D000D74  3C02A000   LUI V0, -24576
9D000D78  2403000D   ADDIU V1, ZERO, 13
9D000D7C  AC433918   SW V1, 14616(V0)
696:                                 token.str[0]=')';
9D000D80  24423918   ADDIU V0, V0, 14616
9D000D84  24030029   ADDIU V1, ZERO, 41
9D000D88  A0430004   SB V1, 4(V0)
697:                                 token.str[1]=0;
698:                                 break;
9D000D8C  0B4003C9   J 0x9D000F24
9D000D90  A0400005   SB ZERO, 5(V0)
699:                             case ',':
700:                                 token.id=eCOMMA;
9D000D94  3C02A000   LUI V0, -24576
9D000D98  2403000B   ADDIU V1, ZERO, 11
9D000D9C  AC433918   SW V1, 14616(V0)
701:                                 token.str[0]=',';
9D000DA0  24423918   ADDIU V0, V0, 14616
9D000DA4  2403002C   ADDIU V1, ZERO, 44
9D000DA8  A0430004   SB V1, 4(V0)
702:                                 token.str[1]=0;
703:                                 break;
9D000DAC  0B4003C9   J 0x9D000F24
9D000DB0  A0400005   SB ZERO, 5(V0)
704:                             case ';':
705:                                 token.id=eSEMICOL;
9D000DB4  3C02A000   LUI V0, -24576
9D000DB8  2403000E   ADDIU V1, ZERO, 14
9D000DBC  AC433918   SW V1, 14616(V0)
706:                                 token.str[0]=';';
9D000DC0  24423918   ADDIU V0, V0, 14616
9D000DC4  2403003B   ADDIU V1, ZERO, 59
9D000DC8  A0430004   SB V1, 4(V0)
707:                                 token.str[1]=0;
708:                                 break;
9D000DCC  0B4003C9   J 0x9D000F24
9D000DD0  A0400005   SB ZERO, 5(V0)
709:                             case '?': // alias pour PRINT
710:                                 token.id=eKWORD;
9D000DD4  3C02A000   LUI V0, -24576
9D000DD8  24030018   ADDIU V1, ZERO, 24
9D000DDC  AC433918   SW V1, 14616(V0)
711:                                 token.n=eKW_PRINT;
9D000DE0  24423918   ADDIU V0, V0, 14616
9D000DE4  24030027   ADDIU V1, ZERO, 39
712:                                 break;
9D000DE8  0B4003C9   J 0x9D000F24
9D000DEC  AC430004   SW V1, 4(V0)
713:                             case '@': // référence
714:                                 token.id=eKWORD;
9D000DF0  3C02A000   LUI V0, -24576
9D000DF4  24030018   ADDIU V1, ZERO, 24
9D000DF8  AC433918   SW V1, 14616(V0)
715:                                 token.n=eKW_REF;
9D000DFC  24423918   ADDIU V0, V0, 14616
9D000E00  2403002C   ADDIU V1, ZERO, 44
716:                                 break;
9D000E04  0B4003C9   J 0x9D000F24
9D000E08  AC430004   SW V1, 4(V0)
717:                             case '\n':
718:                             case '\r':
719:                                 line_count++;
9D000E0C  8F828090   LW V0, -32624(GP)
9D000E10  24420001   ADDIU V0, V0, 1
9D000E14  AF828090   SW V0, -32624(GP)
720:                                 if (activ_reader->device==eDEV_SDCARD){ // considéré comme un espace
9D000E18  8F828098   LW V0, -32616(GP)
9D000E1C  8C430000   LW V1, 0(V0)
9D000E20  24020002   ADDIU V0, ZERO, 2
9D000E24  14620006   BNE V1, V0, 0x9D000E40
9D000E28  3C02A000   LUI V0, -24576
721:                                     next_token();
9D000E2C  0F4001A6   JAL next_token
9D000E30  00000000   NOP
722:                                     break;
9D000E34  0B4003CA   J 0x9D000F28
9D000E38  8FBF002C   LW RA, 44(SP)
723:                                 }
724:                             case ':':    
725:                                 token.id=eSTOP;
9D000E3C  3C02A000   LUI V0, -24576
9D000E40  24030001   ADDIU V1, ZERO, 1
9D000E44  AC433918   SW V1, 14616(V0)
726:                                 token.str[0]='\n';
9D000E48  24423918   ADDIU V0, V0, 14616
9D000E4C  2403000A   ADDIU V1, ZERO, 10
9D000E50  A0430004   SB V1, 4(V0)
727:                                 token.str[1]=0;
728:                                 break;
9D000E54  0B4003C9   J 0x9D000F24
9D000E58  A0400005   SB ZERO, 5(V0)
729:                         }//switch(c)
730:                     }//if
731:                 }//next_token()
9D000CC8  0B4003CA   J 0x9D000F28
9D000CCC  8FBF002C   LW RA, 44(SP)
9D000D4C  0B4003CA   J 0x9D000F28
9D000D50  8FBF002C   LW RA, 44(SP)
9D000F24  8FBF002C   LW RA, 44(SP)
9D000F28  8FB50028   LW S5, 40(SP)
9D000F2C  8FB40024   LW S4, 36(SP)
9D000F30  8FB30020   LW S3, 32(SP)
9D000F34  8FB2001C   LW S2, 28(SP)
9D000F38  8FB10018   LW S1, 24(SP)
9D000F3C  8FB00014   LW S0, 20(SP)
9D000F40  03E00008   JR RA
9D000F44  27BD0030   ADDIU SP, SP, 48
732:                 
733:                 //devrait-être à la fin de la commande
734:                 static void expect_end(){
735:                     next_token();
736:                     if (!((token.id>=eNONE) && (token.id<=eCOLON))) throw(eERR_EXTRA_ARG);
737:                 }//f()
738:                 
739:                 
740:                 static bool try_relation(){
741:                     next_token();
9D0020F8  0F4001A6   JAL next_token
742:                     if (!((token.id>=eEQUAL) && (token.id<=eLE))){
9D002100  3C02A000   LUI V0, -24576
743:                         unget_token=true;
9D002118  A3828084   SB V0, -32636(GP)
744:                         return false;
745:                     } 
746:                     return true;
747:                 }//f
748:                 
749:                 static bool try_boolop(){
9D000F48  27BDFFE8   ADDIU SP, SP, -24
9D000F4C  AFBF0014   SW RA, 20(SP)
750:                     next_token();
9D000F50  0F4001A6   JAL next_token
9D000F54  00000000   NOP
751:                     if ((token.id==eKWORD) && ((token.n==eKW_NOT) || (token.n==eKW_AND)||(token.n==eKW_OR))){
9D000F58  3C02A000   LUI V0, -24576
9D000F5C  8C433918   LW V1, 14616(V0)
9D000F60  24020018   ADDIU V0, ZERO, 24
9D000F64  14620009   BNE V1, V0, 0x9D000F8C
9D000F68  24020001   ADDIU V0, ZERO, 1
9D000F6C  3C02A000   LUI V0, -24576
9D000F70  8C42391C   LW V0, 14620(V0)
9D000F74  2443FFDC   ADDIU V1, V0, -36
9D000F78  2C630002   SLTIU V1, V1, 2
9D000F7C  14600006   BNE V1, ZERO, 0x9D000F98
9D000F80  24030001   ADDIU V1, ZERO, 1
9D000F84  10430006   BEQ V0, V1, 0x9D000FA0
9D000F88  24020001   ADDIU V0, ZERO, 1
752:                         return true;
9D000F98  0B4003E9   J 0x9D000FA4
9D000F9C  24020001   ADDIU V0, ZERO, 1
9D000FA0  24020001   ADDIU V0, ZERO, 1
753:                     }else{
754:                         unget_token=true;
9D000F8C  A3828084   SB V0, -32636(GP)
755:                         return false;
9D000F90  0B4003E9   J 0x9D000FA4
9D000F94  00001021   ADDU V0, ZERO, ZERO
756:                     }
757:                 }//f
9D000FA4  8FBF0014   LW RA, 20(SP)
9D000FA8  03E00008   JR RA
9D000FAC  27BD0018   ADDIU SP, SP, 24
758:                 
759:                 static void expect(tok_id_t t){
9D000FB0  27BDFFE8   ADDIU SP, SP, -24
9D000FB4  AFBF0014   SW RA, 20(SP)
9D000FB8  AFB00010   SW S0, 16(SP)
760:                     next_token();
9D000FBC  0F4001A6   JAL next_token
9D000FC0  00808021   ADDU S0, A0, ZERO
761:                     if (token.id!=t) throw(eERR_SYNTAX);
9D000FC4  3C02A000   LUI V0, -24576
9D000FC8  8C423918   LW V0, 14616(V0)
9D000FCC  10500003   BEQ V0, S0, 0x9D000FDC
9D000FD0  8FBF0014   LW RA, 20(SP)
9D000FD4  0F400080   JAL throw
9D000FD8  24040007   ADDIU A0, ZERO, 7
762:                 }
9D000FDC  8FB00010   LW S0, 16(SP)
9D000FE0  03E00008   JR RA
9D000FE4  27BD0018   ADDIU SP, SP, 24
763:                 
764:                 //static bool try_string(){
765:                 //    next_token();
766:                 //    if (token.id==eSTRING) return true;
767:                 //    unget_token=true;
768:                 //    return false;
769:                 //}//f
770:                 
771:                 static bool try_addop(){
772:                     next_token();
9D001E7C  0F4001A6   JAL next_token
9D001EE8  0F4001A6   JAL next_token
9D001EEC  00000000   NOP
773:                     if ((token.id==ePLUS) || (token.id==eMINUS)) return true;
9D001E84  3C02A000   LUI V0, -24576
9D001EA4  0B4007B2   J 0x9D001EC8
9D001EA8  3C11A000   LUI S1, -24576
9D001EC4  3C11A000   LUI S1, -24576
9D001EF0  8E303918   LW S0, 14616(S1)
9D001EF4  2602FFFA   ADDIU V0, S0, -6
9D001EF8  2C420002   SLTIU V0, V0, 2
9D001EFC  14400015   BNE V0, ZERO, 0x9D001F54
9D001F00  24020001   ADDIU V0, ZERO, 1
9D001F4C  0B4007B2   J 0x9D001EC8
9D001F50  3C11A000   LUI S1, -24576
774:                     unget_token=true;
9D001F04  A3828084   SB V0, -32636(GP)
775:                     return false;
776:                 }//f
777:                 
778:                 static bool try_mulop(){
779:                     next_token();
9D002A54  0F4001A6   JAL next_token
9D002A58  00000000   NOP
780:                     if ((token.id==eMUL)||(token.id==eDIV)||token.id==eMOD) return true;
9D002A18  3C11A000   LUI S1, -24576
9D002A5C  8E303918   LW S0, 14616(S1)
9D002A60  2602FFF8   ADDIU V0, S0, -8
9D002A64  2C420003   SLTIU V0, V0, 3
9D002A68  14400003   BNE V0, ZERO, 0x9D002A78
9D002A6C  24020001   ADDIU V0, ZERO, 1
781:                     unget_token=true;
9D002A70  0B400AA8   J 0x9D002AA0
9D002A74  A3828084   SB V0, -32636(GP)
782:                     return false;
783:                 }//f
784:                 
785:                 typedef enum {eNO_FILTER,eACCEPT_ALL,eACCEPT_END_WITH,eACCEPT_ANY_POS,
786:                         eACCEPT_SAME,eACCEPT_START_WITH} filter_enum;
787:                 
788:                 typedef struct{
789:                     char *subs; // sous-chaïne filtre.
790:                     filter_enum criteria; // critère
791:                 }filter_t;
792:                 
793:                 static void parse_filter(){
794:                     char c;
795:                     int i=0;
796:                     skip_space();
797:                     while (!activ_reader->eof && 
798:                             (isalnum((c=reader_getc(activ_reader))) || c=='*' || c=='_' || c=='.')){
799:                         token.str[i++]=toupper(c);
800:                     }
801:                     reader_ungetc(activ_reader);
802:                     token.str[i]=0;
803:                     if (!i) token.id=eNONE; else token.id=eSTRING;
804:                 }//f
805:                 
806:                 static void set_filter(filter_t *filter){
807:                     filter->criteria=eACCEPT_ALL;
808:                     parse_filter();
809:                     if (token.id==eNONE){
810:                         filter->criteria=eNO_FILTER;
811:                         return;
812:                     }
813:                     if (token.str[0]=='*' && token.str[1]==0){
814:                         return;
815:                     }
816:                     if (token.str[0]=='*'){
817:                         filter->criteria++;
818:                     }else{
819:                         filter->criteria=eACCEPT_SAME;
820:                     }
821:                     if (token.str[strlen(token.str)-1]=='*'){
822:                         token.str[strlen(token.str)-1]=0;
823:                         filter->criteria++;
824:                     }
825:                     switch(filter->criteria){
826:                         case eACCEPT_START_WITH:
827:                         case eACCEPT_SAME:
828:                             strcpy(filter->subs,token.str);
829:                             break;
830:                         case eACCEPT_END_WITH:
831:                         case eACCEPT_ANY_POS:
832:                             strcpy(filter->subs,&token.str[1]);
833:                             break;
834:                         case eNO_FILTER:
835:                         case eACCEPT_ALL:
836:                             break;
837:                     }//switch
838:                 }//f()
839:                 
840:                 
841:                 static bool filter_accept(filter_t *filter, const char* text){
842:                     bool result=false;
843:                     char temp[32];
844:                     
845:                     strcpy(temp,text);
846:                     uppercase(temp);
847:                     switch (filter->criteria){
848:                         case eACCEPT_SAME:
849:                             if (!strcmp(filter->subs,temp)) result=true;
850:                             break;
851:                         case eACCEPT_START_WITH:
852:                             if (strstr(temp,filter->subs)==temp) result=true;
853:                             break;
854:                         case eACCEPT_END_WITH:
855:                             if (strstr(temp,filter->subs)==temp+strlen(temp)-strlen(filter->subs)) result=true;
856:                             break;
857:                         case eACCEPT_ANY_POS:
858:                             if (strstr(temp,filter->subs)) result=true;
859:                             break;
860:                         case eACCEPT_ALL:
861:                         case eNO_FILTER:
862:                             result=true;
863:                             break;
864:                     }
865:                     return result;
866:                 }//f()
867:                 
868:                 //static void checkbound(var_t* var, int index);
869:                 static void expression();
870:                 
871:                 // compile le calcul d'indice dans les variables vecteur
872:                 static void code_array_address(var_t *var){
9D001F84  27BDFFE8   ADDIU SP, SP, -24
9D001F88  AFBF0014   SW RA, 20(SP)
9D001F8C  AFB00010   SW S0, 16(SP)
873:                     expression();
9D001F90  0F400799   JAL expression
9D001F94  00808021   ADDU S0, A0, ZERO
874:                     expect(eRPAREN);
9D001F98  0F4003EC   JAL expect
9D001F9C  2404000D   ADDIU A0, ZERO, 13
875:                     if (var->vtype==eVAR_INTARRAY || var->vtype==eVAR_STRARRAY){
9D001FA0  92020005   LBU V0, 5(S0)
9D001FA4  24030002   ADDIU V1, ZERO, 2
9D001FA8  10430003   BEQ V0, V1, 0x9D001FB8
9D001FAC  24030004   ADDIU V1, ZERO, 4
9D001FB0  14430005   BNE V0, V1, 0x9D001FC8
9D001FB4  00000000   NOP
876:                         bytecode(ILSHIFT);//2*index
9D001FB8  0F400445   JAL bytecode
9D001FBC  24040034   ADDIU A0, ZERO, 52
9D001FC0  0B4007F6   J 0x9D001FD8
9D001FC4  00000000   NOP
877:                     }else{
878:                         // élément 0 et 1  réservé pour size
879:                         // index 1 correspond à array[2]
880:                         _litc(1);
9D001FC8  0F400445   JAL bytecode
9D001FCC  24040003   ADDIU A0, ZERO, 3
881:                         bytecode(IPLUS);
9D001FD0  0F400445   JAL bytecode
9D001FD4  24040015   ADDIU A0, ZERO, 21
882:                     }
883:                     //index dans le tableau
884:                     _lit((uint32_t)var->adr);
9D001FD8  0F400445   JAL bytecode
9D001FDC  24040001   ADDIU A0, ZERO, 1
885:                     bytecode(IPLUS);
9D001FE0  0F400445   JAL bytecode
9D001FE4  24040015   ADDIU A0, ZERO, 21
886:                 }//f
9D001FE8  8FBF0014   LW RA, 20(SP)
9D001FEC  8FB00010   LW S0, 16(SP)
9D001FF0  03E00008   JR RA
9D001FF4  27BD0018   ADDIU SP, SP, 24
887:                 
888:                 
889:                 static void parse_arg_list(int arg_count){
9D0025F4  27BDFFD8   ADDIU SP, SP, -40
9D0025F8  AFBF0024   SW RA, 36(SP)
9D0025FC  AFB30020   SW S3, 32(SP)
9D002600  AFB2001C   SW S2, 28(SP)
9D002604  AFB10018   SW S1, 24(SP)
9D002608  AFB00014   SW S0, 20(SP)
9D00260C  00809821   ADDU S3, A0, ZERO
890:                     int count=0;
9D002648  00008021   ADDU S0, ZERO, ZERO
891:                     expect(eLPAREN);
9D002610  0F4003EC   JAL expect
9D002614  2404000C   ADDIU A0, ZERO, 12
892:                     next_token();
9D002618  0F4001A6   JAL next_token
9D00261C  00000000   NOP
893:                     if (token.id==eRPAREN){
9D002620  3C02A000   LUI V0, -24576
9D002624  8C433918   LW V1, 14616(V0)
9D002628  2402000D   ADDIU V0, ZERO, 13
9D00262C  14620005   BNE V1, V0, 0x9D002644
9D002630  24020001   ADDIU V0, ZERO, 1
894:                         if (arg_count) throw(eERR_MISSING_ARG);
9D002634  1260001A   BEQ S3, ZERO, 0x9D0026A0
9D002638  8FBF0024   LW RA, 36(SP)
9D00263C  0F400080   JAL throw
9D002640  24040004   ADDIU A0, ZERO, 4
895:                         return;
896:                     }
897:                     unget_token=true;
9D002644  A3828084   SB V0, -32636(GP)
898:                     do{
899:                         expression();
9D002654  0F400799   JAL expression
9D002658  26100001   ADDIU S0, S0, 1
900:                         count++;
901:                         next_token();
9D00265C  0F4001A6   JAL next_token
9D002660  00000000   NOP
902:                     }while (token.id==eCOMMA);
9D00264C  3C12A000   LUI S2, -24576
9D002650  2411000B   ADDIU S1, ZERO, 11
9D002664  8E423918   LW V0, 14616(S2)
9D002668  1051FFFA   BEQ V0, S1, 0x9D002654
9D00266C  2403000D   ADDIU V1, ZERO, 13
903:                     if (token.id!=eRPAREN) throw(eERR_SYNTAX);
9D002670  10430003   BEQ V0, V1, 0x9D002680
9D002674  0213102A   SLT V0, S0, S3
9D002678  0F400080   JAL throw
9D00267C  24040007   ADDIU A0, ZERO, 7
904:                     if (count<arg_count) throw(eERR_MISSING_ARG);
9D002680  50400003   BEQL V0, ZERO, 0x9D002690
9D002684  0270802A   SLT S0, S3, S0
9D002688  0F400080   JAL throw
9D00268C  24040004   ADDIU A0, ZERO, 4
905:                     if (count>arg_count) throw(eERR_EXTRA_ARG);
9D002690  12000003   BEQ S0, ZERO, 0x9D0026A0
9D002694  8FBF0024   LW RA, 36(SP)
9D002698  0F400080   JAL throw
9D00269C  24040005   ADDIU A0, ZERO, 5
906:                 }//f
9D0026A0  8FB30020   LW S3, 32(SP)
9D0026A4  8FB2001C   LW S2, 28(SP)
9D0026A8  8FB10018   LW S1, 24(SP)
9D0026AC  8FB00014   LW S0, 20(SP)
9D0026B0  03E00008   JR RA
9D0026B4  27BD0028   ADDIU SP, SP, 40
907:                 
908:                 
909:                 static void factor(){
9D0026B8  27BDFFE0   ADDIU SP, SP, -32
9D0026BC  AFBF001C   SW RA, 28(SP)
910:                     var_t *var;
911:                     int i;
912:                     
913:                     next_token();
9D0026C0  0F4001A6   JAL next_token
9D0026C4  AFB00018   SW S0, 24(SP)
914:                     switch(token.id){
9D0026C8  3C02A000   LUI V0, -24576
9D0026CC  8C423918   LW V0, 14616(V0)
9D0026D0  2442FFFD   ADDIU V0, V0, -3
9D0026D4  2C430017   SLTIU V1, V0, 23
9D0026D8  106000C2   BEQ V1, ZERO, 0x9D0029E4
9D0026DC  00021080   SLL V0, V0, 2
9D0026E0  3C039D00   LUI V1, -25344
9D0026E4  246326F8   ADDIU V1, V1, 9976
9D0026E8  00621021   ADDU V0, V1, V0
9D0026EC  8C420000   LW V0, 0(V0)
9D0026F0  00400008   JR V0
9D0026F4  00000000   NOP
915:                         case eKWORD:
916:                             if (KEYWORD[token.n].len&FUNCTION){
9D002754  3C02A000   LUI V0, -24576
9D002758  8C42391C   LW V0, 14620(V0)
9D00275C  00021880   SLL V1, V0, 2
9D002760  00022100   SLL A0, V0, 4
9D002764  00831823   SUBU V1, A0, V1
9D002768  3C049D01   LUI A0, -25343
9D00276C  24842C6C   ADDIU A0, A0, 11372
9D002770  00641821   ADDU V1, V1, A0
9D002774  90630004   LBU V1, 4(V1)
9D002778  30630040   ANDI V1, V1, 64
9D00277C  306300FF   ANDI V1, V1, 255
9D002780  10600009   BEQ V1, ZERO, 0x9D0027A8
9D002784  00021880   SLL V1, V0, 2
917:                                 KEYWORD[token.n].cfn();
9D002788  00021100   SLL V0, V0, 4
9D00278C  00431023   SUBU V0, V0, V1
9D002790  00441021   ADDU V0, V0, A0
9D002794  8C420000   LW V0, 0(V0)
9D002798  0040F809   JALR V0
9D00279C  00000000   NOP
9D0027A0  0B400A7B   J 0x9D0029EC
9D0027A4  8FBF001C   LW RA, 28(SP)
918:                             }else  throw(eERR_SYNTAX);
9D0027A8  0F400080   JAL throw
9D0027AC  24040007   ADDIU A0, ZERO, 7
919:                             break;
920:                         case eIDENT:
921:                             if ((var=var_search(token.str))){
9D0027B0  3C04A000   LUI A0, -24576
9D0027B4  0F40006B   JAL var_search
9D0027B8  2484391C   ADDIU A0, A0, 14620
9D0027BC  1040004D   BEQ V0, ZERO, 0x9D0028F4
9D0027C0  00408021   ADDU S0, V0, ZERO
922:                                 switch(var->vtype){
9D0027C4  90420005   LBU V0, 5(V0)
9D0027C8  2C42000A   SLTIU V0, V0, 10
9D0027CC  10400047   BEQ V0, ZERO, 0x9D0028EC
9D0027D0  3C029D00   LUI V0, -25344
9D0027D4  92030005   LBU V1, 5(S0)
9D0027D8  00031880   SLL V1, V1, 2
9D0027DC  244227F0   ADDIU V0, V0, 10224
9D0027E0  00431021   ADDU V0, V0, V1
9D0027E4  8C420000   LW V0, 0(V0)
9D0027E8  00400008   JR V0
9D0027EC  00000000   NOP
923:                                     case eVAR_FUNC:
924:                                         _litc(0);
9D002818  0F400445   JAL bytecode
9D00281C  24040003   ADDIU A0, ZERO, 3
925:                                         parse_arg_list(*((uint8_t*)(var->adr+1)));
9D002820  8E02000C   LW V0, 12(S0)
9D002824  0F40097D   JAL parse_arg_list
9D002828  90440001   LBU A0, 1(V0)
926:                                         bytecode(ICALL);
9D00282C  0F400445   JAL bytecode
9D002830  24040056   ADDIU A0, ZERO, 86
927:                                         bytecode(_byte0((uint32_t)&var->adr));
9D002834  2610000C   ADDIU S0, S0, 12
9D002838  0F400445   JAL bytecode
9D00283C  320400FF   ANDI A0, S0, 255
928:                                         bytecode(_byte1((uint32_t)&var->adr));
9D002840  0F400445   JAL bytecode
9D002844  7E043A00   EXT A0, S0, 8, 8
929:                                         break;
9D002848  0B400A7B   J 0x9D0029EC
9D00284C  8FBF001C   LW RA, 28(SP)
930:                                     case eVAR_LOCAL:
931:                                         bytecode(ILCFETCH);
9D002850  0F400445   JAL bytecode
9D002854  24040061   ADDIU A0, ZERO, 97
932:                                         bytecode(var->n&(DSTACK_SIZE-1));
9D002858  8E04000C   LW A0, 12(S0)
9D00285C  0F400445   JAL bytecode
9D002860  3084007F   ANDI A0, A0, 127
933:                                         break;
9D002864  0B400A7B   J 0x9D0029EC
9D002868  8FBF001C   LW RA, 28(SP)
934:                                     case eVAR_BYTE:
935:                                         _lit((uint32_t)&var->n);
9D00286C  0F400445   JAL bytecode
9D002870  24040001   ADDIU A0, ZERO, 1
936:                                         bytecode(ICFETCH);
9D002874  0F400445   JAL bytecode
9D002878  2404000C   ADDIU A0, ZERO, 12
937:                                         break;
9D00287C  0B400A7B   J 0x9D0029EC
9D002880  8FBF001C   LW RA, 28(SP)
938:                                     case eVAR_CONST:
939:                                         _lit(var->n);
9D002884  0F400445   JAL bytecode
9D002888  24040001   ADDIU A0, ZERO, 1
940:                                         break;
9D00288C  0B400A7B   J 0x9D0029EC
9D002890  8FBF001C   LW RA, 28(SP)
941:                                     case eVAR_INT:
942:                                         _lit((uint32_t)&var->n);
9D002894  0F400445   JAL bytecode
9D002898  24040001   ADDIU A0, ZERO, 1
943:                                         bytecode(IFETCH);
9D00289C  0F400445   JAL bytecode
9D0028A0  2404000A   ADDIU A0, ZERO, 10
944:                                         break;
9D0028A4  0B400A7B   J 0x9D0029EC
9D0028A8  8FBF001C   LW RA, 28(SP)
945:                                     case eVAR_BYTEARRAY:
946:                                         expect(eLPAREN);
9D0028AC  0F4003EC   JAL expect
9D0028B0  2404000C   ADDIU A0, ZERO, 12
947:                                         code_array_address(var);
9D0028B4  0F4007E1   JAL code_array_address
9D0028B8  02002021   ADDU A0, S0, ZERO
948:                 //                        expression();
949:                 //                        expect(eRPAREN);
950:                 //                        _lit((uint32_t)var->adr);
951:                 //                        bytecode(ADD);
952:                                         bytecode(ICFETCH);
9D0028BC  0F400445   JAL bytecode
9D0028C0  2404000C   ADDIU A0, ZERO, 12
953:                                         break;
9D0028C4  0B400A7B   J 0x9D0029EC
9D0028C8  8FBF001C   LW RA, 28(SP)
954:                                     case eVAR_INTARRAY:
955:                                         expect(eLPAREN);
9D0028CC  0F4003EC   JAL expect
9D0028D0  2404000C   ADDIU A0, ZERO, 12
956:                                         code_array_address(var);
9D0028D4  0F4007E1   JAL code_array_address
9D0028D8  02002021   ADDU A0, S0, ZERO
957:                 //                        expression();
958:                 //                        expect(eRPAREN);
959:                 //                        bytecode(SHL);
960:                 //                        _lit((uint32_t)var->adr);
961:                 //                        bytecode(ADD);
962:                                         bytecode(IFETCH);
9D0028DC  0F400445   JAL bytecode
9D0028E0  2404000A   ADDIU A0, ZERO, 10
963:                                         break;
9D0028E4  0B400A7B   J 0x9D0029EC
9D0028E8  8FBF001C   LW RA, 28(SP)
964:                                     default:
965:                                         throw(eERR_SYNTAX);
9D0028EC  0F400080   JAL throw
9D0028F0  24040007   ADDIU A0, ZERO, 7
966:                                 }//switch
967:                             }else if (!var){
968:                                 if (var_local){
9D0028F4  93828078   LBU V0, -32648(GP)
9D0028F8  10400010   BEQ V0, ZERO, 0x9D00293C
9D0028FC  3C04A000   LUI A0, -24576
969:                                     i=varlist->n+1;
9D002900  8F828080   LW V0, -32640(GP)
9D002904  8C42000C   LW V0, 12(V0)
9D002908  24420001   ADDIU V0, V0, 1
9D00290C  AFA20010   SW V0, 16(SP)
970:                                     var=var_create(token.str,(char*)&i);
9D002910  2484391C   ADDIU A0, A0, 14620
9D002914  0F400115   JAL var_create
9D002918  27A50010   ADDIU A1, SP, 16
971:                                     _litc(0);
9D00291C  0F400445   JAL bytecode
9D002920  24040003   ADDIU A0, ZERO, 3
972:                                     bytecode(ILCSTORE);
9D002924  0F400445   JAL bytecode
9D002928  24040060   ADDIU A0, ZERO, 96
973:                                     bytecode(i);
9D00292C  0F400445   JAL bytecode
9D002930  93A40010   LBU A0, 16(SP)
9D002934  0B400A7B   J 0x9D0029EC
9D002938  8FBF001C   LW RA, 28(SP)
974:                                 }else{
975:                                     var=var_create(token.str,NULL);
9D00293C  2484391C   ADDIU A0, A0, 14620
9D002940  0F400115   JAL var_create
9D002944  00002821   ADDU A1, ZERO, ZERO
976:                                     next_token();
9D002948  0F4001A6   JAL next_token
9D00294C  00000000   NOP
977:                                     if (token.id==eLPAREN) throw(eERR_SYNTAX);
9D002950  3C02A000   LUI V0, -24576
9D002954  8C433918   LW V1, 14616(V0)
9D002958  2402000C   ADDIU V0, ZERO, 12
9D00295C  14620003   BNE V1, V0, 0x9D00296C
9D002960  24020001   ADDIU V0, ZERO, 1
9D002964  0F400080   JAL throw
9D002968  24040007   ADDIU A0, ZERO, 7
978:                                     unget_token=true;
9D00296C  A3828084   SB V0, -32636(GP)
979:                                     _lit((uint32_t)&var->n);
9D002970  0F400445   JAL bytecode
9D002974  24040001   ADDIU A0, ZERO, 1
980:                                     bytecode(IFETCH);
9D002978  0F400445   JAL bytecode
9D00297C  2404000A   ADDIU A0, ZERO, 10
981:                                 }
982:                             }else{
983:                                 throw(eERR_SYNTAX);
984:                             }
985:                             break;
986:                         case eCHAR:
987:                             _litc(token.n&127);
9D002988  0F400445   JAL bytecode
9D00298C  24040003   ADDIU A0, ZERO, 3
988:                             break;
9D002990  0B400A7B   J 0x9D0029EC
9D002994  8FBF001C   LW RA, 28(SP)
989:                         case eNUMBER:
990:                             if (token.n>=0 && token.n<256){
9D002998  3C02A000   LUI V0, -24576
9D00299C  8C42391C   LW V0, 14620(V0)
9D0029A0  2C420100   SLTIU V0, V0, 256
9D0029A4  10400005   BEQ V0, ZERO, 0x9D0029BC
9D0029A8  00000000   NOP
991:                                 _litc((uint8_t)token.n);
9D0029AC  0F400445   JAL bytecode
9D0029B0  24040003   ADDIU A0, ZERO, 3
9D0029B4  0B400A7B   J 0x9D0029EC
9D0029B8  8FBF001C   LW RA, 28(SP)
992:                             }else{
993:                                 _lit(token.n);
9D0029BC  0F400445   JAL bytecode
9D0029C0  24040001   ADDIU A0, ZERO, 1
994:                             }
995:                             break;
996:                         case eLPAREN:
997:                             expression();
9D0029CC  0F400799   JAL expression
9D0029D0  00000000   NOP
998:                             expect(eRPAREN);
9D0029D4  0F4003EC   JAL expect
9D0029D8  2404000D   ADDIU A0, ZERO, 13
999:                             break;
9D0029DC  0B400A7B   J 0x9D0029EC
9D0029E0  8FBF001C   LW RA, 28(SP)
1000:                        default:
1001:                            throw(eERR_SYNTAX);
9D0029E4  0F400080   JAL throw
9D0029E8  24040007   ADDIU A0, ZERO, 7
1002:                    }//switch
1003:                }//f()
9D002980  0B400A7B   J 0x9D0029EC
9D002984  8FBF001C   LW RA, 28(SP)
9D0029C4  0B400A7B   J 0x9D0029EC
9D0029C8  8FBF001C   LW RA, 28(SP)
9D0029EC  8FB00018   LW S0, 24(SP)
9D0029F0  03E00008   JR RA
9D0029F4  27BD0020   ADDIU SP, SP, 32
1004:                
1005:                static void term(){
9D0029F8  27BDFFD8   ADDIU SP, SP, -40
9D0029FC  AFBF0024   SW RA, 36(SP)
9D002A00  AFB40020   SW S4, 32(SP)
9D002A04  AFB3001C   SW S3, 28(SP)
9D002A08  AFB20018   SW S2, 24(SP)
9D002A0C  AFB10014   SW S1, 20(SP)
1006:                    int op;
1007:                    
1008:                    factor();
9D002A10  0F4009AE   JAL factor
9D002A14  AFB00010   SW S0, 16(SP)
1009:                    while (try_mulop()){
9D002A24  0B400A95   J 0x9D002A54
9D002A28  24140008   ADDIU S4, ZERO, 8
1010:                        op=token.id;
1011:                        factor();
9D002A78  0F4009AE   JAL factor
9D002A7C  00000000   NOP
1012:                        switch(op){
9D002A1C  24120009   ADDIU S2, ZERO, 9
9D002A20  2413000A   ADDIU S3, ZERO, 10
9D002A80  1212FFEE   BEQ S0, S2, 0x9D002A3C
9D002A84  00000000   NOP
9D002A88  1213FFF0   BEQ S0, S3, 0x9D002A4C
9D002A8C  00000000   NOP
9D002A90  1614FFF0   BNE S0, S4, 0x9D002A54
9D002A94  00000000   NOP
9D002A98  0B400A8B   J 0x9D002A2C
9D002A9C  00000000   NOP
1013:                            case eMUL:
1014:                                bytecode(ISTAR);
9D002A2C  0F400445   JAL bytecode
9D002A30  24040017   ADDIU A0, ZERO, 23
1015:                                break;
9D002A34  0B400A95   J 0x9D002A54
9D002A38  00000000   NOP
1016:                            case eDIV:
1017:                                bytecode(ISLASH);
9D002A3C  0F400445   JAL bytecode
9D002A40  2404001B   ADDIU A0, ZERO, 27
1018:                                break;
9D002A44  0B400A95   J 0x9D002A54
9D002A48  00000000   NOP
1019:                            case eMOD:
1020:                                bytecode(IMOD);
9D002A4C  0F400445   JAL bytecode
9D002A50  2404001D   ADDIU A0, ZERO, 29
1021:                                break;
1022:                        }//switch
1023:                    }
1024:                }//f 
9D002AA0  8FBF0024   LW RA, 36(SP)
9D002AA4  8FB40020   LW S4, 32(SP)
9D002AA8  8FB3001C   LW S3, 28(SP)
9D002AAC  8FB20018   LW S2, 24(SP)
9D002AB0  8FB10014   LW S1, 20(SP)
9D002AB4  8FB00010   LW S0, 16(SP)
9D002AB8  03E00008   JR RA
9D002ABC  27BD0028   ADDIU SP, SP, 40
1025:                
1026:                static void expression(){
9D001E64  27BDFFD8   ADDIU SP, SP, -40
9D001E68  AFBF0024   SW RA, 36(SP)
9D001E6C  AFB30020   SW S3, 32(SP)
9D001E70  AFB2001C   SW S2, 28(SP)
9D001E74  AFB10018   SW S1, 24(SP)
9D001E78  AFB00014   SW S0, 20(SP)
1027:                    int mark_dp=dptr;
1028:                    int op=eNONE;
1029:                    if (try_addop()){
1030:                        bytecode(ICLIT);
9D001F1C  0F400445   JAL bytecode
9D001F20  24040003   ADDIU A0, ZERO, 3
1031:                        bytecode(0);
9D001F24  0F400445   JAL bytecode
9D001F28  00002021   ADDU A0, ZERO, ZERO
1032:                        op=token.id;
9D001F2C  3C02A000   LUI V0, -24576
1033:                    }
1034:                    term();
9D001E9C  0F400A7E   JAL term
9D001EA0  A3828084   SB V0, -32636(GP)
9D001F30  0F400A7E   JAL term
9D001F34  8C503918   LW S0, 14616(V0)
1035:                    switch(op){
9D001F38  24020006   ADDIU V0, ZERO, 6
9D001F3C  1202FFDB   BEQ S0, V0, 0x9D001EAC
9D001F40  24020007   ADDIU V0, ZERO, 7
9D001F44  1202FFDD   BEQ S0, V0, 0x9D001EBC
9D001F48  00000000   NOP
1036:                        case ePLUS:
1037:                            bytecode(IPLUS);
9D001EAC  0F400445   JAL bytecode
9D001EB0  24040015   ADDIU A0, ZERO, 21
1038:                            break;
9D001EB4  0B4007B2   J 0x9D001EC8
9D001EB8  3C11A000   LUI S1, -24576
1039:                        case eMINUS:
1040:                            bytecode(ISUB);
9D001EBC  0F400445   JAL bytecode
9D001EC0  24040016   ADDIU A0, ZERO, 22
1041:                    }    
1042:                    while (try_addop()){
1043:                        op=token.id;
1044:                        term();
9D001F54  0F400A7E   JAL term
9D001F58  00000000   NOP
1045:                        if (op==ePLUS){
9D001EC8  0B4007BA   J 0x9D001EE8
9D001ECC  24130006   ADDIU S3, ZERO, 6
9D001F5C  1613FFE0   BNE S0, S3, 0x9D001EE0
9D001F60  00000000   NOP
9D001F64  0B4007B4   J 0x9D001ED0
9D001F68  00000000   NOP
1046:                            bytecode(IPLUS);
9D001ED0  0F400445   JAL bytecode
9D001ED4  24040015   ADDIU A0, ZERO, 21
9D001ED8  0B4007BA   J 0x9D001EE8
9D001EDC  00000000   NOP
1047:                        }else{
1048:                            bytecode(ISUB);
9D001EE0  0F400445   JAL bytecode
9D001EE4  24040016   ADDIU A0, ZERO, 22
1049:                        }
1050:                    }
1051:                    if (dptr==mark_dp) throw(eERR_SYNTAX);
9D001F08  8F82C11C   LW V0, -16100(GP)
9D001F0C  16420017   BNE S2, V0, 0x9D001F6C
9D001F10  8FBF0024   LW RA, 36(SP)
9D001F14  0F400080   JAL throw
9D001F18  24040007   ADDIU A0, ZERO, 7
1052:                }//f()
9D001F6C  8FB30020   LW S3, 32(SP)
9D001F70  8FB2001C   LW S2, 28(SP)
9D001F74  8FB10018   LW S1, 24(SP)
9D001F78  8FB00014   LW S0, 20(SP)
9D001F7C  03E00008   JR RA
9D001F80  27BD0028   ADDIU SP, SP, 40
1053:                
1054:                static void condition(){
1055:                    int rel;
1056:                    //print(con,"condition\n");
1057:                    expression();
9D0020F0  0F400799   JAL expression
9D0020F4  00000000   NOP
1058:                    if (!try_relation()){
1059:                        _litc(0);
9D00211C  0F400445   JAL bytecode
9D002120  24040003   ADDIU A0, ZERO, 3
1060:                        bytecode(IEQUAL);
9D002124  0F400445   JAL bytecode
9D002128  2404003A   ADDIU A0, ZERO, 58
1061:                        bytecode(INOT);
9D00212C  0F400445   JAL bytecode
9D002130  24040025   ADDIU A0, ZERO, 37
9D002134  0B400865   J 0x9D002194
9D002138  00000000   NOP
1062:                        return;
1063:                    }
1064:                    rel=token.id;
1065:                    expression();
9D0021AC  0F400799   JAL expression
9D0021B0  2610FFF1   ADDIU S0, S0, -15
1066:                    switch(rel){
9D0021B4  2E020006   SLTIU V0, S0, 6
9D0021B8  1040FFF6   BEQ V0, ZERO, 0x9D002194
9D0021BC  00108080   SLL S0, S0, 2
9D0021C0  3C029D00   LUI V0, -25344
9D0021C4  244221D8   ADDIU V0, V0, 8664
9D0021C8  00508021   ADDU S0, V0, S0
9D0021CC  8E020000   LW V0, 0(S0)
9D0021D0  00400008   JR V0
9D0021D4  00000000   NOP
1067:                        case eEQUAL:
1068:                            bytecode(IEQUAL);
9D00213C  0F400445   JAL bytecode
9D002140  2404003A   ADDIU A0, ZERO, 58
9D002144  0B400865   J 0x9D002194
9D002148  00000000   NOP
1069:                            break;
1070:                        case eNOTEQUAL:
1071:                            bytecode(INEQUAL);
9D00214C  0F400445   JAL bytecode
9D002150  2404003B   ADDIU A0, ZERO, 59
9D002154  0B400865   J 0x9D002194
9D002158  00000000   NOP
1072:                            break;
1073:                        case eGT:
1074:                            bytecode(IGREATER);
9D00215C  0F400445   JAL bytecode
9D002160  2404003D   ADDIU A0, ZERO, 61
9D002164  0B400865   J 0x9D002194
9D002168  00000000   NOP
1075:                            break;
1076:                        case eGE:
1077:                            bytecode(IGTEQ);
9D00216C  0F400445   JAL bytecode
9D002170  2404003F   ADDIU A0, ZERO, 63
9D002174  0B400865   J 0x9D002194
9D002178  00000000   NOP
1078:                            break;
1079:                        case eLT:
1080:                            bytecode(ILESS);
9D00217C  0F400445   JAL bytecode
9D002180  2404003C   ADDIU A0, ZERO, 60
9D002184  0B400865   J 0x9D002194
9D002188  00000000   NOP
1081:                            break;
1082:                        case eLE:
1083:                            bytecode(ILTEQ);
9D00218C  0F400445   JAL bytecode
9D002190  2404003E   ADDIU A0, ZERO, 62
1084:                            break;
1085:                    }//switch
1086:                }//f
1087:                
1088:                static void bool_expression();
1089:                
1090:                static void bool_factor(){
9D0020B8  27BDFFE0   ADDIU SP, SP, -32
9D0020BC  AFBF001C   SW RA, 28(SP)
9D0020C0  AFB10018   SW S1, 24(SP)
1091:                    int boolop=0;
9D0020EC  00008821   ADDU S1, ZERO, ZERO
1092:                    //print(con,"bool_factor\n");
1093:                    if (try_boolop()){
9D0020C4  0F4003D2   JAL try_boolop
9D0020C8  AFB00014   SW S0, 20(SP)
9D0020CC  10400007   BEQ V0, ZERO, 0x9D0020EC
9D0020D0  3C02A000   LUI V0, -24576
1094:                        if (token.n!=eKW_NOT) throw(eERR_SYNTAX);
9D0020D4  8C43391C   LW V1, 14620(V0)
9D0020D8  24020024   ADDIU V0, ZERO, 36
9D0020DC  10620004   BEQ V1, V0, 0x9D0020F0
9D0020E0  24110024   ADDIU S1, ZERO, 36
9D0020E4  0F400080   JAL throw
9D0020E8  24040007   ADDIU A0, ZERO, 7
1095:                        boolop=eKW_NOT;
1096:                    }
1097:                    condition();
1098:                    if (boolop){
9D002194  52200016   BEQL S1, ZERO, 0x9D0021F0
9D002198  8FBF001C   LW RA, 28(SP)
1099:                        bytecode(INOT);
9D00219C  0F400445   JAL bytecode
9D0021A0  24040025   ADDIU A0, ZERO, 37
1100:                    }
1101:                }//f
9D0021A4  0B40087C   J 0x9D0021F0
9D0021A8  8FBF001C   LW RA, 28(SP)
9D0021F0  8FB10018   LW S1, 24(SP)
9D0021F4  8FB00014   LW S0, 20(SP)
9D0021F8  03E00008   JR RA
9D0021FC  27BD0020   ADDIU SP, SP, 32
1102:                
1103:                static void fix_branch_address();
1104:                
1105:                static void bool_term(){// print(con,"bool_term()\n");
9D002200  27BDFFD8   ADDIU SP, SP, -40
9D002204  AFBF0024   SW RA, 36(SP)
9D002208  AFB30020   SW S3, 32(SP)
9D00220C  AFB2001C   SW S2, 28(SP)
9D002210  AFB10018   SW S1, 24(SP)
1106:                    int fix_count=0; // pour évaluation court-circuitée.
9D00221C  00008021   ADDU S0, ZERO, ZERO
1107:                    bool_factor();
9D002214  0F40082E   JAL bool_factor
9D002218  AFB00014   SW S0, 20(SP)
1108:                    while (try_boolop() && token.n==eKW_AND){
9D002220  3C12A000   LUI S2, -24576
9D002224  24110001   ADDIU S1, ZERO, 1
9D00222C  0B40089F   J 0x9D00227C
9D002230  26734080   ADDIU S3, S3, 16512
9D00227C  0F4003D2   JAL try_boolop
9D002280  00000000   NOP
9D002284  10400006   BEQ V0, ZERO, 0x9D0022A0
9D002288  26423918   ADDIU V0, S2, 14616
9D00228C  8C420004   LW V0, 4(V0)
9D002290  1051FFE8   BEQ V0, S1, 0x9D002234
9D002294  02001021   ADDU V0, S0, ZERO
9D002298  0B4008AA   J 0x9D0022A8
9D00229C  24030001   ADDIU V1, ZERO, 1
9D0022A0  02001021   ADDU V0, S0, ZERO
1109:                        //code pour évaluation court-circuitée
1110:                        bytecode(IDUP);
9D002234  0F400445   JAL bytecode
9D002238  24040011   ADDIU A0, ZERO, 17
1111:                        bytecode(IQBRAZ); // si premier facteur==faux saut court-circuit.
9D00223C  0F400445   JAL bytecode
9D002240  24040037   ADDIU A0, ZERO, 55
1112:                        rstack[++rsp]=dptr;
9D002228  3C13A000   LUI S3, -24576
9D002244  9383C114   LBU V1, -16108(GP)
9D002248  24630001   ADDIU V1, V1, 1
9D00224C  7C031C20   SEB V1, V1
9D002250  A383C114   SB V1, -16108(GP)
9D002254  8F82C11C   LW V0, -16100(GP)
9D002258  00031880   SLL V1, V1, 2
9D00225C  00731821   ADDU V1, V1, S3
9D002260  AC620000   SW V0, 0(V1)
1113:                        dptr+=2;
9D002264  24420002   ADDIU V0, V0, 2
9D002268  AF82C11C   SW V0, -16100(GP)
1114:                        fix_count++;
1115:                        bool_factor();
9D00226C  0F40082E   JAL bool_factor
9D002270  26100001   ADDIU S0, S0, 1
1116:                        bytecode(IAND);
9D002274  0F400445   JAL bytecode
9D002278  24040022   ADDIU A0, ZERO, 34
1117:                    }
1118:                    unget_token=true;
9D0022A4  24030001   ADDIU V1, ZERO, 1
1119:                    while (fix_count){
9D0022A8  10400005   BEQ V0, ZERO, 0x9D0022C0
9D0022AC  A3838084   SB V1, -32636(GP)
9D0022B8  1600FFFD   BNE S0, ZERO, 0x9D0022B0
9D0022BC  00000000   NOP
1120:                        fix_branch_address();
9D0022B0  0F400002   JAL fix_branch_address
9D0022B4  2610FFFF   ADDIU S0, S0, -1
1121:                        fix_count--;
1122:                    }
1123:                }//f
9D0022C0  8FBF0024   LW RA, 36(SP)
9D0022C4  8FB30020   LW S3, 32(SP)
9D0022C8  8FB2001C   LW S2, 28(SP)
9D0022CC  8FB10018   LW S1, 24(SP)
9D0022D0  8FB00014   LW S0, 20(SP)
9D0022D4  03E00008   JR RA
9D0022D8  27BD0028   ADDIU SP, SP, 40
1124:                
1125:                static void bool_expression(){// print(con,"bool_expression()\n");
9D0022DC  27BDFFD8   ADDIU SP, SP, -40
9D0022E0  AFBF0024   SW RA, 36(SP)
9D0022E4  AFB30020   SW S3, 32(SP)
9D0022E8  AFB2001C   SW S2, 28(SP)
9D0022EC  AFB10018   SW S1, 24(SP)
1126:                    int fix_count=0; // pour évaluation court-circuitée.
9D0022F8  00008021   ADDU S0, ZERO, ZERO
1127:                    bool_term(); //print(con,"first bool_term done\n");
9D0022F0  0F400880   JAL bool_term
9D0022F4  AFB00014   SW S0, 20(SP)
1128:                    while (try_boolop() && token.n==eKW_OR){
9D0022FC  3C12A000   LUI S2, -24576
9D002300  24110025   ADDIU S1, ZERO, 37
9D002308  0B4008D6   J 0x9D002358
9D00230C  26734080   ADDIU S3, S3, 16512
9D002358  0F4003D2   JAL try_boolop
9D00235C  00000000   NOP
9D002360  10400006   BEQ V0, ZERO, 0x9D00237C
9D002364  26423918   ADDIU V0, S2, 14616
9D002368  8C420004   LW V0, 4(V0)
9D00236C  1051FFE8   BEQ V0, S1, 0x9D002310
9D002370  02001021   ADDU V0, S0, ZERO
9D002374  0B4008E1   J 0x9D002384
9D002378  24030001   ADDIU V1, ZERO, 1
9D00237C  02001021   ADDU V0, S0, ZERO
1129:                        bytecode(IDUP);
9D002310  0F400445   JAL bytecode
9D002314  24040011   ADDIU A0, ZERO, 17
1130:                        bytecode(IQBRA); // is premier facteur==vrai saut court-circuit.
9D002318  0F400445   JAL bytecode
9D00231C  24040007   ADDIU A0, ZERO, 7
1131:                        rstack[++rsp]=dptr;
9D002304  3C13A000   LUI S3, -24576
9D002320  9383C114   LBU V1, -16108(GP)
9D002324  24630001   ADDIU V1, V1, 1
9D002328  7C031C20   SEB V1, V1
9D00232C  A383C114   SB V1, -16108(GP)
9D002330  8F82C11C   LW V0, -16100(GP)
9D002334  00031880   SLL V1, V1, 2
9D002338  00731821   ADDU V1, V1, S3
9D00233C  AC620000   SW V0, 0(V1)
1132:                        dptr+=2;
9D002340  24420002   ADDIU V0, V0, 2
9D002344  AF82C11C   SW V0, -16100(GP)
1133:                        fix_count++;
1134:                        bool_term();
9D002348  0F400880   JAL bool_term
9D00234C  26100001   ADDIU S0, S0, 1
1135:                        bytecode(IOR);
9D002350  0F400445   JAL bytecode
9D002354  24040023   ADDIU A0, ZERO, 35
1136:                    }
1137:                    unget_token=true;
9D002380  24030001   ADDIU V1, ZERO, 1
1138:                    while (fix_count){
9D002384  10400005   BEQ V0, ZERO, 0x9D00239C
9D002388  A3838084   SB V1, -32636(GP)
9D002394  1600FFFD   BNE S0, ZERO, 0x9D00238C
9D002398  00000000   NOP
1139:                        fix_branch_address();
9D00238C  0F400002   JAL fix_branch_address
9D002390  2610FFFF   ADDIU S0, S0, -1
1140:                        fix_count--;
1141:                    }
1142:                }//f
9D00239C  8FBF0024   LW RA, 36(SP)
9D0023A0  8FB30020   LW S3, 32(SP)
9D0023A4  8FB2001C   LW S2, 28(SP)
9D0023A8  8FB10018   LW S1, 24(SP)
9D0023AC  8FB00014   LW S0, 20(SP)
9D0023B0  03E00008   JR RA
9D0023B4  27BD0028   ADDIU SP, SP, 40
1143:                
1144:                static void bad_syntax(){
9D000588  27BDFFE8   ADDIU SP, SP, -24
9D00058C  AFBF0014   SW RA, 20(SP)
1145:                    throw(eERR_SYNTAX);
9D000590  0F400080   JAL throw
9D000594  24040007   ADDIU A0, ZERO, 7
1146:                }//f
1147:                
1148:                static void compile();
1149:                
1150:                static  const char* compile_msg[]={
1151:                    "compiling ",
1152:                    "completed ",
1153:                    "file open error "
1154:                };
1155:                
1156:                #define COMPILING 0
1157:                #define COMP_END 1
1158:                #define COMP_FILE_ERROR 2
1159:                
1160:                static void compiler_msg(int msg_id, char *detail){
9D000104  27BDFF98   ADDIU SP, SP, -104
9D000108  AFBF0064   SW RA, 100(SP)
9D00010C  AFB00060   SW S0, 96(SP)
9D000110  00A08021   ADDU S0, A1, ZERO
1161:                    char msg[CHAR_PER_LINE];
1162:                    strcpy(msg,compile_msg[msg_id]);
9D000114  00042080   SLL A0, A0, 2
9D000118  3C029D01   LUI V0, -25343
9D00011C  24422894   ADDIU V0, V0, 10388
9D000120  00821021   ADDU V0, A0, V0
9D000124  27A40010   ADDIU A0, SP, 16
9D000128  0F406D40   JAL strcpy
9D00012C  8C450000   LW A1, 0(V0)
1163:                    print(con,msg);
9D000130  97848062   LHU A0, -32670(GP)
9D000134  0F404FCC   JAL print
9D000138  27A50010   ADDIU A1, SP, 16
1164:                    print(con,detail);
9D00013C  97848062   LHU A0, -32670(GP)
9D000140  0F404FCC   JAL print
9D000144  02002821   ADDU A1, S0, ZERO
1165:                    crlf(con);
9D000148  0F404FF3   JAL crlf
9D00014C  97848062   LHU A0, -32670(GP)
1166:                }//f
9D000150  8FBF0064   LW RA, 100(SP)
9D000154  8FB00060   LW S0, 96(SP)
9D000158  03E00008   JR RA
9D00015C  27BD0068   ADDIU SP, SP, 104
1167:                
1168:                /*************************
1169:                 * commandes BASIC
1170:                 *************************/
1171:                
1172:                
1173:                // '(' number {','number}')'
1174:                static void init_int_array(var_t *var){
1175:                    int *iarray=NULL;
9D003B5C  AFA00030   SW ZERO, 48(SP)
9D003B60  3AD60003   XORI S6, S6, 3
9D003B64  24020001   ADDIU V0, ZERO, 1
9D003B68  24030002   ADDIU V1, ZERO, 2
9D003B6C  0076100A   MOVZ V0, V1, S6
9D003B70  0040B021   ADDU S6, V0, ZERO
1176:                    unsigned char *barray=NULL;
9D003B48  0000B821   ADDU S7, ZERO, ZERO
1177:                    int size,count=1,state=0;
9D003B4C  0B400EDD   J 0x9D003B74
9D003B50  24160001   ADDIU S6, ZERO, 1
1178:                    
1179:                    if (var->vtype==eVAR_INTARRAY){
9D003B30  56C20008   BNEL S6, V0, 0x9D003B54
9D003B34  8E57000C   LW S7, 12(S2)
1180:                        iarray=var->adr;
9D003B38  8E42000C   LW V0, 12(S2)
9D003B3C  AFA20030   SW V0, 48(SP)
1181:                        size=*iarray;
9D003B40  8C430000   LW V1, 0(V0)
9D003B44  AFA30034   SW V1, 52(SP)
1182:                    }else{
1183:                        barray=var->adr;
1184:                        size=*barray;
9D003B54  92E40000   LBU A0, 0(S7)
9D003B58  AFA40034   SW A0, 52(SP)
1185:                    }
1186:                    if (var->vtype==eVAR_BYTEARRAY) count=2;
1187:                    expect(eLPAREN);
9D003B74  0F4003EC   JAL expect
9D003B78  2404000C   ADDIU A0, ZERO, 12
1188:                    next_token();
9D003B7C  0F4001A6   JAL next_token
9D003B80  0000A821   ADDU S5, ZERO, ZERO
1189:                    while (token.id!=eRPAREN){
9D003B84  2414000D   ADDIU S4, ZERO, 13
9D003C84  8E023918   LW V0, 14616(S0)
9D003C88  1454FFC1   BNE V0, S4, 0x9D003B90
9D003C8C  2C43001A   SLTIU V1, V0, 26
1190:                        switch (token.id){
9D003854  3C139D00   LUI S3, -25344
9D003B90  10600038   BEQ V1, ZERO, 0x9D003C74
9D003B94  00021080   SLL V0, V0, 2
9D003B98  02621021   ADDU V0, S3, V0
9D003B9C  8C420000   LW V0, 0(V0)
9D003BA0  00400008   JR V0
9D003BA4  00000000   NOP
1191:                            case eCHAR:
1192:                            case eNUMBER: 
1193:                                if (state) throw(eERR_SYNTAX);
9D003C10  52A00003   BEQL S5, ZERO, 0x9D003C20
9D003C14  92420005   LBU V0, 5(S2)
9D003C18  0F400080   JAL throw
9D003C1C  24040007   ADDIU A0, ZERO, 7
1194:                                if (var->vtype==eVAR_INTARRAY){
9D003B88  0B400F21   J 0x9D003C84
9D003B8C  241E0002   ADDIU S8, ZERO, 2
9D003C20  145E000A   BNE V0, S8, 0x9D003C4C
9D003C24  02F61021   ADDU V0, S7, S6
1195:                                    iarray[count++]=token.n;
9D003C28  26023918   ADDIU V0, S0, 14616
9D003C2C  8C430004   LW V1, 4(V0)
9D003C30  00161080   SLL V0, S6, 2
9D003C34  8FA40030   LW A0, 48(SP)
9D003C38  00821021   ADDU V0, A0, V0
9D003C3C  AC430000   SW V1, 0(V0)
9D003C40  26D60001   ADDIU S6, S6, 1
1196:                                }else{
1197:                                    barray[count++]=(uint8_t)token.n;
9D003C4C  26033918   ADDIU V1, S0, 14616
9D003C50  8C630004   LW V1, 4(V1)
9D003C54  A0430000   SB V1, 0(V0)
9D003C58  26D60001   ADDIU S6, S6, 1
1198:                                }
1199:                                state=1;
9D003C44  0B400F1F   J 0x9D003C7C
9D003C48  24150001   ADDIU S5, ZERO, 1
9D003C5C  0B400F1F   J 0x9D003C7C
9D003C60  24150001   ADDIU S5, ZERO, 1
1200:                                break;
1201:                            case eCOMMA:
1202:                                if (!state){
9D003C64  16A00005   BNE S5, ZERO, 0x9D003C7C
9D003C68  0000A821   ADDU S5, ZERO, ZERO
1203:                                    throw(eERR_SYNTAX);
9D003C6C  0F400080   JAL throw
9D003C70  24040007   ADDIU A0, ZERO, 7
1204:                                }else{
1205:                                    state=0;
1206:                                }
1207:                                break;
1208:                            case eRPAREN:
1209:                                continue;
1210:                                break;
1211:                            case eSTOP:
1212:                                break;
1213:                            default:
1214:                                throw(eERR_SYNTAX);
9D003C74  0F400080   JAL throw
9D003C78  24040007   ADDIU A0, ZERO, 7
1215:                        }//switch
1216:                        next_token();
9D003C7C  0F4001A6   JAL next_token
9D003C80  00000000   NOP
1217:                    }
1218:                    if (count<size) throw(eERR_MISSING_ARG);
9D003C90  8FA30034   LW V1, 52(SP)
9D003C94  02C3102A   SLT V0, S6, V1
9D003C98  50400003   BEQL V0, ZERO, 0x9D003CA8
9D003C9C  92430005   LBU V1, 5(S2)
9D003CA0  0F400080   JAL throw
9D003CA4  24040004   ADDIU A0, ZERO, 4
1219:                    if (((var->vtype==eVAR_BYTEARRAY) && (count>(size+2))) ||
9D003CA8  24020003   ADDIU V0, ZERO, 3
9D003CAC  14620008   BNE V1, V0, 0x9D003CD0
9D003CB0  8FA30034   LW V1, 52(SP)
9D003CB4  8FA40034   LW A0, 52(SP)
9D003CB8  24820002   ADDIU V0, A0, 2
9D003CBC  0056B02A   SLT S6, V0, S6
9D003CC0  12C00035   BEQ S6, ZERO, 0x9D003D98
9D003CC4  00000000   NOP
9D003CC8  0B400F38   J 0x9D003CE0
9D003CCC  00000000   NOP
1220:                        ((var->vtype!=eVAR_BYTEARRAY) && (count>(size+1)))) throw(eERR_EXTRA_ARG);
9D003CD0  24620001   ADDIU V0, V1, 1
9D003CD4  0056B02A   SLT S6, V0, S6
9D003CD8  12C0002F   BEQ S6, ZERO, 0x9D003D98
9D003CDC  00000000   NOP
9D003CE0  0F400080   JAL throw
9D003CE4  24040005   ADDIU A0, ZERO, 5
1221:                }//f
1222:                
1223:                static void init_str_array(var_t *var){
1224:                    uint32_t *array,size;
1225:                    int count=1,state=0;
9D003A3C  24140001   ADDIU S4, ZERO, 1
1226:                    char *newstr;
1227:                    
1228:                    complevel++;
9D003A18  8F828064   LW V0, -32668(GP)
9D003A1C  24420001   ADDIU V0, V0, 1
9D003A20  AF828064   SW V0, -32668(GP)
1229:                    array=var->adr;
9D003A24  8E57000C   LW S7, 12(S2)
1230:                    size=array[0];
9D003A28  8EFE0000   LW S8, 0(S7)
1231:                    expect(eLPAREN);
9D003A2C  0F4003EC   JAL expect
9D003A30  2404000C   ADDIU A0, ZERO, 12
1232:                    next_token();
9D003A34  0F4001A6   JAL next_token
9D003A38  0000B021   ADDU S6, ZERO, ZERO
1233:                    while(token.id!=eRPAREN){
9D003A40  2415000D   ADDIU S5, ZERO, 13
9D003AF0  8E023918   LW V0, 14616(S0)
9D003AF4  1455FFD5   BNE V0, S5, 0x9D003A4C
9D003AF8  00000000   NOP
1234:                        switch (token.id){
9D003A44  0B400EBC   J 0x9D003AF0
9D003A48  24120005   ADDIU S2, ZERO, 5
9D003A4C  1052000E   BEQ V0, S2, 0x9D003A88
9D003A50  2C430006   SLTIU V1, V0, 6
9D003A54  10600006   BEQ V1, ZERO, 0x9D003A70
9D003A58  2403000B   ADDIU V1, ZERO, 11
9D003A5C  24030001   ADDIU V1, ZERO, 1
9D003A60  10430021   BEQ V0, V1, 0x9D003AE8
9D003A64  00000000   NOP
9D003A68  0B400EB8   J 0x9D003AE0
9D003A6C  00000000   NOP
9D003A70  10430017   BEQ V0, V1, 0x9D003AD0
9D003A74  2403000D   ADDIU V1, ZERO, 13
9D003A78  10430021   BEQ V0, V1, 0x9D003B00
9D003A7C  029E102B   SLTU V0, S4, S8
9D003A80  0B400EB8   J 0x9D003AE0
9D003A84  00000000   NOP
1235:                            case eSTRING: 
1236:                                if (state) throw(eERR_SYNTAX);
9D003A88  12C00003   BEQ S6, ZERO, 0x9D003A98
9D003A8C  00000000   NOP
9D003A90  0F400080   JAL throw
9D003A94  24040007   ADDIU A0, ZERO, 7
1237:                                newstr=alloc_var_space(strlen(token.str)+1);
9D003A98  0F406EC2   JAL strlen
9D003A9C  02202021   ADDU A0, S1, ZERO
9D003AA0  0F400104   JAL alloc_var_space
9D003AA4  24440001   ADDIU A0, V0, 1
9D003AA8  0040B021   ADDU S6, V0, ZERO
1238:                                strcpy(newstr,token.str);
9D003AAC  00402021   ADDU A0, V0, ZERO
9D003AB0  0F406D40   JAL strcpy
9D003AB4  02202821   ADDU A1, S1, ZERO
1239:                                array[count++]=(uint32_t)newstr;
9D003AB8  00141080   SLL V0, S4, 2
9D003ABC  02E21021   ADDU V0, S7, V0
9D003AC0  AC560000   SW S6, 0(V0)
9D003AC4  26940001   ADDIU S4, S4, 1
1240:                                state=1;
9D003AC8  0B400EBA   J 0x9D003AE8
9D003ACC  24160001   ADDIU S6, ZERO, 1
1241:                                break;
1242:                            case eCOMMA:
1243:                                if (!state){
9D003AD0  56C00005   BNEL S6, ZERO, 0x9D003AE8
9D003AD4  0000B021   ADDU S6, ZERO, ZERO
1244:                                    count++;
9D003AD8  0B400EBA   J 0x9D003AE8
9D003ADC  26940001   ADDIU S4, S4, 1
1245:                                }else{
1246:                                    state=0;
1247:                                }
1248:                                break;
1249:                            case eRPAREN:
1250:                                continue;
1251:                                break;
1252:                            case eSTOP:
1253:                                break;
1254:                            default:
1255:                                throw(eERR_SYNTAX);
9D003AE0  0F400080   JAL throw
9D003AE4  24040007   ADDIU A0, ZERO, 7
1256:                        }
1257:                        next_token();
9D003AE8  0F4001A6   JAL next_token
9D003AEC  00000000   NOP
1258:                    }
1259:                    if (count<size) throw(eERR_MISSING_ARG);
9D003AFC  029E102B   SLTU V0, S4, S8
9D003B00  50400003   BEQL V0, ZERO, 0x9D003B10
9D003B04  27DE0001   ADDIU S8, S8, 1
9D003B08  0F400080   JAL throw
9D003B0C  24040004   ADDIU A0, ZERO, 4
1260:                    if (count>(size+1)) throw(eERR_EXTRA_ARG);
9D003B10  03D4A02B   SLTU S4, S8, S4
9D003B14  12800003   BEQ S4, ZERO, 0x9D003B24
9D003B18  8F828064   LW V0, -32668(GP)
9D003B1C  0F400080   JAL throw
9D003B20  24040005   ADDIU A0, ZERO, 5
1261:                    complevel--;
9D003B24  2442FFFF   ADDIU V0, V0, -1
9D003B28  0B400F66   J 0x9D003D98
9D003B2C  AF828064   SW V0, -32668(GP)
1262:                }//f
1263:                
1264:                static void dim_array(char *var_name){
1265:                    int size=0, len;
1266:                    void *array;
1267:                    var_t *new_var, *var;
1268:                    
1269:                    next_token();
9D0038B0  0F4001A6   JAL next_token
9D0038B4  00000000   NOP
1270:                    if (token.id==eNUMBER){
9D0038B8  8E023918   LW V0, 14616(S0)
9D0038BC  24030004   ADDIU V1, ZERO, 4
9D0038C0  14430004   BNE V0, V1, 0x9D0038D4
9D0038C4  24030003   ADDIU V1, ZERO, 3
1271:                        size=token.n;
9D0038C8  26023918   ADDIU V0, S0, 14616
9D0038CC  0B400E42   J 0x9D003908
9D0038D0  8C520004   LW S2, 4(V0)
1272:                    }else if (token.id==eIDENT){
9D0038D4  1443000A   BNE V0, V1, 0x9D003900
9D0038D8  00000000   NOP
1273:                        var=var_search(token.str);
9D0038DC  0F40006B   JAL var_search
9D0038E0  02202021   ADDU A0, S1, ZERO
1274:                        if (!(var && (var->vtype==eVAR_CONST))) throw(eERR_BAD_ARG);
9D0038E4  10400004   BEQ V0, ZERO, 0x9D0038F8
9D0038E8  24030008   ADDIU V1, ZERO, 8
9D0038EC  90440005   LBU A0, 5(V0)
9D0038F0  50830005   BEQL A0, V1, 0x9D003908
9D0038F4  8C52000C   LW S2, 12(V0)
9D0038F8  0F400080   JAL throw
9D0038FC  24040006   ADDIU A0, ZERO, 6
1275:                        size=var->n;
1276:                    }else{
1277:                        throw(eERR_BAD_ARG);
9D003900  0F400080   JAL throw
9D003904  24040006   ADDIU A0, ZERO, 6
1278:                    }
1279:                    expect(eRPAREN);
9D003908  0F4003EC   JAL expect
9D00390C  2404000D   ADDIU A0, ZERO, 13
1280:                    len=strlen(var_name);
9D003910  0F406EC2   JAL strlen
9D003914  27A40010   ADDIU A0, SP, 16
1281:                    if (size<1) throw(eERR_BAD_ARG);
9D003918  1E400003   BGTZ S2, 0x9D003928
9D00391C  0040B021   ADDU S6, V0, ZERO
9D003920  0F400080   JAL throw
9D003924  24040006   ADDIU A0, ZERO, 6
1282:                    if (var_name[len-1]=='#'){ //table d'octets
9D003928  03A2A821   ADDU S5, SP, V0
9D00392C  26B5000F   ADDIU S5, S5, 15
9D003930  82A30000   LB V1, 0(S5)
9D003934  24020023   ADDIU V0, ZERO, 35
9D003938  5462000B   BNEL V1, V0, 0x9D003968
9D00393C  26570001   ADDIU S7, S2, 1
1283:                        array=alloc_var_space(size+2);
9D003940  26570002   ADDIU S7, S2, 2
9D003944  0F400104   JAL alloc_var_space
9D003948  02E02021   ADDU A0, S7, ZERO
9D00394C  0040A021   ADDU S4, V0, ZERO
1284:                        memset(array,0,size+2);
9D003950  00402021   ADDU A0, V0, ZERO
9D003954  00002821   ADDU A1, ZERO, ZERO
9D003958  0F40775D   JAL memset
9D00395C  02E03021   ADDU A2, S7, ZERO
1285:                        *((uint32_t*)array)=size;
9D003960  0B400E63   J 0x9D00398C
9D003964  AE920000   SW S2, 0(S4)
1286:                    }else{ // table d'entiers ou de chaînes
1287:                        array=alloc_var_space(sizeof(int)*(size+1));
9D003968  0017B880   SLL S7, S7, 2
9D00396C  0F400104   JAL alloc_var_space
9D003970  02E02021   ADDU A0, S7, ZERO
9D003974  0040A021   ADDU S4, V0, ZERO
1288:                        memset(array,0,sizeof(int)*(size+1));
9D003978  00402021   ADDU A0, V0, ZERO
9D00397C  00002821   ADDU A1, ZERO, ZERO
9D003980  0F40775D   JAL memset
9D003984  02E03021   ADDU A2, S7, ZERO
1289:                        *((uint32_t*)array)=size;
9D003988  AE920000   SW S2, 0(S4)
1290:                    }
1291:                    new_var=(var_t*)alloc_var_space(sizeof(var_t));
9D00398C  0F400104   JAL alloc_var_space
9D003990  24040010   ADDIU A0, ZERO, 16
9D003994  00409021   ADDU S2, V0, ZERO
1292:                    new_var->name=alloc_var_space(len+1);
9D003998  0F400104   JAL alloc_var_space
9D00399C  26C40001   ADDIU A0, S6, 1
9D0039A0  AE420008   SW V0, 8(S2)
1293:                    strcpy(new_var->name,var_name);
9D0039A4  00402021   ADDU A0, V0, ZERO
9D0039A8  0F406D40   JAL strcpy
9D0039AC  27A50010   ADDIU A1, SP, 16
1294:                    new_var->adr=array;
9D0039B0  AE54000C   SW S4, 12(S2)
1295:                    if (var_name[len-1]=='$'){
9D0039B4  82A20000   LB V0, 0(S5)
9D0039B8  24030024   ADDIU V1, ZERO, 36
9D0039BC  14430004   BNE V0, V1, 0x9D0039D0
9D0039C0  24030023   ADDIU V1, ZERO, 35
1296:                        new_var->vtype=eVAR_STRARRAY;
9D0039C4  24020004   ADDIU V0, ZERO, 4
9D0039C8  0B400E7A   J 0x9D0039E8
9D0039CC  A2420005   SB V0, 5(S2)
1297:                    }else if (var_name[len-1]=='#'){
9D0039D0  14430004   BNE V0, V1, 0x9D0039E4
9D0039D4  24020002   ADDIU V0, ZERO, 2
1298:                        new_var->vtype=eVAR_BYTEARRAY;
9D0039D8  24020003   ADDIU V0, ZERO, 3
9D0039DC  0B400E7A   J 0x9D0039E8
9D0039E0  A2420005   SB V0, 5(S2)
1299:                    }else{
1300:                        new_var->vtype=eVAR_INTARRAY;
9D0039E4  A2420005   SB V0, 5(S2)
1301:                    }
1302:                    new_var->next=varlist;
9D0039E8  8F828080   LW V0, -32640(GP)
9D0039EC  AE420000   SW V0, 0(S2)
1303:                    varlist=new_var;
1304:                    next_token();
9D0039F0  0F4001A6   JAL next_token
9D0039F4  AF928080   SW S2, -32640(GP)
1305:                    if (token.id==eEQUAL){
9D0039F8  8E033918   LW V1, 14616(S0)
9D0039FC  2402000F   ADDIU V0, ZERO, 15
9D003A00  146200B9   BNE V1, V0, 0x9D003CE8
9D003A04  24020001   ADDIU V0, ZERO, 1
1306:                        if (new_var->vtype==eVAR_STRARRAY){
9D003A08  92560005   LBU S6, 5(S2)
9D003A0C  24020004   ADDIU V0, ZERO, 4
9D003A10  16C20047   BNE S6, V0, 0x9D003B30
9D003A14  24020002   ADDIU V0, ZERO, 2
1307:                            init_str_array(new_var);
1308:                        }else{
1309:                            init_int_array(new_var);
1310:                        }
1311:                    }else{
1312:                        unget_token=true;
9D003CE8  0B400F66   J 0x9D003D98
9D003CEC  A3828084   SB V0, -32636(GP)
1313:                    }
1314:                }//f
1315:                
1316:                // DIM identifier['('number')'] {','identifier['('number')']}|
1317:                //     identifier['='expression] {','identifier['='expression]}|
1318:                //     identifier$= STRING|
1319:                //     identifier$='('string{,string}')'
1320:                //     identifier['#']='('number{,number}')'
1321:                
1322:                static void kw_dim(){
9D003814  27BDFFA0   ADDIU SP, SP, -96
9D003818  AFBF005C   SW RA, 92(SP)
9D00381C  AFBE0058   SW S8, 88(SP)
9D003820  AFB70054   SW S7, 84(SP)
9D003824  AFB60050   SW S6, 80(SP)
9D003828  AFB5004C   SW S5, 76(SP)
9D00382C  AFB40048   SW S4, 72(SP)
9D003830  AFB30044   SW S3, 68(SP)
9D003834  AFB20040   SW S2, 64(SP)
9D003838  AFB1003C   SW S1, 60(SP)
9D00383C  AFB00038   SW S0, 56(SP)
1323:                    char var_name[32];
1324:                    var_t *new_var;
1325:                    
1326:                    expect(eIDENT);
9D003840  0F4003EC   JAL expect
9D003844  24040003   ADDIU A0, ZERO, 3
1327:                    while (token.id==eIDENT){
9D003848  3C10A000   LUI S0, -24576
9D003858  0B400F6E   J 0x9D003DB8
9D00385C  26733BA8   ADDIU S3, S3, 15272
9D003DB8  8E033918   LW V1, 14616(S0)
9D003DBC  24020003   ADDIU V0, ZERO, 3
9D003DC0  1062FEA7   BEQ V1, V0, 0x9D003860
9D003DC4  24020001   ADDIU V0, ZERO, 1
1328:                        if (var_search(token.str)) throw(eERR_REDEF);
9D00384C  3C11A000   LUI S1, -24576
9D003850  2631391C   ADDIU S1, S1, 14620
9D003860  0F40006B   JAL var_search
9D003864  02202021   ADDU A0, S1, ZERO
9D003868  10400003   BEQ V0, ZERO, 0x9D003878
9D00386C  27A40010   ADDIU A0, SP, 16
9D003870  0F400080   JAL throw
9D003874  24040009   ADDIU A0, ZERO, 9
1329:                        strcpy(var_name,token.str);
9D003878  0F406D40   JAL strcpy
9D00387C  02202821   ADDU A1, S1, ZERO
1330:                        next_token();
9D003880  0F4001A6   JAL next_token
9D003884  00000000   NOP
1331:                        switch(token.id){
9D003888  8E023918   LW V0, 14616(S0)
9D00388C  2403000C   ADDIU V1, ZERO, 12
9D003890  10430007   BEQ V0, V1, 0x9D0038B0
9D003894  2403000F   ADDIU V1, ZERO, 15
9D003898  10430119   BEQ V0, V1, 0x9D003D00
9D00389C  2403000B   ADDIU V1, ZERO, 11
9D0038A0  14430139   BNE V0, V1, 0x9D003D88
9D0038A4  27A40010   ADDIU A0, SP, 16
9D0038A8  0B400F3C   J 0x9D003CF0
9D0038AC  00000000   NOP
1332:                            case eLPAREN:
1333:                                dim_array(var_name);
1334:                                break;
1335:                            case eCOMMA:
1336:                                new_var=var_create(var_name,NULL);
9D003CF0  0F400115   JAL var_create
9D003CF4  00002821   ADDU A1, ZERO, ZERO
1337:                                break;
9D003CF8  0B400F66   J 0x9D003D98
9D003CFC  00000000   NOP
1338:                            case eEQUAL:
1339:                                new_var=var_create(var_name,NULL);
9D003D00  27A40010   ADDIU A0, SP, 16
9D003D04  0F400115   JAL var_create
9D003D08  00002821   ADDU A1, ZERO, ZERO
9D003D0C  00409021   ADDU S2, V0, ZERO
1340:                                if (new_var->vtype==eVAR_STR){
9D003D10  90430005   LBU V1, 5(V0)
9D003D14  24020001   ADDIU V0, ZERO, 1
9D003D18  14620013   BNE V1, V0, 0x9D003D68
9D003D1C  00000000   NOP
1341:                                    next_token();
9D003D20  0F4001A6   JAL next_token
9D003D24  00000000   NOP
1342:                                    if (token.id!=eSTRING) throw(eERR_BAD_ARG);
9D003D28  8E033918   LW V1, 14616(S0)
9D003D2C  24020005   ADDIU V0, ZERO, 5
9D003D30  10620003   BEQ V1, V0, 0x9D003D40
9D003D34  00000000   NOP
9D003D38  0F400080   JAL throw
9D003D3C  24040006   ADDIU A0, ZERO, 6
1343:                                    new_var->str=alloc_var_space(strlen(token.str)+1);
9D003D40  0F406EC2   JAL strlen
9D003D44  02202021   ADDU A0, S1, ZERO
9D003D48  0F400104   JAL alloc_var_space
9D003D4C  24440001   ADDIU A0, V0, 1
9D003D50  AE42000C   SW V0, 12(S2)
1344:                                    strcpy((char*)new_var->str,token.str);
9D003D54  00402021   ADDU A0, V0, ZERO
9D003D58  0F406D40   JAL strcpy
9D003D5C  02202821   ADDU A1, S1, ZERO
9D003D60  0B400F66   J 0x9D003D98
9D003D64  00000000   NOP
1345:                                }else{
1346:                                    expression();
9D003D68  0F400799   JAL expression
9D003D6C  00000000   NOP
1347:                                    _lit((uint32_t)&new_var->n);
9D003D70  0F400445   JAL bytecode
9D003D74  24040001   ADDIU A0, ZERO, 1
1348:                                    bytecode(ISTORE);
9D003D78  0F400445   JAL bytecode
9D003D7C  24040009   ADDIU A0, ZERO, 9
9D003D80  0B400F66   J 0x9D003D98
9D003D84  00000000   NOP
1349:                                }
1350:                                break;
1351:                            default:
1352:                                new_var=var_create(var_name,NULL);
9D003D88  0F400115   JAL var_create
9D003D8C  00002821   ADDU A1, ZERO, ZERO
1353:                                unget_token=true;
9D003D90  24020001   ADDIU V0, ZERO, 1
9D003D94  A3828084   SB V0, -32636(GP)
1354:                                break;
1355:                                
1356:                        }//switch
1357:                        next_token();
9D003D98  0F4001A6   JAL next_token
9D003D9C  00000000   NOP
1358:                        if (token.id==eCOMMA) next_token();
9D003DA0  8E033918   LW V1, 14616(S0)
9D003DA4  2402000B   ADDIU V0, ZERO, 11
9D003DA8  14620005   BNE V1, V0, 0x9D003DC0
9D003DAC  24020003   ADDIU V0, ZERO, 3
9D003DB0  0F4001A6   JAL next_token
9D003DB4  00000000   NOP
1359:                    }//while
1360:                    unget_token=true;
9D003DC8  A3828084   SB V0, -32636(GP)
1361:                }//f
9D003DCC  8FBF005C   LW RA, 92(SP)
9D003DD0  8FBE0058   LW S8, 88(SP)
9D003DD4  8FB70054   LW S7, 84(SP)
9D003DD8  8FB60050   LW S6, 80(SP)
9D003DDC  8FB5004C   LW S5, 76(SP)
9D003DE0  8FB40048   LW S4, 72(SP)
9D003DE4  8FB30044   LW S3, 68(SP)
9D003DE8  8FB20040   LW S2, 64(SP)
9D003DEC  8FB1003C   LW S1, 60(SP)
9D003DF0  8FB00038   LW S0, 56(SP)
9D003DF4  03E00008   JR RA
9D003DF8  27BD0060   ADDIU SP, SP, 96
1362:                
1363:                //passe une variable par référence
1364:                static void kw_ref(){
9D0017E8  27BDFFE8   ADDIU SP, SP, -24
9D0017EC  AFBF0014   SW RA, 20(SP)
1365:                    var_t *var;
1366:                    
1367:                    next_token();
9D0017F0  0F4001A6   JAL next_token
9D0017F4  AFB00010   SW S0, 16(SP)
1368:                    if (token.id!=eIDENT) throw(eERR_BAD_ARG);
9D0017F8  3C02A000   LUI V0, -24576
9D0017FC  8C433918   LW V1, 14616(V0)
9D001800  24020003   ADDIU V0, ZERO, 3
9D001804  50620003   BEQL V1, V0, 0x9D001814
9D001808  3C04A000   LUI A0, -24576
9D00180C  0F400080   JAL throw
9D001810  24040006   ADDIU A0, ZERO, 6
1369:                    var=var_search(token.str);
9D001814  0F40006B   JAL var_search
9D001818  2484391C   ADDIU A0, A0, 14620
1370:                    if (!var) throw(eERR_BAD_ARG);
9D00181C  14400003   BNE V0, ZERO, 0x9D00182C
9D001820  00408021   ADDU S0, V0, ZERO
9D001824  0F400080   JAL throw
9D001828  24040006   ADDIU A0, ZERO, 6
1371:                    bytecode(ILIT);
9D00182C  0F400445   JAL bytecode
9D001830  24040001   ADDIU A0, ZERO, 1
1372:                    switch(var->vtype){
9D001834  92020005   LBU V0, 5(S0)
9D001838  2C420009   SLTIU V0, V0, 9
9D00183C  10400028   BEQ V0, ZERO, 0x9D0018E0
9D001840  3C029D00   LUI V0, -25344
9D001844  92030005   LBU V1, 5(S0)
9D001848  00031880   SLL V1, V1, 2
9D00184C  24421860   ADDIU V0, V0, 6240
9D001850  00431021   ADDU V0, V0, V1
9D001854  8C420000   LW V0, 0(V0)
9D001858  00400008   JR V0
9D00185C  00000000   NOP
1373:                    case eVAR_INT:
1374:                    case eVAR_CONST:
1375:                        bytecode(_byte0((uint32_t)&var->n));
9D001884  2610000C   ADDIU S0, S0, 12
9D001888  0F400445   JAL bytecode
9D00188C  320400FF   ANDI A0, S0, 255
1376:                        bytecode(_byte1((uint32_t)&var->n));
9D001890  0F400445   JAL bytecode
9D001894  7E043A00   EXT A0, S0, 8, 8
1377:                        break;
9D001898  0B40063A   J 0x9D0018E8
9D00189C  8FBF0014   LW RA, 20(SP)
1378:                    case eVAR_INTARRAY:
1379:                    case eVAR_STRARRAY:
1380:                    case eVAR_BYTEARRAY:
1381:                        bytecode(_byte0(((uint32_t)var->adr)+2));
9D0018A0  8E04000C   LW A0, 12(S0)
9D0018A4  24840002   ADDIU A0, A0, 2
9D0018A8  0F400445   JAL bytecode
9D0018AC  308400FF   ANDI A0, A0, 255
1382:                        bytecode(_byte1(((uint32_t)var->adr)+2));
9D0018B0  8E04000C   LW A0, 12(S0)
9D0018B4  24840002   ADDIU A0, A0, 2
9D0018B8  0F400445   JAL bytecode
9D0018BC  7C843A00   EXT A0, A0, 8, 8
1383:                        break;
9D0018C0  0B40063A   J 0x9D0018E8
9D0018C4  8FBF0014   LW RA, 20(SP)
1384:                    case eVAR_FUNC:
1385:                    case eVAR_SUB:
1386:                    case eVAR_STR:
1387:                        bytecode(_byte0((uint32_t)var->adr));
9D0018C8  0F400445   JAL bytecode
9D0018CC  9204000C   LBU A0, 12(S0)
1388:                        bytecode(_byte1((uint32_t)var->adr));
9D0018D0  0F400445   JAL bytecode
9D0018D4  9204000D   LBU A0, 13(S0)
1389:                        break;
9D0018D8  0B40063A   J 0x9D0018E8
9D0018DC  8FBF0014   LW RA, 20(SP)
1390:                    default:
1391:                        throw(eERR_BAD_ARG);
9D0018E0  0F400080   JAL throw
9D0018E4  24040006   ADDIU A0, ZERO, 6
1392:                    }//switch
1393:                }//f
9D0018E8  8FB00010   LW S0, 16(SP)
9D0018EC  03E00008   JR RA
9D0018F0  27BD0018   ADDIU SP, SP, 24
1394:                
1395:                // UBOUND(var_name)
1396:                // retourne le dernier indice
1397:                // du tableau
1398:                static void kw_ubound(){
9D0014CC  27BDFFC8   ADDIU SP, SP, -56
9D0014D0  AFBF0034   SW RA, 52(SP)
1399:                    var_t *var;
1400:                    char name[32];
1401:                    expect(eLPAREN);
9D0014D4  0F4003EC   JAL expect
9D0014D8  2404000C   ADDIU A0, ZERO, 12
1402:                    expect(eIDENT);
9D0014DC  0F4003EC   JAL expect
9D0014E0  24040003   ADDIU A0, ZERO, 3
1403:                    strcpy(name,token.str);
9D0014E4  27A40010   ADDIU A0, SP, 16
9D0014E8  3C05A000   LUI A1, -24576
9D0014EC  0F406D40   JAL strcpy
9D0014F0  24A5391C   ADDIU A1, A1, 14620
1404:                    expect(eRPAREN);
9D0014F4  0F4003EC   JAL expect
9D0014F8  2404000D   ADDIU A0, ZERO, 13
1405:                    var=var_search(name);
9D0014FC  0F40006B   JAL var_search
9D001500  27A40010   ADDIU A0, SP, 16
1406:                    if (!var || !(var->vtype>=eVAR_INTARRAY && var->vtype<=eVAR_STRARRAY)) throw(eERR_BAD_ARG);
9D001504  10400007   BEQ V0, ZERO, 0x9D001524
9D001508  00000000   NOP
9D00150C  90420005   LBU V0, 5(V0)
9D001510  2442FFFE   ADDIU V0, V0, -2
9D001514  304200FF   ANDI V0, V0, 255
9D001518  2C420003   SLTIU V0, V0, 3
9D00151C  14400003   BNE V0, ZERO, 0x9D00152C
9D001520  00000000   NOP
9D001524  0F400080   JAL throw
9D001528  24040006   ADDIU A0, ZERO, 6
1407:                    _lit((uint32_t)var->adr);
9D00152C  0F400445   JAL bytecode
9D001530  24040001   ADDIU A0, ZERO, 1
1408:                    bytecode(IUBOUND);
9D001534  0F400445   JAL bytecode
9D001538  24040090   ADDIU A0, ZERO, 144
1409:                }//f
9D00153C  8FBF0034   LW RA, 52(SP)
9D001540  03E00008   JR RA
9D001544  27BD0038   ADDIU SP, SP, 56
1410:                
1411:                static void kw_use(){
9D004514  27BDFEC8   ADDIU SP, SP, -312
9D004518  AFBF0134   SW RA, 308(SP)
9D00451C  AFB20130   SW S2, 304(SP)
9D004520  AFB1012C   SW S1, 300(SP)
9D004524  AFB00128   SW S0, 296(SP)
1412:                    reader_t *old_reader, freader;
1413:                    FIL *fh;
1414:                    uint32_t lcount;
1415:                    FRESULT result;
1416:                    
1417:                    if (activ_reader->device==eDEV_KBD) throw(eERR_SYNTAX);
9D004528  8F828098   LW V0, -32616(GP)
9D00452C  8C420000   LW V0, 0(V0)
9D004530  14400003   BNE V0, ZERO, 0x9D004540
9D004534  00000000   NOP
9D004538  0F400080   JAL throw
9D00453C  24040007   ADDIU A0, ZERO, 7
1418:                    expect(eSTRING);
9D004540  0F4003EC   JAL expect
9D004544  24040005   ADDIU A0, ZERO, 5
1419:                    uppercase(token.str);
9D004548  3C10A000   LUI S0, -24576
9D00454C  0F404F53   JAL uppercase
9D004550  2604391C   ADDIU A0, S0, 14620
1420:                    if (!(result=f_open(fh,token.str,FA_READ))){
9D004554  00002021   ADDU A0, ZERO, ZERO
9D004558  2605391C   ADDIU A1, S0, 14620
9D00455C  0F4018E7   JAL f_open
9D004560  24060001   ADDIU A2, ZERO, 1
9D004564  1440001A   BNE V0, ZERO, 0x9D0045D0
9D004568  27B10010   ADDIU S1, SP, 16
1421:                        reader_init(&freader,eDEV_SDCARD,fh);
9D00456C  02202021   ADDU A0, S1, ZERO
9D004570  24050002   ADDIU A1, ZERO, 2
9D004574  00008021   ADDU S0, ZERO, ZERO
9D004578  0F406849   JAL reader_init
9D00457C  02003021   ADDU A2, S0, ZERO
1422:                        old_reader=activ_reader;
9D004580  8F928098   LW S2, -32616(GP)
1423:                        activ_reader=&freader;
9D004584  AF918098   SW S1, -32616(GP)
1424:                        compiler_msg(COMPILING, token.str);
9D004588  00002021   ADDU A0, ZERO, ZERO
9D00458C  3C05A000   LUI A1, -24576
9D004590  0F400041   JAL compiler_msg
9D004594  24A5391C   ADDIU A1, A1, 14620
1425:                        lcount=line_count;
9D004598  8F918090   LW S1, -32624(GP)
1426:                        line_count=1;
9D00459C  24020001   ADDIU V0, ZERO, 1
1427:                        compile();
9D0045A0  0F4010DC   JAL compile
9D0045A4  AF828090   SW V0, -32624(GP)
1428:                        line_count=lcount+1;
9D0045A8  26310001   ADDIU S1, S1, 1
9D0045AC  AF918090   SW S1, -32624(GP)
1429:                        f_close(fh);
9D0045B0  0F401BC6   JAL f_close
9D0045B4  02002021   ADDU A0, S0, ZERO
1430:                        activ_reader=old_reader;
9D0045B8  AF928098   SW S2, -32616(GP)
1431:                        compiler_msg(COMP_END,NULL);
9D0045BC  24040001   ADDIU A0, ZERO, 1
9D0045C0  0F400041   JAL compiler_msg
9D0045C4  00002821   ADDU A1, ZERO, ZERO
1432:                    }else{
1433:                        compiler_msg(COMP_FILE_ERROR,NULL);
9D0045D0  24040002   ADDIU A0, ZERO, 2
9D0045D4  0F400041   JAL compiler_msg
9D0045D8  00002821   ADDU A1, ZERO, ZERO
1434:                        throw(eERR_BAD_ARG);
9D0045DC  0F400080   JAL throw
9D0045E0  24040006   ADDIU A0, ZERO, 6
1435:                    }
1436:                }//f
9D0045C8  0B401179   J 0x9D0045E4
9D0045CC  8FBF0134   LW RA, 308(SP)
9D0045E4  8FB20130   LW S2, 304(SP)
9D0045E8  8FB1012C   LW S1, 300(SP)
9D0045EC  8FB00128   LW S0, 296(SP)
9D0045F0  03E00008   JR RA
9D0045F4  27BD0138   ADDIU SP, SP, 312
1437:                
1438:                //VIDEO(0|1)
1439:                // déactive|active la sortie vidéo
1440:                static void kw_video(){
9D002AE4  27BDFFE8   ADDIU SP, SP, -24
9D002AE8  AFBF0014   SW RA, 20(SP)
1441:                    parse_arg_list(1);
9D002AEC  0F40097D   JAL parse_arg_list
9D002AF0  24040001   ADDIU A0, ZERO, 1
1442:                    bytecode(IVIDEOCTRL);
9D002AF4  0F400445   JAL bytecode
9D002AF8  2404008F   ADDIU A0, ZERO, 143
1443:                }//f
9D002AFC  8FBF0014   LW RA, 20(SP)
9D002B00  03E00008   JR RA
9D002B04  27BD0018   ADDIU SP, SP, 24
1444:                
1445:                //CURLINE()
1446:                // retourne la position ligne du curseur texte
1447:                static void kw_curline(){
9D0032F4  27BDFFE8   ADDIU SP, SP, -24
9D0032F8  AFBF0014   SW RA, 20(SP)
1448:                    parse_arg_list(0);
9D0032FC  0F40097D   JAL parse_arg_list
9D003300  00002021   ADDU A0, ZERO, ZERO
1449:                    bytecode(ICURLINE);
9D003304  0F400445   JAL bytecode
9D003308  2404008E   ADDIU A0, ZERO, 142
1450:                }//f
9D00330C  8FBF0014   LW RA, 20(SP)
9D003310  03E00008   JR RA
9D003314  27BD0018   ADDIU SP, SP, 24
1451:                
1452:                //CURCOL()
1453:                // retourne la position colonne du curseur texte
1454:                static void kw_curcol(){
9D003318  27BDFFE8   ADDIU SP, SP, -24
9D00331C  AFBF0014   SW RA, 20(SP)
1455:                    parse_arg_list(0);
9D003320  0F40097D   JAL parse_arg_list
9D003324  00002021   ADDU A0, ZERO, ZERO
1456:                    bytecode(ICURCOL);
9D003328  0F400445   JAL bytecode
9D00332C  2404008D   ADDIU A0, ZERO, 141
1457:                }//f
9D003330  8FBF0014   LW RA, 20(SP)
9D003334  03E00008   JR RA
9D003338  27BD0018   ADDIU SP, SP, 24
1458:                
1459:                // EXEC @identifier
1460:                //static void kw_exec(){
1461:                //    expression();
1462:                //    bytecode(EXEC);
1463:                //}//f
1464:                
1465:                // COLOR(texte,fond)
1466:                // fixe couleur de police et du fond
1467:                static void kw_color(){
9D00333C  27BDFFE8   ADDIU SP, SP, -24
9D003340  AFBF0014   SW RA, 20(SP)
1468:                    parse_arg_list(2);
9D003344  0F40097D   JAL parse_arg_list
9D003348  24040002   ADDIU A0, ZERO, 2
1469:                    bytecode(IBACK_COLOR);
9D00334C  0F400445   JAL bytecode
9D003350  24040083   ADDIU A0, ZERO, 131
1470:                    bytecode(IFONT_COLOR);
9D003354  0F400445   JAL bytecode
9D003358  2404008C   ADDIU A0, ZERO, 140
1471:                }//f
9D00335C  8FBF0014   LW RA, 20(SP)
9D003360  03E00008   JR RA
9D003364  27BD0018   ADDIU SP, SP, 24
1472:                
1473:                // CONST  nom[$]=expr|string [, nom[$]=expr|string]
1474:                // définition d'une constante
1475:                static void kw_const(){
9D000FE8  27BDFFB8   ADDIU SP, SP, -72
9D000FEC  AFBF0044   SW RA, 68(SP)
9D000FF0  AFB40040   SW S4, 64(SP)
9D000FF4  AFB3003C   SW S3, 60(SP)
9D000FF8  AFB20038   SW S2, 56(SP)
9D000FFC  AFB10034   SW S1, 52(SP)
9D001000  AFB00030   SW S0, 48(SP)
1476:                    char name[32];
1477:                    var_t *var;
1478:                    
1479:                    expect(eIDENT);
9D001004  0F4003EC   JAL expect
9D001008  24040003   ADDIU A0, ZERO, 3
1480:                    while (token.id==eIDENT){
9D00100C  3C02A000   LUI V0, -24576
9D001010  8C433918   LW V1, 14616(V0)
9D001014  24020003   ADDIU V0, ZERO, 3
9D001018  14620034   BNE V1, V0, 0x9D0010EC
9D00101C  3C12A000   LUI S2, -24576
9D0010DC  8E233918   LW V1, 14616(S1)
9D0010E0  24020003   ADDIU V0, ZERO, 3
9D0010E4  5062FFD3   BEQL V1, V0, 0x9D001034
9D0010E8  27A40010   ADDIU A0, SP, 16
1481:                        strcpy(name,token.str);
9D001020  2652391C   ADDIU S2, S2, 14620
9D001030  27A40010   ADDIU A0, SP, 16
9D001034  0F406D40   JAL strcpy
9D001038  02402821   ADDU A1, S2, ZERO
1482:                        if ((var=var_search(name))) throw(eERR_REDEF);
9D00103C  0F40006B   JAL var_search
9D001040  27A40010   ADDIU A0, SP, 16
9D001044  10400003   BEQ V0, ZERO, 0x9D001054
9D001048  00000000   NOP
9D00104C  0F400080   JAL throw
9D001050  24040009   ADDIU A0, ZERO, 9
1483:                        expect(eEQUAL);
9D001054  0F4003EC   JAL expect
9D001058  2404000F   ADDIU A0, ZERO, 15
1484:                        var=var_create(name,NULL);
9D00105C  27A40010   ADDIU A0, SP, 16
9D001060  0F400115   JAL var_create
9D001064  00002821   ADDU A1, ZERO, ZERO
9D001068  00408021   ADDU S0, V0, ZERO
1485:                        if (var->vtype==eVAR_STR){
9D001024  24130001   ADDIU S3, ZERO, 1
9D00106C  90420005   LBU V0, 5(V0)
9D001070  5453000D   BNEL V0, S3, 0x9D0010A8
9D001074  A2140005   SB S4, 5(S0)
1486:                            expect(eSTRING);
9D001078  0F4003EC   JAL expect
9D00107C  24040005   ADDIU A0, ZERO, 5
1487:                            var->str=alloc_var_space(strlen(token.str)+1);
9D001080  0F406EC2   JAL strlen
9D001084  02402021   ADDU A0, S2, ZERO
9D001088  0F400104   JAL alloc_var_space
9D00108C  24440001   ADDIU A0, V0, 1
9D001090  AE02000C   SW V0, 12(S0)
1488:                            strcpy(var->str,token.str);
9D001094  00402021   ADDU A0, V0, ZERO
9D001098  0F406D40   JAL strcpy
9D00109C  02402821   ADDU A1, S2, ZERO
9D0010A0  0B40042F   J 0x9D0010BC
9D0010A4  00000000   NOP
1489:                        }else{
1490:                            var->vtype=eVAR_CONST;
9D001028  24140008   ADDIU S4, ZERO, 8
1491:                            expect(eNUMBER);
9D0010A8  0F4003EC   JAL expect
9D0010AC  24040004   ADDIU A0, ZERO, 4
1492:                            var->n=token.n;
9D00102C  3C11A000   LUI S1, -24576
9D0010B0  26223918   ADDIU V0, S1, 14616
9D0010B4  8C420004   LW V0, 4(V0)
9D0010B8  AE02000C   SW V0, 12(S0)
1493:                        }
1494:                        next_token();
9D0010BC  0F4001A6   JAL next_token
9D0010C0  00000000   NOP
1495:                        if (token.id==eCOMMA)
9D0010C4  8E233918   LW V1, 14616(S1)
9D0010C8  2402000B   ADDIU V0, ZERO, 11
9D0010CC  14620008   BNE V1, V0, 0x9D0010F0
9D0010D0  24020001   ADDIU V0, ZERO, 1
1496:                            expect(eIDENT);
9D0010D4  0F4003EC   JAL expect
9D0010D8  24040003   ADDIU A0, ZERO, 3
1497:                        else
1498:                            break;
1499:                    }//while
1500:                    unget_token=true;
9D0010EC  24020001   ADDIU V0, ZERO, 1
9D0010F0  A3828084   SB V0, -32636(GP)
1501:                }//f
9D0010F4  8FBF0044   LW RA, 68(SP)
9D0010F8  8FB40040   LW S4, 64(SP)
9D0010FC  8FB3003C   LW S3, 60(SP)
9D001100  8FB20038   LW S2, 56(SP)
9D001104  8FB10034   LW S1, 52(SP)
9D001108  8FB00030   LW S0, 48(SP)
9D00110C  03E00008   JR RA
9D001110  27BD0048   ADDIU SP, SP, 72
1502:                
1503:                // ABS(expression)
1504:                // fonction retourne valeur absolue
1505:                static void kw_abs(){
9D0033F8  27BDFFE8   ADDIU SP, SP, -24
9D0033FC  AFBF0014   SW RA, 20(SP)
1506:                    parse_arg_list(1);
9D003400  0F40097D   JAL parse_arg_list
9D003404  24040001   ADDIU A0, ZERO, 1
1507:                    bytecode(IABS);
9D003408  0F400445   JAL bytecode
9D00340C  24040033   ADDIU A0, ZERO, 51
1508:                }//f
9D003410  8FBF0014   LW RA, 20(SP)
9D003414  03E00008   JR RA
9D003418  27BD0018   ADDIU SP, SP, 24
1509:                
1510:                // SHL(expression)
1511:                // décalage à gauche de 1 bit
1512:                static void kw_shl(){
9D002C28  27BDFFE8   ADDIU SP, SP, -24
9D002C2C  AFBF0014   SW RA, 20(SP)
1513:                    parse_arg_list(1);
9D002C30  0F40097D   JAL parse_arg_list
9D002C34  24040001   ADDIU A0, ZERO, 1
1514:                    bytecode(ILSHIFT);
9D002C38  0F400445   JAL bytecode
9D002C3C  24040034   ADDIU A0, ZERO, 52
1515:                }//f
9D002C40  8FBF0014   LW RA, 20(SP)
9D002C44  03E00008   JR RA
9D002C48  27BD0018   ADDIU SP, SP, 24
1516:                
1517:                // SHR(expression)
1518:                // décale à droite de 1 bit
1519:                static void kw_shr(){
9D002C04  27BDFFE8   ADDIU SP, SP, -24
9D002C08  AFBF0014   SW RA, 20(SP)
1520:                    parse_arg_list(1);
9D002C0C  0F40097D   JAL parse_arg_list
9D002C10  24040001   ADDIU A0, ZERO, 1
1521:                    bytecode(IRSHIFT);
9D002C14  0F400445   JAL bytecode
9D002C18  24040035   ADDIU A0, ZERO, 53
1522:                }//f
9D002C1C  8FBF0014   LW RA, 20(SP)
9D002C20  03E00008   JR RA
9D002C24  27BD0018   ADDIU SP, SP, 24
1523:                
1524:                // BTEST(expression1,expression2{0-15})
1525:                // fonction test bit de expression1
1526:                // retourne vrai si 1
1527:                static void kw_btest(){
9D00338C  27BDFFE8   ADDIU SP, SP, -24
9D003390  AFBF0014   SW RA, 20(SP)
1528:                    parse_arg_list(2);
9D003394  0F40097D   JAL parse_arg_list
9D003398  24040002   ADDIU A0, ZERO, 2
1529:                    bytecode(IBTEST);
9D00339C  0F400445   JAL bytecode
9D0033A0  2404008B   ADDIU A0, ZERO, 139
1530:                }//f
9D0033A4  8FBF0014   LW RA, 20(SP)
9D0033A8  03E00008   JR RA
9D0033AC  27BD0018   ADDIU SP, SP, 24
1531:                
1532:                // BEEP(freq,msec,wait{0,1})
1533:                // fait entendre une tonalité
1534:                // durée ne millisecondes
1535:                static void kw_beep(){
9D0033D4  27BDFFE8   ADDIU SP, SP, -24
9D0033D8  AFBF0014   SW RA, 20(SP)
1536:                    parse_arg_list(3);
9D0033DC  0F40097D   JAL parse_arg_list
9D0033E0  24040003   ADDIU A0, ZERO, 3
1537:                    bytecode(IBEEP);
9D0033E4  0F400445   JAL bytecode
9D0033E8  2404008A   ADDIU A0, ZERO, 138
1538:                }//f
9D0033EC  8FBF0014   LW RA, 20(SP)
9D0033F0  03E00008   JR RA
9D0033F4  27BD0018   ADDIU SP, SP, 24
1539:                
1540:                
1541:                //TONE(note{0-47},msec,wait{0,1})
1542:                //fait entendre un note de la gamme tempérée
1543:                static void kw_tone(){
9D002B2C  27BDFFE8   ADDIU SP, SP, -24
9D002B30  AFBF0014   SW RA, 20(SP)
1544:                    parse_arg_list(3);
9D002B34  0F40097D   JAL parse_arg_list
9D002B38  24040003   ADDIU A0, ZERO, 3
1545:                    bytecode(ITONE);
9D002B3C  0F400445   JAL bytecode
9D002B40  24040089   ADDIU A0, ZERO, 137
1546:                }//f
9D002B44  8FBF0014   LW RA, 20(SP)
9D002B48  03E00008   JR RA
9D002B4C  27BD0018   ADDIU SP, SP, 24
1547:                
1548:                //PAUSE(msec)
1549:                // suspend exécution
1550:                // argument en millisecondes
1551:                static void kw_pause(){
9D002DD8  27BDFFE8   ADDIU SP, SP, -24
9D002DDC  AFBF0014   SW RA, 20(SP)
1552:                    parse_arg_list(1);
9D002DE0  0F40097D   JAL parse_arg_list
9D002DE4  24040001   ADDIU A0, ZERO, 1
1553:                    bytecode(IIDLE);
9D002DE8  0F400445   JAL bytecode
9D002DEC  24040088   ADDIU A0, ZERO, 136
1554:                }//f
9D002DF0  8FBF0014   LW RA, 20(SP)
9D002DF4  03E00008   JR RA
9D002DF8  27BD0018   ADDIU SP, SP, 24
1555:                
1556:                //TICKS()
1557:                //retourne la valeur du compteur
1558:                // de millisecondes du système
1559:                static void kw_ticks(){
9D002B50  27BDFFE8   ADDIU SP, SP, -24
9D002B54  AFBF0014   SW RA, 20(SP)
1560:                    parse_arg_list(0);
9D002B58  0F40097D   JAL parse_arg_list
9D002B5C  00002021   ADDU A0, ZERO, ZERO
1561:                    bytecode(ITICKS);
9D002B60  0F400445   JAL bytecode
9D002B64  24040026   ADDIU A0, ZERO, 38
1562:                }//f
9D002B68  8FBF0014   LW RA, 20(SP)
9D002B6C  03E00008   JR RA
9D002B70  27BD0018   ADDIU SP, SP, 24
1563:                
1564:                // SETTMR(msec)
1565:                // initialise _pause_timer
1566:                static void kw_set_timer(){
9D002C4C  27BDFFE8   ADDIU SP, SP, -24
9D002C50  AFBF0014   SW RA, 20(SP)
1567:                    parse_arg_list(1);
9D002C54  0F40097D   JAL parse_arg_list
9D002C58  24040001   ADDIU A0, ZERO, 1
1568:                    bytecode(ISETTMR);
9D002C5C  0F400445   JAL bytecode
9D002C60  24040087   ADDIU A0, ZERO, 135
1569:                }//f
9D002C64  8FBF0014   LW RA, 20(SP)
9D002C68  03E00008   JR RA
9D002C6C  27BD0018   ADDIU SP, SP, 24
1570:                
1571:                // TIMEOUT()
1572:                // retourne vrai si _pause_timer==0
1573:                static void kw_timeout(){
9D001228  27BDFFE8   ADDIU SP, SP, -24
9D00122C  AFBF0014   SW RA, 20(SP)
1574:                    expect(eLPAREN);
9D001230  0F4003EC   JAL expect
9D001234  2404000C   ADDIU A0, ZERO, 12
1575:                    expect(eRPAREN);
9D001238  0F4003EC   JAL expect
9D00123C  2404000D   ADDIU A0, ZERO, 13
1576:                    bytecode(ITIMEOUT);
9D001240  0F400445   JAL bytecode
9D001244  24040086   ADDIU A0, ZERO, 134
1577:                }//f
9D001248  8FBF0014   LW RA, 20(SP)
9D00124C  03E00008   JR RA
9D001250  27BD0018   ADDIU SP, SP, 24
1578:                
1579:                //NOISE(msec)
1580:                // génère un bruit blanc
1581:                // durée en millisecondes
1582:                static void kw_noise(){
9D002DFC  27BDFFE8   ADDIU SP, SP, -24
9D002E00  AFBF0014   SW RA, 20(SP)
1583:                    parse_arg_list(1);
9D002E04  0F40097D   JAL parse_arg_list
9D002E08  24040001   ADDIU A0, ZERO, 1
1584:                    bytecode(INOISE);
9D002E0C  0F400445   JAL bytecode
9D002E10  24040085   ADDIU A0, ZERO, 133
1585:                }//f
9D002E14  8FBF0014   LW RA, 20(SP)
9D002E18  03E00008   JR RA
9D002E1C  27BD0018   ADDIU SP, SP, 24
1586:                
1587:                // FONCTION BASIC: JSTICK()
1588:                // retourne un entier entre 0 et 31
1589:                // chaque bit représente un bouton
1590:                // 1=enfoncé, 0=relâché
1591:                // joystick Atari 2600
1592:                // bit 0 bouton
1593:                // bit 1 droite
1594:                // bit 2 gauche
1595:                // bit 3 bas
1596:                // bit 4 haut
1597:                static void kw_read_jstick(){
9D0012D4  27BDFFE8   ADDIU SP, SP, -24
9D0012D8  AFBF0014   SW RA, 20(SP)
1598:                    expect(eLPAREN);
9D0012DC  0F4003EC   JAL expect
9D0012E0  2404000C   ADDIU A0, ZERO, 12
1599:                    expect(eRPAREN);
9D0012E4  0F4003EC   JAL expect
9D0012E8  2404000D   ADDIU A0, ZERO, 13
1600:                    bytecode(IJSTICK);
9D0012EC  0F400445   JAL bytecode
9D0012F0  24040084   ADDIU A0, ZERO, 132
1601:                }//f
9D0012F4  8FBF0014   LW RA, 20(SP)
9D0012F8  03E00008   JR RA
9D0012FC  27BD0018   ADDIU SP, SP, 24
1602:                
1603:                //COMMANDE BASIC: BYE
1604:                //quitte l'interpréteur
1605:                static void kw_bye(){
9D001490  27BDFFE8   ADDIU SP, SP, -24
9D001494  AFBF0014   SW RA, 20(SP)
1606:                    if (!complevel && (activ_reader->device==eDEV_KBD)){
9D001498  8F828064   LW V0, -32668(GP)
9D00149C  14400006   BNE V0, ZERO, 0x9D0014B8
9D0014A0  8F828098   LW V0, -32616(GP)
9D0014A4  8C420000   LW V0, 0(V0)
9D0014A8  14400003   BNE V0, ZERO, 0x9D0014B8
9D0014AC  24020001   ADDIU V0, ZERO, 1
1607:                        exit_basic=true;
1608:                        return;
9D0014B0  0B400530   J 0x9D0014C0
9D0014B4  A38280A0   SB V0, -32608(GP)
1609:                    }
1610:                    bytecode(IBYE);
9D0014B8  0F400445   JAL bytecode
9D0014BC  00002021   ADDU A0, ZERO, ZERO
1611:                }//f
9D0014C0  8FBF0014   LW RA, 20(SP)
9D0014C4  03E00008   JR RA
9D0014C8  27BD0018   ADDIU SP, SP, 24
1612:                
1613:                // RETURN expression
1614:                // utilisé dans les fonctions
1615:                static void kw_return(){
9D0034EC  27BDFFE8   ADDIU SP, SP, -24
9D0034F0  AFBF0014   SW RA, 20(SP)
1616:                        expression();
9D0034F4  0F400799   JAL expression
9D0034F8  00000000   NOP
1617:                        bytecode(ILCSTORE);
9D0034FC  0F400445   JAL bytecode
9D003500  24040060   ADDIU A0, ZERO, 96
1618:                        bytecode(0);
9D003504  0F400445   JAL bytecode
9D003508  00002021   ADDU A0, ZERO, ZERO
1619:                        bytecode(ILEAVE);
9D00350C  0F400445   JAL bytecode
9D003510  24040080   ADDIU A0, ZERO, 128
1620:                        if (globals>varlist){
9D003514  8F828080   LW V0, -32640(GP)
9D003518  8F83807C   LW V1, -32644(GP)
9D00351C  0043182B   SLTU V1, V0, V1
9D003520  10600005   BEQ V1, ZERO, 0x9D003538
9D003524  00000000   NOP
1621:                            bytecode(varlist->n);
9D003528  0F400445   JAL bytecode
9D00352C  9044000C   LBU A0, 12(V0)
9D003530  0B400D51   J 0x9D003544
9D003534  8FBF0014   LW RA, 20(SP)
1622:                        }else{
1623:                            bytecode(0);
9D003538  0F400445   JAL bytecode
9D00353C  00002021   ADDU A0, ZERO, ZERO
1624:                        }
1625:                }//f
9D003540  8FBF0014   LW RA, 20(SP)
9D003544  03E00008   JR RA
9D003548  27BD0018   ADDIU SP, SP, 24
1626:                
1627:                // EXIT SUB
1628:                // termine l'exécution d'une sous-routine
1629:                // en n'importe quel point de celle-ci.
1630:                // sauf à l'intérieur d'une boucle FOR
1631:                static void kw_exit(){
9D001BE0  27BDFFE8   ADDIU SP, SP, -24
9D001BE4  AFBF0014   SW RA, 20(SP)
1632:                    expect(eKWORD);
9D001BE8  0F4003EC   JAL expect
9D001BEC  24040018   ADDIU A0, ZERO, 24
1633:                    if (token.n != eKW_SUB) throw(eERR_SYNTAX);
9D001BF0  3C02A000   LUI V0, -24576
9D001BF4  8C43391C   LW V1, 14620(V0)
9D001BF8  24020042   ADDIU V0, ZERO, 66
9D001BFC  10620003   BEQ V1, V0, 0x9D001C0C
9D001C00  00000000   NOP
9D001C04  0F400080   JAL throw
9D001C08  24040007   ADDIU A0, ZERO, 7
1634:                    bytecode(ILEAVE);
9D001C0C  0F400445   JAL bytecode
9D001C10  24040080   ADDIU A0, ZERO, 128
1635:                    if (globals>varlist){
9D001C14  8F828080   LW V0, -32640(GP)
9D001C18  8F83807C   LW V1, -32644(GP)
9D001C1C  0043182B   SLTU V1, V0, V1
9D001C20  10600005   BEQ V1, ZERO, 0x9D001C38
9D001C24  00000000   NOP
1636:                        bytecode(varlist->n);
9D001C28  0F400445   JAL bytecode
9D001C2C  9044000C   LBU A0, 12(V0)
9D001C30  0B400711   J 0x9D001C44
9D001C34  8FBF0014   LW RA, 20(SP)
1637:                    }else{
1638:                        bytecode(0);
9D001C38  0F400445   JAL bytecode
9D001C3C  00002021   ADDU A0, ZERO, ZERO
1639:                    }
1640:                }//f
9D001C40  8FBF0014   LW RA, 20(SP)
9D001C44  03E00008   JR RA
9D001C48  27BD0018   ADDIU SP, SP, 24
1641:                
1642:                // CLS [color]
1643:                // efface écran
1644:                // si argument couleur
1645:                // fixe la couleur de fond
1646:                static void kw_cls(){
9D00143C  27BDFFE8   ADDIU SP, SP, -24
9D001440  AFBF0014   SW RA, 20(SP)
1647:                    uint8_t color;
1648:                   
1649:                    next_token();
9D001444  0F4001A6   JAL next_token
9D001448  00000000   NOP
1650:                    if (token.id==eNUMBER){
9D00144C  3C02A000   LUI V0, -24576
9D001450  8C433918   LW V1, 14616(V0)
9D001454  24020004   ADDIU V0, ZERO, 4
9D001458  14620007   BNE V1, V0, 0x9D001478
9D00145C  24020001   ADDIU V0, ZERO, 1
1651:                        color=token.n;
1652:                        _litc(color);
9D001460  0F400445   JAL bytecode
9D001464  24040003   ADDIU A0, ZERO, 3
1653:                        bytecode(IBACK_COLOR);
9D001468  0F400445   JAL bytecode
9D00146C  24040083   ADDIU A0, ZERO, 131
9D001470  0B40051F   J 0x9D00147C
9D001474  00000000   NOP
1654:                    }else{
1655:                        unget_token=true;
9D001478  A3828084   SB V0, -32636(GP)
1656:                    }
1657:                    bytecode(ICLS);
9D00147C  0F400445   JAL bytecode
9D001480  24040082   ADDIU A0, ZERO, 130
1658:                }//f
9D001484  8FBF0014   LW RA, 20(SP)
9D001488  03E00008   JR RA
9D00148C  27BD0018   ADDIU SP, SP, 24
1659:                
1660:                // LOCATE(ligne,colonne)
1661:                //positionne le curseur texte
1662:                static void kw_locate(){
9D002E8C  27BDFFE8   ADDIU SP, SP, -24
9D002E90  AFBF0014   SW RA, 20(SP)
1663:                    parse_arg_list(2);
9D002E94  0F40097D   JAL parse_arg_list
9D002E98  24040002   ADDIU A0, ZERO, 2
1664:                    bytecode(ILOCATE);
9D002E9C  0F400445   JAL bytecode
9D002EA0  24040081   ADDIU A0, ZERO, 129
1665:                }//f
9D002EA4  8FBF0014   LW RA, 20(SP)
9D002EA8  03E00008   JR RA
9D002EAC  27BD0018   ADDIU SP, SP, 24
1666:                
1667:                // REM commentaire
1668:                // aussi ' commentaire
1669:                static void kw_rem(){
9D000160  27BDFFE8   ADDIU SP, SP, -24
9D000164  AFBF0014   SW RA, 20(SP)
9D000168  AFB00010   SW S0, 16(SP)
1670:                    char c=0;
1671:                    while (!(activ_reader->eof || ((c=reader_getc(activ_reader))=='\n')));
9D00016C  2410000A   ADDIU S0, ZERO, 10
9D000170  8F848098   LW A0, -32616(GP)
9D000174  8C82010C   LW V0, 268(A0)
9D000178  14400006   BNE V0, ZERO, 0x9D000194
9D00017C  8F828090   LW V0, -32624(GP)
9D000180  0F40684F   JAL reader_getc
9D000184  00000000   NOP
9D000188  1450FFFA   BNE V0, S0, 0x9D000174
9D00018C  8F848098   LW A0, -32616(GP)
1672:                    line_count++;
9D000190  8F828090   LW V0, -32624(GP)
9D000194  24420001   ADDIU V0, V0, 1
9D000198  AF828090   SW V0, -32624(GP)
1673:                }//f()
9D00019C  8FBF0014   LW RA, 20(SP)
9D0001A0  8FB00010   LW S0, 16(SP)
9D0001A4  03E00008   JR RA
9D0001A8  27BD0018   ADDIU SP, SP, 24
1674:                
1675:                // IF condition THEN bloc_instructions ELSE bloc_instructions END IF
1676:                static void kw_if(){
9D00243C  27BDFFE8   ADDIU SP, SP, -24
9D002440  AFBF0014   SW RA, 20(SP)
1677:                    complevel++;
9D002444  8F828064   LW V0, -32668(GP)
9D002448  24420001   ADDIU V0, V0, 1
9D00244C  AF828064   SW V0, -32668(GP)
1678:                    rstack[++rsp]=eKW_IF;
9D002450  9382C114   LBU V0, -16108(GP)
9D002454  24420001   ADDIU V0, V0, 1
9D002458  7C021420   SEB V0, V0
9D00245C  A382C114   SB V0, -16108(GP)
9D002460  00021080   SLL V0, V0, 2
9D002464  3C03A000   LUI V1, -24576
9D002468  24634080   ADDIU V1, V1, 16512
9D00246C  00431021   ADDU V0, V0, V1
9D002470  24030016   ADDIU V1, ZERO, 22
1679:                    bool_expression();
9D002474  0F4008B7   JAL bool_expression
9D002478  AC430000   SW V1, 0(V0)
1680:                }//f
9D00247C  8FBF0014   LW RA, 20(SP)
9D002480  03E00008   JR RA
9D002484  27BD0018   ADDIU SP, SP, 24
1681:                
1682:                // THEN voir kw_if
1683:                static void kw_then(){
9D001254  27BDFFE8   ADDIU SP, SP, -24
9D001258  AFBF0014   SW RA, 20(SP)
1684:                    bytecode(IQBRAZ);
9D00125C  0F400445   JAL bytecode
9D001260  24040037   ADDIU A0, ZERO, 55
1685:                    rstack[++rsp]=dptr;
9D001264  9382C114   LBU V0, -16108(GP)
9D001268  24420001   ADDIU V0, V0, 1
9D00126C  7C021420   SEB V0, V0
9D001270  A382C114   SB V0, -16108(GP)
9D001274  00021080   SLL V0, V0, 2
9D001278  3C03A000   LUI V1, -24576
9D00127C  24634080   ADDIU V1, V1, 16512
9D001280  00431021   ADDU V0, V0, V1
9D001284  8F83C11C   LW V1, -16100(GP)
9D001288  AC430000   SW V1, 0(V0)
1686:                    bytecode(0);
9D00128C  0F400445   JAL bytecode
9D001290  00002021   ADDU A0, ZERO, ZERO
1687:                    bytecode(0);
9D001294  0F400445   JAL bytecode
9D001298  00002021   ADDU A0, ZERO, ZERO
1688:                }//f
9D00129C  8FBF0014   LW RA, 20(SP)
9D0012A0  03E00008   JR RA
9D0012A4  27BD0018   ADDIU SP, SP, 24
1689:                
1690:                static void fix_branch_address(){
1691:                    progspace[rstack[rsp]]=_byte0(dptr-rstack[rsp]-2);
9D000008  8F83809C   LW V1, -32612(GP)
9D00000C  8384C114   LB A0, -16108(GP)
9D000010  00042080   SLL A0, A0, 2
9D000014  3C02A000   LUI V0, -24576
9D000018  24424080   ADDIU V0, V0, 16512
9D00001C  00822021   ADDU A0, A0, V0
9D000020  8C840000   LW A0, 0(A0)
9D000024  00642821   ADDU A1, V1, A0
9D000028  8F86C11C   LW A2, -16100(GP)
9D00002C  24C6FFFE   ADDIU A2, A2, -2
9D000030  00C42023   SUBU A0, A2, A0
9D000034  A0A40000   SB A0, 0(A1)
1692:                    progspace[rstack[rsp]+1]=_byte1(dptr-rstack[rsp]-2);
9D000038  8384C114   LB A0, -16108(GP)
9D00003C  00042080   SLL A0, A0, 2
9D000040  00821021   ADDU V0, A0, V0
9D000044  8C420000   LW V0, 0(V0)
9D000048  00621821   ADDU V1, V1, V0
9D00004C  8F84C11C   LW A0, -16100(GP)
9D000050  2484FFFE   ADDIU A0, A0, -2
9D000054  00821023   SUBU V0, A0, V0
9D000058  00021202   SRL V0, V0, 8
9D00005C  A0620001   SB V0, 1(V1)
1693:                    rsp--;
9D000060  9382C114   LBU V0, -16108(GP)
9D000064  2442FFFF   ADDIU V0, V0, -1
9D000068  03E00008   JR RA
9D00006C  A382C114   SB V0, -16108(GP)
1694:                }//f
1695:                
1696:                // ELSE voir kw_if
1697:                static void kw_else(){
9D0013DC  27BDFFE8   ADDIU SP, SP, -24
9D0013E0  AFBF0014   SW RA, 20(SP)
1698:                    bytecode(IBRA);
9D0013E4  0F400445   JAL bytecode
9D0013E8  24040006   ADDIU A0, ZERO, 6
1699:                    bytecode(0);
9D0013EC  0F400445   JAL bytecode
9D0013F0  00002021   ADDU A0, ZERO, ZERO
1700:                    bytecode(0);
9D0013F4  0F400445   JAL bytecode
9D0013F8  00002021   ADDU A0, ZERO, ZERO
1701:                    fix_branch_address();
9D0013FC  0F400002   JAL fix_branch_address
9D001400  00000000   NOP
1702:                    rstack[++rsp]=dptr-2;
9D001404  9382C114   LBU V0, -16108(GP)
9D001408  24420001   ADDIU V0, V0, 1
9D00140C  7C021420   SEB V0, V0
9D001410  A382C114   SB V0, -16108(GP)
9D001414  00021080   SLL V0, V0, 2
9D001418  3C03A000   LUI V1, -24576
9D00141C  24634080   ADDIU V1, V1, 16512
9D001420  00431021   ADDU V0, V0, V1
9D001424  8F83C11C   LW V1, -16100(GP)
9D001428  2463FFFE   ADDIU V1, V1, -2
9D00142C  AC430000   SW V1, 0(V0)
1703:                }//f
9D001430  8FBF0014   LW RA, 20(SP)
9D001434  03E00008   JR RA
9D001438  27BD0018   ADDIU SP, SP, 24
1704:                
1705:                //déplace le code des sous-routine
1706:                //à la fin de l'espace libre
1707:                static void movecode(var_t *var){
1708:                    uint32_t size;
1709:                    void *pos, *adr;
1710:                    
1711:                    pos=var->adr;
9D001DD0  8E93000C   LW S3, 12(S4)
1712:                    size=(uint32_t)&progspace[dptr]-(uint32_t)pos;
9D001DD4  8F92809C   LW S2, -32612(GP)
1713:                    if (size&1) size++;
9D001DE4  32020001   ANDI V0, S0, 1
1714:                    adr=endmark-size;
9D001DEC  02308823   SUBU S1, S1, S0
1715:                    memmove(adr,pos,size);
9D001DF0  02202021   ADDU A0, S1, ZERO
1716:                    endmark=adr;
9D001E00  AF91C118   SW S1, -16104(GP)
1717:                    dptr=(uint8_t*)pos-(uint8_t*)progspace;
9D001E04  02722023   SUBU A0, S3, S2
1718:                    memset(&progspace[dptr],0,size);
9D001E0C  02442021   ADDU A0, S2, A0
1719:                    var->adr=adr; 
9D001E1C  AE91000C   SW S1, 12(S4)
1720:                //    {
1721:                //    int i;
1722:                //    for (i=0;i<size;i++) print_int(con,con,*(uint8_t*)adr++,4);
1723:                //    }
1724:                }//f
1725:                
1726:                // END [IF|SUB|FUNC|SELECT]  termine les blocs conditionnels.
1727:                static void kw_end(){ // IF ->(R: blockend adr -- ) |
9D001C4C  27BDFFD8   ADDIU SP, SP, -40
9D001C50  AFBF0024   SW RA, 36(SP)
9D001C54  AFB40020   SW S4, 32(SP)
9D001C58  AFB3001C   SW S3, 28(SP)
9D001C5C  AFB20018   SW S2, 24(SP)
9D001C60  AFB10014   SW S1, 20(SP)
9D001C64  AFB00010   SW S0, 16(SP)
1728:                                      //SELECT -> (R: n*(addr,...) blockend n -- )
1729:                                      //SUB et FUNC -> (R: endmark blockend &var -- )
1730:                    int blockend,fix_count;
1731:                    var_t *var;
1732:                
1733:                    expect(eKWORD);
9D001C68  0F4003EC   JAL expect
9D001C6C  24040018   ADDIU A0, ZERO, 24
1734:                    blockend=token.n;
9D001C8C  3C04A000   LUI A0, -24576
1735:                    if (rstack[rsp-1]!=blockend) throw(eERR_SYNTAX);
9D001C70  8383C114   LB V1, -16108(GP)
9D001C74  2464FFFF   ADDIU A0, V1, -1
9D001C78  00042080   SLL A0, A0, 2
9D001C7C  3C02A000   LUI V0, -24576
9D001C80  24424080   ADDIU V0, V0, 16512
9D001C84  00821021   ADDU V0, A0, V0
9D001C88  8C420000   LW V0, 0(V0)
9D001C90  8C84391C   LW A0, 14620(A0)
9D001C94  10440003   BEQ V0, A0, 0x9D001CA4
9D001C98  24040016   ADDIU A0, ZERO, 22
9D001C9C  0F400080   JAL throw
9D001CA0  24040007   ADDIU A0, ZERO, 7
1736:                    switch (blockend){
9D001CA4  1044000F   BEQ V0, A0, 0x9D001CE4
9D001CA8  28440017   SLTI A0, V0, 23
9D001CAC  10800006   BEQ A0, ZERO, 0x9D001CC8
9D001CB0  24040037   ADDIU A0, ZERO, 55
9D001CB4  24030014   ADDIU V1, ZERO, 20
9D001CB8  10430023   BEQ V0, V1, 0x9D001D48
9D001CBC  00000000   NOP
9D001CC0  0B40078C   J 0x9D001E30
9D001CC4  00000000   NOP
9D001CC8  5044000C   BEQL V0, A0, 0x9D001CFC
9D001CCC  2462FFFF   ADDIU V0, V1, -1
9D001CD0  24030042   ADDIU V1, ZERO, 66
9D001CD4  10430020   BEQ V0, V1, 0x9D001D58
9D001CD8  00000000   NOP
9D001CDC  0B40078C   J 0x9D001E30
9D001CE0  00000000   NOP
1737:                        case eKW_IF:
1738:                            fix_branch_address();
9D001CE4  0F400002   JAL fix_branch_address
9D001CE8  00000000   NOP
1739:                            rsp--; //drop eKW_IF
9D001CEC  9382C114   LBU V0, -16108(GP)
9D001CF0  2442FFFF   ADDIU V0, V0, -1
1740:                            break;
9D001CF4  0B40078E   J 0x9D001E38
9D001CF8  A382C114   SB V0, -16108(GP)
1741:                        case eKW_SELECT:
1742:                            fix_count=rstack[rsp--];
9D001CFC  A382C114   SB V0, -16108(GP)
9D001D00  00031080   SLL V0, V1, 2
9D001D04  3C04A000   LUI A0, -24576
9D001D08  24844080   ADDIU A0, A0, 16512
9D001D0C  00441021   ADDU V0, V0, A0
9D001D10  8C500000   LW S0, 0(V0)
1743:                            if (!fix_count) throw(eERR_SYNTAX);
9D001D14  16000003   BNE S0, ZERO, 0x9D001D24
9D001D18  2463FFFE   ADDIU V1, V1, -2
9D001D1C  0F400080   JAL throw
9D001D20  24040007   ADDIU A0, ZERO, 7
1744:                            rsp--; //drop eKW_SELECT
9D001D24  A383C114   SB V1, -16108(GP)
1745:                            while (fix_count){ //print_int(con,fix_count,0); crlf(con);
9D001D30  1600FFFD   BNE S0, ZERO, 0x9D001D28
9D001D34  00000000   NOP
1746:                                fix_branch_address();
9D001D28  0F400002   JAL fix_branch_address
9D001D2C  2610FFFF   ADDIU S0, S0, -1
1747:                                fix_count--;
1748:                            } //print_int(con,rsp,0);
1749:                            bytecode(IDROP);
9D001D38  0F400445   JAL bytecode
9D001D3C  24040010   ADDIU A0, ZERO, 16
1750:                            break;
9D001D40  0B40078F   J 0x9D001E3C
9D001D44  8F828064   LW V0, -32668(GP)
1751:                        case eKW_FUNC:
1752:                            bytecode(ILCSTORE);
9D001D48  0F400445   JAL bytecode
9D001D4C  24040060   ADDIU A0, ZERO, 96
1753:                            bytecode(0);
9D001D50  0F400445   JAL bytecode
9D001D54  00002021   ADDU A0, ZERO, ZERO
1754:                        case eKW_SUB:
1755:                            bytecode(ILEAVE);
9D001D58  0F400445   JAL bytecode
9D001D5C  24040080   ADDIU A0, ZERO, 128
1756:                            if (globals>varlist){
9D001D60  8F90807C   LW S0, -32644(GP)
9D001D64  8F828080   LW V0, -32640(GP)
9D001D68  0050182B   SLTU V1, V0, S0
9D001D6C  10600005   BEQ V1, ZERO, 0x9D001D84
9D001D70  00000000   NOP
1757:                                bytecode(varlist->n);
9D001D74  0F400445   JAL bytecode
9D001D78  9044000C   LBU A0, 12(V0)
9D001D7C  0B400764   J 0x9D001D90
9D001D80  AF908080   SW S0, -32640(GP)
1758:                            }else{
1759:                                bytecode(0);
9D001D84  0F400445   JAL bytecode
9D001D88  00002021   ADDU A0, ZERO, ZERO
1760:                            }
1761:                            varlist=globals;
9D001D8C  AF908080   SW S0, -32640(GP)
1762:                            globals=NULL;
9D001D90  AF80807C   SW ZERO, -32644(GP)
1763:                            var_local=false;
9D001D94  A3808078   SB ZERO, -32648(GP)
1764:                            var=(var_t*)rstack[rsp--];
9D001D98  8382C114   LB V0, -16108(GP)
9D001D9C  2443FFFF   ADDIU V1, V0, -1
9D001DA0  7C031C20   SEB V1, V1
9D001DA4  A383C114   SB V1, -16108(GP)
9D001DA8  00022080   SLL A0, V0, 2
9D001DAC  3C02A000   LUI V0, -24576
9D001DB0  24424080   ADDIU V0, V0, 16512
9D001DB4  00822021   ADDU A0, A0, V0
9D001DB8  8C940000   LW S4, 0(A0)
1765:                            endmark=(void*)rstack[rsp-1];
9D001DBC  2463FFFF   ADDIU V1, V1, -1
9D001DC0  00031880   SLL V1, V1, 2
9D001DC4  00621021   ADDU V0, V1, V0
9D001DC8  8C510000   LW S1, 0(V0)
9D001DCC  AF91C118   SW S1, -16104(GP)
1766:                            movecode(var);
1767:                            rsp-=2; // drop eKW_xxx et endmark
9D001E20  9382C114   LBU V0, -16108(GP)
9D001E24  2442FFFE   ADDIU V0, V0, -2
1768:                            var_local=false;
1769:                //#define DEBUG
1770:                #ifdef DEBUG
1771:                    {
1772:                        uint8_t * bc;    
1773:                        for(bc=(uint8_t*)var->adr;*bc!=LEAVE;bc++){
1774:                            print_int(con,con,*bc,0);put_char(' ');
1775:                        }
1776:                        print_int(con,con,*bc,0);put_char(' ');
1777:                        bc++;
1778:                        print_int(con,con,*bc,0);put_char(' ');
1779:                    }
1780:                #endif
1781:                //#undef DEBUG
1782:                            break;
9D001E28  0B40078E   J 0x9D001E38
9D001E2C  A382C114   SB V0, -16108(GP)
1783:                        default:
1784:                            throw(eERR_SYNTAX);
9D001E30  0F400080   JAL throw
9D001E34  24040007   ADDIU A0, ZERO, 7
1785:                    }//switch
1786:                    complevel--;
9D001E38  8F828064   LW V0, -32668(GP)
9D001E3C  2442FFFF   ADDIU V0, V0, -1
9D001E40  AF828064   SW V0, -32668(GP)
1787:                }
9D001E44  8FBF0024   LW RA, 36(SP)
9D001E48  8FB40020   LW S4, 32(SP)
9D001E4C  8FB3001C   LW S3, 28(SP)
9D001E50  8FB20018   LW S2, 24(SP)
9D001E54  8FB10014   LW S1, 20(SP)
9D001E58  8FB00010   LW S0, 16(SP)
9D001E5C  03E00008   JR RA
9D001E60  27BD0028   ADDIU SP, SP, 40
1788:                
1789:                // SELECT CASE  expression
1790:                // CASE expression
1791:                //   bloc_instructions
1792:                // {CASE expression {,expression}
1793:                //   bloc_instructions}
1794:                // [CASE ELSE
1795:                //   bloc_instructions]
1796:                // END SELECT
1797:                static void kw_select(){
9D002574  27BDFFE8   ADDIU SP, SP, -24
9D002578  AFBF0014   SW RA, 20(SP)
1798:                    expect(eKWORD);
9D00257C  0F4003EC   JAL expect
9D002580  24040018   ADDIU A0, ZERO, 24
1799:                    if (token.n!=eKW_CASE) throw(eERR_SYNTAX);
9D002584  3C02A000   LUI V0, -24576
9D002588  8C43391C   LW V1, 14620(V0)
9D00258C  24020006   ADDIU V0, ZERO, 6
9D002590  10620003   BEQ V1, V0, 0x9D0025A0
9D002594  8F828064   LW V0, -32668(GP)
9D002598  0F400080   JAL throw
9D00259C  24040007   ADDIU A0, ZERO, 7
1800:                    complevel++;
9D0025A0  24420001   ADDIU V0, V0, 1
9D0025A4  AF828064   SW V0, -32668(GP)
1801:                    rstack[++rsp]=eKW_SELECT;
9D0025A8  8383C114   LB V1, -16108(GP)
9D0025AC  24640001   ADDIU A0, V1, 1
9D0025B0  7C042420   SEB A0, A0
9D0025B4  00042080   SLL A0, A0, 2
9D0025B8  3C02A000   LUI V0, -24576
9D0025BC  24424080   ADDIU V0, V0, 16512
9D0025C0  00822021   ADDU A0, A0, V0
9D0025C4  24050037   ADDIU A1, ZERO, 55
9D0025C8  AC850000   SW A1, 0(A0)
1802:                    rstack[++rsp]=0; // compteur clauses CASE
9D0025CC  24630002   ADDIU V1, V1, 2
9D0025D0  7C031C20   SEB V1, V1
9D0025D4  A383C114   SB V1, -16108(GP)
9D0025D8  00031880   SLL V1, V1, 2
9D0025DC  00621021   ADDU V0, V1, V0
1803:                    expression();
9D0025E0  0F400799   JAL expression
9D0025E4  AC400000   SW ZERO, 0(V0)
1804:                }//f
9D0025E8  8FBF0014   LW RA, 20(SP)
9D0025EC  03E00008   JR RA
9D0025F0  27BD0018   ADDIU SP, SP, 24
1805:                
1806:                // compile la liste des expression d'un CASE, voir kw_select
1807:                static void compile_case_list(){
1808:                    int fix_count=0;
9D003F70  00008021   ADDU S0, ZERO, ZERO
1809:                    next_token();
9D003F48  0F4001A6   JAL next_token
9D003F4C  00000000   NOP
1810:                    if (token.id==eSTOP) throw(eERR_SYNTAX);
9D003F50  3C02A000   LUI V0, -24576
9D003F54  8C433918   LW V1, 14616(V0)
9D003F58  24020001   ADDIU V0, ZERO, 1
9D003F5C  14620003   BNE V1, V0, 0x9D003F6C
9D003F60  24020001   ADDIU V0, ZERO, 1
9D003F64  0F400080   JAL throw
9D003F68  24040007   ADDIU A0, ZERO, 7
1811:                    unget_token=true;
9D003F6C  A3828084   SB V0, -32636(GP)
1812:                    while (token.id != eSTOP){
9D003F74  3C11A000   LUI S1, -24576
9D003F78  24120001   ADDIU S2, ZERO, 1
9D003FF0  8E223918   LW V0, 14616(S1)
9D003FF4  1452FFE5   BNE V0, S2, 0x9D003F8C
9D003FF8  00000000   NOP
1813:                        bytecode(IDUP);
9D003F8C  0F400445   JAL bytecode
9D003F90  24040011   ADDIU A0, ZERO, 17
1814:                        expression();
9D003F94  0F400799   JAL expression
9D003F98  26100001   ADDIU S0, S0, 1
1815:                        bytecode(IEQUAL);
9D003F9C  0F400445   JAL bytecode
9D003FA0  2404003A   ADDIU A0, ZERO, 58
1816:                        bytecode(IQBRAZ);
9D003FA4  0F400445   JAL bytecode
9D003FA8  24040037   ADDIU A0, ZERO, 55
1817:                        rstack[++rsp]=dptr;
9D003F7C  3C14A000   LUI S4, -24576
9D003F80  26944080   ADDIU S4, S4, 16512
9D003FAC  9383C114   LBU V1, -16108(GP)
9D003FB0  24630001   ADDIU V1, V1, 1
9D003FB4  7C031C20   SEB V1, V1
9D003FB8  A383C114   SB V1, -16108(GP)
9D003FBC  8F82C11C   LW V0, -16100(GP)
9D003FC0  00031880   SLL V1, V1, 2
9D003FC4  00741821   ADDU V1, V1, S4
9D003FC8  AC620000   SW V0, 0(V1)
1818:                        dptr+=2;
9D003FCC  24420002   ADDIU V0, V0, 2
1819:                        fix_count++;
1820:                        next_token();
9D003FD0  0F4001A6   JAL next_token
9D003FD4  AF82C11C   SW V0, -16100(GP)
1821:                        if (token.id!=eCOMMA){
9D003F84  0B400FFC   J 0x9D003FF0
9D003F88  2413000B   ADDIU S3, ZERO, 11
9D003FD8  8E223918   LW V0, 14616(S1)
9D003FDC  10530005   BEQ V0, S3, 0x9D003FF4
9D003FE0  00000000   NOP
1822:                            unget_token=true;
9D003FE4  24020001   ADDIU V0, ZERO, 1
9D003FE8  0B400FFF   J 0x9D003FFC
9D003FEC  A3828084   SB V0, -32636(GP)
1823:                            break;
1824:                        }
1825:                    }//while
1826:                    bytecode(IBRA);
9D003FFC  0F400445   JAL bytecode
9D004000  24040006   ADDIU A0, ZERO, 6
1827:                    dptr+=2;
9D004004  8F82C11C   LW V0, -16100(GP)
9D004008  24420002   ADDIU V0, V0, 2
1828:                    while (fix_count){
9D00400C  12000005   BEQ S0, ZERO, 0x9D004024
9D004010  AF82C11C   SW V0, -16100(GP)
9D00401C  1600FFFD   BNE S0, ZERO, 0x9D004014
9D004020  00000000   NOP
1829:                        fix_branch_address();
9D004014  0F400002   JAL fix_branch_address
9D004018  2610FFFF   ADDIU S0, S0, -1
1830:                        fix_count--;
1831:                    }
1832:                    rsp++;
9D004024  9382C114   LBU V0, -16108(GP)
9D004028  24420001   ADDIU V0, V0, 1
9D00402C  7C021420   SEB V0, V0
9D004030  A382C114   SB V0, -16108(GP)
1833:                    rstack[rsp]=rstack[rsp-1]+1; //incrémente le nombre de clause CASE
9D004034  2444FFFF   ADDIU A0, V0, -1
9D004038  00022880   SLL A1, V0, 2
9D00403C  3C03A000   LUI V1, -24576
9D004040  24634080   ADDIU V1, V1, 16512
9D004044  00A32821   ADDU A1, A1, V1
9D004048  00042080   SLL A0, A0, 2
9D00404C  00832021   ADDU A0, A0, V1
9D004050  8C860000   LW A2, 0(A0)
9D004054  24C60001   ADDIU A2, A2, 1
9D004058  ACA60000   SW A2, 0(A1)
1834:                    rstack[rsp-1]=rstack[rsp-2]; // blockend
9D00405C  2442FFFE   ADDIU V0, V0, -2
9D004060  00021080   SLL V0, V0, 2
9D004064  00431821   ADDU V1, V0, V1
9D004068  8C620000   LW V0, 0(V1)
9D00406C  AC820000   SW V0, 0(A0)
1835:                    rstack[rsp-2]=dptr-2;   // bra_adr
9D004070  8F82C11C   LW V0, -16100(GP)
9D004074  2442FFFE   ADDIU V0, V0, -2
9D004078  AC620000   SW V0, 0(V1)
1836:                }//f
1837:                
1838:                // compile un CASE, voir kw_select
1839:                static void kw_case(){
9D003DFC  27BDFFD8   ADDIU SP, SP, -40
9D003E00  AFBF0024   SW RA, 36(SP)
9D003E04  AFB40020   SW S4, 32(SP)
9D003E08  AFB3001C   SW S3, 28(SP)
9D003E0C  AFB20018   SW S2, 24(SP)
9D003E10  AFB10014   SW S1, 20(SP)
1840:                    uint32_t adr;
1841:                    next_token();
9D003E14  0F4001A6   JAL next_token
9D003E18  AFB00010   SW S0, 16(SP)
1842:                    if (token.id==eKWORD && token.n==eKW_ELSE){
9D003E1C  3C02A000   LUI V0, -24576
9D003E20  8C433918   LW V1, 14616(V0)
9D003E24  24020018   ADDIU V0, ZERO, 24
9D003E28  14620028   BNE V1, V0, 0x9D003ECC
9D003E2C  24020001   ADDIU V0, ZERO, 1
9D003E30  3C02A000   LUI V0, -24576
9D003E34  8C43391C   LW V1, 14620(V0)
9D003E38  24020010   ADDIU V0, ZERO, 16
9D003E3C  14620023   BNE V1, V0, 0x9D003ECC
9D003E40  24020001   ADDIU V0, ZERO, 1
1843:                        if (rstack[rsp]){
9D003E44  8382C114   LB V0, -16108(GP)
9D003E48  00022080   SLL A0, V0, 2
9D003E4C  3C03A000   LUI V1, -24576
9D003E50  24634080   ADDIU V1, V1, 16512
9D003E54  00831821   ADDU V1, A0, V1
9D003E58  8C630000   LW V1, 0(V1)
9D003E5C  10600019   BEQ V1, ZERO, 0x9D003EC4
9D003E60  3C10A000   LUI S0, -24576
1844:                            adr=rstack[rsp-2]; //( br_adr blockend n  -- br_adr blockend n)
9D003E64  2442FFFE   ADDIU V0, V0, -2
9D003E68  00021080   SLL V0, V0, 2
9D003E6C  26104080   ADDIU S0, S0, 16512
9D003E70  00501021   ADDU V0, V0, S0
9D003E74  8C510000   LW S1, 0(V0)
1845:                            bytecode(IBRA);  // branchement à la sortie du select case
9D003E78  0F400445   JAL bytecode
9D003E7C  24040006   ADDIU A0, ZERO, 6
1846:                            rstack[rsp-2]=dptr; // (adr blockend n -- dptr blockend n )
9D003E80  8382C114   LB V0, -16108(GP)
9D003E84  8F83C11C   LW V1, -16100(GP)
9D003E88  2444FFFE   ADDIU A0, V0, -2
9D003E8C  00042080   SLL A0, A0, 2
9D003E90  00902021   ADDU A0, A0, S0
9D003E94  AC830000   SW V1, 0(A0)
1847:                            dptr+=2;
9D003E98  24630002   ADDIU V1, V1, 2
9D003E9C  AF83C11C   SW V1, -16100(GP)
1848:                            rstack[++rsp]=adr;
9D003EA0  24420001   ADDIU V0, V0, 1
9D003EA4  7C021420   SEB V0, V0
9D003EA8  A382C114   SB V0, -16108(GP)
9D003EAC  00021080   SLL V0, V0, 2
9D003EB0  00508021   ADDU S0, V0, S0
1849:                            fix_branch_address(); // fixe branchement vers CASE ELSE
9D003EB4  0F400002   JAL fix_branch_address
9D003EB8  AE110000   SW S1, 0(S0)
9D003EBC  0B401020   J 0x9D004080
9D003EC0  8FBF0024   LW RA, 36(SP)
1850:                        }else
1851:                            throw(eERR_SYNTAX);
9D003EC4  0F400080   JAL throw
9D003EC8  24040007   ADDIU A0, ZERO, 7
1852:                    }else{
1853:                        unget_token=true;
9D003ECC  A3828084   SB V0, -32636(GP)
1854:                        if (rstack[rsp]){//y a-t-il un case avant celui-ci?
9D003ED0  8382C114   LB V0, -16108(GP)
9D003ED4  00022080   SLL A0, V0, 2
9D003ED8  3C03A000   LUI V1, -24576
9D003EDC  24634080   ADDIU V1, V1, 16512
9D003EE0  00831821   ADDU V1, A0, V1
9D003EE4  8C630000   LW V1, 0(V1)
9D003EE8  10600017   BEQ V1, ZERO, 0x9D003F48
9D003EEC  2442FFFE   ADDIU V0, V0, -2
1855:                            adr=rstack[rsp-2]; //( br_adr blockend n  -- br_adr blockend n)
9D003EF0  00021080   SLL V0, V0, 2
9D003EF4  3C10A000   LUI S0, -24576
9D003EF8  26104080   ADDIU S0, S0, 16512
9D003EFC  00501021   ADDU V0, V0, S0
9D003F00  8C510000   LW S1, 0(V0)
1856:                            bytecode(IBRA);  // branchement à la sortie du select case
9D003F04  0F400445   JAL bytecode
9D003F08  24040006   ADDIU A0, ZERO, 6
1857:                            rstack[rsp-2]=dptr; // (adr blockend n -- dptr blockend n )
9D003F0C  8382C114   LB V0, -16108(GP)
9D003F10  8F83C11C   LW V1, -16100(GP)
9D003F14  2444FFFE   ADDIU A0, V0, -2
9D003F18  00042080   SLL A0, A0, 2
9D003F1C  00902021   ADDU A0, A0, S0
9D003F20  AC830000   SW V1, 0(A0)
1858:                            dptr+=2;
9D003F24  24630002   ADDIU V1, V1, 2
9D003F28  AF83C11C   SW V1, -16100(GP)
1859:                            rstack[++rsp]=adr;
9D003F2C  24420001   ADDIU V0, V0, 1
9D003F30  7C021420   SEB V0, V0
9D003F34  A382C114   SB V0, -16108(GP)
9D003F38  00021080   SLL V0, V0, 2
9D003F3C  00508021   ADDU S0, V0, S0
1860:                            fix_branch_address(); // fixe branchement vers ce case
9D003F40  0F400002   JAL fix_branch_address
9D003F44  AE110000   SW S1, 0(S0)
1861:                        }
1862:                        compile_case_list();
1863:                    }
1864:                }//f
9D00407C  8FBF0024   LW RA, 36(SP)
9D004080  8FB40020   LW S4, 32(SP)
9D004084  8FB3001C   LW S3, 28(SP)
9D004088  8FB20018   LW S2, 24(SP)
9D00408C  8FB10014   LW S1, 20(SP)
9D004090  8FB00010   LW S0, 16(SP)
9D004094  03E00008   JR RA
9D004098  27BD0028   ADDIU SP, SP, 40
1865:                
1866:                // RND())
1867:                // génération nombre pseudo-aléatoire
1868:                static void kw_rnd(){
9D0012A8  27BDFFE8   ADDIU SP, SP, -24
9D0012AC  AFBF0014   SW RA, 20(SP)
1869:                    expect(eLPAREN);
9D0012B0  0F4003EC   JAL expect
9D0012B4  2404000C   ADDIU A0, ZERO, 12
1870:                    expect(eRPAREN);
9D0012B8  0F4003EC   JAL expect
9D0012BC  2404000D   ADDIU A0, ZERO, 13
1871:                    bytecode(IRND);
9D0012C0  0F400445   JAL bytecode
9D0012C4  2404004C   ADDIU A0, ZERO, 76
1872:                }//f
9D0012C8  8FBF0014   LW RA, 20(SP)
9D0012CC  03E00008   JR RA
9D0012D0  27BD0018   ADDIU SP, SP, 24
1873:                
1874:                //RANDOMIZE()
1875:                static void kw_randomize(){
9D002DB4  27BDFFE8   ADDIU SP, SP, -24
9D002DB8  AFBF0014   SW RA, 20(SP)
1876:                    parse_arg_list(0);
9D002DBC  0F40097D   JAL parse_arg_list
9D002DC0  00002021   ADDU A0, ZERO, ZERO
1877:                    bytecode(IRANDOMIZE);
9D002DC4  0F400445   JAL bytecode
9D002DC8  2404007F   ADDIU A0, ZERO, 127
1878:                }//f
9D002DCC  8FBF0014   LW RA, 20(SP)
9D002DD0  03E00008   JR RA
9D002DD4  27BD0018   ADDIU SP, SP, 24
1879:                
1880:                //MAX(expr1,expr2)
1881:                static void kw_max(){
9D002E68  27BDFFE8   ADDIU SP, SP, -24
9D002E6C  AFBF0014   SW RA, 20(SP)
1882:                    parse_arg_list(2);
9D002E70  0F40097D   JAL parse_arg_list
9D002E74  24040002   ADDIU A0, ZERO, 2
1883:                    bytecode(IMAX);
9D002E78  0F400445   JAL bytecode
9D002E7C  24040032   ADDIU A0, ZERO, 50
1884:                }//f
9D002E80  8FBF0014   LW RA, 20(SP)
9D002E84  03E00008   JR RA
9D002E88  27BD0018   ADDIU SP, SP, 24
1885:                
1886:                //MIN(expr1,expr2)
1887:                static void kw_min(){
9D002E20  27BDFFE8   ADDIU SP, SP, -24
9D002E24  AFBF0014   SW RA, 20(SP)
1888:                    parse_arg_list(2);
9D002E28  0F40097D   JAL parse_arg_list
9D002E2C  24040002   ADDIU A0, ZERO, 2
1889:                    bytecode(IMIN);
9D002E30  0F400445   JAL bytecode
9D002E34  24040031   ADDIU A0, ZERO, 49
1890:                }//f
9D002E38  8FBF0014   LW RA, 20(SP)
9D002E3C  03E00008   JR RA
9D002E40  27BD0018   ADDIU SP, SP, 24
1891:                
1892:                //MDIV(expr1,expr2,expr3)
1893:                //multiplie expr1*expr2
1894:                //garde résultat sur 32 bits
1895:                //divise résultat 32 bits par
1896:                // epxr3
1897:                static void kw_mdiv(){
9D002E44  27BDFFE8   ADDIU SP, SP, -24
9D002E48  AFBF0014   SW RA, 20(SP)
1898:                    parse_arg_list(3);
9D002E4C  0F40097D   JAL parse_arg_list
9D002E50  24040003   ADDIU A0, ZERO, 3
1899:                    bytecode(IMDIV);
9D002E54  0F400445   JAL bytecode
9D002E58  2404007E   ADDIU A0, ZERO, 126
1900:                }//f
9D002E5C  8FBF0014   LW RA, 20(SP)
9D002E60  03E00008   JR RA
9D002E64  27BD0018   ADDIU SP, SP, 24
1901:                
1902:                // GETPIXEL(x,y)
1903:                // retourne la couleur du pixel
1904:                // en position {x,y}
1905:                static void kw_getpixel(){
9D0032AC  27BDFFE8   ADDIU SP, SP, -24
9D0032B0  AFBF0014   SW RA, 20(SP)
1906:                    parse_arg_list(2);
9D0032B4  0F40097D   JAL parse_arg_list
9D0032B8  24040002   ADDIU A0, ZERO, 2
1907:                    bytecode(IGETPIXEL);
9D0032BC  0F400445   JAL bytecode
9D0032C0  2404007D   ADDIU A0, ZERO, 125
1908:                }//f
9D0032C4  8FBF0014   LW RA, 20(SP)
9D0032C8  03E00008   JR RA
9D0032CC  27BD0018   ADDIU SP, SP, 24
1909:                
1910:                // SETPIXEL(x,y,c)
1911:                // fixe la couleur du pixel
1912:                // en position x,y
1913:                // c-> couleur {0-15}
1914:                static void kw_setpixel(){
9D002C70  27BDFFE8   ADDIU SP, SP, -24
9D002C74  AFBF0014   SW RA, 20(SP)
1915:                    parse_arg_list(3);
9D002C78  0F40097D   JAL parse_arg_list
9D002C7C  24040003   ADDIU A0, ZERO, 3
1916:                    bytecode(ISETPIXEL);
9D002C80  0F400445   JAL bytecode
9D002C84  2404007C   ADDIU A0, ZERO, 124
1917:                }//f
9D002C88  8FBF0014   LW RA, 20(SP)
9D002C8C  03E00008   JR RA
9D002C90  27BD0018   ADDIU SP, SP, 24
1918:                
1919:                // XORPIXEL(x,y,xor_value)
1920:                // XOR le pixel avec xor_value {0-15}
1921:                static void kw_xorpixel(){
9D002AC0  27BDFFE8   ADDIU SP, SP, -24
9D002AC4  AFBF0014   SW RA, 20(SP)
1922:                    parse_arg_list(3);
9D002AC8  0F40097D   JAL parse_arg_list
9D002ACC  24040003   ADDIU A0, ZERO, 3
1923:                    bytecode(IXORPIXEL);
9D002AD0  0F400445   JAL bytecode
9D002AD4  2404007B   ADDIU A0, ZERO, 123
1924:                }//f
9D002AD8  8FBF0014   LW RA, 20(SP)
9D002ADC  03E00008   JR RA
9D002AE0  27BD0018   ADDIU SP, SP, 24
1925:                
1926:                // SCRLUP(n)
1927:                // glisse l'écran vers le haut de n lignes
1928:                static void kw_scrlup(){
9D002D00  27BDFFE8   ADDIU SP, SP, -24
9D002D04  AFBF0014   SW RA, 20(SP)
1929:                    parse_arg_list(1);
9D002D08  0F40097D   JAL parse_arg_list
9D002D0C  24040001   ADDIU A0, ZERO, 1
1930:                    bytecode(ISCRLUP);
9D002D10  0F400445   JAL bytecode
9D002D14  2404007A   ADDIU A0, ZERO, 122
1931:                }//f
9D002D18  8FBF0014   LW RA, 20(SP)
9D002D1C  03E00008   JR RA
9D002D20  27BD0018   ADDIU SP, SP, 24
1932:                
1933:                // SCRLDN(n)
1934:                // glisse l'écran vers le bas de n lignes
1935:                static void kw_scrldown(){
9D002CDC  27BDFFE8   ADDIU SP, SP, -24
9D002CE0  AFBF0014   SW RA, 20(SP)
1936:                    parse_arg_list(1);
9D002CE4  0F40097D   JAL parse_arg_list
9D002CE8  24040001   ADDIU A0, ZERO, 1
1937:                    bytecode(ISCRLDN);
9D002CEC  0F400445   JAL bytecode
9D002CF0  24040079   ADDIU A0, ZERO, 121
1938:                    
1939:                }//f
9D002CF4  8FBF0014   LW RA, 20(SP)
9D002CF8  03E00008   JR RA
9D002CFC  27BD0018   ADDIU SP, SP, 24
1940:                
1941:                // SRCLRT(n)
1942:                // glisse l'écran vers la droite de n pixel
1943:                // n doit-être pair
1944:                static void kw_scrlright(){
9D002CB8  27BDFFE8   ADDIU SP, SP, -24
9D002CBC  AFBF0014   SW RA, 20(SP)
1945:                    parse_arg_list(1);
9D002CC0  0F40097D   JAL parse_arg_list
9D002CC4  24040001   ADDIU A0, ZERO, 1
1946:                    bytecode(ISCRLRT);
9D002CC8  0F400445   JAL bytecode
9D002CCC  24040078   ADDIU A0, ZERO, 120
1947:                    
1948:                }//f
9D002CD0  8FBF0014   LW RA, 20(SP)
9D002CD4  03E00008   JR RA
9D002CD8  27BD0018   ADDIU SP, SP, 24
1949:                
1950:                // SCRLLT(n)
1951:                // glisse l'afficage de n pixel vers la gauche
1952:                static void kw_scrlleft(){
9D002C94  27BDFFE8   ADDIU SP, SP, -24
9D002C98  AFBF0014   SW RA, 20(SP)
1953:                    parse_arg_list(1);
9D002C9C  0F40097D   JAL parse_arg_list
9D002CA0  24040001   ADDIU A0, ZERO, 1
1954:                    bytecode(ISCRLLT);
9D002CA4  0F400445   JAL bytecode
9D002CA8  24040077   ADDIU A0, ZERO, 119
1955:                    
1956:                }//f
9D002CAC  8FBF0014   LW RA, 20(SP)
9D002CB0  03E00008   JR RA
9D002CB4  27BD0018   ADDIU SP, SP, 24
1957:                
1958:                // LINE(x1,y,x2,y2,color)
1959:                // trace une ligne droite
1960:                static void kw_line(){
9D002EB0  27BDFFE8   ADDIU SP, SP, -24
9D002EB4  AFBF0014   SW RA, 20(SP)
1961:                    parse_arg_list(5);
9D002EB8  0F40097D   JAL parse_arg_list
9D002EBC  24040005   ADDIU A0, ZERO, 5
1962:                    bytecode(ILINE);
9D002EC0  0F400445   JAL bytecode
9D002EC4  24040076   ADDIU A0, ZERO, 118
1963:                }//f
9D002EC8  8FBF0014   LW RA, 20(SP)
9D002ECC  03E00008   JR RA
9D002ED0  27BD0018   ADDIU SP, SP, 24
1964:                
1965:                //BOX(x,y,width,height,color)
1966:                //desssine une rectangle plein
1967:                static void kw_box(){
9D0033B0  27BDFFE8   ADDIU SP, SP, -24
9D0033B4  AFBF0014   SW RA, 20(SP)
1968:                    parse_arg_list(5);
9D0033B8  0F40097D   JAL parse_arg_list
9D0033BC  24040005   ADDIU A0, ZERO, 5
1969:                    bytecode(IBOX);
9D0033C0  0F400445   JAL bytecode
9D0033C4  24040075   ADDIU A0, ZERO, 117
1970:                }//f
9D0033C8  8FBF0014   LW RA, 20(SP)
9D0033CC  03E00008   JR RA
9D0033D0  27BD0018   ADDIU SP, SP, 24
1971:                
1972:                //RECT(x0,y0,width,height,color)
1973:                //dessine un rectangle vide
1974:                static void kw_rect(){
9D002D90  27BDFFE8   ADDIU SP, SP, -24
9D002D94  AFBF0014   SW RA, 20(SP)
1975:                    parse_arg_list(5);
9D002D98  0F40097D   JAL parse_arg_list
9D002D9C  24040005   ADDIU A0, ZERO, 5
1976:                    bytecode(IRECT);
9D002DA0  0F400445   JAL bytecode
9D002DA4  24040074   ADDIU A0, ZERO, 116
1977:                }//f
9D002DA8  8FBF0014   LW RA, 20(SP)
9D002DAC  03E00008   JR RA
9D002DB0  27BD0018   ADDIU SP, SP, 24
1978:                
1979:                //CIRCLE(xc,yc,r, color)
1980:                //dissine un cercle rayon r, centré sur xc,yc
1981:                static void kw_circle(){
9D003368  27BDFFE8   ADDIU SP, SP, -24
9D00336C  AFBF0014   SW RA, 20(SP)
1982:                    parse_arg_list(4);
9D003370  0F40097D   JAL parse_arg_list
9D003374  24040004   ADDIU A0, ZERO, 4
1983:                    bytecode(ICIRCLE);
9D003378  0F400445   JAL bytecode
9D00337C  24040073   ADDIU A0, ZERO, 115
1984:                }//f
9D003380  8FBF0014   LW RA, 20(SP)
9D003384  03E00008   JR RA
9D003388  27BD0018   ADDIU SP, SP, 24
1985:                
1986:                //ELLIPSE(xc,yc,w,h,color)
1987:                //dessine une ellipse centrée sur xc,yc
1988:                // et de largeur w, hauteur h
1989:                static void kw_ellipse(){
9D0032D0  27BDFFE8   ADDIU SP, SP, -24
9D0032D4  AFBF0014   SW RA, 20(SP)
1990:                    parse_arg_list(5);
9D0032D8  0F40097D   JAL parse_arg_list
9D0032DC  24040005   ADDIU A0, ZERO, 5
1991:                    bytecode(IELLIPSE);
9D0032E0  0F400445   JAL bytecode
9D0032E4  24040072   ADDIU A0, ZERO, 114
1992:                }//f
9D0032E8  8FBF0014   LW RA, 20(SP)
9D0032EC  03E00008   JR RA
9D0032F0  27BD0018   ADDIU SP, SP, 24
1993:                
1994:                
1995:                // SPRITE(x,y,width,height,@sprite,@save_back)
1996:                // desssine le sprite à la position désigné
1997:                // sprite est un vecteur de type octet
1998:                //save_back est un vecteur de type octet de même grandeur que sprite
1999:                //save_back est utilisé pour sauvegarder le fond d'écran
2000:                //en vue de sa restauration
2001:                static void kw_sprite(){
9D002BE0  27BDFFE8   ADDIU SP, SP, -24
9D002BE4  AFBF0014   SW RA, 20(SP)
2002:                    parse_arg_list(6);
9D002BE8  0F40097D   JAL parse_arg_list
9D002BEC  24040006   ADDIU A0, ZERO, 6
2003:                    bytecode(ISPRITE);
9D002BF0  0F400445   JAL bytecode
9D002BF4  24040071   ADDIU A0, ZERO, 113
2004:                }//f
9D002BF8  8FBF0014   LW RA, 20(SP)
9D002BFC  03E00008   JR RA
9D002C00  27BD0018   ADDIU SP, SP, 24
2005:                
2006:                //REMSPR(x,y,width,height,@rest_back)
2007:                //efface le sprite en restaurant les bits
2008:                // de fond d'écran sauvegardés par SPRITE()
2009:                static void kw_remove_sprite(){
9D002D6C  27BDFFE8   ADDIU SP, SP, -24
9D002D70  AFBF0014   SW RA, 20(SP)
2010:                    parse_arg_list(5);
9D002D74  0F40097D   JAL parse_arg_list
9D002D78  24040005   ADDIU A0, ZERO, 5
2011:                    bytecode(IREMSPR);
9D002D7C  0F400445   JAL bytecode
9D002D80  24040070   ADDIU A0, ZERO, 112
2012:                }//f
9D002D84  8FBF0014   LW RA, 20(SP)
9D002D88  03E00008   JR RA
9D002D8C  27BD0018   ADDIU SP, SP, 24
2013:                
2014:                static void kw_let();
2015:                
2016:                // FOR var=expression TO expression [STEP expression]
2017:                //  bloc_instructions
2018:                // NEXT var
2019:                static void kw_for(){
9D0045F8  27BDFFC8   ADDIU SP, SP, -56
9D0045FC  AFBF0034   SW RA, 52(SP)
2020:                    var_t *var;
2021:                    char name[32];
2022:                    
2023:                    next_token();
9D004600  0F4001A6   JAL next_token
9D004604  AFB00030   SW S0, 48(SP)
2024:                    if (token.id!=eIDENT) throw(eERR_SYNTAX);
9D004608  3C02A000   LUI V0, -24576
9D00460C  8C433918   LW V1, 14616(V0)
9D004610  24020003   ADDIU V0, ZERO, 3
9D004614  50620003   BEQL V1, V0, 0x9D004624
9D004618  27A40010   ADDIU A0, SP, 16
9D00461C  0F400080   JAL throw
9D004620  24040007   ADDIU A0, ZERO, 7
2025:                    strcpy(name,token.str);
9D004624  3C10A000   LUI S0, -24576
9D004628  0F406D40   JAL strcpy
9D00462C  2605391C   ADDIU A1, S0, 14620
2026:                    complevel++;
9D004630  8F828064   LW V0, -32668(GP)
9D004634  24420001   ADDIU V0, V0, 1
9D004638  AF828064   SW V0, -32668(GP)
2027:                    bytecode(ISAVELOOP);
9D00463C  0F400445   JAL bytecode
9D004640  2404006F   ADDIU A0, ZERO, 111
2028:                    unget_token=true;
9D004644  24020001   ADDIU V0, ZERO, 1
2029:                    kw_let();
9D004648  0F401027   JAL kw_let
9D00464C  A3828084   SB V0, -32636(GP)
2030:                    expect(eIDENT);
9D004650  0F4003EC   JAL expect
9D004654  24040003   ADDIU A0, ZERO, 3
2031:                    if (strcmp(token.str,"TO")) throw (eERR_SYNTAX);
9D004658  2604391C   ADDIU A0, S0, 14620
9D00465C  3C059D01   LUI A1, -25343
9D004660  0F407138   JAL 0x9D01C4E0
9D004664  24A52834   ADDIU A1, A1, 10292
9D004668  10400003   BEQ V0, ZERO, 0x9D004678
9D00466C  00000000   NOP
9D004670  0F400080   JAL throw
9D004674  24040007   ADDIU A0, ZERO, 7
2032:                    expression();
9D004678  0F400799   JAL expression
9D00467C  00000000   NOP
2033:                    bytecode(ISAVELIMIT);
9D004680  0F400445   JAL bytecode
9D004684  2404006E   ADDIU A0, ZERO, 110
2034:                    next_token();
9D004688  0F4001A6   JAL next_token
9D00468C  00000000   NOP
2035:                    if (token.id==eIDENT && !strcmp(token.str,"STEP")){
9D004690  3C02A000   LUI V0, -24576
9D004694  8C433918   LW V1, 14616(V0)
9D004698  24020003   ADDIU V0, ZERO, 3
9D00469C  1462000D   BNE V1, V0, 0x9D0046D4
9D0046A0  3C04A000   LUI A0, -24576
9D0046A4  2484391C   ADDIU A0, A0, 14620
9D0046A8  3C059D01   LUI A1, -25343
9D0046AC  0F407138   JAL 0x9D01C4E0
9D0046B0  24A52838   ADDIU A1, A1, 10296
9D0046B4  14400007   BNE V0, ZERO, 0x9D0046D4
9D0046B8  00000000   NOP
2036:                        expression();
9D0046BC  0F400799   JAL expression
9D0046C0  00000000   NOP
2037:                        bytecode(ISAVESTEP);
9D0046C4  0F400445   JAL bytecode
9D0046C8  2404006D   ADDIU A0, ZERO, 109
9D0046CC  0B4011BB   J 0x9D0046EC
9D0046D0  00000000   NOP
2038:                    }else{
2039:                        _litc(1);
9D0046D4  0F400445   JAL bytecode
9D0046D8  24040003   ADDIU A0, ZERO, 3
2040:                        bytecode(ISAVESTEP);
9D0046DC  0F400445   JAL bytecode
9D0046E0  2404006D   ADDIU A0, ZERO, 109
2041:                        unget_token=true;
9D0046E4  24020001   ADDIU V0, ZERO, 1
9D0046E8  A3828084   SB V0, -32636(GP)
2042:                    }
2043:                    var=var_search(name);
9D0046EC  0F40006B   JAL var_search
9D0046F0  27A40010   ADDIU A0, SP, 16
9D0046F4  00408021   ADDU S0, V0, ZERO
2044:                    if (var->vtype==eVAR_LOCAL){
9D0046F8  90430005   LBU V1, 5(V0)
9D0046FC  24020007   ADDIU V0, ZERO, 7
9D004700  14620007   BNE V1, V0, 0x9D004720
9D004704  00000000   NOP
2045:                        bytecode(ILCADR);
9D004708  0F400445   JAL bytecode
9D00470C  2404006B   ADDIU A0, ZERO, 107
2046:                        bytecode(var->n);
9D004710  0F400445   JAL bytecode
9D004714  9204000C   LBU A0, 12(S0)
9D004718  0B4011CA   J 0x9D004728
9D00471C  00000000   NOP
2047:                    }else{
2048:                        _lit((uint32_t)&var->n);
9D004720  0F400445   JAL bytecode
9D004724  24040001   ADDIU A0, ZERO, 1
2049:                    }
2050:                    bytecode(IFETCH);
9D004728  0F400445   JAL bytecode
9D00472C  2404000A   ADDIU A0, ZERO, 10
2051:                    bytecode(ILOOPTEST);
9D004730  0F400445   JAL bytecode
9D004734  2404006C   ADDIU A0, ZERO, 108
2052:                    bytecode(IQBRAZ);
9D004738  0F400445   JAL bytecode
9D00473C  24040037   ADDIU A0, ZERO, 55
2053:                    rstack[++rsp]=dptr;
9D004740  9382C114   LBU V0, -16108(GP)
9D004744  24420001   ADDIU V0, V0, 1
9D004748  7C021420   SEB V0, V0
9D00474C  A382C114   SB V0, -16108(GP)
9D004750  00021080   SLL V0, V0, 2
9D004754  3C03A000   LUI V1, -24576
9D004758  24634080   ADDIU V1, V1, 16512
9D00475C  00431021   ADDU V0, V0, V1
9D004760  8F83C11C   LW V1, -16100(GP)
9D004764  AC430000   SW V1, 0(V0)
2054:                    bytecode(0);
9D004768  0F400445   JAL bytecode
9D00476C  00002021   ADDU A0, ZERO, ZERO
2055:                    bytecode(0);
9D004770  0F400445   JAL bytecode
9D004774  00002021   ADDU A0, ZERO, ZERO
2056:                }//f
9D004778  8FBF0034   LW RA, 52(SP)
9D00477C  8FB00030   LW S0, 48(SP)
9D004780  03E00008   JR RA
9D004784  27BD0038   ADDIU SP, SP, 56
2057:                
2058:                // voir kw_for()
2059:                static void kw_next(){
9D0018F4  27BDFFE8   ADDIU SP, SP, -24
9D0018F8  AFBF0014   SW RA, 20(SP)
9D0018FC  AFB00010   SW S0, 16(SP)
2060:                    var_t *var;
2061:                    
2062:                    expect(eIDENT);
9D001900  0F4003EC   JAL expect
9D001904  24040003   ADDIU A0, ZERO, 3
2063:                    var=var_search(token.str);
9D001908  3C04A000   LUI A0, -24576
9D00190C  0F40006B   JAL var_search
9D001910  2484391C   ADDIU A0, A0, 14620
2064:                    if (!(var && ((var->vtype==eVAR_INT) || (var->vtype==eVAR_LOCAL)))) throw(eERR_BAD_ARG);
9D001914  10400006   BEQ V0, ZERO, 0x9D001930
9D001918  00408021   ADDU S0, V0, ZERO
9D00191C  90420005   LBU V0, 5(V0)
9D001920  1040000B   BEQ V0, ZERO, 0x9D001950
9D001924  24030007   ADDIU V1, ZERO, 7
9D001928  10430003   BEQ V0, V1, 0x9D001938
9D00192C  00000000   NOP
9D001930  0F400080   JAL throw
9D001934  24040006   ADDIU A0, ZERO, 6
2065:                    if (var->vtype==eVAR_LOCAL){
2066:                        bytecode(ILCADR);
9D001938  0F400445   JAL bytecode
9D00193C  2404006B   ADDIU A0, ZERO, 107
2067:                        bytecode(var->n);
9D001940  0F400445   JAL bytecode
9D001944  9204000C   LBU A0, 12(S0)
9D001948  0B400656   J 0x9D001958
9D00194C  00000000   NOP
2068:                    }else{
2069:                        _lit((uint32_t)&var->adr);
9D001950  0F400445   JAL bytecode
9D001954  24040001   ADDIU A0, ZERO, 1
2070:                    }
2071:                    bytecode(INEXT);
9D001958  0F400445   JAL bytecode
9D00195C  2404006A   ADDIU A0, ZERO, 106
2072:                    bytecode(IBRA);
9D001960  0F400445   JAL bytecode
9D001964  24040006   ADDIU A0, ZERO, 6
2073:                    progspace[dptr]=_byte0((rstack[rsp]-dptr-4));
9D001968  8F85809C   LW A1, -32612(GP)
9D00196C  8F82C11C   LW V0, -16100(GP)
9D001970  00A21821   ADDU V1, A1, V0
9D001974  2404FFFC   ADDIU A0, ZERO, -4
9D001978  00823823   SUBU A3, A0, V0
9D00197C  8386C114   LB A2, -16108(GP)
9D001980  00063080   SLL A2, A2, 2
9D001984  3C02A000   LUI V0, -24576
9D001988  24424080   ADDIU V0, V0, 16512
9D00198C  00C23021   ADDU A2, A2, V0
9D001990  8CC60000   LW A2, 0(A2)
9D001994  00E63021   ADDU A2, A3, A2
9D001998  A0660000   SB A2, 0(V1)
2074:                    progspace[dptr+1]=_byte1((rstack[rsp]-dptr-4));
9D00199C  8F83C11C   LW V1, -16100(GP)
9D0019A0  00A32821   ADDU A1, A1, V1
9D0019A4  00831823   SUBU V1, A0, V1
9D0019A8  8384C114   LB A0, -16108(GP)
9D0019AC  00042080   SLL A0, A0, 2
9D0019B0  00821021   ADDU V0, A0, V0
9D0019B4  8C420000   LW V0, 0(V0)
9D0019B8  00621821   ADDU V1, V1, V0
9D0019BC  00031A02   SRL V1, V1, 8
9D0019C0  A0A30001   SB V1, 1(A1)
2075:                    dptr+=2;
9D0019C4  8F82C11C   LW V0, -16100(GP)
9D0019C8  24420002   ADDIU V0, V0, 2
2076:                    fix_branch_address();
9D0019CC  0F400002   JAL fix_branch_address
9D0019D0  AF82C11C   SW V0, -16100(GP)
2077:                    bytecode(IRESTLOOP); 
9D0019D4  0F400445   JAL bytecode
9D0019D8  24040069   ADDIU A0, ZERO, 105
2078:                    complevel--;
9D0019DC  8F828064   LW V0, -32668(GP)
9D0019E0  2442FFFF   ADDIU V0, V0, -1
9D0019E4  AF828064   SW V0, -32668(GP)
2079:                }//f
9D0019E8  8FBF0014   LW RA, 20(SP)
9D0019EC  8FB00010   LW S0, 16(SP)
9D0019F0  03E00008   JR RA
9D0019F4  27BD0018   ADDIU SP, SP, 24
2080:                
2081:                // WHILE condition
2082:                //  bloc_instructions
2083:                // WEND
2084:                static void kw_while(){
9D0023B8  27BDFFE8   ADDIU SP, SP, -24
9D0023BC  AFBF0014   SW RA, 20(SP)
9D0023C0  AFB00010   SW S0, 16(SP)
2085:                    complevel++;
9D0023C4  8F828064   LW V0, -32668(GP)
9D0023C8  24420001   ADDIU V0, V0, 1
9D0023CC  AF828064   SW V0, -32668(GP)
2086:                    rstack[++rsp]=dptr;
9D0023D0  9382C114   LBU V0, -16108(GP)
9D0023D4  24420001   ADDIU V0, V0, 1
9D0023D8  7C021420   SEB V0, V0
9D0023DC  A382C114   SB V0, -16108(GP)
9D0023E0  00021080   SLL V0, V0, 2
9D0023E4  3C10A000   LUI S0, -24576
9D0023E8  26104080   ADDIU S0, S0, 16512
9D0023EC  00501021   ADDU V0, V0, S0
9D0023F0  8F83C11C   LW V1, -16100(GP)
2087:                    bool_expression();
9D0023F4  0F4008B7   JAL bool_expression
9D0023F8  AC430000   SW V1, 0(V0)
2088:                    bytecode(IQBRAZ);
9D0023FC  0F400445   JAL bytecode
9D002400  24040037   ADDIU A0, ZERO, 55
2089:                    rstack[++rsp]=dptr;
9D002404  9383C114   LBU V1, -16108(GP)
9D002408  24630001   ADDIU V1, V1, 1
9D00240C  7C031C20   SEB V1, V1
9D002410  A383C114   SB V1, -16108(GP)
9D002414  8F82C11C   LW V0, -16100(GP)
9D002418  00031880   SLL V1, V1, 2
9D00241C  00708021   ADDU S0, V1, S0
9D002420  AE020000   SW V0, 0(S0)
2090:                    dptr+=2;
9D002424  24420002   ADDIU V0, V0, 2
9D002428  AF82C11C   SW V0, -16100(GP)
2091:                }//f
9D00242C  8FBF0014   LW RA, 20(SP)
9D002430  8FB00010   LW S0, 16(SP)
9D002434  03E00008   JR RA
9D002438  27BD0018   ADDIU SP, SP, 24
2092:                
2093:                // voir kw_while()
2094:                static void kw_wend(){
9D001154  27BDFFE8   ADDIU SP, SP, -24
9D001158  AFBF0014   SW RA, 20(SP)
2095:                    bytecode(IBRA);
9D00115C  0F400445   JAL bytecode
9D001160  24040006   ADDIU A0, ZERO, 6
2096:                    progspace[dptr]=_byte0(rstack[rsp-1]-dptr-2);
9D001164  8F85809C   LW A1, -32612(GP)
9D001168  8F82C11C   LW V0, -16100(GP)
9D00116C  00A21821   ADDU V1, A1, V0
9D001170  2404FFFE   ADDIU A0, ZERO, -2
9D001174  00823823   SUBU A3, A0, V0
9D001178  8386C114   LB A2, -16108(GP)
9D00117C  24C6FFFF   ADDIU A2, A2, -1
9D001180  00063080   SLL A2, A2, 2
9D001184  3C02A000   LUI V0, -24576
9D001188  24424080   ADDIU V0, V0, 16512
9D00118C  00C23021   ADDU A2, A2, V0
9D001190  8CC60000   LW A2, 0(A2)
9D001194  00E63021   ADDU A2, A3, A2
9D001198  A0660000   SB A2, 0(V1)
2097:                    progspace[dptr+1]=_byte1(rstack[rsp-1]-dptr-2);
9D00119C  8F83C11C   LW V1, -16100(GP)
9D0011A0  00A32821   ADDU A1, A1, V1
9D0011A4  00831823   SUBU V1, A0, V1
9D0011A8  8384C114   LB A0, -16108(GP)
9D0011AC  2484FFFF   ADDIU A0, A0, -1
9D0011B0  00042080   SLL A0, A0, 2
9D0011B4  00821021   ADDU V0, A0, V0
9D0011B8  8C420000   LW V0, 0(V0)
9D0011BC  00621821   ADDU V1, V1, V0
9D0011C0  00031A02   SRL V1, V1, 8
9D0011C4  A0A30001   SB V1, 1(A1)
2098:                    dptr+=2;
9D0011C8  8F82C11C   LW V0, -16100(GP)
9D0011CC  24420002   ADDIU V0, V0, 2
2099:                    fix_branch_address();
9D0011D0  0F400002   JAL fix_branch_address
9D0011D4  AF82C11C   SW V0, -16100(GP)
2100:                    rsp--;
9D0011D8  9382C114   LBU V0, -16108(GP)
9D0011DC  2442FFFF   ADDIU V0, V0, -1
9D0011E0  A382C114   SB V0, -16108(GP)
2101:                    complevel--;
9D0011E4  8F828064   LW V0, -32668(GP)
9D0011E8  2442FFFF   ADDIU V0, V0, -1
9D0011EC  AF828064   SW V0, -32668(GP)
2102:                }//f
9D0011F0  8FBF0014   LW RA, 20(SP)
9D0011F4  03E00008   JR RA
9D0011F8  27BD0018   ADDIU SP, SP, 24
2103:                
2104:                // DO 
2105:                //   bloc_instructions
2106:                // LOOP WHILE|UNTIL condition
2107:                static void kw_do(){
2108:                    complevel++;
9D000070  8F828064   LW V0, -32668(GP)
9D000074  24420001   ADDIU V0, V0, 1
9D000078  AF828064   SW V0, -32668(GP)
2109:                    rstack[++rsp]=dptr;
9D00007C  9382C114   LBU V0, -16108(GP)
9D000080  24420001   ADDIU V0, V0, 1
9D000084  7C021420   SEB V0, V0
9D000088  A382C114   SB V0, -16108(GP)
9D00008C  00021080   SLL V0, V0, 2
9D000090  3C03A000   LUI V1, -24576
9D000094  24634080   ADDIU V1, V1, 16512
9D000098  00431021   ADDU V0, V0, V1
9D00009C  8F83C11C   LW V1, -16100(GP)
9D0000A0  03E00008   JR RA
9D0000A4  AC430000   SW V1, 0(V0)
2110:                }//f
2111:                
2112:                // voir kw_do()
2113:                static void kw_loop(){
9D002488  27BDFFE8   ADDIU SP, SP, -24
9D00248C  AFBF0014   SW RA, 20(SP)
2114:                    expect(eKWORD);
9D002490  0F4003EC   JAL expect
9D002494  24040018   ADDIU A0, ZERO, 24
2115:                    if (token.n==eKW_WHILE){
9D002498  3C02A000   LUI V0, -24576
9D00249C  8C42391C   LW V0, 14620(V0)
9D0024A0  2403004E   ADDIU V1, ZERO, 78
9D0024A4  14430007   BNE V0, V1, 0x9D0024C4
9D0024A8  24030049   ADDIU V1, ZERO, 73
2116:                        bool_expression();
9D0024AC  0F4008B7   JAL bool_expression
9D0024B0  00000000   NOP
2117:                        bytecode(IQBRAZ);
9D0024B4  0F400445   JAL bytecode
9D0024B8  24040037   ADDIU A0, ZERO, 55
9D0024BC  0B40093B   J 0x9D0024EC
9D0024C0  8F85809C   LW A1, -32612(GP)
2118:                        
2119:                    }else if (token.n==eKW_UNTIL){
9D0024C4  14430007   BNE V0, V1, 0x9D0024E4
9D0024C8  00000000   NOP
2120:                        bool_expression();
9D0024CC  0F4008B7   JAL bool_expression
9D0024D0  00000000   NOP
2121:                        bytecode(IQBRAZ);  
9D0024D4  0F400445   JAL bytecode
9D0024D8  24040037   ADDIU A0, ZERO, 55
9D0024DC  0B40093B   J 0x9D0024EC
9D0024E0  8F85809C   LW A1, -32612(GP)
2122:                    }else{
2123:                        throw(eERR_SYNTAX);
9D0024E4  0F400080   JAL throw
9D0024E8  24040007   ADDIU A0, ZERO, 7
2124:                    }
2125:                    progspace[dptr]=_byte0(rstack[rsp]-dptr-2);
9D0024EC  8F82C11C   LW V0, -16100(GP)
9D0024F0  00A21821   ADDU V1, A1, V0
9D0024F4  2404FFFE   ADDIU A0, ZERO, -2
9D0024F8  00823823   SUBU A3, A0, V0
9D0024FC  8386C114   LB A2, -16108(GP)
9D002500  00063080   SLL A2, A2, 2
9D002504  3C02A000   LUI V0, -24576
9D002508  24424080   ADDIU V0, V0, 16512
9D00250C  00C23021   ADDU A2, A2, V0
9D002510  8CC60000   LW A2, 0(A2)
9D002514  00E63021   ADDU A2, A3, A2
9D002518  A0660000   SB A2, 0(V1)
2126:                    progspace[dptr+1]=_byte1(rstack[rsp]-dptr-2);
9D00251C  8F83C11C   LW V1, -16100(GP)
9D002520  00A32821   ADDU A1, A1, V1
9D002524  00831823   SUBU V1, A0, V1
9D002528  8384C114   LB A0, -16108(GP)
9D00252C  00042080   SLL A0, A0, 2
9D002530  00821021   ADDU V0, A0, V0
9D002534  8C420000   LW V0, 0(V0)
9D002538  00621821   ADDU V1, V1, V0
9D00253C  00031A02   SRL V1, V1, 8
9D002540  A0A30001   SB V1, 1(A1)
2127:                    dptr+=2;
9D002544  8F82C11C   LW V0, -16100(GP)
9D002548  24420002   ADDIU V0, V0, 2
9D00254C  AF82C11C   SW V0, -16100(GP)
2128:                    rsp--;
9D002550  9382C114   LBU V0, -16108(GP)
9D002554  2442FFFF   ADDIU V0, V0, -1
9D002558  A382C114   SB V0, -16108(GP)
2129:                    complevel--;
9D00255C  8F828064   LW V0, -32668(GP)
9D002560  2442FFFF   ADDIU V0, V0, -1
9D002564  AF828064   SW V0, -32668(GP)
2130:                }//f
9D002568  8FBF0014   LW RA, 20(SP)
9D00256C  03E00008   JR RA
9D002570  27BD0018   ADDIU SP, SP, 24
2131:                
2132:                // compile une chaîne litérale
2133:                // de longueur maximale de 255 caractères
2134:                static void literal_string(char *lit_str){
9D001754  27BDFFE0   ADDIU SP, SP, -32
9D001758  AFBF001C   SW RA, 28(SP)
9D00175C  AFB20018   SW S2, 24(SP)
9D001760  AFB10014   SW S1, 20(SP)
9D001764  AFB00010   SW S0, 16(SP)
2135:                    int size;
2136:                
2137:                    size=strlen(lit_str)&0xff;
9D001768  0F406EC2   JAL strlen
9D00176C  00809021   ADDU S2, A0, ZERO
9D001770  305000FF   ANDI S0, V0, 255
2138:                    if ((void*)&progspace[dptr+size+2]>endmark) throw(eERR_PROGSPACE);
9D001774  8F91809C   LW S1, -32612(GP)
9D001778  8F82C11C   LW V0, -16100(GP)
9D00177C  24420002   ADDIU V0, V0, 2
9D001780  00501021   ADDU V0, V0, S0
9D001784  02221021   ADDU V0, S1, V0
9D001788  8F83C118   LW V1, -16104(GP)
9D00178C  0062102B   SLTU V0, V1, V0
9D001790  10400003   BEQ V0, ZERO, 0x9D0017A0
9D001794  00000000   NOP
9D001798  0F400080   JAL throw
9D00179C  2404000E   ADDIU A0, ZERO, 14
2139:                    bytecode(ILITS);
9D0017A0  0F400445   JAL bytecode
9D0017A4  24040055   ADDIU A0, ZERO, 85
2140:                    bytecode(size);
9D0017A8  0F400445   JAL bytecode
9D0017AC  02002021   ADDU A0, S0, ZERO
2141:                    memmove((void*)&progspace[dptr],lit_str,size);
9D0017B0  8F84C11C   LW A0, -16100(GP)
9D0017B4  02242021   ADDU A0, S1, A0
9D0017B8  02402821   ADDU A1, S2, ZERO
9D0017BC  0F4079A7   JAL memmove
9D0017C0  02003021   ADDU A2, S0, ZERO
2142:                    dptr+=size;
9D0017C4  8F82C11C   LW V0, -16100(GP)
9D0017C8  00508021   ADDU S0, V0, S0
9D0017CC  AF90C11C   SW S0, -16100(GP)
2143:                }//f
9D0017D0  8FBF001C   LW RA, 28(SP)
9D0017D4  8FB20018   LW S2, 24(SP)
9D0017D8  8FB10014   LW S1, 20(SP)
9D0017DC  8FB00010   LW S0, 16(SP)
9D0017E0  03E00008   JR RA
9D0017E4  27BD0020   ADDIU SP, SP, 32
2144:                
2145:                
2146:                //SRLOAD file_name
2147:                //charge un fichier dans la SPIRAM
2148:                // retourne la grandeur en octet
2149:                static void kw_srload(){
9D001FF8  27BDFFE8   ADDIU SP, SP, -24
9D001FFC  AFBF0014   SW RA, 20(SP)
2150:                    var_t *var;
2151:                    
2152:                    next_token();
9D002000  0F4001A6   JAL next_token
9D002004  AFB00010   SW S0, 16(SP)
2153:                    if (token.id==eSTRING){
9D002008  3C02A000   LUI V0, -24576
9D00200C  8C423918   LW V0, 14616(V0)
9D002010  24030005   ADDIU V1, ZERO, 5
9D002014  14430006   BNE V0, V1, 0x9D002030
9D002018  24030003   ADDIU V1, ZERO, 3
2154:                        literal_string(token.str);
9D00201C  3C04A000   LUI A0, -24576
9D002020  0F4005D5   JAL literal_string
9D002024  2484391C   ADDIU A0, A0, 14620
9D002028  0B400828   J 0x9D0020A0
9D00202C  00000000   NOP
2155:                    }else if (token.id==eIDENT){
9D002030  14430019   BNE V0, V1, 0x9D002098
9D002034  3C04A000   LUI A0, -24576
2156:                        var=var_search(token.str);
9D002038  0F40006B   JAL var_search
9D00203C  2484391C   ADDIU A0, A0, 14620
2157:                        if (!var || !(var->vtype==eVAR_STR || var->vtype==eVAR_STRARRAY)) throw(eERR_BAD_ARG);
9D002040  10400007   BEQ V0, ZERO, 0x9D002060
9D002044  00408021   ADDU S0, V0, ZERO
9D002048  90420005   LBU V0, 5(V0)
9D00204C  24030001   ADDIU V1, ZERO, 1
9D002050  1043000B   BEQ V0, V1, 0x9D002080
9D002054  24030004   ADDIU V1, ZERO, 4
9D002058  10430003   BEQ V0, V1, 0x9D002068
9D00205C  00000000   NOP
9D002060  0F400080   JAL throw
9D002064  24040006   ADDIU A0, ZERO, 6
2158:                        if (var->vtype==eVAR_STRARRAY){
2159:                            expect(eLPAREN);
9D002068  0F4003EC   JAL expect
9D00206C  2404000C   ADDIU A0, ZERO, 12
2160:                            code_array_address(var);
9D002070  0F4007E1   JAL code_array_address
9D002074  02002021   ADDU A0, S0, ZERO
9D002078  0B400822   J 0x9D002088
9D00207C  00000000   NOP
2161:                        }else{
2162:                            _lit((uint32_t)&var->str);
9D002080  0F400445   JAL bytecode
9D002084  24040001   ADDIU A0, ZERO, 1
2163:                        }
2164:                        bytecode(IFETCH);
9D002088  0F400445   JAL bytecode
9D00208C  2404000A   ADDIU A0, ZERO, 10
9D002090  0B400828   J 0x9D0020A0
9D002094  00000000   NOP
2165:                    }else{
2166:                        throw(eERR_BAD_ARG);
9D002098  0F400080   JAL throw
9D00209C  24040006   ADDIU A0, ZERO, 6
2167:                    }
2168:                    bytecode(ISRLOAD);
9D0020A0  0F400445   JAL bytecode
9D0020A4  24040068   ADDIU A0, ZERO, 104
2169:                }//f
9D0020A8  8FBF0014   LW RA, 20(SP)
9D0020AC  8FB00010   LW S0, 16(SP)
9D0020B0  03E00008   JR RA
9D0020B4  27BD0018   ADDIU SP, SP, 24
2170:                
2171:                //SRSAVE file_name, size
2172:                //sauvegarde SPIRAM dans un fichier
2173:                static void kw_srsave(){
9D00341C  27BDFFE8   ADDIU SP, SP, -24
9D003420  AFBF0014   SW RA, 20(SP)
2174:                    var_t *var;
2175:                    
2176:                    next_token();
9D003424  0F4001A6   JAL next_token
9D003428  AFB00010   SW S0, 16(SP)
2177:                    if (token.id==eSTRING){
9D00342C  3C02A000   LUI V0, -24576
9D003430  8C423918   LW V0, 14616(V0)
9D003434  24030005   ADDIU V1, ZERO, 5
9D003438  14430006   BNE V0, V1, 0x9D003454
9D00343C  24030003   ADDIU V1, ZERO, 3
2178:                        literal_string(token.str);
9D003440  3C04A000   LUI A0, -24576
9D003444  0F4005D5   JAL literal_string
9D003448  2484391C   ADDIU A0, A0, 14620
9D00344C  0B400D31   J 0x9D0034C4
9D003450  00000000   NOP
2179:                    }else if (token.id==eIDENT){
9D003454  14430019   BNE V0, V1, 0x9D0034BC
9D003458  3C04A000   LUI A0, -24576
2180:                        var=var_search(token.str);
9D00345C  0F40006B   JAL var_search
9D003460  2484391C   ADDIU A0, A0, 14620
2181:                        if (!var || !(var->vtype==eVAR_STR || var->vtype==eVAR_STRARRAY)) throw(eERR_BAD_ARG);
9D003464  10400007   BEQ V0, ZERO, 0x9D003484
9D003468  00408021   ADDU S0, V0, ZERO
9D00346C  90420005   LBU V0, 5(V0)
9D003470  24030001   ADDIU V1, ZERO, 1
9D003474  1043000B   BEQ V0, V1, 0x9D0034A4
9D003478  24030004   ADDIU V1, ZERO, 4
9D00347C  10430003   BEQ V0, V1, 0x9D00348C
9D003480  00000000   NOP
9D003484  0F400080   JAL throw
9D003488  24040006   ADDIU A0, ZERO, 6
2182:                        if (var->vtype==eVAR_STRARRAY){
2183:                            expect(eLPAREN);
9D00348C  0F4003EC   JAL expect
9D003490  2404000C   ADDIU A0, ZERO, 12
2184:                            code_array_address(var);
9D003494  0F4007E1   JAL code_array_address
9D003498  02002021   ADDU A0, S0, ZERO
9D00349C  0B400D2B   J 0x9D0034AC
9D0034A0  00000000   NOP
2185:                        }else{
2186:                            _lit((uint32_t)&var->str);
9D0034A4  0F400445   JAL bytecode
9D0034A8  24040001   ADDIU A0, ZERO, 1
2187:                        }
2188:                        bytecode(IFETCH);
9D0034AC  0F400445   JAL bytecode
9D0034B0  2404000A   ADDIU A0, ZERO, 10
9D0034B4  0B400D31   J 0x9D0034C4
9D0034B8  00000000   NOP
2189:                    }else{
2190:                        throw(eERR_BAD_ARG);
9D0034BC  0F400080   JAL throw
9D0034C0  24040006   ADDIU A0, ZERO, 6
2191:                    }
2192:                    expect(eCOMMA);
9D0034C4  0F4003EC   JAL expect
9D0034C8  2404000B   ADDIU A0, ZERO, 11
2193:                    expression();
9D0034CC  0F400799   JAL expression
9D0034D0  00000000   NOP
2194:                    bytecode(ISRSAVE);
9D0034D4  0F400445   JAL bytecode
9D0034D8  24040067   ADDIU A0, ZERO, 103
2195:                }//f
9D0034DC  8FBF0014   LW RA, 20(SP)
9D0034E0  8FB00010   LW S0, 16(SP)
9D0034E4  03E00008   JR RA
9D0034E8  27BD0018   ADDIU SP, SP, 24
2196:                
2197:                //SRCLEAR(address,size)
2198:                //met à zéro un bloc de mémoire SPIRAM
2199:                static void kw_srclear(){
9D002BBC  27BDFFE8   ADDIU SP, SP, -24
9D002BC0  AFBF0014   SW RA, 20(SP)
2200:                    parse_arg_list(2);
9D002BC4  0F40097D   JAL parse_arg_list
9D002BC8  24040002   ADDIU A0, ZERO, 2
2201:                    bytecode(ISRCLEAR);
9D002BCC  0F400445   JAL bytecode
9D002BD0  24040066   ADDIU A0, ZERO, 102
2202:                }//f
9D002BD4  8FBF0014   LW RA, 20(SP)
9D002BD8  03E00008   JR RA
9D002BDC  27BD0018   ADDIU SP, SP, 24
2203:                
2204:                //SRREAD(address,@var,size)
2205:                //_lit un bloc de mémoire SPIRAM
2206:                //dans une variable
2207:                static void kw_srread(){
9D002B98  27BDFFE8   ADDIU SP, SP, -24
9D002B9C  AFBF0014   SW RA, 20(SP)
2208:                    parse_arg_list(3);
9D002BA0  0F40097D   JAL parse_arg_list
9D002BA4  24040003   ADDIU A0, ZERO, 3
2209:                    bytecode(ISRREAD);
9D002BA8  0F400445   JAL bytecode
9D002BAC  24040065   ADDIU A0, ZERO, 101
2210:                }//f
9D002BB0  8FBF0014   LW RA, 20(SP)
9D002BB4  03E00008   JR RA
9D002BB8  27BD0018   ADDIU SP, SP, 24
2211:                
2212:                //SRWRITE(address,@var,size)
2213:                //copie le contenu d'une variable dans la SPIRAM
2214:                static void kw_srwrite(){
9D002B74  27BDFFE8   ADDIU SP, SP, -24
9D002B78  AFBF0014   SW RA, 20(SP)
2215:                    parse_arg_list(3);
9D002B7C  0F40097D   JAL parse_arg_list
9D002B80  24040003   ADDIU A0, ZERO, 3
2216:                    bytecode(ISRWRITE);
9D002B84  0F400445   JAL bytecode
9D002B88  24040064   ADDIU A0, ZERO, 100
2217:                }//f
9D002B8C  8FBF0014   LW RA, 20(SP)
9D002B90  03E00008   JR RA
9D002B94  27BD0018   ADDIU SP, SP, 24
2218:                
2219:                //RESTSCR(adresse)
2220:                //restore le buffer vidéo à partir de la SPI RAM
2221:                // adresse est l'adresse sour dans SPI RAM
2222:                static void kw_restore_screen(){
9D002D48  27BDFFE8   ADDIU SP, SP, -24
9D002D4C  AFBF0014   SW RA, 20(SP)
2223:                    parse_arg_list(1);
9D002D50  0F40097D   JAL parse_arg_list
9D002D54  24040001   ADDIU A0, ZERO, 1
2224:                    bytecode(IRESTSCR);
9D002D58  0F400445   JAL bytecode
9D002D5C  24040063   ADDIU A0, ZERO, 99
2225:                }//f
9D002D60  8FBF0014   LW RA, 20(SP)
9D002D64  03E00008   JR RA
9D002D68  27BD0018   ADDIU SP, SP, 24
2226:                
2227:                //SAVESCR(adresse)
2228:                //sauvegarde le buffer vidéo dans la SPI RAM
2229:                // adresse est la destination dans SPI RAM
2230:                static void kw_save_screen(){
9D002D24  27BDFFE8   ADDIU SP, SP, -24
9D002D28  AFBF0014   SW RA, 20(SP)
2231:                    parse_arg_list(1);
9D002D2C  0F40097D   JAL parse_arg_list
9D002D30  24040001   ADDIU A0, ZERO, 1
2232:                    bytecode(ISAVESCR);
9D002D34  0F400445   JAL bytecode
9D002D38  24040062   ADDIU A0, ZERO, 98
2233:                }//f
9D002D3C  8FBF0014   LW RA, 20(SP)
9D002D40  03E00008   JR RA
9D002D44  27BD0018   ADDIU SP, SP, 24
2234:                
2235:                //compile l'assignation pour élément de variable
2236:                // vecteur
2237:                static void array_let(char * name){
2238:                    var_t *var;
2239:                    char *adr;
2240:                    
2241:                    var=var_search(name);
9D0041C8  0F40006B   JAL var_search
9D0041CC  27A40010   ADDIU A0, SP, 16
2242:                    if (!var) throw(eERR_NOTDIM);
9D0041D0  14400003   BNE V0, ZERO, 0x9D0041E0
9D0041D4  00408021   ADDU S0, V0, ZERO
9D0041D8  0F400080   JAL throw
9D0041DC  2404000B   ADDIU A0, ZERO, 11
2243:                    if (!(var->vtype>=eVAR_INTARRAY && var->vtype<=eVAR_STRARRAY)) throw(eERR_BAD_ARG);
9D0041E0  90420005   LBU V0, 5(V0)
9D0041E4  2442FFFE   ADDIU V0, V0, -2
9D0041E8  304200FF   ANDI V0, V0, 255
9D0041EC  2C420003   SLTIU V0, V0, 3
9D0041F0  14400003   BNE V0, ZERO, 0x9D004200
9D0041F4  00000000   NOP
9D0041F8  0F400080   JAL throw
9D0041FC  24040006   ADDIU A0, ZERO, 6
2244:                    code_array_address(var);
9D004200  0F4007E1   JAL code_array_address
9D004204  02002021   ADDU A0, S0, ZERO
2245:                    expect(eEQUAL);
9D004208  0F4003EC   JAL expect
9D00420C  2404000F   ADDIU A0, ZERO, 15
2246:                    switch (var->vtype){
9D004210  92020005   LBU V0, 5(S0)
9D004214  24030003   ADDIU V1, ZERO, 3
9D004218  10430021   BEQ V0, V1, 0x9D0042A0
9D00421C  24030004   ADDIU V1, ZERO, 4
9D004220  10430005   BEQ V0, V1, 0x9D004238
9D004224  24030002   ADDIU V1, ZERO, 2
9D004228  14430025   BNE V0, V1, 0x9D0042C0
9D00422C  00000000   NOP
9D004230  0B4010A0   J 0x9D004280
9D004234  00000000   NOP
2247:                        case eVAR_STRARRAY:
2248:                            expect(eSTRING);
9D004238  0F4003EC   JAL expect
9D00423C  24040005   ADDIU A0, ZERO, 5
2249:                            adr=(char*)alloc_var_space(strlen(token.str)+1);
9D004240  3C10A000   LUI S0, -24576
9D004244  0F406EC2   JAL strlen
9D004248  2604391C   ADDIU A0, S0, 14620
9D00424C  0F400104   JAL alloc_var_space
9D004250  24440001   ADDIU A0, V0, 1
2250:                            strcpy(adr,token.str);
9D004254  00402021   ADDU A0, V0, ZERO
9D004258  0F406D40   JAL strcpy
9D00425C  2605391C   ADDIU A1, S0, 14620
2251:                            _lit((uint32_t)adr);
9D004260  0F400445   JAL bytecode
9D004264  24040001   ADDIU A0, ZERO, 1
2252:                            bytecode(ISWAP);
9D004268  0F400445   JAL bytecode
9D00426C  24040012   ADDIU A0, ZERO, 18
2253:                            bytecode(ISTORE);
9D004270  0F400445   JAL bytecode
9D004274  24040009   ADDIU A0, ZERO, 9
2254:                            break;
2255:                        case eVAR_INTARRAY:
2256:                            expression();
9D004280  0F400799   JAL expression
9D004284  00000000   NOP
2257:                            bytecode(ISWAP);
9D004288  0F400445   JAL bytecode
9D00428C  24040012   ADDIU A0, ZERO, 18
2258:                            bytecode(ISTORE);
9D004290  0F400445   JAL bytecode
9D004294  24040009   ADDIU A0, ZERO, 9
2259:                            break;
2260:                        case eVAR_BYTEARRAY:
2261:                            expression();
9D0042A0  0F400799   JAL expression
9D0042A4  00000000   NOP
2262:                            bytecode(ISWAP);
9D0042A8  0F400445   JAL bytecode
9D0042AC  24040012   ADDIU A0, ZERO, 18
2263:                            bytecode(ICSTORE);
9D0042B0  0F400445   JAL bytecode
9D0042B4  2404000B   ADDIU A0, ZERO, 11
2264:                            break;
2265:                        default:
2266:                            throw(eERR_SYNTAX);
9D0042C0  0F400080   JAL throw
9D0042C4  24040007   ADDIU A0, ZERO, 7
2267:                    }//switch
2268:                }//f
2269:                
2270:                // compile le code pour le stockage d'untier
2271:                static void store_integer(var_t *var){
9D001B24  27BDFFE8   ADDIU SP, SP, -24
9D001B28  AFBF0014   SW RA, 20(SP)
9D001B2C  AFB00010   SW S0, 16(SP)
2272:                    switch(var->vtype){
9D001B30  90820005   LBU V0, 5(A0)
9D001B34  24030007   ADDIU V1, ZERO, 7
9D001B38  1043000E   BEQ V0, V1, 0x9D001B74
9D001B3C  00808021   ADDU S0, A0, ZERO
9D001B40  2C430008   SLTIU V1, V0, 8
9D001B44  10600005   BEQ V1, ZERO, 0x9D001B5C
9D001B48  24030008   ADDIU V1, ZERO, 8
9D001B4C  1040000F   BEQ V0, ZERO, 0x9D001B8C
9D001B50  00000000   NOP
9D001B54  0B4006F3   J 0x9D001BCC
9D001B58  00000000   NOP
9D001B5C  10430017   BEQ V0, V1, 0x9D001BBC
9D001B60  24030009   ADDIU V1, ZERO, 9
9D001B64  1043000F   BEQ V0, V1, 0x9D001BA4
9D001B68  00000000   NOP
9D001B6C  0B4006F3   J 0x9D001BCC
9D001B70  00000000   NOP
2273:                        case eVAR_LOCAL:
2274:                            bytecode(ILCSTORE);
9D001B74  0F400445   JAL bytecode
9D001B78  24040060   ADDIU A0, ZERO, 96
2275:                            bytecode(var->n);
9D001B7C  0F400445   JAL bytecode
9D001B80  9204000C   LBU A0, 12(S0)
2276:                            break;
9D001B84  0B4006F5   J 0x9D001BD4
9D001B88  8FBF0014   LW RA, 20(SP)
2277:                        case eVAR_INT:
2278:                            _lit(((uint32_t)(int*)&var->n));
9D001B8C  0F400445   JAL bytecode
9D001B90  24040001   ADDIU A0, ZERO, 1
2279:                            bytecode(ISTORE);
9D001B94  0F400445   JAL bytecode
9D001B98  24040009   ADDIU A0, ZERO, 9
2280:                            break;
9D001B9C  0B4006F5   J 0x9D001BD4
9D001BA0  8FBF0014   LW RA, 20(SP)
2281:                        case eVAR_BYTE:
2282:                            _lit(((uint32_t)(int*)&var->n));
9D001BA4  0F400445   JAL bytecode
9D001BA8  24040001   ADDIU A0, ZERO, 1
2283:                            bytecode(ICSTORE);
9D001BAC  0F400445   JAL bytecode
9D001BB0  2404000B   ADDIU A0, ZERO, 11
2284:                            break;
9D001BB4  0B4006F5   J 0x9D001BD4
9D001BB8  8FBF0014   LW RA, 20(SP)
2285:                        case eVAR_CONST:
2286:                            // ignore les assignations de constantes jette la valeur
2287:                            bytecode(IDROP);
9D001BBC  0F400445   JAL bytecode
9D001BC0  24040010   ADDIU A0, ZERO, 16
2288:                            break;
9D001BC4  0B4006F5   J 0x9D001BD4
9D001BC8  8FBF0014   LW RA, 20(SP)
2289:                        default:
2290:                            throw (eERR_BAD_ARG);
9D001BCC  0F400080   JAL throw
9D001BD0  24040006   ADDIU A0, ZERO, 6
2291:                    }//switch
2292:                }//f
9D001BD4  8FB00010   LW S0, 16(SP)
9D001BD8  03E00008   JR RA
9D001BDC  27BD0018   ADDIU SP, SP, 24
2293:                
2294:                // KEY()
2295:                //attend une touche du clavier
2296:                // retourne la valeur ASCII
2297:                static void kw_waitkey(){
9D0011FC  27BDFFE8   ADDIU SP, SP, -24
9D001200  AFBF0014   SW RA, 20(SP)
2298:                    expect(eLPAREN);
9D001204  0F4003EC   JAL expect
9D001208  2404000C   ADDIU A0, ZERO, 12
2299:                    expect(eRPAREN);
9D00120C  0F4003EC   JAL expect
9D001210  2404000D   ADDIU A0, ZERO, 13
2300:                    bytecode(IKEY);
9D001214  0F400445   JAL bytecode
9D001218  2404004F   ADDIU A0, ZERO, 79
2301:                }//f
9D00121C  8FBF0014   LW RA, 20(SP)
9D001220  03E00008   JR RA
9D001224  27BD0018   ADDIU SP, SP, 24
2302:                
2303:                //LEN(var$|string)
2304:                static void kw_len(){
9D003714  27BDFFE8   ADDIU SP, SP, -24
9D003718  AFBF0014   SW RA, 20(SP)
2305:                    var_t *var;
2306:                    expect(eLPAREN);
9D00371C  0F4003EC   JAL expect
9D003720  2404000C   ADDIU A0, ZERO, 12
2307:                    next_token();
9D003724  0F4001A6   JAL next_token
9D003728  00000000   NOP
2308:                    if (token.id==eSTRING){
9D00372C  3C02A000   LUI V0, -24576
9D003730  8C423918   LW V0, 14616(V0)
9D003734  24030005   ADDIU V1, ZERO, 5
9D003738  14430006   BNE V0, V1, 0x9D003754
9D00373C  24030003   ADDIU V1, ZERO, 3
2309:                        literal_string(token.str);
9D003740  3C04A000   LUI A0, -24576
9D003744  0F4005D5   JAL literal_string
9D003748  2484391C   ADDIU A0, A0, 14620
9D00374C  0B400DFE   J 0x9D0037F8
9D003750  00000000   NOP
2310:                    }else if (token.id==eIDENT){
9D003754  14430026   BNE V0, V1, 0x9D0037F0
9D003758  3C04A000   LUI A0, -24576
2311:                        var=var_search(token.str);
9D00375C  0F40006B   JAL var_search
9D003760  2484391C   ADDIU A0, A0, 14620
2312:                        if (!var) throw(eERR_BAD_ARG);
9D003764  54400003   BNEL V0, ZERO, 0x9D003774
9D003768  90420005   LBU V0, 5(V0)
9D00376C  0F400080   JAL throw
9D003770  24040006   ADDIU A0, ZERO, 6
2313:                        switch(var->vtype){
9D003774  24030001   ADDIU V1, ZERO, 1
9D003778  10430005   BEQ V0, V1, 0x9D003790
9D00377C  24030004   ADDIU V1, ZERO, 4
9D003780  10430007   BEQ V0, V1, 0x9D0037A0
9D003784  00000000   NOP
9D003788  0B400DFA   J 0x9D0037E8
9D00378C  00000000   NOP
2314:                            case eVAR_STR:
2315:                                _lit((uint32_t)var->str);
9D003790  0F400445   JAL bytecode
9D003794  24040001   ADDIU A0, ZERO, 1
2316:                                break;
9D003798  0B400DFE   J 0x9D0037F8
9D00379C  00000000   NOP
2317:                            case eVAR_STRARRAY:
2318:                                _lit((uint32_t)var->adr);
9D0037A0  0F400445   JAL bytecode
9D0037A4  24040001   ADDIU A0, ZERO, 1
2319:                                expect(eLPAREN);
9D0037A8  0F4003EC   JAL expect
9D0037AC  2404000C   ADDIU A0, ZERO, 12
2320:                                expression();
9D0037B0  0F400799   JAL expression
9D0037B4  00000000   NOP
2321:                                expect(eRPAREN);
9D0037B8  0F4003EC   JAL expect
9D0037BC  2404000D   ADDIU A0, ZERO, 13
2322:                                _litc(1);
9D0037C0  0F400445   JAL bytecode
9D0037C4  24040003   ADDIU A0, ZERO, 3
2323:                                bytecode(IPLUS);
9D0037C8  0F400445   JAL bytecode
9D0037CC  24040015   ADDIU A0, ZERO, 21
2324:                                bytecode(ILSHIFT);
9D0037D0  0F400445   JAL bytecode
9D0037D4  24040034   ADDIU A0, ZERO, 52
2325:                                bytecode(IPLUS);
9D0037D8  0F400445   JAL bytecode
9D0037DC  24040015   ADDIU A0, ZERO, 21
2326:                                break;
9D0037E0  0B400DFE   J 0x9D0037F8
9D0037E4  00000000   NOP
2327:                            default:
2328:                                throw(eERR_BAD_ARG);
9D0037E8  0F400080   JAL throw
9D0037EC  24040006   ADDIU A0, ZERO, 6
2329:                        }//switch
2330:                    }else{
2331:                        throw(eERR_BAD_ARG);
9D0037F0  0F400080   JAL throw
9D0037F4  24040006   ADDIU A0, ZERO, 6
2332:                    }
2333:                    bytecode(ILEN);
9D0037F8  0F400445   JAL bytecode
9D0037FC  2404005F   ADDIU A0, ZERO, 95
2334:                    expect(eRPAREN);
9D003800  0F4003EC   JAL expect
9D003804  2404000D   ADDIU A0, ZERO, 13
2335:                }//f
9D003808  8FBF0014   LW RA, 20(SP)
9D00380C  03E00008   JR RA
9D003810  27BD0018   ADDIU SP, SP, 24
2336:                
2337:                //compile le code qui vérifie si une
2338:                // chaine est déjà assignée à cette variable
2339:                static void compile_accept_var(var_t* var){
9D00132C  27BDFFE8   ADDIU SP, SP, -24
9D001330  AFBF0014   SW RA, 20(SP)
9D001334  AFB00010   SW S0, 16(SP)
2340:                    bytecode(IFETCH); // (var->str -- char* )
9D001338  0F400445   JAL bytecode
9D00133C  2404000A   ADDIU A0, ZERO, 10
2341:                    bytecode(IQBRAZ); // si NULL accepte
9D001340  0F400445   JAL bytecode
9D001344  24040037   ADDIU A0, ZERO, 55
2342:                    rstack[++rsp]=dptr;
9D001348  9382C114   LBU V0, -16108(GP)
9D00134C  24420001   ADDIU V0, V0, 1
9D001350  7C021420   SEB V0, V0
9D001354  A382C114   SB V0, -16108(GP)
9D001358  00021080   SLL V0, V0, 2
9D00135C  3C10A000   LUI S0, -24576
9D001360  26104080   ADDIU S0, S0, 16512
9D001364  00501021   ADDU V0, V0, S0
9D001368  8F83C11C   LW V1, -16100(GP)
9D00136C  AC430000   SW V1, 0(V0)
2343:                    bytecode(0);
9D001370  0F400445   JAL bytecode
9D001374  00002021   ADDU A0, ZERO, ZERO
2344:                    bytecode(0);
9D001378  0F400445   JAL bytecode
9D00137C  00002021   ADDU A0, ZERO, ZERO
2345:                    // variable chaîne déjà assignée on ignore cette variable
2346:                    bytecode(IDROP); // la copie ne sera pas utilisée
9D001380  0F400445   JAL bytecode
9D001384  24040010   ADDIU A0, ZERO, 16
2347:                    bytecode(IBRA);
9D001388  0F400445   JAL bytecode
9D00138C  24040006   ADDIU A0, ZERO, 6
2348:                    bytecode(0);
9D001390  0F400445   JAL bytecode
9D001394  00002021   ADDU A0, ZERO, ZERO
2349:                    bytecode(0);
9D001398  0F400445   JAL bytecode
9D00139C  00002021   ADDU A0, ZERO, ZERO
2350:                    fix_branch_address();
9D0013A0  0F400002   JAL fix_branch_address
9D0013A4  00000000   NOP
2351:                    rstack[++rsp]=dptr-2;
9D0013A8  9382C114   LBU V0, -16108(GP)
9D0013AC  24420001   ADDIU V0, V0, 1
9D0013B0  7C021420   SEB V0, V0
9D0013B4  A382C114   SB V0, -16108(GP)
9D0013B8  00021080   SLL V0, V0, 2
9D0013BC  00508021   ADDU S0, V0, S0
9D0013C0  8F82C11C   LW V0, -16100(GP)
9D0013C4  2442FFFE   ADDIU V0, V0, -2
9D0013C8  AE020000   SW V0, 0(S0)
2352:                }//f
9D0013CC  8FBF0014   LW RA, 20(SP)
9D0013D0  8FB00010   LW S0, 16(SP)
9D0013D4  03E00008   JR RA
9D0013D8  27BD0018   ADDIU SP, SP, 24
2353:                
2354:                // INPUT [string ','] identifier (',' identifier)
2355:                // saisie au clavier de
2356:                // valeur de variables
2357:                static void kw_input(){
9D002ED4  27BDFFB8   ADDIU SP, SP, -72
9D002ED8  AFBF0044   SW RA, 68(SP)
9D002EDC  AFB30040   SW S3, 64(SP)
9D002EE0  AFB2003C   SW S2, 60(SP)
9D002EE4  AFB10038   SW S1, 56(SP)
2358:                    char name[32];
2359:                    var_t *var;
2360:                    
2361:                    next_token();
9D002EE8  0F4001A6   JAL next_token
9D002EEC  AFB00034   SW S0, 52(SP)
2362:                    if (token.id==eSTRING){
9D002EF0  3C02A000   LUI V0, -24576
9D002EF4  8C423918   LW V0, 14616(V0)
9D002EF8  24030005   ADDIU V1, ZERO, 5
9D002EFC  14430013   BNE V0, V1, 0x9D002F4C
9D002F00  24030003   ADDIU V1, ZERO, 3
2363:                        literal_string(token.str);
9D002F04  3C04A000   LUI A0, -24576
9D002F08  0F4005D5   JAL literal_string
9D002F0C  2484391C   ADDIU A0, A0, 14620
2364:                        bytecode(ITYPE);
9D002F10  0F400445   JAL bytecode
9D002F14  24040052   ADDIU A0, ZERO, 82
2365:                        bytecode(ICR);
9D002F18  0F400445   JAL bytecode
9D002F1C  24040053   ADDIU A0, ZERO, 83
2366:                        expect(eCOMMA);
9D002F20  0F4003EC   JAL expect
9D002F24  2404000B   ADDIU A0, ZERO, 11
2367:                        expect(eIDENT);
9D002F28  0F4003EC   JAL expect
9D002F2C  24040003   ADDIU A0, ZERO, 3
2368:                    }else if(token.id!=eIDENT) throw(eERR_BAD_ARG); 
9D002F4C  14430006   BNE V0, V1, 0x9D002F68
9D002F50  3C12A000   LUI S2, -24576
9D002F68  0F400080   JAL throw
9D002F6C  24040006   ADDIU A0, ZERO, 6
2369:                    while (token.id==eIDENT){
9D002F30  3C02A000   LUI V0, -24576
9D002F34  8C433918   LW V1, 14616(V0)
9D002F38  24020003   ADDIU V0, ZERO, 3
9D002F3C  10620005   BEQ V1, V0, 0x9D002F54
9D002F40  3C12A000   LUI S2, -24576
9D003228  8E233918   LW V1, 14616(S1)
9D00322C  24020003   ADDIU V0, ZERO, 3
9D003230  1062FF50   BEQ V1, V0, 0x9D002F74
9D003234  27A40010   ADDIU A0, SP, 16
2370:                        strcpy(name,token.str);
9D002F54  2652391C   ADDIU S2, S2, 14620
9D002F70  27A40010   ADDIU A0, SP, 16
9D002F74  0F406D40   JAL strcpy
9D002F78  02402821   ADDU A1, S2, ZERO
2371:                        var=var_search(name);
9D002F7C  0F40006B   JAL var_search
9D002F80  27A40010   ADDIU A0, SP, 16
2372:                        //dans contexte SUB|FUNC seule les variables préexistante
2373:                        //peuvent-être utilisées
2374:                        if (!var && var_local) throw(eERR_BAD_ARG);
9D002F84  144000B7   BNE V0, ZERO, 0x9D003264
9D002F88  00408021   ADDU S0, V0, ZERO
9D002F8C  93828078   LBU V0, -32648(GP)
9D002F90  104000AC   BEQ V0, ZERO, 0x9D003244
9D002F94  00000000   NOP
9D002F98  0F400080   JAL throw
9D002F9C  24040006   ADDIU A0, ZERO, 6
2375:                        next_token();
9D003244  0F4001A6   JAL next_token
9D003248  00000000   NOP
9D003264  0F4001A6   JAL next_token
9D003268  00000000   NOP
2376:                        //seules les variables vecteur préexistantes peuvent-être utilisées
2377:                        if (token.id==eLPAREN && !var) throw(eERR_BAD_ARG);
9D002F58  3C11A000   LUI S1, -24576
9D002FA0  0F400080   JAL throw
9D002FA4  24040006   ADDIU A0, ZERO, 6
9D00324C  8E233918   LW V1, 14616(S1)
9D003250  2402000C   ADDIU V0, ZERO, 12
9D003254  14620008   BNE V1, V0, 0x9D003278
9D003258  24020001   ADDIU V0, ZERO, 1
9D00325C  0B400BE8   J 0x9D002FA0
9D003260  00000000   NOP
2378:                        unget_token=true;
9D00326C  24020001   ADDIU V0, ZERO, 1
9D003270  0B400BEA   J 0x9D002FA8
9D003274  A3828084   SB V0, -32636(GP)
9D003278  A3828084   SB V0, -32636(GP)
2379:                        if (!var) var=var_create(name,NULL);
9D00327C  27A40010   ADDIU A0, SP, 16
9D003280  0F400115   JAL var_create
9D003284  00002821   ADDU A1, ZERO, ZERO
9D003288  0B400BEA   J 0x9D002FA8
9D00328C  00408021   ADDU S0, V0, ZERO
2380:                        if (var->vtype>=eVAR_INTARRAY && var->vtype<=eVAR_STRARRAY){
9D002FA8  92020005   LBU V0, 5(S0)
9D002FAC  2442FFFE   ADDIU V0, V0, -2
9D002FB0  304200FF   ANDI V0, V0, 255
9D002FB4  2C420003   SLTIU V0, V0, 3
9D002FB8  50400004   BEQL V0, ZERO, 0x9D002FCC
9D002FBC  92020005   LBU V0, 5(S0)
2381:                            parse_arg_list(1);
9D002FC0  0F40097D   JAL parse_arg_list
9D002FC4  24040001   ADDIU A0, ZERO, 1
2382:                        }
2383:                        switch (var->vtype){ 
9D002F5C  3C139D00   LUI S3, -25344
9D002F60  0B400BDC   J 0x9D002F70
9D002F64  26732FF0   ADDIU S3, S3, 12272
9D002FC8  92020005   LBU V0, 5(S0)
9D002FCC  2C42000A   SLTIU V0, V0, 10
9D002FD0  1040008D   BEQ V0, ZERO, 0x9D003208
9D002FD4  00000000   NOP
9D002FD8  92020005   LBU V0, 5(S0)
9D002FDC  00021080   SLL V0, V0, 2
9D002FE0  02621021   ADDU V0, S3, V0
9D002FE4  8C420000   LW V0, 0(V0)
9D002FE8  00400008   JR V0
9D002FEC  00000000   NOP
2384:                            case eVAR_STR:
2385:                                _lit((uint32_t)&var->str);
9D003018  0F400445   JAL bytecode
9D00301C  24040001   ADDIU A0, ZERO, 1
2386:                                bytecode(IDUP); //conserve une copie
9D003020  0F400445   JAL bytecode
9D003024  24040011   ADDIU A0, ZERO, 17
2387:                                compile_accept_var(var);
9D003028  0F4004CB   JAL compile_accept_var
9D00302C  02002021   ADDU A0, S0, ZERO
2388:                                // var accepté, lecture de la  chaîne au clavier
2389:                                _prt_varname(var);
9D003030  0F400445   JAL bytecode
9D003034  24040001   ADDIU A0, ZERO, 1
9D003038  0F400445   JAL bytecode
9D00303C  24040052   ADDIU A0, ZERO, 82
2390:                                _litc(CHAR_PER_LINE-2);
9D003040  0F400445   JAL bytecode
9D003044  24040003   ADDIU A0, ZERO, 3
2391:                                bytecode(IACCEPT); // ( var_adr buffsize -- var_adr _pad n )
9D003048  0F400445   JAL bytecode
9D00304C  2404005E   ADDIU A0, ZERO, 94
2392:                                _litc(1);
9D003050  0F400445   JAL bytecode
9D003054  24040003   ADDIU A0, ZERO, 3
2393:                                bytecode(IPLUS);
9D003058  0F400445   JAL bytecode
9D00305C  24040015   ADDIU A0, ZERO, 21
2394:                                bytecode(IALLOC);  //( var_adr _pad alloc_size -- var_adr _pad void* )
9D003060  0F400445   JAL bytecode
9D003064  2404005D   ADDIU A0, ZERO, 93
2395:                                bytecode(ISWAP);  //( var_adr _pad void* -- var_adr void* _pad )
9D003068  0F400445   JAL bytecode
9D00306C  24040012   ADDIU A0, ZERO, 18
2396:                                bytecode(IOVER);  //( var_adr void* _pad -- var_adr void* _pad void* )
9D003070  0F400445   JAL bytecode
9D003074  24040013   ADDIU A0, ZERO, 19
2397:                                bytecode(ISTRCPY); // ( var_adr void* src* dest* -- var_adr void* )
9D003078  0F400445   JAL bytecode
9D00307C  2404005C   ADDIU A0, ZERO, 92
2398:                                bytecode(ISWAP); // ( var_adr void* -- void* var_adr )
9D003080  0F400445   JAL bytecode
9D003084  24040012   ADDIU A0, ZERO, 18
2399:                                bytecode(ISTORE);   //( void* var_adr -- )
9D003088  0F400445   JAL bytecode
9D00308C  24040009   ADDIU A0, ZERO, 9
2400:                                fix_branch_address();
9D003090  0F400002   JAL fix_branch_address
9D003094  00000000   NOP
2401:                                break;
9D003098  0B400C82   J 0x9D003208
9D00309C  00000000   NOP
2402:                            case eVAR_STRARRAY:  // ( -- index )
2403:                                bytecode(ILSHIFT);   // ( index -- 2*index)
9D0030A0  0F400445   JAL bytecode
9D0030A4  24040034   ADDIU A0, ZERO, 52
2404:                                _lit((uint32_t)var->adr);
9D0030A8  0F400445   JAL bytecode
9D0030AC  24040001   ADDIU A0, ZERO, 1
2405:                                bytecode(IPLUS);  // ( -- &var(index) )
9D0030B0  0F400445   JAL bytecode
9D0030B4  24040015   ADDIU A0, ZERO, 21
2406:                                bytecode(IDUP);  // garde une copie
9D0030B8  0F400445   JAL bytecode
9D0030BC  24040011   ADDIU A0, ZERO, 17
2407:                                compile_accept_var(var);
9D0030C0  0F4004CB   JAL compile_accept_var
9D0030C4  02002021   ADDU A0, S0, ZERO
2408:                                //var acceptée, lecture de la chaîne au clavier 
2409:                                _prt_varname(var);  // ( var_adr -- var_adr )
9D0030C8  0F400445   JAL bytecode
9D0030CC  24040001   ADDIU A0, ZERO, 1
9D0030D0  0F400445   JAL bytecode
9D0030D4  24040052   ADDIU A0, ZERO, 82
2410:                                _litc(CHAR_PER_LINE-2); //( var_adr -- var_adr buffsize )
9D0030D8  0F400445   JAL bytecode
9D0030DC  24040003   ADDIU A0, ZERO, 3
2411:                                bytecode(IACCEPT); // ( var_adr buffsize -- var_adr _pad strlen )
9D0030E0  0F400445   JAL bytecode
9D0030E4  2404005E   ADDIU A0, ZERO, 94
2412:                                _litc(1);
9D0030E8  0F400445   JAL bytecode
9D0030EC  24040003   ADDIU A0, ZERO, 3
2413:                                bytecode(IPLUS);   // incrémente strlen
9D0030F0  0F400445   JAL bytecode
9D0030F4  24040015   ADDIU A0, ZERO, 21
2414:                                bytecode(IALLOC);  //( var_adr _pad alloc_size -- var_adr _pad void* )
9D0030F8  0F400445   JAL bytecode
9D0030FC  2404005D   ADDIU A0, ZERO, 93
2415:                                bytecode(ISWAP);   // ( var_adr _pad void* -- var_adr void* _pad  )
9D003100  0F400445   JAL bytecode
9D003104  24040012   ADDIU A0, ZERO, 18
2416:                                bytecode(IOVER);  // ( _var_adr void* _pad -- _var_adr void* _pad void*  )
9D003108  0F400445   JAL bytecode
9D00310C  24040013   ADDIU A0, ZERO, 19
2417:                                bytecode(ISTRCPY); // ( _var_adr void* src* dest* -- _var_adr void* )
9D003110  0F400445   JAL bytecode
9D003114  2404005C   ADDIU A0, ZERO, 92
2418:                                bytecode(ISWAP);   // ( _var_adr void* -- void* _var_adr )
9D003118  0F400445   JAL bytecode
9D00311C  24040012   ADDIU A0, ZERO, 18
2419:                                bytecode(ISTORE);   //( void* _var_adr  -- )
9D003120  0F400445   JAL bytecode
9D003124  24040009   ADDIU A0, ZERO, 9
2420:                                fix_branch_address();
9D003128  0F400002   JAL fix_branch_address
9D00312C  00000000   NOP
2421:                                break;
9D003130  0B400C82   J 0x9D003208
9D003134  00000000   NOP
2422:                            case eVAR_LOCAL:
2423:                            case eVAR_INT:
2424:                            case eVAR_BYTE:
2425:                                _litc(17);
9D003138  0F400445   JAL bytecode
9D00313C  24040003   ADDIU A0, ZERO, 3
2426:                                bytecode(IACCEPT);
9D003140  0F400445   JAL bytecode
9D003144  2404005E   ADDIU A0, ZERO, 94
2427:                                bytecode(IDROP);
9D003148  0F400445   JAL bytecode
9D00314C  24040010   ADDIU A0, ZERO, 16
2428:                                bytecode(IINT);
9D003150  0F400445   JAL bytecode
9D003154  2404005B   ADDIU A0, ZERO, 91
2429:                                store_integer(var);
9D003158  0F4006C9   JAL store_integer
9D00315C  02002021   ADDU A0, S0, ZERO
2430:                                break;
9D003160  0B400C82   J 0x9D003208
9D003164  00000000   NOP
2431:                            case eVAR_INTARRAY:
2432:                                bytecode(ILSHIFT);
9D003168  0F400445   JAL bytecode
9D00316C  24040034   ADDIU A0, ZERO, 52
2433:                                _lit((uint32_t)var->adr);
9D003170  0F400445   JAL bytecode
9D003174  24040001   ADDIU A0, ZERO, 1
2434:                                bytecode(IPLUS);
9D003178  0F400445   JAL bytecode
9D00317C  24040015   ADDIU A0, ZERO, 21
2435:                                _litc(17);
9D003180  0F400445   JAL bytecode
9D003184  24040003   ADDIU A0, ZERO, 3
2436:                                bytecode(IACCEPT);
9D003188  0F400445   JAL bytecode
9D00318C  2404005E   ADDIU A0, ZERO, 94
2437:                                bytecode(IDROP);
9D003190  0F400445   JAL bytecode
9D003194  24040010   ADDIU A0, ZERO, 16
2438:                                bytecode(IINT);
9D003198  0F400445   JAL bytecode
9D00319C  2404005B   ADDIU A0, ZERO, 91
2439:                                bytecode(ISWAP);
9D0031A0  0F400445   JAL bytecode
9D0031A4  24040012   ADDIU A0, ZERO, 18
2440:                                bytecode(ISTORE);
9D0031A8  0F400445   JAL bytecode
9D0031AC  24040009   ADDIU A0, ZERO, 9
2441:                                break;
9D0031B0  0B400C82   J 0x9D003208
9D0031B4  00000000   NOP
2442:                            case eVAR_BYTEARRAY:
2443:                                _litc(1);
9D0031B8  0F400445   JAL bytecode
9D0031BC  24040003   ADDIU A0, ZERO, 3
2444:                                bytecode(IPLUS);
9D0031C0  0F400445   JAL bytecode
9D0031C4  24040015   ADDIU A0, ZERO, 21
2445:                                _lit((uint32_t)var->adr);
9D0031C8  0F400445   JAL bytecode
9D0031CC  24040001   ADDIU A0, ZERO, 1
2446:                                bytecode(IPLUS);
9D0031D0  0F400445   JAL bytecode
9D0031D4  24040015   ADDIU A0, ZERO, 21
2447:                                _litc(9);
9D0031D8  0F400445   JAL bytecode
9D0031DC  24040003   ADDIU A0, ZERO, 3
2448:                                bytecode(IACCEPT);
9D0031E0  0F400445   JAL bytecode
9D0031E4  2404005E   ADDIU A0, ZERO, 94
2449:                                bytecode(IDROP);
9D0031E8  0F400445   JAL bytecode
9D0031EC  24040010   ADDIU A0, ZERO, 16
2450:                                bytecode(IINT);
9D0031F0  0F400445   JAL bytecode
9D0031F4  2404005B   ADDIU A0, ZERO, 91
2451:                                bytecode(ISWAP);
9D0031F8  0F400445   JAL bytecode
9D0031FC  24040012   ADDIU A0, ZERO, 18
2452:                                bytecode(ICSTORE);
9D003200  0F400445   JAL bytecode
9D003204  2404000B   ADDIU A0, ZERO, 11
2453:                                break;
2454:                        }//switch
2455:                        next_token();
9D003208  0F4001A6   JAL next_token
9D00320C  00000000   NOP
2456:                        if (token.id==eCOMMA){
9D003210  8E233918   LW V1, 14616(S1)
9D003214  2402000B   ADDIU V0, ZERO, 11
9D003218  14620008   BNE V1, V0, 0x9D00323C
9D00321C  24020001   ADDIU V0, ZERO, 1
2457:                            next_token();
9D003220  0F4001A6   JAL next_token
9D003224  00000000   NOP
2458:                        }else{
2459:                            break;
2460:                        }
2461:                    }
2462:                    unget_token=true;
9D002F44  0B400C8F   J 0x9D00323C
9D002F48  24020001   ADDIU V0, ZERO, 1
9D003238  24020001   ADDIU V0, ZERO, 1
9D00323C  0B400CA4   J 0x9D003290
9D003240  A3828084   SB V0, -32636(GP)
2463:                }//f
9D003290  8FBF0044   LW RA, 68(SP)
9D003294  8FB30040   LW S3, 64(SP)
9D003298  8FB2003C   LW S2, 60(SP)
9D00329C  8FB10038   LW S1, 56(SP)
9D0032A0  8FB00034   LW S0, 52(SP)
9D0032A4  03E00008   JR RA
9D0032A8  27BD0048   ADDIU SP, SP, 72
2464:                
2465:                // LET varname=expression
2466:                //assigne une valeur à une variable
2467:                //si la variable n'existe pas elle est créée.
2468:                static void kw_let(){
9D00409C  27BDFFC0   ADDIU SP, SP, -64
9D0040A0  AFBF003C   SW RA, 60(SP)
9D0040A4  AFB10038   SW S1, 56(SP)
9D0040A8  AFB00034   SW S0, 52(SP)
2469:                    char name[32];
2470:                    var_t *var;
2471:                    int len;
2472:                    
2473:                    expect(eIDENT);
9D0040AC  0F4003EC   JAL expect
9D0040B0  24040003   ADDIU A0, ZERO, 3
2474:                    strcpy(name,token.str);
9D0040B4  27A40010   ADDIU A0, SP, 16
9D0040B8  3C05A000   LUI A1, -24576
9D0040BC  0F406D40   JAL strcpy
9D0040C0  24A5391C   ADDIU A1, A1, 14620
2475:                    len=strlen(name);
9D0040C4  0F406EC2   JAL strlen
9D0040C8  27A40010   ADDIU A0, SP, 16
2476:                    next_token();
9D0040CC  0F4001A6   JAL next_token
9D0040D0  00408021   ADDU S0, V0, ZERO
2477:                    if (var_local){ // on ne peut pas allouer de chaîne dans les sous-routine
9D0040D4  93828078   LBU V0, -32648(GP)
9D0040D8  10400037   BEQ V0, ZERO, 0x9D0041B8
9D0040DC  3C02A000   LUI V0, -24576
2478:                        if (name[len-1]=='$') throw(eERR_SYNTAX);
9D0040E0  03B08021   ADDU S0, SP, S0
9D0040E4  8203000F   LB V1, 15(S0)
9D0040E8  24020024   ADDIU V0, ZERO, 36
9D0040EC  14620003   BNE V1, V0, 0x9D0040FC
9D0040F0  00000000   NOP
9D0040F4  0F400080   JAL throw
9D0040F8  24040007   ADDIU A0, ZERO, 7
2479:                        var=var_search(name);
9D0040FC  0F40006B   JAL var_search
9D004100  27A40010   ADDIU A0, SP, 16
2480:                        if (!var) throw(eERR_BAD_ARG); // pas d'auto création à l'intérieur des sous-routines
9D004104  14400003   BNE V0, ZERO, 0x9D004114
9D004108  00408021   ADDU S0, V0, ZERO
9D00410C  0F400080   JAL throw
9D004110  24040006   ADDIU A0, ZERO, 6
2481:                        if (token.id==eLPAREN && (var->vtype==eVAR_INTARRAY || var->vtype==eVAR_BYTEARRAY)){
9D004114  3C02A000   LUI V0, -24576
9D004118  8C423918   LW V0, 14616(V0)
9D00411C  2403000C   ADDIU V1, ZERO, 12
9D004120  1443001B   BNE V0, V1, 0x9D004190
9D004124  2403000F   ADDIU V1, ZERO, 15
9D004128  92020005   LBU V0, 5(S0)
9D00412C  2442FFFE   ADDIU V0, V0, -2
9D004130  304200FF   ANDI V0, V0, 255
9D004134  2C420002   SLTIU V0, V0, 2
9D004138  1040001D   BEQ V0, ZERO, 0x9D0041B0
9D00413C  00000000   NOP
2482:                            code_array_address(var);
9D004140  0F4007E1   JAL code_array_address
9D004144  02002021   ADDU A0, S0, ZERO
2483:                            expect(eEQUAL);
9D004148  0F4003EC   JAL expect
9D00414C  2404000F   ADDIU A0, ZERO, 15
2484:                            expression();
9D004150  0F400799   JAL expression
9D004154  00000000   NOP
2485:                            bytecode(ISWAP);
9D004158  0F400445   JAL bytecode
9D00415C  24040012   ADDIU A0, ZERO, 18
2486:                            if (var->vtype==eVAR_INTARRAY){
9D004160  92030005   LBU V1, 5(S0)
9D004164  24020002   ADDIU V0, ZERO, 2
9D004168  14620005   BNE V1, V0, 0x9D004180
9D00416C  00000000   NOP
2487:                                bytecode(ISTORE);
9D004170  0F400445   JAL bytecode
9D004174  24040009   ADDIU A0, ZERO, 9
9D004178  0B4010D8   J 0x9D004360
9D00417C  8FBF003C   LW RA, 60(SP)
2488:                            }else{
2489:                                bytecode(ICSTORE);
9D004180  0F400445   JAL bytecode
9D004184  2404000B   ADDIU A0, ZERO, 11
2490:                            }
2491:                        }else if (token.id==eEQUAL){
9D004190  14430007   BNE V0, V1, 0x9D0041B0
9D004194  00000000   NOP
2492:                            expression();
9D004198  0F400799   JAL expression
9D00419C  00000000   NOP
2493:                            store_integer(var);
9D0041A0  0F4006C9   JAL store_integer
9D0041A4  02002021   ADDU A0, S0, ZERO
9D0041A8  0B4010D8   J 0x9D004360
9D0041AC  8FBF003C   LW RA, 60(SP)
2494:                        }else throw(eERR_SYNTAX);
9D0041B0  0F400080   JAL throw
9D0041B4  24040007   ADDIU A0, ZERO, 7
2495:                    }else{
2496:                        if (token.id==eLPAREN){
9D0041B8  8C433918   LW V1, 14616(V0)
9D0041BC  2402000C   ADDIU V0, ZERO, 12
9D0041C0  14620041   BNE V1, V0, 0x9D0042C8
9D0041C4  00000000   NOP
2497:                            array_let(name);
2498:                        }else{
2499:                            var=var_search(name);
9D0042C8  0F40006B   JAL var_search
9D0042CC  27A40010   ADDIU A0, SP, 16
2500:                            if (!var) var=var_create(name,NULL);
9D0042D0  14400005   BNE V0, ZERO, 0x9D0042E8
9D0042D4  00408821   ADDU S1, V0, ZERO
9D0042D8  27A40010   ADDIU A0, SP, 16
9D0042DC  0F400115   JAL var_create
9D0042E0  00002821   ADDU A1, ZERO, ZERO
9D0042E4  00408821   ADDU S1, V0, ZERO
2501:                            unget_token=true;
9D0042E8  24020001   ADDIU V0, ZERO, 1
9D0042EC  A3828084   SB V0, -32636(GP)
2502:                            expect(eEQUAL);
9D0042F0  0F4003EC   JAL expect
9D0042F4  2404000F   ADDIU A0, ZERO, 15
2503:                            if (name[len-1]=='$'){
9D0042F8  03B01021   ADDU V0, SP, S0
9D0042FC  8043000F   LB V1, 15(V0)
9D004300  24020024   ADDIU V0, ZERO, 36
9D004304  14620011   BNE V1, V0, 0x9D00434C
9D004308  00000000   NOP
2504:                                if (var->str) throw(eERR_ASSIGN);
9D00430C  8E22000C   LW V0, 12(S1)
9D004310  10400003   BEQ V0, ZERO, 0x9D004320
9D004314  00000000   NOP
9D004318  0F400080   JAL throw
9D00431C  2404000A   ADDIU A0, ZERO, 10
2505:                                expect(eSTRING);
9D004320  0F4003EC   JAL expect
9D004324  24040005   ADDIU A0, ZERO, 5
2506:                                var->str=alloc_var_space(len+1);
9D004328  0F400104   JAL alloc_var_space
9D00432C  26040001   ADDIU A0, S0, 1
9D004330  AE22000C   SW V0, 12(S1)
2507:                                strcpy(var->str,token.str);
9D004334  00402021   ADDU A0, V0, ZERO
9D004338  3C05A000   LUI A1, -24576
9D00433C  0F406D40   JAL strcpy
9D004340  24A5391C   ADDIU A1, A1, 14620
9D004344  0B4010D8   J 0x9D004360
9D004348  8FBF003C   LW RA, 60(SP)
2508:                            }else{
2509:                                expression();
9D00434C  0F400799   JAL expression
9D004350  00000000   NOP
2510:                                store_integer(var);
9D004354  0F4006C9   JAL store_integer
9D004358  02202021   ADDU A0, S1, ZERO
2511:                            }
2512:                        }//if
2513:                    }//if
2514:                }//f()
9D004188  0B4010D8   J 0x9D004360
9D00418C  8FBF003C   LW RA, 60(SP)
9D004278  0B4010D8   J 0x9D004360
9D00427C  8FBF003C   LW RA, 60(SP)
9D004298  0B4010D8   J 0x9D004360
9D00429C  8FBF003C   LW RA, 60(SP)
9D0042B8  0B4010D8   J 0x9D004360
9D0042BC  8FBF003C   LW RA, 60(SP)
9D00435C  8FBF003C   LW RA, 60(SP)
9D004360  8FB10038   LW S1, 56(SP)
9D004364  8FB00034   LW S0, 52(SP)
9D004368  03E00008   JR RA
9D00436C  27BD0040   ADDIU SP, SP, 64
2515:                
2516:                // LOCAL identifier {,identifier}
2517:                // création des variables locales
2518:                // à l'intérieur des SUB|FUNC
2519:                static void kw_local(){
9D0019F8  27BDFFC8   ADDIU SP, SP, -56
9D0019FC  AFBF0034   SW RA, 52(SP)
9D001A00  AFB50030   SW S5, 48(SP)
9D001A04  AFB4002C   SW S4, 44(SP)
9D001A08  AFB30028   SW S3, 40(SP)
9D001A0C  AFB20024   SW S2, 36(SP)
9D001A10  AFB10020   SW S1, 32(SP)
9D001A14  AFB0001C   SW S0, 28(SP)
2520:                    var_t *var;
2521:                    int i,lc=0;
2522:                    if (!var_local) throw(eERR_SYNTAX);
9D001A18  93828078   LBU V0, -32648(GP)
9D001A1C  14400003   BNE V0, ZERO, 0x9D001A2C
9D001A20  00000000   NOP
9D001A24  0F400080   JAL throw
9D001A28  24040007   ADDIU A0, ZERO, 7
2523:                    next_token();
9D001A2C  0F4001A6   JAL next_token
9D001A30  00000000   NOP
2524:                    while(token.id==eIDENT){
9D001A34  3C02A000   LUI V0, -24576
9D001A38  8C433918   LW V1, 14616(V0)
9D001A3C  24020003   ADDIU V0, ZERO, 3
9D001A40  14620029   BNE V1, V0, 0x9D001AE8
9D001A44  00008021   ADDU S0, ZERO, ZERO
9D001AD0  8E233918   LW V1, 14616(S1)
9D001AD4  24020003   ADDIU V0, ZERO, 3
9D001AD8  1062FFE1   BEQ V1, V0, 0x9D001A60
9D001ADC  24020001   ADDIU V0, ZERO, 1
9D001AE0  0B4006BC   J 0x9D001AF0
9D001AE4  A3828084   SB V0, -32636(GP)
2525:                        if (token.str[strlen(token.str)-1]=='#' || 
9D001A48  3C12A000   LUI S2, -24576
9D001A4C  2652391C   ADDIU S2, S2, 14620
9D001A50  3C11A000   LUI S1, -24576
9D001A54  26333918   ADDIU S3, S1, 14616
9D001A60  0F406EC2   JAL strlen
9D001A64  02402021   ADDU A0, S2, ZERO
9D001A68  02621021   ADDU V0, S3, V0
9D001A6C  90420003   LBU V0, 3(V0)
9D001A70  2442FFDD   ADDIU V0, V0, -35
9D001A74  304200FF   ANDI V0, V0, 255
9D001A78  2C420002   SLTIU V0, V0, 2
9D001A7C  10400003   BEQ V0, ZERO, 0x9D001A8C
9D001A80  8F828080   LW V0, -32640(GP)
2526:                                token.str[strlen(token.str)-1]=='$' ) throw(eERR_BAD_ARG);
9D001A84  0F400080   JAL throw
9D001A88  24040006   ADDIU A0, ZERO, 6
2527:                        if (globals>varlist){
9D001A8C  8F83807C   LW V1, -32644(GP)
9D001A90  0043182B   SLTU V1, V0, V1
9D001A94  50600004   BEQL V1, ZERO, 0x9D001AA8
9D001A98  AFB50010   SW S5, 16(SP)
2528:                            i=varlist->n+1; 
9D001A9C  8C42000C   LW V0, 12(V0)
9D001AA0  24420001   ADDIU V0, V0, 1
9D001AA4  AFA20010   SW V0, 16(SP)
2529:                        }else{
2530:                            i=1;
9D001A58  24150001   ADDIU S5, ZERO, 1
2531:                        }
2532:                        var=var_create(token.str,(char*)&i);
9D001AA8  02402021   ADDU A0, S2, ZERO
9D001AAC  0F400115   JAL var_create
9D001AB0  27A50010   ADDIU A1, SP, 16
2533:                        lc++;
2534:                        next_token();
9D001AB4  0F4001A6   JAL next_token
9D001AB8  26100001   ADDIU S0, S0, 1
2535:                        if (token.id!=eCOMMA) break;
9D001A5C  2414000B   ADDIU S4, ZERO, 11
9D001ABC  8E223918   LW V0, 14616(S1)
9D001AC0  1454000A   BNE V0, S4, 0x9D001AEC
9D001AC4  24020001   ADDIU V0, ZERO, 1
2536:                        next_token();
9D001AC8  0F4001A6   JAL next_token
9D001ACC  00000000   NOP
2537:                    }//while
2538:                    unget_token=true;
9D001AE8  24020001   ADDIU V0, ZERO, 1
9D001AEC  A3828084   SB V0, -32636(GP)
2539:                    bytecode(ILCVARSPACE);
9D001AF0  0F400445   JAL bytecode
9D001AF4  2404005A   ADDIU A0, ZERO, 90
2540:                    bytecode(lc);
9D001AF8  0F400445   JAL bytecode
9D001AFC  320400FF   ANDI A0, S0, 255
2541:                }//f
9D001B00  8FBF0034   LW RA, 52(SP)
9D001B04  8FB50030   LW S5, 48(SP)
9D001B08  8FB4002C   LW S4, 44(SP)
9D001B0C  8FB30028   LW S3, 40(SP)
9D001B10  8FB20024   LW S2, 36(SP)
9D001B14  8FB10020   LW S1, 32(SP)
9D001B18  8FB0001C   LW S0, 28(SP)
9D001B1C  03E00008   JR RA
9D001B20  27BD0038   ADDIU SP, SP, 56
2542:                
2543:                // PRINT|? chaine|identifier|expression {,chaine|identifier|expression}
2544:                static void kw_print(){
9D003570  27BDFFD8   ADDIU SP, SP, -40
9D003574  AFBF0024   SW RA, 36(SP)
9D003578  AFB40020   SW S4, 32(SP)
9D00357C  AFB3001C   SW S3, 28(SP)
9D003580  AFB20018   SW S2, 24(SP)
9D003584  AFB10014   SW S1, 20(SP)
2545:                    var_t *var;
2546:                    
2547:                    next_token();
9D003588  0F4001A6   JAL next_token
9D00358C  AFB00010   SW S0, 16(SP)
2548:                    while (!activ_reader->eof){
9D003590  8F828098   LW V0, -32616(GP)
9D003594  8C42010C   LW V0, 268(V0)
9D003598  14400056   BNE V0, ZERO, 0x9D0036F4
9D00359C  3C10A000   LUI S0, -24576
9D0036E4  8F828098   LW V0, -32616(GP)
9D0036E8  8C42010C   LW V0, 268(V0)
9D0036EC  1040FFB1   BEQ V0, ZERO, 0x9D0035B4
9D0036F0  8E023918   LW V0, 14616(S0)
2549:                        switch (token.id){
9D0035A0  24110003   ADDIU S1, ZERO, 3
9D0035B0  8E023918   LW V0, 14616(S0)
9D0035B4  1051000F   BEQ V0, S1, 0x9D0035F4
9D0035B8  24030005   ADDIU V1, ZERO, 5
9D0035BC  10430005   BEQ V0, V1, 0x9D0035D4
9D0035C0  24030001   ADDIU V1, ZERO, 1
9D0035C4  14430034   BNE V0, V1, 0x9D003698
9D0035C8  24020001   ADDIU V0, ZERO, 1
9D0035CC  0B400DA2   J 0x9D003688
9D0035D0  00000000   NOP
2550:                            case eSTRING:
2551:                                literal_string(token.str);
9D0035D4  0F4005D5   JAL literal_string
9D0035D8  02402021   ADDU A0, S2, ZERO
2552:                                bytecode(ITYPE);
9D0035DC  0F400445   JAL bytecode
9D0035E0  24040052   ADDIU A0, ZERO, 82
2553:                                bytecode(ISPACE);
9D0035E4  0F400445   JAL bytecode
9D0035E8  24040059   ADDIU A0, ZERO, 89
2554:                                break;
9D0035EC  0B400DAA   J 0x9D0036A8
9D0035F0  00000000   NOP
2555:                            case eIDENT:
2556:                                if(token.str[strlen(token.str)-1]=='$'){
9D0035A4  3C12A000   LUI S2, -24576
9D0035A8  2652391C   ADDIU S2, S2, 14620
9D0035AC  26133918   ADDIU S3, S0, 14616
9D0035F4  0F406EC2   JAL strlen
9D0035F8  02402021   ADDU A0, S2, ZERO
9D0035FC  02621021   ADDU V0, S3, V0
9D003600  80430003   LB V1, 3(V0)
9D003604  24020024   ADDIU V0, ZERO, 36
9D003608  14620019   BNE V1, V0, 0x9D003670
9D00360C  24020001   ADDIU V0, ZERO, 1
2557:                                    if ((var=var_search(token.str))){
9D003610  0F40006B   JAL var_search
9D003614  02402021   ADDU A0, S2, ZERO
9D003618  10400023   BEQ V0, ZERO, 0x9D0036A8
9D00361C  0040A021   ADDU S4, V0, ZERO
2558:                                        if (var->vtype==eVAR_STRARRAY){
9D003620  90430005   LBU V1, 5(V0)
9D003624  24020004   ADDIU V0, ZERO, 4
9D003628  14620007   BNE V1, V0, 0x9D003648
9D00362C  00000000   NOP
2559:                                            expect(eLPAREN);
9D003630  0F4003EC   JAL expect
9D003634  2404000C   ADDIU A0, ZERO, 12
2560:                                            code_array_address(var);
9D003638  0F4007E1   JAL code_array_address
9D00363C  02802021   ADDU A0, S4, ZERO
9D003640  0B400D94   J 0x9D003650
9D003644  00000000   NOP
2561:                                        }else{
2562:                                            _lit((uint32_t)&var->str);
9D003648  0F400445   JAL bytecode
9D00364C  24040001   ADDIU A0, ZERO, 1
2563:                                        }
2564:                                        bytecode(IFETCH);
9D003650  0F400445   JAL bytecode
9D003654  2404000A   ADDIU A0, ZERO, 10
2565:                                        bytecode(ITYPE);
9D003658  0F400445   JAL bytecode
9D00365C  24040052   ADDIU A0, ZERO, 82
2566:                                        bytecode(ISPACE);
9D003660  0F400445   JAL bytecode
9D003664  24040059   ADDIU A0, ZERO, 89
9D003668  0B400DAA   J 0x9D0036A8
9D00366C  00000000   NOP
2567:                                    }
2568:                                }else{ 
2569:                                    unget_token=true;
2570:                                    expression();
9D003670  0F400799   JAL expression
9D003674  A3828084   SB V0, -32636(GP)
2571:                                    bytecode(IDOT);
9D003678  0F400445   JAL bytecode
9D00367C  24040054   ADDIU A0, ZERO, 84
9D003680  0B400DAA   J 0x9D0036A8
9D003684  00000000   NOP
2572:                                }
2573:                               break;
2574:                            case eSTOP:
2575:                                bytecode(ICR);
9D003688  0F400445   JAL bytecode
9D00368C  24040053   ADDIU A0, ZERO, 83
2576:                                break;
9D003690  0B400DAA   J 0x9D0036A8
9D003694  00000000   NOP
2577:                            default:
2578:                                unget_token=true;
2579:                                expression();
9D003698  0F400799   JAL expression
9D00369C  A3828084   SB V0, -32636(GP)
2580:                                bytecode(IDOT);
9D0036A0  0F400445   JAL bytecode
9D0036A4  24040054   ADDIU A0, ZERO, 84
2581:                                
2582:                        }//switch
2583:                        next_token();
9D0036A8  0F4001A6   JAL next_token
9D0036AC  00000000   NOP
2584:                        if (token.id==eSEMICOL){
9D0036B0  8E023918   LW V0, 14616(S0)
9D0036B4  2403000E   ADDIU V1, ZERO, 14
9D0036B8  1043000E   BEQ V0, V1, 0x9D0036F4
9D0036BC  2403000B   ADDIU V1, ZERO, 11
2585:                            break;
2586:                        }
2587:                        if (token.id!=eCOMMA){
9D0036C0  10430006   BEQ V0, V1, 0x9D0036DC
9D0036C4  00000000   NOP
2588:                            bytecode(ICR);
9D0036C8  0F400445   JAL bytecode
9D0036CC  24040053   ADDIU A0, ZERO, 83
2589:                           // crlf(con);
2590:                            unget_token=true;
9D0036D0  24020001   ADDIU V0, ZERO, 1
2591:                            break;
9D0036D4  0B400DBD   J 0x9D0036F4
9D0036D8  A3828084   SB V0, -32636(GP)
2592:                        }
2593:                        next_token();
9D0036DC  0F4001A6   JAL next_token
9D0036E0  00000000   NOP
2594:                    }//while
2595:                }//f()
9D0036F4  8FBF0024   LW RA, 36(SP)
9D0036F8  8FB40020   LW S4, 32(SP)
9D0036FC  8FB3001C   LW S3, 28(SP)
9D003700  8FB20018   LW S2, 24(SP)
9D003704  8FB10014   LW S1, 20(SP)
9D003708  8FB00010   LW S0, 16(SP)
9D00370C  03E00008   JR RA
9D003710  27BD0028   ADDIU SP, SP, 40
2596:                
2597:                // PUTC(expression)
2598:                // imprime un caractère ASCII
2599:                static void kw_putc(){
9D00354C  27BDFFE8   ADDIU SP, SP, -24
9D003550  AFBF0014   SW RA, 20(SP)
2600:                    expression();
9D003554  0F400799   JAL expression
9D003558  00000000   NOP
2601:                    bytecode(IEMIT);
9D00355C  0F400445   JAL bytecode
9D003560  24040051   ADDIU A0, ZERO, 81
2602:                }//f
9D003564  8FBF0014   LW RA, 20(SP)
9D003568  03E00008   JR RA
9D00356C  27BD0018   ADDIU SP, SP, 24
2603:                
2604:                // KEY()
2605:                // retourne indicateur touche clavier
2606:                // ou zéro
2607:                static void kw_key(){ 
9D001300  27BDFFE8   ADDIU SP, SP, -24
9D001304  AFBF0014   SW RA, 20(SP)
2608:                    expect(eLPAREN);
9D001308  0F4003EC   JAL expect
9D00130C  2404000C   ADDIU A0, ZERO, 12
2609:                    expect(eRPAREN);
9D001310  0F4003EC   JAL expect
9D001314  2404000D   ADDIU A0, ZERO, 13
2610:                    bytecode(IKEY);
9D001318  0F400445   JAL bytecode
9D00131C  2404004F   ADDIU A0, ZERO, 79
2611:                }//f
9D001320  8FBF0014   LW RA, 20(SP)
9D001324  03E00008   JR RA
9D001328  27BD0018   ADDIU SP, SP, 24
2612:                
2613:                // cré la liste des arguments pour
2614:                // la compilation des SUB|FUNC
2615:                static void create_arg_list(){
2616:                    var_t *var;
2617:                    int i=0;
9D001654  AFA00010   SW ZERO, 16(SP)
2618:                    expect(eLPAREN);
9D001658  0F4003EC   JAL expect
2619:                    next_token();
9D001660  0F4001A6   JAL next_token
2620:                    while (token.id==eIDENT){
9D001668  3C02A000   LUI V0, -24576
9D001688  24130003   ADDIU S3, ZERO, 3
9D0016C0  8E023918   LW V0, 14616(S0)
2621:                        i++;
9D00168C  8FA20010   LW V0, 16(SP)
2622:                        var=var_create(token.str,(char*)&i);
9D00167C  2652391C   ADDIU S2, S2, 14620
9D001698  02402021   ADDU A0, S2, ZERO
2623:                        next_token();
9D0016A4  0F4001A6   JAL next_token
2624:                        if (token.id!=eCOMMA) break;
9D001680  3C10A000   LUI S0, -24576
9D0016AC  8E023918   LW V0, 14616(S0)
2625:                        next_token();
9D0016B8  0F4001A6   JAL next_token
2626:                    }
2627:                    if (token.id!=eRPAREN) throw(eERR_SYNTAX);
9D0016CC  3C02A000   LUI V0, -24576
2628:                    bytecode(IFRAME);
9D0016E8  0F400445   JAL bytecode
2629:                    bytecode(i);
9D0016F0  0F400445   JAL bytecode
9D0016F4  93A40010   LBU A0, 16(SP)
2630:                }//f
2631:                
2632:                //cré une nouvelle variable de type eVAR_SUB|eVAR_FUNC
2633:                static void subrtn_create(int var_type, int blockend){
9D001548  27BDFFD0   ADDIU SP, SP, -48
9D00154C  AFBF002C   SW RA, 44(SP)
9D001550  AFB30028   SW S3, 40(SP)
9D001554  AFB20024   SW S2, 36(SP)
9D001558  AFB10020   SW S1, 32(SP)
9D00155C  AFB0001C   SW S0, 28(SP)
2634:                    var_t *var;
2635:                
2636:                    if (var_local) throw(eERR_SYNTAX);
9D001560  93828078   LBU V0, -32648(GP)
9D001564  10400003   BEQ V0, ZERO, 0x9D001574
9D001568  00808821   ADDU S1, A0, ZERO
9D00156C  0F400080   JAL throw
9D001570  24040007   ADDIU A0, ZERO, 7
9D001574  00A08021   ADDU S0, A1, ZERO
2637:                    expect(eIDENT);
9D001578  0F4003EC   JAL expect
9D00157C  24040003   ADDIU A0, ZERO, 3
2638:                    if (token.str[strlen(token.str)-1]=='$') throw(eERR_SYNTAX);
9D001580  3C04A000   LUI A0, -24576
9D001584  0F406EC2   JAL strlen
9D001588  2484391C   ADDIU A0, A0, 14620
9D00158C  3C03A000   LUI V1, -24576
9D001590  24633918   ADDIU V1, V1, 14616
9D001594  00621021   ADDU V0, V1, V0
9D001598  80430003   LB V1, 3(V0)
9D00159C  24020024   ADDIU V0, ZERO, 36
9D0015A0  54620003   BNEL V1, V0, 0x9D0015B0
9D0015A4  3C04A000   LUI A0, -24576
9D0015A8  0F400080   JAL throw
9D0015AC  24040007   ADDIU A0, ZERO, 7
2639:                    var=var_search(token.str);
9D0015B0  0F40006B   JAL var_search
9D0015B4  2484391C   ADDIU A0, A0, 14620
2640:                    if (var) throw(eERR_REDEF);
9D0015B8  50400003   BEQL V0, ZERO, 0x9D0015C8
9D0015BC  3C04A000   LUI A0, -24576
9D0015C0  0F400080   JAL throw
9D0015C4  24040009   ADDIU A0, ZERO, 9
2641:                    var=var_create(token.str,NULL);
9D0015C8  2484391C   ADDIU A0, A0, 14620
9D0015CC  0F400115   JAL var_create
9D0015D0  00002821   ADDU A1, ZERO, ZERO
2642:                    var->vtype=var_type;
9D0015D4  A0510005   SB S1, 5(V0)
2643:                    var->adr=(void*)&progspace[dptr];
9D0015D8  8F83C11C   LW V1, -16100(GP)
9D0015DC  8F84809C   LW A0, -32612(GP)
9D0015E0  00831821   ADDU V1, A0, V1
9D0015E4  AC43000C   SW V1, 12(V0)
2644:                    globals=varlist;
9D0015E8  8F838080   LW V1, -32640(GP)
9D0015EC  AF83807C   SW V1, -32644(GP)
2645:                    var_local=true;
9D0015F0  24030001   ADDIU V1, ZERO, 1
9D0015F4  A3838078   SB V1, -32648(GP)
2646:                    rstack[++rsp]=(uint32_t)endmark;
9D0015F8  8384C114   LB A0, -16108(GP)
9D0015FC  24850001   ADDIU A1, A0, 1
9D001600  7C052C20   SEB A1, A1
9D001604  00052880   SLL A1, A1, 2
9D001608  3C03A000   LUI V1, -24576
9D00160C  24634080   ADDIU V1, V1, 16512
9D001610  00A32821   ADDU A1, A1, V1
9D001614  8F86C118   LW A2, -16104(GP)
9D001618  ACA60000   SW A2, 0(A1)
2647:                    complevel++;
9D00161C  8F858064   LW A1, -32668(GP)
9D001620  24A50001   ADDIU A1, A1, 1
9D001624  AF858064   SW A1, -32668(GP)
2648:                    rstack[++rsp]=blockend;
9D001628  24850002   ADDIU A1, A0, 2
9D00162C  7C052C20   SEB A1, A1
9D001630  00052880   SLL A1, A1, 2
9D001634  00A32821   ADDU A1, A1, V1
9D001638  ACB00000   SW S0, 0(A1)
2649:                    rstack[++rsp]=(uint32_t)var;
9D00163C  24840003   ADDIU A0, A0, 3
9D001640  7C042420   SEB A0, A0
9D001644  A384C114   SB A0, -16108(GP)
9D001648  00042080   SLL A0, A0, 2
9D00164C  00831821   ADDU V1, A0, V1
9D001650  AC620000   SW V0, 0(V1)
2650:                    create_arg_list();
2651:                }//f
9D0016F8  8FBF002C   LW RA, 44(SP)
9D0016FC  8FB30028   LW S3, 40(SP)
9D001700  8FB20024   LW S2, 36(SP)
9D001704  8FB10020   LW S1, 32(SP)
9D001708  8FB0001C   LW S0, 28(SP)
9D00170C  03E00008   JR RA
9D001710  27BD0030   ADDIU SP, SP, 48
2652:                
2653:                // FUNC identifier (arg_list)
2654:                //   bloc_intructions
2655:                //   RETURN expression
2656:                // END FUNC
2657:                static void kw_func(){
9D001734  27BDFFE8   ADDIU SP, SP, -24
9D001738  AFBF0014   SW RA, 20(SP)
2658:                    subrtn_create(eVAR_FUNC,eKW_FUNC);
9D00173C  24040006   ADDIU A0, ZERO, 6
9D001740  0F400552   JAL subrtn_create
9D001744  24050014   ADDIU A1, ZERO, 20
2659:                }//f
9D001748  8FBF0014   LW RA, 20(SP)
9D00174C  03E00008   JR RA
9D001750  27BD0018   ADDIU SP, SP, 24
2660:                
2661:                // SUB idientifier (arg_list)
2662:                //  bloc_instructions
2663:                // END SUB
2664:                static void kw_sub(){
9D001714  27BDFFE8   ADDIU SP, SP, -24
9D001718  AFBF0014   SW RA, 20(SP)
2665:                    subrtn_create(eVAR_SUB,eKW_SUB);
9D00171C  24040005   ADDIU A0, ZERO, 5
9D001720  0F400552   JAL subrtn_create
9D001724  24050042   ADDIU A1, ZERO, 66
2666:                }//f
9D001728  8FBF0014   LW RA, 20(SP)
9D00172C  03E00008   JR RA
9D001730  27BD0018   ADDIU SP, SP, 24
2667:                
2668:                // TRACE(expression)
2669:                // active ou désactive le mode traçage
2670:                // pour le débogage
2671:                // expression -> 0|1 {off|on}
2672:                static void kw_trace(){
9D002B08  27BDFFE8   ADDIU SP, SP, -24
9D002B0C  AFBF0014   SW RA, 20(SP)
2673:                    parse_arg_list(1); 
9D002B10  0F40097D   JAL parse_arg_list
9D002B14  24040001   ADDIU A0, ZERO, 1
2674:                    bytecode(ITRACE);
9D002B18  0F400445   JAL bytecode
9D002B1C  24040057   ADDIU A0, ZERO, 87
2675:                }//f
9D002B20  8FBF0014   LW RA, 20(SP)
9D002B24  03E00008   JR RA
9D002B28  27BD0018   ADDIU SP, SP, 24
2676:                
2677:                
2678:                
2679:                static void compile(){
9D004370  27BDFFD8   ADDIU SP, SP, -40
9D004374  AFBF0024   SW RA, 36(SP)
9D004378  AFB30020   SW S3, 32(SP)
9D00437C  AFB2001C   SW S2, 28(SP)
9D004380  AFB10018   SW S1, 24(SP)
9D004384  AFB00014   SW S0, 20(SP)
2680:                    var_t *var;
2681:                    uint32_t adr;
2682:                    
2683:                    do{
2684:                        next_token();
9D00439C  0F4001A6   JAL next_token
9D0043A0  00000000   NOP
2685:                        switch(token.id){ 
9D004388  3C10A000   LUI S0, -24576
9D0043A4  8E023918   LW V0, 14616(S0)
9D0043A8  24030001   ADDIU V1, ZERO, 1
9D0043AC  50430047   BEQL V0, V1, 0x9D0044CC
9D0043B0  8F828098   LW V0, -32616(GP)
9D0043B4  1040004D   BEQ V0, ZERO, 0x9D0044EC
9D0043B8  24030003   ADDIU V1, ZERO, 3
9D0043BC  1043001E   BEQ V0, V1, 0x9D004438
9D0043C0  24030018   ADDIU V1, ZERO, 24
9D0043C4  14430047   BNE V0, V1, 0x9D0044E4
9D0043C8  26023918   ADDIU V0, S0, 14616
2686:                            case eKWORD:
2687:                                if ((KEYWORD[token.n].len&FUNCTION)==FUNCTION){
9D004394  3C119D01   LUI S1, -25343
9D004398  26312C6C   ADDIU S1, S1, 11372
9D0043CC  8C420004   LW V0, 4(V0)
9D0043D0  00021880   SLL V1, V0, 2
9D0043D4  00022100   SLL A0, V0, 4
9D0043D8  00831823   SUBU V1, A0, V1
9D0043DC  00711821   ADDU V1, V1, S1
9D0043E0  90630004   LBU V1, 4(V1)
9D0043E4  30630040   ANDI V1, V1, 64
9D0043E8  306300FF   ANDI V1, V1, 255
9D0043EC  1060000A   BEQ V1, ZERO, 0x9D004418
9D0043F0  00021880   SLL V1, V0, 2
2688:                                    KEYWORD[token.n].cfn();
9D0043F4  00831023   SUBU V0, A0, V1
9D0043F8  00511021   ADDU V0, V0, S1
9D0043FC  8C420000   LW V0, 0(V0)
9D004400  0040F809   JALR V0
9D004404  00000000   NOP
2689:                                    bytecode(IDROP);
9D004408  0F400445   JAL bytecode
9D00440C  24040010   ADDIU A0, ZERO, 16
9D004410  0B40113C   J 0x9D0044F0
9D004414  8F828098   LW V0, -32616(GP)
2690:                                }else{
2691:                                    KEYWORD[token.n].cfn();
9D004418  00021100   SLL V0, V0, 4
9D00441C  00431023   SUBU V0, V0, V1
9D004420  00511021   ADDU V0, V0, S1
9D004424  8C420000   LW V0, 0(V0)
9D004428  0040F809   JALR V0
9D00442C  00000000   NOP
2692:                                }
2693:                                break;
2694:                            case eIDENT:
2695:                                if ((var=var_search(token.str))){
9D00438C  3C12A000   LUI S2, -24576
9D004390  2652391C   ADDIU S2, S2, 14620
9D004438  0F40006B   JAL var_search
9D00443C  02402021   ADDU A0, S2, ZERO
9D004440  1040001D   BEQ V0, ZERO, 0x9D0044B8
9D004444  00409821   ADDU S3, V0, ZERO
2696:                                    if (var->vtype==eVAR_SUB){
9D004448  90420005   LBU V0, 5(V0)
9D00444C  24030005   ADDIU V1, ZERO, 5
9D004450  14430008   BNE V0, V1, 0x9D004474
9D004454  24030006   ADDIU V1, ZERO, 6
2697:                                        adr=(uint32_t)var->adr;
2698:                                        parse_arg_list(*((uint8_t*)(adr+1)));
9D004458  8E62000C   LW V0, 12(S3)
9D00445C  0F40097D   JAL parse_arg_list
9D004460  90440001   LBU A0, 1(V0)
2699:                                        bytecode(ICALL);
9D004464  0F400445   JAL bytecode
9D004468  24040056   ADDIU A0, ZERO, 86
9D00446C  0B40113C   J 0x9D0044F0
9D004470  8F828098   LW V0, -32616(GP)
2700:                                        _splitn((uint32_t)&var->adr);
2701:                                    }else if (var->vtype==eVAR_FUNC){
9D004474  5443000C   BNEL V0, V1, 0x9D0044A8
9D004478  24020001   ADDIU V0, ZERO, 1
2702:                                        _litc(0);
9D00447C  0F400445   JAL bytecode
9D004480  24040003   ADDIU A0, ZERO, 3
2703:                                        adr=(uint32_t)var->adr;
2704:                                        parse_arg_list(*((uint8_t*)(adr+1)));
9D004484  8E62000C   LW V0, 12(S3)
9D004488  0F40097D   JAL parse_arg_list
9D00448C  90440001   LBU A0, 1(V0)
2705:                                        bytecode(ICALL);
9D004490  0F400445   JAL bytecode
9D004494  24040056   ADDIU A0, ZERO, 86
2706:                                        _splitn((uint32_t)&var->adr);
2707:                                        bytecode(IDROP);
9D004498  0F400445   JAL bytecode
9D00449C  24040010   ADDIU A0, ZERO, 16
9D0044A0  0B40113C   J 0x9D0044F0
9D0044A4  8F828098   LW V0, -32616(GP)
2708:                                    }else{
2709:                                        unget_token=true;
2710:                                        kw_let();
9D0044A8  0F401027   JAL kw_let
9D0044AC  A3828084   SB V0, -32636(GP)
2711:                                    }
2712:                                }else{
2713:                                    unget_token=true;
9D0044B8  24020001   ADDIU V0, ZERO, 1
2714:                                    kw_let();
9D0044BC  0F401027   JAL kw_let
9D0044C0  A3828084   SB V0, -32636(GP)
2715:                                }
2716:                                break;
2717:                            case eSTOP:
2718:                                if (activ_reader->device==eDEV_KBD) activ_reader->eof=true;
9D0044CC  8C430000   LW V1, 0(V0)
9D0044D0  54600007   BNEL V1, ZERO, 0x9D0044F0
9D0044D4  8F828098   LW V0, -32616(GP)
9D0044D8  24030001   ADDIU V1, ZERO, 1
9D0044DC  0B40113B   J 0x9D0044EC
9D0044E0  AC43010C   SW V1, 268(V0)
2719:                                break;
2720:                            case eNONE:
2721:                                break;
2722:                            default:
2723:                                throw(eERR_SYNTAX);
9D0044E4  0F400080   JAL throw
9D0044E8  24040007   ADDIU A0, ZERO, 7
2724:                                break;
2725:                        }//switch
2726:                    }while (!activ_reader->eof);
9D004430  0B40113C   J 0x9D0044F0
9D004434  8F828098   LW V0, -32616(GP)
9D0044B0  0B40113C   J 0x9D0044F0
9D0044B4  8F828098   LW V0, -32616(GP)
9D0044C4  0B40113C   J 0x9D0044F0
9D0044C8  8F828098   LW V0, -32616(GP)
9D0044EC  8F828098   LW V0, -32616(GP)
9D0044F0  8C42010C   LW V0, 268(V0)
9D0044F4  1040FFA9   BEQ V0, ZERO, 0x9D00439C
9D0044F8  8FBF0024   LW RA, 36(SP)
2727:                }//f
9D0044FC  8FB30020   LW S3, 32(SP)
9D004500  8FB2001C   LW S2, 28(SP)
9D004504  8FB10018   LW S1, 24(SP)
9D004508  8FB00014   LW S0, 20(SP)
9D00450C  03E00008   JR RA
9D004510  27BD0028   ADDIU SP, SP, 40
2728:                
2729:                //efface le contenu de progspace
2730:                static void clear(){
9D0000A8  27BDFFE8   ADDIU SP, SP, -24
9D0000AC  AFBF0014   SW RA, 20(SP)
2731:                    rsp=-1;
9D0000B0  2402FFFF   ADDIU V0, ZERO, -1
9D0000B4  A382C114   SB V0, -16108(GP)
2732:                    dptr=0;
9D0000B8  AF80C11C   SW ZERO, -16100(GP)
2733:                    varlist=NULL;
9D0000BC  AF808080   SW ZERO, -32640(GP)
2734:                    globals=NULL;
9D0000C0  AF80807C   SW ZERO, -32644(GP)
2735:                    var_local=false;
9D0000C4  A3808078   SB ZERO, -32648(GP)
2736:                    complevel=0;
9D0000C8  AF808064   SW ZERO, -32668(GP)
2737:                    endmark=(void*)progspace+prog_size;
9D0000CC  8F84809C   LW A0, -32612(GP)
9D0000D0  8F868094   LW A2, -32620(GP)
9D0000D4  00861021   ADDU V0, A0, A2
9D0000D8  AF82C118   SW V0, -16104(GP)
2738:                    memset((void*)progspace,0,prog_size);
9D0000DC  0F40775D   JAL memset
9D0000E0  00002821   ADDU A1, ZERO, ZERO
2739:                    line_count=0;
9D0000E4  AF808090   SW ZERO, -32624(GP)
2740:                    program_loaded=false;
9D0000E8  A380808D   SB ZERO, -32627(GP)
2741:                    run_it=false;
9D0000EC  A380808C   SB ZERO, -32628(GP)
2742:                    program_end=0;
9D0000F0  AF808088   SW ZERO, -32632(GP)
2743:                    exit_basic=false;
9D0000F4  A38080A0   SB ZERO, -32608(GP)
2744:                }//f
9D0000F8  8FBF0014   LW RA, 20(SP)
9D0000FC  03E00008   JR RA
9D000100  27BD0018   ADDIU SP, SP, 24
2745:                
2746:                
2747:                int BASIC_shell(const char* file_name){
9D004788  27BDFFD8   ADDIU SP, SP, -40
9D00478C  AFBF0024   SW RA, 36(SP)
9D004790  AFB10020   SW S1, 32(SP)
9D004794  AFB0001C   SW S0, 28(SP)
9D004798  00808821   ADDU S1, A0, ZERO
2748:                    clear_screen(con);
9D00479C  0F404F63   JAL clear_screen
9D0047A0  97848062   LHU A0, -32670(GP)
2749:                    FIL *fh;
2750:                    FRESULT result;
2751:                    int vm_exit_code;
2752:                    
2753:                    prog_size=(biggest_chunk()-4096)&0xfff0;
9D0047A4  0F4052C2   JAL biggest_chunk
9D0047A8  00000000   NOP
9D0047AC  2442F000   ADDIU V0, V0, -4096
9D0047B0  3050FFF0   ANDI S0, V0, -16
9D0047B4  AF908094   SW S0, -32620(GP)
2754:                    progspace=malloc(prog_size);
9D0047B8  0F4064A8   JAL malloc
9D0047BC  02002021   ADDU A0, S0, ZERO
9D0047C0  AF82809C   SW V0, -32612(GP)
2755:                    sprintf((char*)progspace,"vpcBASIC v1.0\nRAM available: %d bytes\n",prog_size);
9D0047C4  00402021   ADDU A0, V0, ZERO
9D0047C8  3C059D01   LUI A1, -25343
9D0047CC  24A52840   ADDIU A1, A1, 10304
9D0047D0  0F407973   JAL _sprintf_cdnopsuxX
9D0047D4  02003021   ADDU A2, S0, ZERO
2756:                    print(con,progspace);
9D0047D8  97848062   LHU A0, -32670(GP)
9D0047DC  0F404FCC   JAL print
9D0047E0  8F85809C   LW A1, -32612(GP)
2757:                    clear();
9D0047E4  0F40002A   JAL clear
9D0047E8  00000000   NOP
2758:                //  initialisation lecteur source.
2759:                    if (file_name && !(result=f_open(fh,file_name,FA_READ))){
9D0047EC  1220000D   BEQ S1, ZERO, 0x9D004824
9D0047F0  00002021   ADDU A0, ZERO, ZERO
9D0047F4  02202821   ADDU A1, S1, ZERO
9D0047F8  0F4018E7   JAL f_open
9D0047FC  24060001   ADDIU A2, ZERO, 1
9D004800  14400009   BNE V0, ZERO, 0x9D004828
9D004804  3C04A000   LUI A0, -24576
2760:                        reader_init(&file_reader,eDEV_SDCARD,fh);
9D004808  3C04A000   LUI A0, -24576
9D00480C  2484399C   ADDIU A0, A0, 14748
9D004810  24050002   ADDIU A1, ZERO, 2
9D004814  0F406849   JAL reader_init
9D004818  00003021   ADDU A2, ZERO, ZERO
9D00481C  0B40120F   J 0x9D00483C
9D004820  3C02A000   LUI V0, -24576
2761:                    }else{
2762:                        reader_init(&std_reader,eDEV_KBD,NULL);
9D004824  3C04A000   LUI A0, -24576
9D004828  24843AB0   ADDIU A0, A0, 15024
9D00482C  00002821   ADDU A1, ZERO, ZERO
9D004830  0F406849   JAL reader_init
9D004834  00003021   ADDU A2, ZERO, ZERO
2763:                    }
2764:                    activ_reader=&std_reader; 
9D004838  3C02A000   LUI V0, -24576
9D00483C  24423AB0   ADDIU V0, V0, 15024
9D004840  AF828098   SW V0, -32616(GP)
2765:                    while (!exit_basic){
9D004858  0B40124E   J 0x9D004938
9D00485C  AFA20014   SW V0, 20(SP)
9D004938  938280A0   LBU V0, -32608(GP)
9D00493C  1040FFC8   BEQ V0, ZERO, 0x9D004860
9D004940  00000000   NOP
2766:                        if (!setjmp(failed)){
9D004844  3C02A000   LUI V0, -24576
9D004848  24423BC4   ADDIU V0, V0, 15300
9D00484C  AFA20010   SW V0, 16(SP)
9D004860  0F407957   JAL setjmp
9D004864  8FA40010   LW A0, 16(SP)
9D004868  1440002B   BNE V0, ZERO, 0x9D004918
9D00486C  00000000   NOP
2767:                            //activ_reader->eof=false;
2768:                            compile();
9D004870  0F4010DC   JAL compile
9D004874  00000000   NOP
2769:                            if (fh){result=f_close(fh);}
2770:                            if (!complevel){
9D004878  8F828064   LW V0, -32668(GP)
9D00487C  1440002F   BNE V0, ZERO, 0x9D00493C
9D004880  938280A0   LBU V0, -32608(GP)
2771:                                if (program_loaded && run_it){
9D004884  9382808D   LBU V0, -32627(GP)
9D004888  1040000A   BEQ V0, ZERO, 0x9D0048B4
9D00488C  8F908088   LW S0, -32632(GP)
9D004890  9382808C   LBU V0, -32628(GP)
9D004894  10400008   BEQ V0, ZERO, 0x9D0048B8
9D004898  8F82C11C   LW V0, -16100(GP)
2772:                                    vm_exit_code=StackVM(progspace);
9D00489C  0F4042D7   JAL StackVM
9D0048A0  8F84809C   LW A0, -32612(GP)
2773:                                    if (vm_exit_code) throw(vm_exit_code);
9D0048A4  50400024   BEQL V0, ZERO, 0x9D004938
9D0048A8  A380808C   SB ZERO, -32628(GP)
9D0048AC  0F400080   JAL throw
9D0048B0  00402021   ADDU A0, V0, ZERO
2774:                                    run_it=false;
2775:                                }else if (dptr>program_end){
9D0048B4  8F82C11C   LW V0, -16100(GP)
9D0048B8  0202102B   SLTU V0, S0, V0
9D0048BC  1040001F   BEQ V0, ZERO, 0x9D00493C
9D0048C0  938280A0   LBU V0, -32608(GP)
2776:                //#define DEBUG
2777:                #ifdef DEBUG
2778:                    {
2779:                        int i;
2780:                        for (i=program_end;i<=dptr;i++){print_int(con,progspace[i],3);put_char(' ');}crlf(con);
2781:                    }
2782:                #endif
2783:                //#undef DEBUG    
2784:                                    bytecode(IBYE);
9D0048C4  0F400445   JAL bytecode
9D0048C8  00002021   ADDU A0, ZERO, ZERO
2785:                                    vm_exit_code=StackVM(&progspace[program_end]);
9D0048CC  8F84809C   LW A0, -32612(GP)
9D0048D0  0F4042D7   JAL StackVM
9D0048D4  00902021   ADDU A0, A0, S0
2786:                                    if (vm_exit_code){
9D0048D8  50400003   BEQL V0, ZERO, 0x9D0048E8
9D0048DC  8F828098   LW V0, -32616(GP)
2787:                                        throw(vm_exit_code);
9D0048E0  0F400080   JAL throw
9D0048E4  00402021   ADDU A0, V0, ZERO
2788:                                    }
2789:                                    if (activ_reader->device==eDEV_KBD){
9D0048E8  8C420000   LW V0, 0(V0)
9D0048EC  14400013   BNE V0, ZERO, 0x9D00493C
9D0048F0  938280A0   LBU V0, -32608(GP)
2790:                                        memset(&progspace[program_end],0,dptr-program_end);
9D0048F4  8F908088   LW S0, -32632(GP)
9D0048F8  8F84809C   LW A0, -32612(GP)
9D0048FC  00902021   ADDU A0, A0, S0
9D004900  00002821   ADDU A1, ZERO, ZERO
9D004904  8F86C11C   LW A2, -16100(GP)
9D004908  0F40775D   JAL memset
9D00490C  00D03023   SUBU A2, A2, S0
2791:                                        dptr=program_end;
9D004910  0B40124E   J 0x9D004938
9D004914  AF90C11C   SW S0, -16100(GP)
2792:                                    }
2793:                                }
2794:                            }
2795:                        }else{
2796:                            clear();
9D004918  0F40002A   JAL clear
9D00491C  00000000   NOP
2797:                            activ_reader=&std_reader;
9D004850  3C02A000   LUI V0, -24576
9D004854  24423AB0   ADDIU V0, V0, 15024
9D004920  8FA20014   LW V0, 20(SP)
9D004924  AF828098   SW V0, -32616(GP)
2798:                            reader_init(activ_reader,eDEV_KBD,NULL);
9D004928  00402021   ADDU A0, V0, ZERO
9D00492C  00002821   ADDU A1, ZERO, ZERO
9D004930  0F406849   JAL reader_init
9D004934  00003021   ADDU A2, ZERO, ZERO
2799:                        }
2800:                    }//while(1)
2801:                    if (fh){
2802:                        result=f_close(fh);
2803:                    }
2804:                    free(progspace);
9D004944  0F407BCB   JAL free
9D004948  8F84809C   LW A0, -32612(GP)
2805:                    return vm_exit_code;
2806:                }//BASIC_shell()
9D00494C  00001021   ADDU V0, ZERO, ZERO
9D004950  8FBF0024   LW RA, 36(SP)
9D004954  8FB10020   LW S1, 32(SP)
9D004958  8FB0001C   LW S0, 28(SP)
9D00495C  03E00008   JR RA
9D004960  27BD0028   ADDIU SP, SP, 40
---  /home/jacques/github/vpc-32vga/vpc-32.c  -----------------------------------------------------------
1:                   /*
2:                   * Copyright 2013,2016,2018 Jacques Deschênes
3:                   * This file is part of VPC-32VGA.
4:                   *
5:                   *     VPC-32VGA is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-3VGA is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /* 
20:                   * File:   vpc-32.c
21:                   * Author: Jacques Deschênes
22:                   *
23:                   * Created on 26 août 2013, 07:38
24:                   */
25:                  
26:                  
27:                  #include <stdio.h>
28:                  #include <stdlib.h>
29:                  #include <string.h>
30:                  #include <plib.h>
31:                  #include "graphics.h"
32:                  
33:                  #include "hardware/HardwareProfile.h"
34:                  #include "hardware/tvout/vga.h"
35:                  #include "hardware/serial_comm/serial_comm.h"
36:                  #include "hardware/ps2_kbd/keyboard.h"
37:                  #include "hardware/Pinguino/diskio.h"
38:                  #include "hardware/Pinguino/fileio.h"
39:                  #include "console.h"
40:                  #include "hardware/Pinguino/ff.h"
41:                  #include "vpcBASIC/vm.h"
42:                  //#include "vpcBASIC/vpcBASIC.h"
43:                  #include "hardware/sound/sound.h"
44:                  #include "hardware/syscall.h"
45:                  #include "hardware/rtcc/rtcc.h"
46:                  
47:                  // PIC32MX150F128B Configuration Bit Settings
48:                  #include <xc.h>
49:                  
50:                  // DEVCFG3
51:                  // USERID = No Setting
52:                  #pragma config PMDL1WAY = OFF           // permet plusieurs configurations des périphériques.
53:                  #pragma config IOL1WAY = OFF            // permet plusieurs configuration des broches.
54:                  
55:                  // DEVCFG2
56:                  #pragma config FPLLIDIV = DIV_2         // PLL Input Divider (2x Divider)
57:                  #if SYSCLK==50000000L
58:                  #pragma config FPLLMUL = MUL_20
59:                  #elif SYSCLK==40000000L
60:                  #pragma config FPLLMUL = MUL_16         // SYSCLK=40Mhz
61:                  #else
62:                  #pragma config FPLLMUL = MUL_15          // PLL Multiplier (15x Multiplier) SYSCLK=37,5Mhz
63:                  #endif
64:                  #pragma config FPLLODIV = DIV_2         // System PLL Output Clock Divider (PLL Divide by 2)
65:                  
66:                  // DEVCFG1
67:                  #pragma config FNOSC = PRIPLL           // Oscillator Selection Bits (Primary Osc w/PLL (XT+,HS+,EC+PLL))
68:                  #pragma config FSOSCEN = OFF            // Secondary Oscillator Enable (Disabled)
69:                  #pragma config IESO = OFF               // Internal/External Switch Over (Disabled)
70:                  #pragma config POSCMOD = HS             // Primary Oscillator Configuration (XT osc mode)
71:                  #pragma config OSCIOFNC = OFF           // CLKO Output Signal Active on the OSCO Pin (Disabled)
72:                  #pragma config FPBDIV = DIV_1           // Peripheral Clock Divisor (Pb_Clk is Sys_Clk/1)
73:                  #pragma config FCKSM = CSDCMD           // Clock Switching and Monitor Selection (Clock Switch Disable, FSCM Disabled)
74:                  #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT Disabled (SWDTEN Bit Controls))
75:                  
76:                  // DEVCFG0
77:                  #pragma config JTAGEN = OFF             // JTAG Enable (JTAG Disabled)
78:                  #pragma config ICESEL = RESERVED        // ICE/ICD Comm Channel Select (Communicate on PGEC1/PGED1)
79:                  #pragma config PWP = OFF                // Program Flash Write Protect (Disable)
80:                  #pragma config BWP = OFF                // Boot Flash Write Protect bit (Protection Disabled)
81:                  #pragma config CP = OFF                 // Code Protect (Protection Disabled)
82:                  
83:                  
84:                  
85:                  #if defined _DEBUG_
86:                  const char *msg1="video target\r";
87:                  const char *msg2="0123456789";
88:                  
89:                  
90:                  
91:                  void test_pattern(void){
92:                      int i,j;
93:                      for (i=0;i<VRES;i++){
94:                          video_bmp[i][0]=0x80000000;
95:                          video_bmp[i][HRES/32-1]=1;
96:                      }
97:                      for (i=0;i<HRES/32;i++){
98:                          video_bmp[0][i]=0xffffffff;
99:                          video_bmp[VRES-1][i]=0xffffffff;
100:                     }
101:                     for (i=VRES/4;i<VRES/2+VRES/4;i++){
102:                         video_bmp[i][2]=0xFF00FF00;
103:                         video_bmp[i][3]=0xF0F0F0F0;
104:                         video_bmp[i][4]=0xcccccccc;
105:                         video_bmp[i][5]=0xaaaaaaaa;
106:                     }//i
107:                     print(LOCAL_CON,msg1);
108:                     for (i=0;i<8;i++) print(LOCAL_CON,msg2);
109:                     delay_ms(1000);
110:                 }//test_pattern()
111:                 
112:                 const int pts[6]={HRES/2,VRES/2,HRES/2+HRES/3,VRES/2+VRES/3,HRES/2-HRES/3,VRES/2+VRES/3};
113:                 
114:                 void graphics_test(){ // test des fonctions graphiques
115:                     int i;
116:                 
117:                     rectangle(0,0,HRES-1,VRES-1);
118:                     polygon(pts,3);
119:                     circle(HRES/2,VRES/2,100);
120:                     for (i=0;i<100;i++){
121:                         ellipse(HRES/3+i,VRES/3+i,50,30);
122:                     }
123:                     bezier(20,200,20,40,300,40);
124:                     delay_ms(500);
125:                 }//graphics_test
126:                 
127:                 #endif
128:                 
129:                 const unsigned int e3k[]={ // rencontre du 3ième type
130:                 784,500, // sol4
131:                 880,500, // la4
132:                 698,500, // fa4
133:                 349,500, // fa3
134:                 523,500, // do4
135:                 0,0
136:                 };
137:                 
138:                 // affiche la date et l'heure
139:                 void display_date_time(){
9D019E70  27BDFFC8   ADDIU SP, SP, -56
9D019E74  AFBF0034   SW RA, 52(SP)
140:                     char fmt[32];
141:                     rtcc_get_date_str(fmt);
9D019E78  0F40374A   JAL rtcc_get_date_str
9D019E7C  27A40010   ADDIU A0, SP, 16
142:                     print(con,fmt);
9D019E80  97848062   LHU A0, -32670(GP)
9D019E84  0F404FCC   JAL print
9D019E88  27A50010   ADDIU A1, SP, 16
143:                     rtcc_get_time_str(fmt);
9D019E8C  0F40376C   JAL rtcc_get_time_str
9D019E90  27A40010   ADDIU A0, SP, 16
144:                     println(con,fmt);
9D019E94  97848062   LHU A0, -32670(GP)
9D019E98  0F405062   JAL println
9D019E9C  27A50010   ADDIU A1, SP, 16
145:                 }
9D019EA0  8FBF0034   LW RA, 52(SP)
9D019EA4  03E00008   JR RA
9D019EA8  27BD0038   ADDIU SP, SP, 56
146:                 
147:                 
148:                 enum PRT_DEV {VGA,SERIAL,BOTH};
149:                 
150:                 void init_msg(int output, int code, const char *msg){
9D019EAC  27BDFF98   ADDIU SP, SP, -104
9D019EB0  AFBF0064   SW RA, 100(SP)
9D019EB4  AFB00060   SW S0, 96(SP)
9D019EB8  00808021   ADDU S0, A0, ZERO
151:                     char fmt[CHAR_PER_LINE];
152:                 
153:                     if (!code){
9D019EBC  14A00007   BNE A1, ZERO, 0x9D019EDC
9D019EC0  00A03821   ADDU A3, A1, ZERO
154:                         sprintf(fmt,"%s initialization completed.\n",msg);
9D019EC4  27A40010   ADDIU A0, SP, 16
9D019EC8  3C059D02   LUI A1, -25342
9D019ECC  0F407973   JAL _sprintf_cdnopsuxX
9D019ED0  24A5D550   ADDIU A1, A1, -10928
9D019ED4  0B4067BC   J 0x9D019EF0
9D019ED8  24020001   ADDIU V0, ZERO, 1
155:                     }else{
156:                         sprintf(fmt,"%s failed to initialize, error code %d\n",msg,code);
9D019EDC  27A40010   ADDIU A0, SP, 16
9D019EE0  3C059D02   LUI A1, -25342
9D019EE4  0F407973   JAL _sprintf_cdnopsuxX
9D019EE8  24A5D570   ADDIU A1, A1, -10896
157:                     }
158:                     switch (output){
9D019EEC  24020001   ADDIU V0, ZERO, 1
9D019EF0  12020009   BEQ S0, V0, 0x9D019F18
9D019EF4  24020002   ADDIU V0, ZERO, 2
9D019EF8  1202000B   BEQ S0, V0, 0x9D019F28
9D019EFC  00000000   NOP
9D019F00  5600000E   BNEL S0, ZERO, 0x9D019F3C
9D019F04  8FBF0064   LW RA, 100(SP)
159:                         case VGA:
160:                             vga_print(fmt);
9D019F08  0F403AA2   JAL vga_print
9D019F0C  27A40010   ADDIU A0, SP, 16
161:                             break;
9D019F10  0B4067CF   J 0x9D019F3C
9D019F14  8FBF0064   LW RA, 100(SP)
162:                         case SERIAL:
163:                             ser_print(fmt);
9D019F18  0F405504   JAL ser_print
9D019F1C  27A40010   ADDIU A0, SP, 16
164:                             break;
9D019F20  0B4067CF   J 0x9D019F3C
9D019F24  8FBF0064   LW RA, 100(SP)
165:                         case BOTH:
166:                             vga_print(fmt);
9D019F28  0F403AA2   JAL vga_print
9D019F2C  27A40010   ADDIU A0, SP, 16
167:                             ser_print(fmt);
9D019F30  0F405504   JAL ser_print
9D019F34  27A40010   ADDIU A0, SP, 16
168:                     }//switch
169:                 }
9D019F38  8FBF0064   LW RA, 100(SP)
9D019F3C  8FB00060   LW S0, 96(SP)
9D019F40  03E00008   JR RA
9D019F44  27BD0068   ADDIU SP, SP, 104
170:                 
171:                 //__attribute__((mips16))
172:                 void main(void) {
9D019F48  27BDFFE8   ADDIU SP, SP, -24
9D019F4C  AFBF0014   SW RA, 20(SP)
173:                 #if defined _DEBUG_
174:                     debug=-1;
175:                 #endif  
176:                     cold_start_init();
9D019F50  0F405206   JAL cold_start_init
9D019F54  AFB00010   SW S0, 16(SP)
177:                     init_msg(SERIAL,ser_init(115200,DEFAULT_LINE_CTRL),"Serial port");
9D019F58  3C040001   LUI A0, 1
9D019F5C  3484C200   ORI A0, A0, -15872
9D019F60  0F405493   JAL ser_init
9D019F64  00002821   ADDU A1, ZERO, ZERO
9D019F68  24040001   ADDIU A0, ZERO, 1
9D019F6C  00402821   ADDU A1, V0, ZERO
9D019F70  3C069D02   LUI A2, -25342
9D019F74  0F4067AB   JAL init_msg
9D019F78  24C6D598   ADDIU A2, A2, -10856
178:                     vga_init();
9D019F7C  0F403910   JAL vga_init
9D019F80  00000000   NOP
179:                     init_msg(SERIAL,vga_init(),"video");
9D019F84  0F403910   JAL vga_init
9D019F88  00000000   NOP
9D019F8C  24040001   ADDIU A0, ZERO, 1
9D019F90  00402821   ADDU A1, V0, ZERO
9D019F94  3C069D02   LUI A2, -25342
9D019F98  0F4067AB   JAL init_msg
9D019F9C  24C6D5A4   ADDIU A2, A2, -10844
180:                     vga_clear_screen();
9D019FA0  0F40397D   JAL vga_clear_screen
9D019FA4  00000000   NOP
181:                     init_msg(SERIAL,rtcc_init(),"RTCC");
9D019FA8  0F40362B   JAL rtcc_init
9D019FAC  00000000   NOP
9D019FB0  24040001   ADDIU A0, ZERO, 1
9D019FB4  00402821   ADDU A1, V0, ZERO
9D019FB8  3C069D02   LUI A2, -25342
9D019FBC  0F4067AB   JAL init_msg
9D019FC0  24C6D5AC   ADDIU A2, A2, -10836
182:                     heap_size=free_heap();
9D019FC4  0F4052E5   JAL free_heap
9D019FC8  00000000   NOP
183:                 #if defined _DEBUG_
184:                     test_pattern();
185:                 #endif
186:                     init_msg(SERIAL,sound_init(),"Sound");
9D019FCC  0F40606F   JAL sound_init
9D019FD0  AF8280A4   SW V0, -32604(GP)
9D019FD4  24040001   ADDIU A0, ZERO, 1
9D019FD8  00402821   ADDU A1, V0, ZERO
9D019FDC  3C069D02   LUI A2, -25342
9D019FE0  0F4067AB   JAL init_msg
9D019FE4  24C6D5B4   ADDIU A2, A2, -10828
187:                     tune((unsigned int*)&e3k[0]);
9D019FE8  3C049D02   LUI A0, -25342
9D019FEC  0F4060A9   JAL tune
9D019FF0  2484D5EC   ADDIU A0, A0, -10772
188:                     init_msg(SERIAL,kbd_init(),"keyboard");
9D019FF4  0F405FA7   JAL kbd_init
9D019FF8  00000000   NOP
9D019FFC  24040001   ADDIU A0, ZERO, 1
9D01A000  00402821   ADDU A1, V0, ZERO
9D01A004  3C069D02   LUI A2, -25342
9D01A008  0F4067AB   JAL init_msg
9D01A00C  24C6D5BC   ADDIU A2, A2, -10820
189:                     text_coord_t cpos;
190:                     init_msg(SERIAL,!mount(0),"SD card");
9D01A010  0F405908   JAL mount
9D01A014  00002021   ADDU A0, ZERO, ZERO
9D01A018  24040001   ADDIU A0, ZERO, 1
9D01A01C  2C450001   SLTIU A1, V0, 1
9D01A020  3C069D02   LUI A2, -25342
9D01A024  0F4067AB   JAL init_msg
9D01A028  24C6D5C8   ADDIU A2, A2, -10808
191:                     init_msg(SERIAL,sram_init(),"SPI RAM");
9D01A02C  0F404E1E   JAL sram_init
9D01A030  00000000   NOP
9D01A034  24040001   ADDIU A0, ZERO, 1
9D01A038  00402821   ADDU A1, V0, ZERO
9D01A03C  3C069D02   LUI A2, -25342
9D01A040  0F4067AB   JAL init_msg
9D01A044  24C6D5D0   ADDIU A2, A2, -10800
192:                     //test_vm();
193:                 #if defined _DEBUG_    
194:                     // sram test
195:                     circle(HRES/2,VRES/2,100);
196:                     delay_ms(1000);
197:                     sram_write_block(0,&video_bmp,HRES*VRES/8);
198:                     clear_screen();
199:                     delay_ms(1000);
200:                     sram_read_block(0,&video_bmp,HRES*VRES/8);
201:                     delay_ms(1000);
202:                     UartPrint("sound test.\r");
203:                 #endif    
204:                 //    set_cursor(CR_BLOCK); // sauvegare video_buffer dans SRAM
205:                 //    clear_screen();
206:                 //    unsigned char c;
207:                 //    while (1){
208:                 //        c=wait_key(VGA_CONSOLE);
209:                 //        put_char(VGA_CONSOLE,c);
210:                 //    }
211:                 #if defined _DEBUG_
212:                     graphics_test();
213:                     set_curpos(0,LINE_PER_SCREEN-1);
214:                     print(comm_channel,"test");
215:                     sram_write_block(100000,video_bmp,BMP_SIZE);
216:                     delay_ms(1000);
217:                     clear_screen();
218:                     delay_ms(1000);
219:                     sram_read_block(100000,video_bmp,BMP_SIZE);
220:                     delay_ms(1000);
221:                     clear_screen();
222:                 //    print(comm_channel,"heap_size: ");
223:                 //    print_int(comm_channel,heap_size,0);
224:                 //    crlf();
225:                 #endif
226:                 //    char fmt[40];
227:                 //    text_coord_t curpos;
228:                 //    vga_crlf();
229:                 //    curpos=vga_get_curpos();
230:                 //    while(1){
231:                 //        vga_set_curpos(curpos.x,curpos.y);
232:                 //        rtcc_get_date_str(fmt);
233:                 //        vga_print(fmt);
234:                 //        rtcc_get_time_str(fmt);
235:                 //        vga_print(fmt);
236:                 //        vga_put_char(CR);
237:                 //        sprintf(fmt,"system ticks %d\r",ticks());
238:                 //        vga_print(fmt);
239:                 //        _usec_delay(3000);
240:                 //    }
241:                     print(con,"free RAM (bytes): ");
9D01A048  97848062   LHU A0, -32670(GP)
9D01A04C  3C059D02   LUI A1, -25342
9D01A050  0F404FCC   JAL print
9D01A054  24A5D5D8   ADDIU A1, A1, -10792
242:                     print_int(con,free_heap(),0);
9D01A058  0F4052E5   JAL free_heap
9D01A05C  97908062   LHU S0, -32670(GP)
9D01A060  02002021   ADDU A0, S0, ZERO
9D01A064  00402821   ADDU A1, V0, ZERO
9D01A068  0F404FFF   JAL print_int
9D01A06C  00003021   ADDU A2, ZERO, ZERO
243:                     crlf(con);
9D01A070  0F404FF3   JAL crlf
9D01A074  97848062   LHU A0, -32670(GP)
244:                     last_shutdown();
9D01A078  0F403259   JAL last_shutdown
9D01A07C  00000000   NOP
245:                     display_date_time();
9D01A080  0F40679C   JAL display_date_time
9D01A084  00000000   NOP
246:                 //    char c;
247:                 //    while (1){
248:                 //        c=wait_key(con);
249:                 //        if ((c<32)||(c>126)){
250:                 //            print_int(VGA_CONSOLE,(unsigned char)c,1);
251:                 //        }else
252:                 //            vga_put_char(c);
253:                 //    }
254:                     shell();
9D01A088  0F40327A   JAL shell
9D01A08C  00000000   NOP
255:                 } // main()
9D01A090  8FBF0014   LW RA, 20(SP)
9D01A094  8FB00010   LW S0, 16(SP)
9D01A098  03E00008   JR RA
9D01A09C  27BD0018   ADDIU SP, SP, 24
256:                 
257:                 
---  /home/jacques/github/vpc-32vga/shell.c  ------------------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  
20:                  /*
21:                   * File:   shell.h
22:                   * Author: Jacques Deschênes
23:                   *
24:                   * Created on 18 septembre 2013, 07:29
25:                   * Description: un environnement de commande simple pour le VPC-32.
26:                   *   liste des commandes:
27:                   *      ls     liste des fichiers sur la carte SD
28:                   *      rm     efface un fichier.
29:                   *      mv     renomme un fichier.
30:                   *      ed     ouvre l'éditeur
31:                   *      as     assemble un fichier écris en assembleur pour la machine virtuelle.
32:                   *      run    execute un programme compilé pour la machine virtuelle.
33:                   *      cp     copie un fichier
34:                   *      snd    envoie un fichier vers le port sériel
35:                   *      rcv    reçois un fichier par le port sériel
36:                   *      forth  lance l'environnement vpForth
37:                   *      puts mot  imprime à l'écran le mot qui suis
38:                   *      expr {expression}  évalue une expression et retourne le résultat
39:                   */
40:                  
41:                  #include <stdio.h>
42:                  #include <ctype.h>
43:                  #include <stdlib.h>
44:                  #include <string.h>
45:                  #include <setjmp.h>
46:                  #include <plib.h>
47:                  
48:                  #include "hardware/HardwareProfile.h"
49:                  #include "hardware/ps2_kbd/keyboard.h"
50:                  #include "console.h"
51:                  #include "hardware/Pinguino/ff.h"
52:                  #include "hardware/Pinguino/fileio.h"
53:                  #include "shell.h"
54:                  //#include "vpcBASIC/vpcBASIC.h"
55:                  #include "hardware/rtcc/rtcc.h"
56:                  //#include "hardware/serial_comm/serial_comm.h"
57:                  #include "console.h"
58:                  
59:                  #define MAX_LINE_LEN 80
60:                  
61:                  static const char _version[]="1.0";
62:                  static const char *console_name[]={"VGA","SERIAL"};
63:                  static const char _true[]="T";
64:                  static const char _false[]="F";
65:                  static const char _nil[]="";
66:                  
67:                  //jmp_buf back_to_cmd_line;
68:                  
69:                  //dev_t con=SERIAL_CONSOLE;
70:                  dev_t con=VGA_CONSOLE;
71:                  
72:                  static const env_var_t shell_version={NULL,"SHELL_VERSION",(char*)_version};
73:                  static const env_var_t true={(env_var_t*)&shell_version,"TRUE",(char*)_true};
74:                  static const env_var_t false={(env_var_t*)&true,"FALSE",(char*)_false};
75:                  static const env_var_t nil={(env_var_t*)&false,"NIL",(char*)_nil};
76:                  static env_var_t *shell_vars=(env_var_t*)&nil;
77:                  
78:                  static env_var_t *search_var(const char *name);
79:                  static void erase_var(env_var_t *var);
80:                  static char* exec_script(const char *script);
81:                  
82:                  
83:                  static const char *ERR_MSG[]={
84:                      "no error\n",
85:                      "unknown command.\n",
86:                      "syntax error.\n",
87:                      "not implemented yet.\n",
88:                      "Memory allocation error.\n",
89:                      "Bad usage.\n",
90:                      "File open error.\n",
91:                      "Copy error.\n",
92:                      "Mkdir error.\n",
93:                      "file does not exist.\n",
94:                      "operation denied.\n",
95:                      "disk operation error, code is %d \n",
96:                      "no SD card detected.\n"
97:                  };
98:                  
99:                  
100:                 void print_error_msg(SH_ERROR err_code,const char *detail,FRESULT io_code){
9D00B8DC  27BDFFE0   ADDIU SP, SP, -32
9D00B8E0  AFBF001C   SW RA, 28(SP)
9D00B8E4  AFB20018   SW S2, 24(SP)
9D00B8E8  AFB10014   SW S1, 20(SP)
9D00B8EC  AFB00010   SW S0, 16(SP)
101:                     char *fmt;
102:                     if (err_code==ERR_FIO){
9D00B8F0  2402000B   ADDIU V0, ZERO, 11
9D00B8F4  14820012   BNE A0, V0, 0x9D00B940
9D00B8F8  00A08021   ADDU S0, A1, ZERO
9D00B8FC  00C08821   ADDU S1, A2, ZERO
103:                         fmt=malloc(64);
9D00B900  0F4064A8   JAL malloc
9D00B904  24040040   ADDIU A0, ZERO, 64
104:                         if (fmt){
9D00B908  10400014   BEQ V0, ZERO, 0x9D00B95C
9D00B90C  00409021   ADDU S2, V0, ZERO
105:                             sprintf(fmt,ERR_MSG[ERR_FIO],io_code);
9D00B910  00402021   ADDU A0, V0, ZERO
9D00B914  3C059D01   LUI A1, -25343
9D00B918  24A521C4   ADDIU A1, A1, 8644
9D00B91C  0F407973   JAL _sprintf_cdnopsuxX
9D00B920  02203021   ADDU A2, S1, ZERO
106:                             print(con,fmt);
9D00B924  97848062   LHU A0, -32670(GP)
9D00B928  0F404FCC   JAL print
9D00B92C  02402821   ADDU A1, S2, ZERO
107:                             free(fmt);
9D00B930  0F407BCB   JAL free
9D00B934  02402021   ADDU A0, S2, ZERO
9D00B938  0B402E57   J 0x9D00B95C
9D00B93C  00000000   NOP
108:                         }
109:                     }else{
110:                        print(con,ERR_MSG[err_code]);
9D00B940  00042080   SLL A0, A0, 2
9D00B944  3C029D01   LUI V0, -25343
9D00B948  24422748   ADDIU V0, V0, 10056
9D00B94C  00821021   ADDU V0, A0, V0
9D00B950  97848062   LHU A0, -32670(GP)
9D00B954  0F404FCC   JAL print
9D00B958  8C450000   LW A1, 0(V0)
111:                     }
112:                     if (detail){
9D00B95C  12000003   BEQ S0, ZERO, 0x9D00B96C
9D00B960  97848062   LHU A0, -32670(GP)
113:                        print(con,detail);
9D00B964  0F404FCC   JAL print
9D00B968  02002821   ADDU A1, S0, ZERO
114:                     }
115:                 }//print_error_msg()
9D00B96C  8FBF001C   LW RA, 28(SP)
9D00B970  8FB20018   LW S2, 24(SP)
9D00B974  8FB10014   LW S1, 20(SP)
9D00B978  8FB00010   LW S0, 16(SP)
9D00B97C  03E00008   JR RA
9D00B980  27BD0020   ADDIU SP, SP, 32
116:                 
117:                 typedef struct{
118:                     const char *script; // chaîne à analyser
119:                     unsigned  len;  // longueur de la chaîne.
120:                     unsigned  next; // position du curseur de l'analyseur.
121:                     int err_pos;
122:                 } parse_str_t;
123:                 
124:                 
125:                 static int nbr_cmd;
126:                 
127:                 typedef struct shell_cmd{
128:                     char *name;
129:                     char *(*fn)(int,const char**);
130:                 }shell_cmd_t;
131:                 
132:                 static const shell_cmd_t commands[];
133:                 
134:                 //Affichage de la date et heure du dernier shutdown
135:                 //enerigistré dans le RTCC.
136:                 void last_shutdown(){
9D00C964  27BDFF90   ADDIU SP, SP, -112
9D00C968  AFBF006C   SW RA, 108(SP)
137:                     alm_state_t shutdown;
138:                     char fmt[32];
139:                     
140:                     rtcc_power_down_stamp(&shutdown);
9D00C96C  0F403863   JAL rtcc_power_down_stamp
9D00C970  27A40020   ADDIU A0, SP, 32
141:                     if (shutdown.day){
9D00C974  3C0201F0   LUI V0, 496
9D00C978  8FA30020   LW V1, 32(SP)
9D00C97C  00621024   AND V0, V1, V0
9D00C980  10400017   BEQ V0, ZERO, 0x9D00C9E0
9D00C984  8FBF006C   LW RA, 108(SP)
142:                         sprintf(fmt,"Last power down: %s %02d/%02d %02d:%02d\n",weekdays[shutdown.wkday],
9D00C988  00603821   ADDU A3, V1, ZERO
9D00C98C  7C631440   EXT V1, V1, 17, 3
9D00C990  00031880   SLL V1, V1, 2
9D00C994  3C02A000   LUI V0, -24576
9D00C998  244245B8   ADDIU V0, V0, 17848
9D00C99C  00621021   ADDU V0, V1, V0
9D00C9A0  8C460000   LW A2, 0(V0)
9D00C9A4  7CE22500   EXT V0, A3, 20, 5
9D00C9A8  AFA20010   SW V0, 16(SP)
9D00C9AC  7CE22300   EXT V0, A3, 12, 5
9D00C9B0  AFA20014   SW V0, 20(SP)
9D00C9B4  7CE22980   EXT V0, A3, 6, 6
9D00C9B8  AFA20018   SW V0, 24(SP)
9D00C9BC  27A40044   ADDIU A0, SP, 68
9D00C9C0  3C059D01   LUI A1, -25343
9D00C9C4  24A5245C   ADDIU A1, A1, 9308
9D00C9C8  0F407973   JAL _sprintf_cdnopsuxX
9D00C9CC  7CE71E40   EXT A3, A3, 25, 4
143:                                 shutdown.month,shutdown.day,shutdown.hour,shutdown.min);
144:                         print(con,fmt);
9D00C9D0  97848062   LHU A0, -32670(GP)
9D00C9D4  0F404FCC   JAL print
9D00C9D8  27A50044   ADDIU A1, SP, 68
145:                     }
146:                 }
9D00C9DC  8FBF006C   LW RA, 108(SP)
9D00C9E0  03E00008   JR RA
9D00C9E4  27BD0070   ADDIU SP, SP, 112
147:                 
148:                 static int search_command(const char *target){
149:                     int i;
150:                     for (i=nbr_cmd-1;i>=0;i--){
9D00D12C  2410001D   ADDIU S0, ZERO, 29
9D00D148  2610FFFF   ADDIU S0, S0, -1
151:                         if (!strcmp(target,commands[i].name)){
9D00D134  02602021   ADDU A0, S3, ZERO
9D00D138  0F407138   JAL 0x9D01C4E0
9D00D13C  8E450000   LW A1, 0(S2)
9D00D140  10400006   BEQ V0, ZERO, 0x9D00D15C
9D00D144  00000000   NOP
9D00D148  2610FFFF   ADDIU S0, S0, -1
9D00D14C  1614FFF9   BNE S0, S4, 0x9D00D134
9D00D150  2652FFF8   ADDIU S2, S2, -8
152:                             break;
153:                         }
154:                     }
155:                     return i;
156:                 }//search_command()
157:                 
158:                 static char* cmd_help(int tok_count, const char **tok_list){
9D00B15C  27BDFFC8   ADDIU SP, SP, -56
9D00B160  AFBF0034   SW RA, 52(SP)
9D00B164  AFB50030   SW S5, 48(SP)
9D00B168  AFB4002C   SW S4, 44(SP)
9D00B16C  AFB30028   SW S3, 40(SP)
9D00B170  AFB20024   SW S2, 36(SP)
9D00B174  AFB10020   SW S1, 32(SP)
9D00B178  AFB0001C   SW S0, 28(SP)
9D00B17C  3C119D01   LUI S1, -25343
9D00B180  2631259C   ADDIU S1, S1, 9628
159:                     int i;
160:                     text_coord_t pos;
161:                     for(i=0;i<nbr_cmd;i++){
9D00B184  00008021   ADDU S0, ZERO, ZERO
9D00B194  2413001E   ADDIU S3, ZERO, 30
9D00B1F0  26100001   ADDIU S0, S0, 1
9D00B1F4  1613FFE8   BNE S0, S3, 0x9D00B198
9D00B1F8  26310008   ADDIU S1, S1, 8
162:                         pos=get_curpos(con);
9D00B198  27A40010   ADDIU A0, SP, 16
9D00B19C  0F404FA2   JAL get_curpos
9D00B1A0  97858062   LHU A1, -32670(GP)
163:                         if (pos.x>(CHAR_PER_LINE-strlen(commands[i].name)-2)){
9D00B188  2414004E   ADDIU S4, ZERO, 78
9D00B1A4  8E320000   LW S2, 0(S1)
9D00B1A8  0F406EC2   JAL strlen
9D00B1AC  02402021   ADDU A0, S2, ZERO
9D00B1B0  97A30010   LHU V1, 16(SP)
9D00B1B4  02821023   SUBU V0, S4, V0
9D00B1B8  0043182B   SLTU V1, V0, V1
9D00B1BC  10600004   BEQ V1, ZERO, 0x9D00B1D0
9D00B1C0  97848062   LHU A0, -32670(GP)
164:                             put_char(con,'\n');
9D00B1C4  0F404FC0   JAL put_char
9D00B1C8  2405000A   ADDIU A1, ZERO, 10
165:                         }
166:                         print(con,commands[i].name);
9D00B1CC  97848062   LHU A0, -32670(GP)
9D00B1D0  0F404FCC   JAL print
9D00B1D4  02402821   ADDU A1, S2, ZERO
167:                         if (i<(nbr_cmd-1)){
9D00B1D8  2A02001D   SLTI V0, S0, 29
9D00B1DC  50400005   BEQL V0, ZERO, 0x9D00B1F4
9D00B1E0  26100001   ADDIU S0, S0, 1
168:                             print(con," ");
9D00B18C  3C159D01   LUI S5, -25343
9D00B190  26B51F9C   ADDIU S5, S5, 8092
9D00B1E4  97848062   LHU A0, -32670(GP)
9D00B1E8  0F404FCC   JAL print
9D00B1EC  02A02821   ADDU A1, S5, ZERO
169:                         }
170:                     }
171:                     put_char(con,'\n');
9D00B1FC  97848062   LHU A0, -32670(GP)
9D00B200  0F404FC0   JAL put_char
9D00B204  2405000A   ADDIU A1, ZERO, 10
172:                     return NULL;
173:                 }
9D00B208  00001021   ADDU V0, ZERO, ZERO
9D00B20C  8FBF0034   LW RA, 52(SP)
9D00B210  8FB50030   LW S5, 48(SP)
9D00B214  8FB4002C   LW S4, 44(SP)
9D00B218  8FB30028   LW S3, 40(SP)
9D00B21C  8FB20024   LW S2, 36(SP)
9D00B220  8FB10020   LW S1, 32(SP)
9D00B224  8FB0001C   LW S0, 28(SP)
9D00B228  03E00008   JR RA
9D00B22C  27BD0038   ADDIU SP, SP, 56
174:                 
175:                 static char* cmd_cls(int tok_count, const char **tok_list){
9D00B13C  27BDFFE8   ADDIU SP, SP, -24
9D00B140  AFBF0014   SW RA, 20(SP)
176:                     clear_screen(con);
9D00B144  0F404F63   JAL clear_screen
9D00B148  97848062   LHU A0, -32670(GP)
177:                     return NULL;
178:                 }
9D00B14C  00001021   ADDU V0, ZERO, ZERO
9D00B150  8FBF0014   LW RA, 20(SP)
9D00B154  03E00008   JR RA
9D00B158  27BD0018   ADDIU SP, SP, 24
179:                 
180:                 // calibration oscillateur du RTCC
181:                 // +-127 ppm
182:                 static char* cmd_clktrim(int tok_count, const char **tok_list){
9D00B650  27BDFFA8   ADDIU SP, SP, -88
183:                     int trim;
184:                     char fmt[64];
185:                     if (tok_count>1){
9D00B654  28840002   SLTI A0, A0, 2
9D00B658  14800007   BNE A0, ZERO, 0x9D00B678
9D00B65C  AFBF0054   SW RA, 84(SP)
186:                         trim=atoi(tok_list[1]);
9D00B660  0F407787   JAL atoi
9D00B664  8CA40004   LW A0, 4(A1)
187:                         trim=rtcc_calibration(trim);
9D00B668  0F4036BF   JAL rtcc_calibration
9D00B66C  00402021   ADDU A0, V0, ZERO
9D00B670  0B402DA5   J 0x9D00B694
9D00B674  00403021   ADDU A2, V0, ZERO
188:                     }else{
189:                         print(con,
9D00B678  97848062   LHU A0, -32670(GP)
9D00B67C  3C059D01   LUI A1, -25343
9D00B680  0F404FCC   JAL print
9D00B684  24A52084   ADDIU A1, A1, 8324
190:                             "RTCC oscillator calibration\n"
191:                             "USAGE: clktrim n\n"
192:                             "n is added to actual value\n"
193:                             "n is in range {-127..127}\n");
194:                         trim=rtcc_calibration(0);
9D00B688  0F4036BF   JAL rtcc_calibration
9D00B68C  00002021   ADDU A0, ZERO, ZERO
9D00B690  00403021   ADDU A2, V0, ZERO
195:                     }
196:                     sprintf(fmt,"Actual RTCC oscillator trim value: %d",trim);
9D00B694  27A40010   ADDIU A0, SP, 16
9D00B698  3C059D01   LUI A1, -25343
9D00B69C  0F407973   JAL _sprintf_cdnopsuxX
9D00B6A0  24A520E8   ADDIU A1, A1, 8424
197:                     print(con,fmt);
9D00B6A4  97848062   LHU A0, -32670(GP)
9D00B6A8  0F404FCC   JAL print
9D00B6AC  27A50010   ADDIU A1, SP, 16
198:                     return NULL;
199:                 }
9D00B6B0  00001021   ADDU V0, ZERO, ZERO
9D00B6B4  8FBF0054   LW RA, 84(SP)
9D00B6B8  03E00008   JR RA
9D00B6BC  27BD0058   ADDIU SP, SP, 88
200:                 
201:                 
202:                 // imprime le temps depuis
203:                 // le démarrage de l'ordinateur
204:                 static char* cmd_uptime(int tok_count, const char **tok_list){
9D00AED4  27BDFFC0   ADDIU SP, SP, -64
9D00AED8  AFBF003C   SW RA, 60(SP)
205:                     unsigned sys_ticks;
206:                     unsigned day,hour,min,sec,remainder;
207:                     char fmt[32];
208:                     
209:                     sys_ticks=ticks();
9D00AEDC  0F405283   JAL ticks
9D00AEE0  00000000   NOP
210:                     day=sys_ticks/86400000L;
211:                     remainder=sys_ticks%86400000L;
9D00AEE4  3C0631B5   LUI A2, 12725
9D00AEE8  34C6D43B   ORI A2, A2, -11205
9D00AEEC  00460019   MULTU 0, V0, A2
9D00AEF0  00003010   MFHI A2
9D00AEF4  00061E02   SRL V1, A2, 24
9D00AEF8  3C040526   LUI A0, 1318
9D00AEFC  24845C00   ADDIU A0, A0, 23552
9D00AF00  70642802   MUL A1, V1, A0
9D00AF04  00451823   SUBU V1, V0, A1
212:                     hour=remainder/3600000L;
213:                     remainder%=3600000L;
9D00AF08  3C079521   LUI A3, -27359
9D00AF0C  24E77CB1   ADDIU A3, A3, 31921
9D00AF10  00670019   MULTU 0, V1, A3
9D00AF14  00003810   MFHI A3
9D00AF18  00071542   SRL V0, A3, 21
9D00AF1C  00022080   SLL A0, V0, 2
9D00AF20  000229C0   SLL A1, V0, 7
9D00AF24  00A42023   SUBU A0, A1, A0
9D00AF28  00821021   ADDU V0, A0, V0
9D00AF2C  00022100   SLL A0, V0, 4
9D00AF30  00821023   SUBU V0, A0, V0
9D00AF34  00022100   SLL A0, V0, 4
9D00AF38  00821023   SUBU V0, A0, V0
9D00AF3C  000211C0   SLL V0, V0, 7
9D00AF40  00621023   SUBU V0, V1, V0
214:                     min=remainder/60000;
9D00AF44  3C0345E7   LUI V1, 17895
9D00AF48  3463B273   ORI V1, V1, -19853
9D00AF4C  00430019   MULTU 0, V0, V1
9D00AF50  00001810   MFHI V1
9D00AF54  00031B82   SRL V1, V1, 14
215:                     remainder%=60000;
9D00AF5C  00032080   SLL A0, V1, 2
9D00AF60  000329C0   SLL A1, V1, 7
9D00AF64  00A42023   SUBU A0, A1, A0
9D00AF68  00831821   ADDU V1, A0, V1
9D00AF6C  00032100   SLL A0, V1, 4
9D00AF70  00831823   SUBU V1, A0, V1
9D00AF74  00031940   SLL V1, V1, 5
9D00AF78  00431023   SUBU V0, V0, V1
216:                     sec=remainder/1000;
9D00AF7C  3C041062   LUI A0, 4194
9D00AF80  24844DD3   ADDIU A0, A0, 19923
9D00AF84  00440019   MULTU 0, V0, A0
9D00AF88  00001010   MFHI V0
9D00AF8C  00021182   SRL V0, V0, 6
217:                     sprintf(fmt,"%02dd%02dh%02dm%02ds\n",day,hour,min,sec);
9D00AF58  AFA30010   SW V1, 16(SP)
9D00AF90  AFA20014   SW V0, 20(SP)
9D00AF94  27A40018   ADDIU A0, SP, 24
9D00AF98  3C059D01   LUI A1, -25343
9D00AF9C  24A51F74   ADDIU A1, A1, 8052
9D00AFA0  00063602   SRL A2, A2, 24
9D00AFA4  0F407973   JAL _sprintf_cdnopsuxX
9D00AFA8  00073D42   SRL A3, A3, 21
218:                     print(con,fmt);
9D00AFAC  97848062   LHU A0, -32670(GP)
9D00AFB0  0F404FCC   JAL print
9D00AFB4  27A50018   ADDIU A1, SP, 24
219:                     return NULL;
220:                 }
9D00AFB8  00001021   ADDU V0, ZERO, ZERO
9D00AFBC  8FBF003C   LW RA, 60(SP)
9D00AFC0  03E00008   JR RA
9D00AFC4  27BD0040   ADDIU SP, SP, 64
221:                 
222:                 
223:                 static char* cmd_format(int tok_count, const char **tok_list){
9D00C428  27BDFFE8   ADDIU SP, SP, -24
224:                     if (tok_count==2){
9D00C42C  24020002   ADDIU V0, ZERO, 2
9D00C430  14820007   BNE A0, V0, 0x9D00C450
9D00C434  AFBF0014   SW RA, 20(SP)
225:                         print_error_msg(ERR_NOT_DONE,NULL,0);
9D00C438  24040003   ADDIU A0, ZERO, 3
9D00C43C  00002821   ADDU A1, ZERO, ZERO
9D00C440  0F402E37   JAL print_error_msg
9D00C444  00003021   ADDU A2, ZERO, ZERO
9D00C448  0B403119   J 0x9D00C464
9D00C44C  00001021   ADDU V0, ZERO, ZERO
226:                     }else{
227:                         print(con,"USAGE: format volume_name\n");
9D00C450  97848062   LHU A0, -32670(GP)
9D00C454  3C059D01   LUI A1, -25343
9D00C458  0F404FCC   JAL print
9D00C45C  24A5237C   ADDIU A1, A1, 9084
228:                     }
229:                     return NULL;
230:                 }
9D00C460  00001021   ADDU V0, ZERO, ZERO
9D00C464  8FBF0014   LW RA, 20(SP)
9D00C468  03E00008   JR RA
9D00C46C  27BD0018   ADDIU SP, SP, 24
231:                 
232:                 static char* cmd_basic(int tok_count, const char **tok_list){
9D00B230  27BDFFE8   ADDIU SP, SP, -24
9D00B234  AFBF0014   SW RA, 20(SP)
233:                     char *code;
234:                     int exit_code;
235:                 //    if (tok_count>1){
236:                 //        exit_code=BASIC_shell(tok_list[1]);
237:                 //    }else{
238:                 //        exit_code=BASIC_shell(NULL);
239:                 //    }
240:                 //    code=malloc(32);
241:                     exit_code=test_vm();
9D00B238  0F407C8F   JAL test_vm
9D00B23C  AFB00010   SW S0, 16(SP)
242:                     sprintf(code,"\nBASIC exit code: %d", exit_code);
9D00B240  00008021   ADDU S0, ZERO, ZERO
9D00B244  02002021   ADDU A0, S0, ZERO
9D00B248  3C059D01   LUI A1, -25343
9D00B24C  24A51FA0   ADDIU A1, A1, 8096
9D00B250  0F407973   JAL _sprintf_cdnopsuxX
9D00B254  00403021   ADDU A2, V0, ZERO
243:                     return code;
244:                 }
9D00B258  02001021   ADDU V0, S0, ZERO
9D00B25C  8FBF0014   LW RA, 20(SP)
9D00B260  8FB00010   LW S0, 16(SP)
9D00B264  03E00008   JR RA
9D00B268  27BD0018   ADDIU SP, SP, 24
245:                 
246:                 static char* cmd_cd(int tok_count, const char **tok_list){ // change le répertoire courant.
9D00C8A4  27BDFFE0   ADDIU SP, SP, -32
9D00C8A8  AFBF001C   SW RA, 28(SP)
9D00C8AC  AFB10018   SW S1, 24(SP)
9D00C8B0  AFB00014   SW S0, 20(SP)
9D00C8B4  00808021   ADDU S0, A0, ZERO
247:                     char *path;
248:                     if (!SDCardReady){
9D00C8B8  8F8280B4   LW V0, -32588(GP)
9D00C8BC  1440000C   BNE V0, ZERO, 0x9D00C8F0
9D00C8C0  00A08821   ADDU S1, A1, ZERO
249:                         if (!mount(0)){
9D00C8C4  0F405908   JAL mount
9D00C8C8  00002021   ADDU A0, ZERO, ZERO
9D00C8CC  54400007   BNEL V0, ZERO, 0x9D00C8EC
9D00C8D0  24020001   ADDIU V0, ZERO, 1
250:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D00C8D4  2404000C   ADDIU A0, ZERO, 12
9D00C8D8  00002821   ADDU A1, ZERO, ZERO
9D00C8DC  0F402E37   JAL print_error_msg
9D00C8E0  00003021   ADDU A2, ZERO, ZERO
251:                             return;
252:                         }else{
253:                             SDCardReady=TRUE;
9D00C8EC  AF8280B4   SW V0, -32588(GP)
254:                         }
255:                     }
256:                     FRESULT error=FR_OK;
257:                    if (tok_count==2){
9D00C8F0  24020002   ADDIU V0, ZERO, 2
9D00C8F4  16020005   BNE S0, V0, 0x9D00C90C
9D00C8F8  00000000   NOP
258:                        error=f_chdir(tok_list[1]);
9D00C8FC  0F401C02   JAL f_chdir
9D00C900  8E240004   LW A0, 4(S1)
259:                    }
260:                    if (!error){
9D00C904  14400012   BNE V0, ZERO, 0x9D00C950
9D00C908  00001021   ADDU V0, ZERO, ZERO
261:                        path=malloc(255);
9D00C90C  0F4064A8   JAL malloc
9D00C910  240400FF   ADDIU A0, ZERO, 255
262:                        if (path){
9D00C914  1040000D   BEQ V0, ZERO, 0x9D00C94C
9D00C918  00408021   ADDU S0, V0, ZERO
263:                           error=f_getcwd(path,255);
9D00C91C  00402021   ADDU A0, V0, ZERO
9D00C920  0F401C2F   JAL f_getcwd
9D00C924  240500FF   ADDIU A1, ZERO, 255
264:                           if(!error){
9D00C928  14400006   BNE V0, ZERO, 0x9D00C944
9D00C92C  97848062   LHU A0, -32670(GP)
265:                               print(con,path);
9D00C930  0F404FCC   JAL print
9D00C934  02002821   ADDU A1, S0, ZERO
266:                               put_char(con,'\n');
9D00C938  97848062   LHU A0, -32670(GP)
9D00C93C  0F404FC0   JAL put_char
9D00C940  2405000A   ADDIU A1, ZERO, 10
267:                           }
268:                           free(path);
9D00C944  0F407BCB   JAL free
9D00C948  02002021   ADDU A0, S0, ZERO
269:                        }
270:                    }
271:                     return NULL;
9D00C94C  00001021   ADDU V0, ZERO, ZERO
272:                 }//cmd_cd()
9D00C8E4  0B403255   J 0x9D00C954
9D00C8E8  8FBF001C   LW RA, 28(SP)
9D00C950  8FBF001C   LW RA, 28(SP)
9D00C954  8FB10018   LW S1, 24(SP)
9D00C958  8FB00014   LW S0, 20(SP)
9D00C95C  03E00008   JR RA
9D00C960  27BD0020   ADDIU SP, SP, 32
273:                 
274:                 static char* cmd_del(int tok_count, const char **tok_list){ // efface un fichier
9D00C58C  27BDFFE0   ADDIU SP, SP, -32
9D00C590  AFBF001C   SW RA, 28(SP)
9D00C594  AFB20018   SW S2, 24(SP)
9D00C598  AFB10014   SW S1, 20(SP)
9D00C59C  AFB00010   SW S0, 16(SP)
9D00C5A0  00808021   ADDU S0, A0, ZERO
275:                     FILINFO *fi;
276:                     if (!SDCardReady){
9D00C5A4  8F8280B4   LW V0, -32588(GP)
9D00C5A8  1440000C   BNE V0, ZERO, 0x9D00C5DC
9D00C5AC  00A08821   ADDU S1, A1, ZERO
277:                         if (!mount(0)){
9D00C5B0  0F405908   JAL mount
9D00C5B4  00002021   ADDU A0, ZERO, ZERO
9D00C5B8  54400007   BNEL V0, ZERO, 0x9D00C5D8
9D00C5BC  24020001   ADDIU V0, ZERO, 1
278:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D00C5C0  2404000C   ADDIU A0, ZERO, 12
9D00C5C4  00002821   ADDU A1, ZERO, ZERO
9D00C5C8  0F402E37   JAL print_error_msg
9D00C5CC  00003021   ADDU A2, ZERO, ZERO
279:                             return;
280:                         }else{
281:                             SDCardReady=TRUE;
9D00C5D8  AF8280B4   SW V0, -32588(GP)
282:                         }
283:                     }
284:                     FRESULT error=FR_OK;
285:                     if (tok_count==2){
9D00C5DC  24020002   ADDIU V0, ZERO, 2
9D00C5E0  1602002B   BNE S0, V0, 0x9D00C690
9D00C5E4  24040005   ADDIU A0, ZERO, 5
286:                         fi=malloc(sizeof(FILINFO));
9D00C5E8  0F4064A8   JAL malloc
9D00C5EC  24040018   ADDIU A0, ZERO, 24
287:                         if (fi){
9D00C5F0  10400020   BEQ V0, ZERO, 0x9D00C674
9D00C5F4  00408021   ADDU S0, V0, ZERO
288:                             error=f_stat(tok_list[1],fi);
9D00C5F8  8E240004   LW A0, 4(S1)
9D00C5FC  0F401E3C   JAL f_stat
9D00C600  00402821   ADDU A1, V0, ZERO
289:                             if (!error){
9D00C604  14400028   BNE V0, ZERO, 0x9D00C6A8
9D00C608  00409021   ADDU S2, V0, ZERO
290:                                 if (fi->fattrib & (ATT_DIR|ATT_RO)){
9D00C60C  92020008   LBU V0, 8(S0)
9D00C610  30420011   ANDI V0, V0, 17
9D00C614  10400009   BEQ V0, ZERO, 0x9D00C63C
9D00C618  2404000A   ADDIU A0, ZERO, 10
291:                                     print_error_msg(ERR_DENIED,"can't delete directory or read only file.\n",0);
9D00C61C  3C059D01   LUI A1, -25343
9D00C620  24A523BC   ADDIU A1, A1, 9148
9D00C624  0F402E37   JAL print_error_msg
9D00C628  00003021   ADDU A2, ZERO, ZERO
292:                                 }
293:                                 else{
294:                                     error=f_unlink(tok_list[1]);
9D00C63C  0F401F26   JAL f_unlink
9D00C640  8E240004   LW A0, 4(S1)
9D00C644  00409021   ADDU S2, V0, ZERO
295:                                 }
296:                             }
297:                             free(fi);
9D00C62C  0F407BCB   JAL free
9D00C630  02002021   ADDU A0, S0, ZERO
9D00C648  0F407BCB   JAL free
9D00C64C  02002021   ADDU A0, S0, ZERO
9D00C6A8  0F407BCB   JAL free
9D00C6AC  02002021   ADDU A0, S0, ZERO
298:                             if (error){
9D00C650  52400019   BEQL S2, ZERO, 0x9D00C6B8
9D00C654  00001021   ADDU V0, ZERO, ZERO
299:                                 print_error_msg(ERR_FIO,"",error);
9D00C658  2404000B   ADDIU A0, ZERO, 11
9D00C65C  3C059D01   LUI A1, -25343
9D00C660  24A523B8   ADDIU A1, A1, 9144
9D00C664  0F402E37   JAL print_error_msg
9D00C668  02403021   ADDU A2, S2, ZERO
9D00C6B0  0B403197   J 0x9D00C65C
9D00C6B4  2404000B   ADDIU A0, ZERO, 11
300:                             }
301:                         }else{
302:                                print_error_msg(ERR_ALLOC,"delete failed.\n",0);
9D00C674  24040004   ADDIU A0, ZERO, 4
9D00C678  3C059D01   LUI A1, -25343
9D00C67C  24A523E8   ADDIU A1, A1, 9192
9D00C680  0F402E37   JAL print_error_msg
9D00C684  00003021   ADDU A2, ZERO, ZERO
303:                         }
304:                    }else{
305:                        print_error_msg(ERR_USAGE, "delete file USAGE: del file_name\n",0);
9D00C690  3C059D01   LUI A1, -25343
9D00C694  24A523F8   ADDIU A1, A1, 9208
9D00C698  0F402E37   JAL print_error_msg
9D00C69C  00003021   ADDU A2, ZERO, ZERO
306:                    }
307:                     return NULL;
9D00C634  0B4031AE   J 0x9D00C6B8
9D00C638  00001021   ADDU V0, ZERO, ZERO
9D00C66C  0B4031AE   J 0x9D00C6B8
9D00C670  00001021   ADDU V0, ZERO, ZERO
9D00C688  0B4031AE   J 0x9D00C6B8
9D00C68C  00001021   ADDU V0, ZERO, ZERO
9D00C6A0  0B4031AE   J 0x9D00C6B8
9D00C6A4  00001021   ADDU V0, ZERO, ZERO
308:                 }//del()
9D00C5D0  0B4031AF   J 0x9D00C6BC
9D00C5D4  8FBF001C   LW RA, 28(SP)
9D00C6B8  8FBF001C   LW RA, 28(SP)
9D00C6BC  8FB20018   LW S2, 24(SP)
9D00C6C0  8FB10014   LW S1, 20(SP)
9D00C6C4  8FB00010   LW S0, 16(SP)
9D00C6C8  03E00008   JR RA
9D00C6CC  27BD0020   ADDIU SP, SP, 32
309:                 
310:                 static char* cmd_ren(int tok_count, const char **tok_list){ // renomme un fichier
9D00BC4C  27BDFFE0   ADDIU SP, SP, -32
9D00BC50  AFBF001C   SW RA, 28(SP)
9D00BC54  AFB10018   SW S1, 24(SP)
9D00BC58  AFB00014   SW S0, 20(SP)
9D00BC5C  00808021   ADDU S0, A0, ZERO
311:                     if (!SDCardReady){
9D00BC60  8F8280B4   LW V0, -32588(GP)
9D00BC64  1440000C   BNE V0, ZERO, 0x9D00BC98
9D00BC68  00A08821   ADDU S1, A1, ZERO
312:                         if (!mount(0)){
9D00BC6C  0F405908   JAL mount
9D00BC70  00002021   ADDU A0, ZERO, ZERO
9D00BC74  54400007   BNEL V0, ZERO, 0x9D00BC94
9D00BC78  24020001   ADDIU V0, ZERO, 1
313:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D00BC7C  2404000C   ADDIU A0, ZERO, 12
9D00BC80  00002821   ADDU A1, ZERO, ZERO
9D00BC84  0F402E37   JAL print_error_msg
9D00BC88  00003021   ADDU A2, ZERO, ZERO
314:                             return;
315:                         }else{
316:                             SDCardReady=TRUE;
9D00BC94  AF8280B4   SW V0, -32588(GP)
317:                         }
318:                     }
319:                     if (tok_count==3){
9D00BC98  24020003   ADDIU V0, ZERO, 3
9D00BC9C  16020006   BNE S0, V0, 0x9D00BCB8
9D00BCA0  24040005   ADDIU A0, ZERO, 5
320:                         f_rename(tok_list[1],tok_list[2]);
9D00BCA4  8E240004   LW A0, 4(S1)
9D00BCA8  0F4020AA   JAL f_rename
9D00BCAC  8E250008   LW A1, 8(S1)
9D00BCB0  0B402F33   J 0x9D00BCCC
9D00BCB4  00001021   ADDU V0, ZERO, ZERO
321:                     }else{
322:                         print_error_msg(ERR_USAGE,"rename file, USAGE: ren name new_name\n",0);
9D00BCB8  3C059D01   LUI A1, -25343
9D00BCBC  24A52240   ADDIU A1, A1, 8768
9D00BCC0  0F402E37   JAL print_error_msg
9D00BCC4  00003021   ADDU A2, ZERO, ZERO
323:                     }
324:                     return NULL;
9D00BCC8  00001021   ADDU V0, ZERO, ZERO
325:                 }//ren
9D00BC8C  0B402F34   J 0x9D00BCD0
9D00BC90  8FBF001C   LW RA, 28(SP)
9D00BCCC  8FBF001C   LW RA, 28(SP)
9D00BCD0  8FB10018   LW S1, 24(SP)
9D00BCD4  8FB00014   LW S0, 20(SP)
9D00BCD8  03E00008   JR RA
9D00BCDC  27BD0020   ADDIU SP, SP, 32
326:                 
327:                 static char* cmd_copy(int tok_count, const char **tok_list){ // copie un fichier
9D00C6D0  27BDFFD0   ADDIU SP, SP, -48
9D00C6D4  AFBF002C   SW RA, 44(SP)
9D00C6D8  AFB40028   SW S4, 40(SP)
9D00C6DC  AFB30024   SW S3, 36(SP)
9D00C6E0  AFB20020   SW S2, 32(SP)
9D00C6E4  AFB1001C   SW S1, 28(SP)
9D00C6E8  AFB00018   SW S0, 24(SP)
9D00C6EC  00808021   ADDU S0, A0, ZERO
328:                     FIL *fsrc, *fnew;
329:                     char *buff;
330:                     int n;
331:                     if (!SDCardReady){
9D00C6F0  8F8280B4   LW V0, -32588(GP)
9D00C6F4  1440000C   BNE V0, ZERO, 0x9D00C728
9D00C6F8  00A08821   ADDU S1, A1, ZERO
332:                         if (!mount(0)){
9D00C6FC  0F405908   JAL mount
9D00C700  00002021   ADDU A0, ZERO, ZERO
9D00C704  54400007   BNEL V0, ZERO, 0x9D00C724
9D00C708  24020001   ADDIU V0, ZERO, 1
333:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D00C70C  2404000C   ADDIU A0, ZERO, 12
9D00C710  00002821   ADDU A1, ZERO, ZERO
9D00C714  0F402E37   JAL print_error_msg
9D00C718  00003021   ADDU A2, ZERO, ZERO
334:                             return;
335:                         }else{
336:                             SDCardReady=TRUE;
9D00C724  AF8280B4   SW V0, -32588(GP)
337:                         }
338:                     }
339:                     FRESULT error;
340:                     if (tok_count==3){
9D00C728  24020003   ADDIU V0, ZERO, 3
9D00C72C  16020033   BNE S0, V0, 0x9D00C7FC
9D00C730  24040005   ADDIU A0, ZERO, 5
341:                         fsrc=malloc(sizeof(FIL));
9D00C734  0F4064A8   JAL malloc
9D00C738  2404002C   ADDIU A0, ZERO, 44
9D00C73C  00409821   ADDU S3, V0, ZERO
342:                         fnew=malloc(sizeof(FIL));
9D00C740  0F4064A8   JAL malloc
9D00C744  2404002C   ADDIU A0, ZERO, 44
9D00C748  0040A021   ADDU S4, V0, ZERO
343:                         buff=malloc(512);
9D00C74C  0F4064A8   JAL malloc
9D00C750  24040200   ADDIU A0, ZERO, 512
344:                         error=FR_OK;
345:                         if (fsrc && fnew && buff){
9D00C754  12600023   BEQ S3, ZERO, 0x9D00C7E4
9D00C758  00409021   ADDU S2, V0, ZERO
9D00C75C  12800022   BEQ S4, ZERO, 0x9D00C7E8
9D00C760  97848062   LHU A0, -32670(GP)
9D00C764  1040001F   BEQ V0, ZERO, 0x9D00C7E4
9D00C768  02602021   ADDU A0, S3, ZERO
346:                             if ((error=f_open(fsrc,tok_list[1],FA_READ)==FR_OK) &&
9D00C76C  8E250004   LW A1, 4(S1)
9D00C770  0F4018E7   JAL f_open
9D00C774  24060001   ADDIU A2, ZERO, 1
9D00C778  14400042   BNE V0, ZERO, 0x9D00C884
9D00C77C  00001021   ADDU V0, ZERO, ZERO
9D00C790  1440003C   BNE V0, ZERO, 0x9D00C884
9D00C794  00001021   ADDU V0, ZERO, ZERO
347:                                 (error=f_open(fnew,tok_list[2],FA_CREATE_NEW|FA_WRITE)==FR_OK)){
9D00C780  02802021   ADDU A0, S4, ZERO
9D00C784  8E250008   LW A1, 8(S1)
9D00C788  0F4018E7   JAL f_open
9D00C78C  24060006   ADDIU A2, ZERO, 6
348:                                 while ((error=f_read(fsrc,buff,512,&n))==FR_OK){
9D00C798  0B4031F1   J 0x9D00C7C4
9D00C79C  02602021   ADDU A0, S3, ZERO
9D00C7C0  02602021   ADDU A0, S3, ZERO
9D00C7C4  02402821   ADDU A1, S2, ZERO
9D00C7C8  24060200   ADDIU A2, ZERO, 512
9D00C7CC  0F401A00   JAL f_read
9D00C7D0  27A70010   ADDIU A3, SP, 16
9D00C7D4  1040FFF2   BEQ V0, ZERO, 0x9D00C7A0
9D00C7D8  00408021   ADDU S0, V0, ZERO
9D00C7DC  0B403211   J 0x9D00C844
9D00C7E0  00000000   NOP
349:                                     if (n){
9D00C7A0  8FA60010   LW A2, 16(SP)
9D00C7A4  10C0001B   BEQ A2, ZERO, 0x9D00C814
9D00C7A8  02802021   ADDU A0, S4, ZERO
350:                                         if (!((error=f_write(fnew,buff,n,&n))==FR_OK)){
9D00C7AC  02402821   ADDU A1, S2, ZERO
9D00C7B0  0F401AAC   JAL f_write
9D00C7B4  27A70010   ADDIU A3, SP, 16
9D00C7B8  14400022   BNE V0, ZERO, 0x9D00C844
9D00C7BC  00408021   ADDU S0, V0, ZERO
351:                                             break;
352:                                         }
353:                                     }else{
354:                                          break;
355:                                     }
356:                                 }//while
357:                                 f_close(fsrc);
9D00C814  0F401BC6   JAL f_close
9D00C818  02602021   ADDU A0, S3, ZERO
9D00C844  0F401BC6   JAL f_close
9D00C848  02602021   ADDU A0, S3, ZERO
358:                                 f_close(fnew);
9D00C81C  0F401BC6   JAL f_close
9D00C820  02802021   ADDU A0, S4, ZERO
9D00C84C  0F401BC6   JAL f_close
9D00C850  02802021   ADDU A0, S4, ZERO
359:                                 free(buff);
9D00C824  0F407BCB   JAL free
9D00C828  02402021   ADDU A0, S2, ZERO
9D00C854  0F407BCB   JAL free
9D00C858  02402021   ADDU A0, S2, ZERO
360:                                 free(fsrc);
9D00C82C  0F407BCB   JAL free
9D00C830  02602021   ADDU A0, S3, ZERO
9D00C85C  0F407BCB   JAL free
9D00C860  02602021   ADDU A0, S3, ZERO
361:                                 free(fnew);
9D00C834  0F407BCB   JAL free
9D00C838  02802021   ADDU A0, S4, ZERO
9D00C83C  0B403221   J 0x9D00C884
9D00C840  00001021   ADDU V0, ZERO, ZERO
9D00C864  0F407BCB   JAL free
9D00C868  02802021   ADDU A0, S4, ZERO
362:                             }
363:                             if (error){
364:                                 print_error_msg(ERR_FIO,"copy failed.\n",error);
9D00C86C  2404000B   ADDIU A0, ZERO, 11
9D00C870  3C059D01   LUI A1, -25343
9D00C874  24A5244C   ADDIU A1, A1, 9292
9D00C878  0F402E37   JAL print_error_msg
9D00C87C  02003021   ADDU A2, S0, ZERO
9D00C880  00001021   ADDU V0, ZERO, ZERO
365:                             }
366:                         }else{
367:                             print(con,ERR_MSG[ERR_ALLOC]);
9D00C7E4  97848062   LHU A0, -32670(GP)
9D00C7E8  3C059D01   LUI A1, -25343
9D00C7EC  0F404FCC   JAL print
9D00C7F0  24A52338   ADDIU A1, A1, 9016
368:                         }
369:                     }else{
370:                         print_error_msg(ERR_USAGE,"copy file USAGE: copy file_name new_file_name\n",0);
9D00C7FC  3C059D01   LUI A1, -25343
9D00C800  24A5241C   ADDIU A1, A1, 9244
9D00C804  0F402E37   JAL print_error_msg
9D00C808  00003021   ADDU A2, ZERO, ZERO
371:                     }
372:                     return NULL;
9D00C7F4  0B403221   J 0x9D00C884
9D00C7F8  00001021   ADDU V0, ZERO, ZERO
9D00C80C  0B403221   J 0x9D00C884
9D00C810  00001021   ADDU V0, ZERO, ZERO
373:                 }//copy()
9D00C71C  0B403222   J 0x9D00C888
9D00C720  8FBF002C   LW RA, 44(SP)
9D00C884  8FBF002C   LW RA, 44(SP)
9D00C888  8FB40028   LW S4, 40(SP)
9D00C88C  8FB30024   LW S3, 36(SP)
9D00C890  8FB20020   LW S2, 32(SP)
9D00C894  8FB1001C   LW S1, 28(SP)
9D00C898  8FB00018   LW S0, 24(SP)
9D00C89C  03E00008   JR RA
9D00C8A0  27BD0030   ADDIU SP, SP, 48
374:                 
375:                 static char* cmd_send(int tok_count, const char **tok_list){ // envoie un fichier via uart
9D00BC04  27BDFFE8   ADDIU SP, SP, -24
376:                     // to do
377:                    if (tok_count==2){
9D00BC08  24020002   ADDIU V0, ZERO, 2
9D00BC0C  14820007   BNE A0, V0, 0x9D00BC2C
9D00BC10  AFBF0014   SW RA, 20(SP)
378:                        print_error_msg(ERR_NOT_DONE,NULL,0);
9D00BC14  24040003   ADDIU A0, ZERO, 3
9D00BC18  00002821   ADDU A1, ZERO, ZERO
9D00BC1C  0F402E37   JAL print_error_msg
9D00BC20  00003021   ADDU A2, ZERO, ZERO
9D00BC24  0B402F10   J 0x9D00BC40
9D00BC28  00001021   ADDU V0, ZERO, ZERO
379:                    }else{
380:                        print(con, "send file via serial, USAGE: send file_name\n");
9D00BC2C  97848062   LHU A0, -32670(GP)
9D00BC30  3C059D01   LUI A1, -25343
9D00BC34  0F404FCC   JAL print
9D00BC38  24A52210   ADDIU A1, A1, 8720
381:                    }
382:                    return NULL;
383:                 }//cmd_send()
9D00BC3C  00001021   ADDU V0, ZERO, ZERO
9D00BC40  8FBF0014   LW RA, 20(SP)
9D00BC44  03E00008   JR RA
9D00BC48  27BD0018   ADDIU SP, SP, 24
384:                 
385:                 static char* cmd_receive(int tok_count, const char **tok_list){ // reçois un fichier via uart
9D00BCE0  27BDFFE8   ADDIU SP, SP, -24
386:                     // to do
387:                    if (tok_count==2){
9D00BCE4  24020002   ADDIU V0, ZERO, 2
9D00BCE8  14820007   BNE A0, V0, 0x9D00BD08
9D00BCEC  AFBF0014   SW RA, 20(SP)
388:                        print_error_msg(ERR_NOT_DONE,NULL,0);
9D00BCF0  24040003   ADDIU A0, ZERO, 3
9D00BCF4  00002821   ADDU A1, ZERO, ZERO
9D00BCF8  0F402E37   JAL print_error_msg
9D00BCFC  00003021   ADDU A2, ZERO, ZERO
9D00BD00  0B402F47   J 0x9D00BD1C
9D00BD04  00001021   ADDU V0, ZERO, ZERO
389:                    }else{
390:                        print(con, "receive file from serial, USAGE: receive file_name\n");
9D00BD08  97848062   LHU A0, -32670(GP)
9D00BD0C  3C059D01   LUI A1, -25343
9D00BD10  0F404FCC   JAL print
9D00BD14  24A52268   ADDIU A1, A1, 8808
391:                    }
392:                    return NULL;
393:                 }//cmd_receive()
9D00BD18  00001021   ADDU V0, ZERO, ZERO
9D00BD1C  8FBF0014   LW RA, 20(SP)
9D00BD20  03E00008   JR RA
9D00BD24  27BD0018   ADDIU SP, SP, 24
394:                 
395:                 static char* cmd_hdump(int tok_count, const char **tok_list){ // affiche un fichier en hexadécimal
9D00C0FC  27BDFFA0   ADDIU SP, SP, -96
9D00C100  AFBF005C   SW RA, 92(SP)
9D00C104  AFBE0058   SW S8, 88(SP)
9D00C108  AFB70054   SW S7, 84(SP)
9D00C10C  AFB60050   SW S6, 80(SP)
9D00C110  AFB5004C   SW S5, 76(SP)
9D00C114  AFB40048   SW S4, 72(SP)
9D00C118  AFB30044   SW S3, 68(SP)
9D00C11C  AFB20040   SW S2, 64(SP)
9D00C120  AFB1003C   SW S1, 60(SP)
9D00C124  AFB00038   SW S0, 56(SP)
9D00C128  00808021   ADDU S0, A0, ZERO
396:                     FIL *fh;
397:                     unsigned char *fmt, *buff, *rbuff, c,key,line[18];
398:                     int n,col=0,scr_line=0;
9D00C1E0  0000B821   ADDU S7, ZERO, ZERO
9D00C1E4  00008021   ADDU S0, ZERO, ZERO
399:                     unsigned addr=0;
400:                     
401:                     if (!SDCardReady){
9D00C12C  8F8280B4   LW V0, -32588(GP)
9D00C130  1440000C   BNE V0, ZERO, 0x9D00C164
9D00C134  00A08821   ADDU S1, A1, ZERO
402:                         if (!mount(0)){
9D00C138  0F405908   JAL mount
9D00C13C  00002021   ADDU A0, ZERO, ZERO
9D00C140  54400007   BNEL V0, ZERO, 0x9D00C160
9D00C144  24020001   ADDIU V0, ZERO, 1
403:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D00C148  2404000C   ADDIU A0, ZERO, 12
9D00C14C  00002821   ADDU A1, ZERO, ZERO
9D00C150  0F402E37   JAL print_error_msg
9D00C154  00003021   ADDU A2, ZERO, ZERO
404:                             return;
405:                         }else{
406:                             SDCardReady=TRUE;
9D00C160  AF8280B4   SW V0, -32588(GP)
407:                         }
408:                     }
409:                     FRESULT error=FR_OK;
9D00C3C4  00001021   ADDU V0, ZERO, ZERO
410:                     if (tok_count==2){
9D00C164  24020002   ADDIU V0, ZERO, 2
9D00C168  1602009E   BNE S0, V0, 0x9D00C3E4
9D00C16C  24040005   ADDIU A0, ZERO, 5
411:                         fh=malloc(sizeof(FIL));
9D00C170  0F4064A8   JAL malloc
9D00C174  2404002C   ADDIU A0, ZERO, 44
412:                         if (fh && ((error=f_open(fh,tok_list[1],FA_READ))==FR_OK)){
9D00C178  10400092   BEQ V0, ZERO, 0x9D00C3C4
9D00C17C  AFA2002C   SW V0, 44(SP)
9D00C180  00402021   ADDU A0, V0, ZERO
9D00C184  8E250004   LW A1, 4(S1)
9D00C188  0F4018E7   JAL f_open
9D00C18C  24060001   ADDIU A2, ZERO, 1
9D00C190  1440008E   BNE V0, ZERO, 0x9D00C3CC
9D00C194  2404000B   ADDIU A0, ZERO, 11
413:                             if (con==VGA_CONSOLE) clear_screen(con);
9D00C198  97828062   LHU V0, -32670(GP)
9D00C19C  14400003   BNE V0, ZERO, 0x9D00C1AC
9D00C1A0  00000000   NOP
9D00C1A4  0F404F63   JAL clear_screen
9D00C1A8  00002021   ADDU A0, ZERO, ZERO
414:                             buff=malloc(512);
9D00C1AC  0F4064A8   JAL malloc
9D00C1B0  24040200   ADDIU A0, ZERO, 512
9D00C1B4  AFA20028   SW V0, 40(SP)
415:                             fmt=malloc(CHAR_PER_LINE);
9D00C1B8  0F4064A8   JAL malloc
9D00C1BC  24040050   ADDIU A0, ZERO, 80
416:                             if (fmt && buff){
9D00C1C0  10400079   BEQ V0, ZERO, 0x9D00C3A8
9D00C1C4  00409821   ADDU S3, V0, ZERO
9D00C1C8  8FA20028   LW V0, 40(SP)
9D00C1CC  10400076   BEQ V0, ZERO, 0x9D00C3A8
9D00C1D0  0000B021   ADDU S6, ZERO, ZERO
417:                                 key=0;
9D00C1E8  0000A021   ADDU S4, ZERO, ZERO
418:                                 line[16]=CR;
9D00C1D4  2402000D   ADDIU V0, ZERO, 13
9D00C1D8  A3A20020   SB V0, 32(SP)
419:                                 line[17]=0;
9D00C1DC  A3A00021   SB ZERO, 33(SP)
420:                                 while (key!=ESC && f_read(fh,buff,512,&n)==FR_OK){
9D00C2E8  2402001B   ADDIU V0, ZERO, 27
9D00C2EC  56820009   BNEL S4, V0, 0x9D00C314
9D00C2F0  8FA4002C   LW A0, 44(SP)
9D00C2F4  0B4030CB   J 0x9D00C32C
9D00C2F8  00000000   NOP
9D00C310  8FA4002C   LW A0, 44(SP)
9D00C314  8FA50028   LW A1, 40(SP)
9D00C318  24060200   ADDIU A2, ZERO, 512
9D00C31C  0F401A00   JAL f_read
9D00C320  27A70024   ADDIU A3, SP, 36
9D00C324  1040FFB6   BEQ V0, ZERO, 0x9D00C200
9D00C328  8FA20024   LW V0, 36(SP)
421:                                     if (!n) break;
9D00C200  1040004A   BEQ V0, ZERO, 0x9D00C32C
9D00C204  2402001B   ADDIU V0, ZERO, 27
422:                                     rbuff=buff;
423:                                     for(;n && key!=ESC;n--){
9D00C208  12820048   BEQ S4, V0, 0x9D00C32C
9D00C20C  8FB20028   LW S2, 40(SP)
9D00C2D8  8FA20024   LW V0, 36(SP)
9D00C2DC  2442FFFF   ADDIU V0, V0, -1
9D00C2E0  14400006   BNE V0, ZERO, 0x9D00C2FC
9D00C2E4  AFA20024   SW V0, 36(SP)
9D00C2FC  2402001B   ADDIU V0, ZERO, 27
9D00C300  1682FFC6   BNE S4, V0, 0x9D00C21C
9D00C304  00000000   NOP
9D00C308  0B4030CB   J 0x9D00C32C
9D00C30C  00000000   NOP
424:                                         if (!col){
9D00C21C  56000009   BNEL S0, ZERO, 0x9D00C244
9D00C220  26520001   ADDIU S2, S2, 1
425:                                             sprintf(fmt,"%08X  ",addr);
9D00C1EC  3C1E9D01   LUI S8, -25343
9D00C1F0  27DE2364   ADDIU S8, S8, 9060
9D00C224  02602021   ADDU A0, S3, ZERO
9D00C228  03C02821   ADDU A1, S8, ZERO
9D00C22C  0F407973   JAL _sprintf_cdnopsuxX
9D00C230  02C03021   ADDU A2, S6, ZERO
426:                                             print(con,fmt);
9D00C234  97848062   LHU A0, -32670(GP)
9D00C238  0F404FCC   JAL print
9D00C23C  02602821   ADDU A1, S3, ZERO
427:                                         }
428:                                         c=*rbuff++;
9D00C240  26520001   ADDIU S2, S2, 1
9D00C244  9251FFFF   LBU S1, -1(S2)
429:                                         sprintf(fmt,"%02X ",c);
9D00C1F4  3C159D01   LUI S5, -25343
9D00C1F8  0B4030C4   J 0x9D00C310
9D00C1FC  26B5236C   ADDIU S5, S5, 9068
9D00C248  02602021   ADDU A0, S3, ZERO
9D00C24C  02A02821   ADDU A1, S5, ZERO
9D00C250  0F407973   JAL _sprintf_cdnopsuxX
9D00C254  02203021   ADDU A2, S1, ZERO
430:                                         //print_hex(con,c,2); put_char(con,32);
431:                                         if (c>=32) line[col]=c; else line[col]=32;
9D00C258  2E220020   SLTIU V0, S1, 32
9D00C25C  14400004   BNE V0, ZERO, 0x9D00C270
9D00C260  24030020   ADDIU V1, ZERO, 32
9D00C264  03B01021   ADDU V0, SP, S0
9D00C268  0B40309E   J 0x9D00C278
9D00C26C  A0510010   SB S1, 16(V0)
9D00C270  03B01021   ADDU V0, SP, S0
9D00C274  A0430010   SB V1, 16(V0)
432:                                         print(con,fmt);
9D00C278  97848062   LHU A0, -32670(GP)
9D00C27C  0F404FCC   JAL print
9D00C280  02602821   ADDU A1, S3, ZERO
433:                                         col++;
9D00C284  26100001   ADDIU S0, S0, 1
434:                                         if (col==16){
9D00C288  24020010   ADDIU V0, ZERO, 16
9D00C28C  16020013   BNE S0, V0, 0x9D00C2DC
9D00C290  8FA20024   LW V0, 36(SP)
435:                                             print(con,line);
9D00C294  97848062   LHU A0, -32670(GP)
9D00C298  0F404FCC   JAL print
9D00C29C  27A50010   ADDIU A1, SP, 16
436:                                             col=0;
437:                                             addr+=16;
9D00C2A0  26D60010   ADDIU S6, S6, 16
438:                                             scr_line++;
9D00C2A4  26F70001   ADDIU S7, S7, 1
439:                                             if (scr_line==(LINE_PER_SCREEN-1)){
9D00C2A8  2402001D   ADDIU V0, ZERO, 29
9D00C2AC  16E2000A   BNE S7, V0, 0x9D00C2D8
9D00C2B0  00008021   ADDU S0, ZERO, ZERO
440:                                                 print(con,"more...");
9D00C210  3C029D01   LUI V0, -25343
9D00C214  24422374   ADDIU V0, V0, 9076
9D00C218  AFA20030   SW V0, 48(SP)
9D00C2B4  97848062   LHU A0, -32670(GP)
9D00C2B8  0F404FCC   JAL print
9D00C2BC  8FA50030   LW A1, 48(SP)
441:                                                 key=wait_key(con);
9D00C2C0  0F404F87   JAL wait_key
9D00C2C4  97848062   LHU A0, -32670(GP)
9D00C2C8  0040A021   ADDU S4, V0, ZERO
442:                                                 clear_screen(con);
9D00C2CC  0F404F63   JAL clear_screen
9D00C2D0  97848062   LHU A0, -32670(GP)
443:                                                 scr_line=0;
9D00C2D4  0000B821   ADDU S7, ZERO, ZERO
444:                                             }
445:                                         }
446:                                     }
447:                                 }
448:                                 if (col){
9D00C32C  12000014   BEQ S0, ZERO, 0x9D00C380
9D00C330  00000000   NOP
449:                                     strcpy(fmt,"   ");
9D00C334  3C020020   LUI V0, 32
9D00C338  24422020   ADDIU V0, V0, 8224
9D00C33C  AE620000   SW V0, 0(S3)
450:                                     while (col<16){
9D00C340  2A020010   SLTI V0, S0, 16
9D00C344  1040000B   BEQ V0, ZERO, 0x9D00C374
9D00C348  27B20020   ADDIU S2, SP, 32
9D00C34C  27A20010   ADDIU V0, SP, 16
9D00C350  00508021   ADDU S0, V0, S0
9D00C36C  5612FFFB   BNEL S0, S2, 0x9D00C35C
9D00C370  97848062   LHU A0, -32670(GP)
451:                                         print(con,fmt);
9D00C358  97848062   LHU A0, -32670(GP)
9D00C35C  0F404FCC   JAL print
9D00C360  02602821   ADDU A1, S3, ZERO
452:                                         line[col]=32;
9D00C354  24110020   ADDIU S1, ZERO, 32
9D00C364  A2110000   SB S1, 0(S0)
9D00C368  26100001   ADDIU S0, S0, 1
453:                                         col++;
454:                                     }
455:                                     print(con,line);
9D00C374  97848062   LHU A0, -32670(GP)
9D00C378  0F404FCC   JAL print
9D00C37C  27A50010   ADDIU A1, SP, 16
456:                                 }
457:                                 f_close(fh);
9D00C380  0F401BC6   JAL f_close
9D00C384  8FA4002C   LW A0, 44(SP)
458:                                 free(fh);
9D00C388  0F407BCB   JAL free
9D00C38C  8FA4002C   LW A0, 44(SP)
459:                                 free(buff);
9D00C390  0F407BCB   JAL free
9D00C394  8FA40028   LW A0, 40(SP)
460:                                 free(fmt);
9D00C398  0F407BCB   JAL free
9D00C39C  02602021   ADDU A0, S3, ZERO
9D00C3A0  0B4030FE   J 0x9D00C3F8
9D00C3A4  00001021   ADDU V0, ZERO, ZERO
461:                             }else{
462:                                 print_error_msg(ERR_ALLOC,"Can't display file.\n",0);
9D00C3A8  24040004   ADDIU A0, ZERO, 4
9D00C3AC  3C059D01   LUI A1, -25343
9D00C3B0  24A522A8   ADDIU A1, A1, 8872
9D00C3B4  0F402E37   JAL print_error_msg
9D00C3B8  00003021   ADDU A2, ZERO, ZERO
463:                             }
464:                         }else{
465:                             print_error_msg(ERR_FIO,"File open failed.\n",error);
9D00C3C8  2404000B   ADDIU A0, ZERO, 11
9D00C3CC  3C059D01   LUI A1, -25343
9D00C3D0  24A522C0   ADDIU A1, A1, 8896
9D00C3D4  0F402E37   JAL print_error_msg
9D00C3D8  00403021   ADDU A2, V0, ZERO
466:                         }
467:                    }else{
468:                        print_error_msg(ERR_USAGE, "USAGE: more file_name\n",0);
9D00C3E4  3C059D01   LUI A1, -25343
9D00C3E8  24A522D4   ADDIU A1, A1, 8916
9D00C3EC  0F402E37   JAL print_error_msg
9D00C3F0  00003021   ADDU A2, ZERO, ZERO
469:                    }
470:                     return NULL;
9D00C3BC  0B4030FE   J 0x9D00C3F8
9D00C3C0  00001021   ADDU V0, ZERO, ZERO
9D00C3DC  0B4030FE   J 0x9D00C3F8
9D00C3E0  00001021   ADDU V0, ZERO, ZERO
9D00C3F4  00001021   ADDU V0, ZERO, ZERO
471:                 }//f
9D00C158  0B4030FF   J 0x9D00C3FC
9D00C15C  8FBF005C   LW RA, 92(SP)
9D00C3F8  8FBF005C   LW RA, 92(SP)
9D00C3FC  8FBE0058   LW S8, 88(SP)
9D00C400  8FB70054   LW S7, 84(SP)
9D00C404  8FB60050   LW S6, 80(SP)
9D00C408  8FB5004C   LW S5, 76(SP)
9D00C40C  8FB40048   LW S4, 72(SP)
9D00C410  8FB30044   LW S3, 68(SP)
9D00C414  8FB20040   LW S2, 64(SP)
9D00C418  8FB1003C   LW S1, 60(SP)
9D00C41C  8FB00038   LW S0, 56(SP)
9D00C420  03E00008   JR RA
9D00C424  27BD0060   ADDIU SP, SP, 96
472:                 
473:                 static char* cmd_mount(int tok_count, const char **tok_list){// mount SDcard drive
9D00BFB8  27BDFFE8   ADDIU SP, SP, -24
9D00BFBC  AFBF0014   SW RA, 20(SP)
474:                     if (!SDCardReady){
9D00BFC0  8F8280B4   LW V0, -32588(GP)
9D00BFC4  1440000D   BNE V0, ZERO, 0x9D00BFFC
9D00BFC8  00001021   ADDU V0, ZERO, ZERO
475:                         if (!mount(0)){
9D00BFCC  0F405908   JAL mount
9D00BFD0  00002021   ADDU A0, ZERO, ZERO
9D00BFD4  54400007   BNEL V0, ZERO, 0x9D00BFF4
9D00BFD8  24020001   ADDIU V0, ZERO, 1
476:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D00BFDC  2404000C   ADDIU A0, ZERO, 12
9D00BFE0  00002821   ADDU A1, ZERO, ZERO
9D00BFE4  0F402E37   JAL print_error_msg
9D00BFE8  00003021   ADDU A2, ZERO, ZERO
477:                             return;
478:                         }else{
479:                             SDCardReady=TRUE;
9D00BFF4  AF8280B4   SW V0, -32588(GP)
480:                         }
481:                     }
482:                     return NULL;
9D00BFF8  00001021   ADDU V0, ZERO, ZERO
483:                 }
9D00BFEC  0B403000   J 0x9D00C000
9D00BFF0  8FBF0014   LW RA, 20(SP)
9D00BFFC  8FBF0014   LW RA, 20(SP)
9D00C000  03E00008   JR RA
9D00C004  27BD0018   ADDIU SP, SP, 24
484:                 
485:                 static char* cmd_umount(int tok_count, const char **tok_list){
9D00AFC8  27BDFFE8   ADDIU SP, SP, -24
9D00AFCC  AFBF0014   SW RA, 20(SP)
486:                     unmountSD();
9D00AFD0  0F4040C3   JAL unmountSD
9D00AFD4  00000000   NOP
487:                     SDCardReady=FALSE;
9D00AFD8  AF8080B4   SW ZERO, -32588(GP)
488:                     return NULL;
489:                 }
9D00AFDC  00001021   ADDU V0, ZERO, ZERO
9D00AFE0  8FBF0014   LW RA, 20(SP)
9D00AFE4  03E00008   JR RA
9D00AFE8  27BD0018   ADDIU SP, SP, 24
490:                 
491:                 // affiche à l'écran le contenu d'un fichier texte
492:                 static char* cmd_more(int tok_count, const char **tok_list){
9D00BD28  27BDFFC0   ADDIU SP, SP, -64
9D00BD2C  AFBF003C   SW RA, 60(SP)
9D00BD30  AFB70038   SW S7, 56(SP)
9D00BD34  AFB60034   SW S6, 52(SP)
9D00BD38  AFB50030   SW S5, 48(SP)
9D00BD3C  AFB4002C   SW S4, 44(SP)
9D00BD40  AFB30028   SW S3, 40(SP)
9D00BD44  AFB20024   SW S2, 36(SP)
9D00BD48  AFB10020   SW S1, 32(SP)
9D00BD4C  AFB0001C   SW S0, 28(SP)
9D00BD50  00808021   ADDU S0, A0, ZERO
493:                     FIL *fh;
494:                     char *fmt, *buff, *rbuff, c, prev,key;
495:                     int n,lcnt,colcnt=0;
496:                     text_coord_t cpos;
497:                     if (!SDCardReady){
9D00BD54  8F8280B4   LW V0, -32588(GP)
9D00BD58  1440000C   BNE V0, ZERO, 0x9D00BD8C
9D00BD5C  00A08821   ADDU S1, A1, ZERO
498:                         if (!mount(0)){
9D00BD60  0F405908   JAL mount
9D00BD64  00002021   ADDU A0, ZERO, ZERO
9D00BD68  54400007   BNEL V0, ZERO, 0x9D00BD88
9D00BD6C  24020001   ADDIU V0, ZERO, 1
499:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D00BD70  2404000C   ADDIU A0, ZERO, 12
9D00BD74  00002821   ADDU A1, ZERO, ZERO
9D00BD78  0F402E37   JAL print_error_msg
9D00BD7C  00003021   ADDU A2, ZERO, ZERO
500:                             return;
501:                         }else{
502:                             SDCardReady=TRUE;
9D00BD88  AF8280B4   SW V0, -32588(GP)
503:                         }
504:                     }
505:                     FRESULT error=FR_OK;
9D00BF58  00001021   ADDU V0, ZERO, ZERO
506:                     if (tok_count==2){
9D00BD8C  24020002   ADDIU V0, ZERO, 2
9D00BD90  16020079   BNE S0, V0, 0x9D00BF78
9D00BD94  24040005   ADDIU A0, ZERO, 5
507:                         clear_screen(con);
9D00BD98  0F404F63   JAL clear_screen
9D00BD9C  97848062   LHU A0, -32670(GP)
508:                         fh=malloc(sizeof(FIL));
9D00BDA0  0F4064A8   JAL malloc
9D00BDA4  2404002C   ADDIU A0, ZERO, 44
509:                         if (fh && ((error=f_open(fh,tok_list[1],FA_READ))==FR_OK)){
9D00BDA8  1040006B   BEQ V0, ZERO, 0x9D00BF58
9D00BDAC  0040B021   ADDU S6, V0, ZERO
9D00BDB0  00402021   ADDU A0, V0, ZERO
9D00BDB4  8E250004   LW A1, 4(S1)
9D00BDB8  0F4018E7   JAL f_open
9D00BDBC  24060001   ADDIU A2, ZERO, 1
9D00BDC0  14400067   BNE V0, ZERO, 0x9D00BF60
9D00BDC4  2404000B   ADDIU A0, ZERO, 11
510:                             buff=malloc(512);
9D00BDC8  0F4064A8   JAL malloc
9D00BDCC  24040200   ADDIU A0, ZERO, 512
9D00BDD0  0040A821   ADDU S5, V0, ZERO
511:                             fmt=malloc(CHAR_PER_LINE);
9D00BDD4  0F4064A8   JAL malloc
9D00BDD8  24040050   ADDIU A0, ZERO, 80
512:                             if (fmt && buff){
9D00BDDC  10400057   BEQ V0, ZERO, 0x9D00BF3C
9D00BDE0  0040B821   ADDU S7, V0, ZERO
9D00BDE4  12A00055   BEQ S5, ZERO, 0x9D00BF3C
9D00BDE8  00009021   ADDU S2, ZERO, ZERO
513:                                 key=0;
514:                                 while (key!=ESC && f_read(fh,buff,512,&n)==FR_OK){
9D00BEEC  2402001B   ADDIU V0, ZERO, 27
9D00BEF0  12420008   BEQ S2, V0, 0x9D00BF14
9D00BEF4  00000000   NOP
9D00BEF8  02C02021   ADDU A0, S6, ZERO
9D00BEFC  02A02821   ADDU A1, S5, ZERO
9D00BF00  24060200   ADDIU A2, ZERO, 512
9D00BF04  0F401A00   JAL f_read
9D00BF08  27A70010   ADDIU A3, SP, 16
9D00BF0C  5040FFBB   BEQL V0, ZERO, 0x9D00BDFC
9D00BF10  8FA20010   LW V0, 16(SP)
515:                                     if (!n) break;
9D00BDFC  10400045   BEQ V0, ZERO, 0x9D00BF14
9D00BE00  02A08021   ADDU S0, S5, ZERO
516:                                     rbuff=buff;
517:                                     for(;n;n--){
9D00BEDC  8FA20010   LW V0, 16(SP)
9D00BEE0  2442FFFF   ADDIU V0, V0, -1
9D00BEE4  1440FFC8   BNE V0, ZERO, 0x9D00BE08
9D00BEE8  AFA20010   SW V0, 16(SP)
518:                                         c=*rbuff++;
9D00BE08  26100001   ADDIU S0, S0, 1
9D00BE0C  8205FFFF   LB A1, -1(S0)
519:                                         if ((c!=TAB && c!=CR && c!=LF) && (c<32 || c>126)) {c=32;}
9D00BDEC  2411000D   ADDIU S1, ZERO, 13
9D00BE04  24130020   ADDIU S3, ZERO, 32
9D00BE10  30A200FF   ANDI V0, A1, 255
9D00BE14  2443FFF7   ADDIU V1, V0, -9
9D00BE18  306300FF   ANDI V1, V1, 255
9D00BE1C  2C630002   SLTIU V1, V1, 2
9D00BE20  14600006   BNE V1, ZERO, 0x9D00BE3C
9D00BE24  00000000   NOP
9D00BE28  10B10004   BEQ A1, S1, 0x9D00BE3C
9D00BE2C  2442FFE0   ADDIU V0, V0, -32
9D00BE30  304200FF   ANDI V0, V0, 255
9D00BE34  2C42005F   SLTIU V0, V0, 95
9D00BE38  0262280A   MOVZ A1, S3, V0
520:                                         put_char(con,c);
9D00BE3C  0F404FC0   JAL put_char
9D00BE40  97848062   LHU A0, -32670(GP)
521:                                         cpos=get_curpos(con);
9D00BE44  27A40014   ADDIU A0, SP, 20
9D00BE48  0F404FA2   JAL get_curpos
9D00BE4C  97858062   LHU A1, -32670(GP)
522:                                         if (cpos.x==0){
9D00BE50  97A20014   LHU V0, 20(SP)
9D00BE54  14400021   BNE V0, ZERO, 0x9D00BEDC
9D00BE58  97A30016   LHU V1, 22(SP)
523:                                             if (cpos.y>=(LINE_PER_SCREEN-1)){
9D00BE5C  2C63001D   SLTIU V1, V1, 29
9D00BE60  1460001F   BNE V1, ZERO, 0x9D00BEE0
9D00BE64  8FA20010   LW V0, 16(SP)
524:                                                 cpos.y=LINE_PER_SCREEN-1;
525:                                                 invert_video(con,TRUE);
9D00BE68  97848062   LHU A0, -32670(GP)
9D00BE6C  0F404FE7   JAL invert_video
9D00BE70  24050001   ADDIU A1, ZERO, 1
526:                                                 print(con,"-- next --");
9D00BDF0  3C149D01   LUI S4, -25343
9D00BDF4  0B402FBE   J 0x9D00BEF8
9D00BDF8  2694229C   ADDIU S4, S4, 8860
9D00BE74  97848062   LHU A0, -32670(GP)
9D00BE78  0F404FCC   JAL print
9D00BE7C  02802821   ADDU A1, S4, ZERO
527:                                                 invert_video(con,FALSE);
9D00BE80  97848062   LHU A0, -32670(GP)
9D00BE84  0F404FE7   JAL invert_video
9D00BE88  00002821   ADDU A1, ZERO, ZERO
528:                                                 key=wait_key(con);
9D00BE8C  0F404F87   JAL wait_key
9D00BE90  97848062   LHU A0, -32670(GP)
9D00BE94  7C029420   SEB S2, V0
529:                                                 if (key=='q' || key==ESC){key=ESC; break;}
9D00BE98  24020071   ADDIU V0, ZERO, 113
9D00BE9C  1242001D   BEQ S2, V0, 0x9D00BF14
9D00BEA0  00000000   NOP
9D00BEA4  2402001B   ADDIU V0, ZERO, 27
9D00BEA8  1242001A   BEQ S2, V0, 0x9D00BF14
9D00BEAC  00000000   NOP
530:                                                 if (key==CR){
9D00BEB0  16510008   BNE S2, S1, 0x9D00BED4
9D00BEB4  97848062   LHU A0, -32670(GP)
531:                                                     set_curpos(con,cpos.x,cpos.y);
9D00BEB8  00002821   ADDU A1, ZERO, ZERO
9D00BEBC  0F404FB2   JAL set_curpos
9D00BEC0  2406001D   ADDIU A2, ZERO, 29
532:                                                     clear_eol(con);
9D00BEC4  0F404F6F   JAL clear_eol
9D00BEC8  97848062   LHU A0, -32670(GP)
9D00BECC  0B402FB8   J 0x9D00BEE0
9D00BED0  8FA20010   LW V0, 16(SP)
533:                                                 }else{
534:                                                     clear_screen(con);
9D00BED4  0F404F63   JAL clear_screen
9D00BED8  97848062   LHU A0, -32670(GP)
535:                                                 }//if
536:                                             }//if
537:                                         }//if
538:                                     }//for
539:                                 }//while
540:                                 f_close(fh);
9D00BF14  0F401BC6   JAL f_close
9D00BF18  02C02021   ADDU A0, S6, ZERO
541:                                 free(fh);
9D00BF1C  0F407BCB   JAL free
9D00BF20  02C02021   ADDU A0, S6, ZERO
542:                                 free(buff);
9D00BF24  0F407BCB   JAL free
9D00BF28  02A02021   ADDU A0, S5, ZERO
543:                                 free(fmt);
9D00BF2C  0F407BCB   JAL free
9D00BF30  02E02021   ADDU A0, S7, ZERO
9D00BF34  0B402FE3   J 0x9D00BF8C
9D00BF38  00001021   ADDU V0, ZERO, ZERO
544:                             }else{
545:                                 print_error_msg(ERR_ALLOC,"Can't display file.\n",0);
9D00BF3C  24040004   ADDIU A0, ZERO, 4
9D00BF40  3C059D01   LUI A1, -25343
9D00BF44  24A522A8   ADDIU A1, A1, 8872
9D00BF48  0F402E37   JAL print_error_msg
9D00BF4C  00003021   ADDU A2, ZERO, ZERO
546:                             }
547:                         }else{
548:                             print_error_msg(ERR_FIO,"File open failed.\n",error);
9D00BF5C  2404000B   ADDIU A0, ZERO, 11
9D00BF60  3C059D01   LUI A1, -25343
9D00BF64  24A522C0   ADDIU A1, A1, 8896
9D00BF68  0F402E37   JAL print_error_msg
9D00BF6C  00403021   ADDU A2, V0, ZERO
549:                         }
550:                    }else{
551:                        print_error_msg(ERR_USAGE, "USAGE: more file_name\n",0);
9D00BF78  3C059D01   LUI A1, -25343
9D00BF7C  24A522D4   ADDIU A1, A1, 8916
9D00BF80  0F402E37   JAL print_error_msg
9D00BF84  00003021   ADDU A2, ZERO, ZERO
552:                    }
553:                     return NULL;
9D00BF50  0B402FE3   J 0x9D00BF8C
9D00BF54  00001021   ADDU V0, ZERO, ZERO
9D00BF70  0B402FE3   J 0x9D00BF8C
9D00BF74  00001021   ADDU V0, ZERO, ZERO
9D00BF88  00001021   ADDU V0, ZERO, ZERO
554:                 }//more
9D00BD80  0B402FE4   J 0x9D00BF90
9D00BD84  8FBF003C   LW RA, 60(SP)
9D00BF8C  8FBF003C   LW RA, 60(SP)
9D00BF90  8FB70038   LW S7, 56(SP)
9D00BF94  8FB60034   LW S6, 52(SP)
9D00BF98  8FB50030   LW S5, 48(SP)
9D00BF9C  8FB4002C   LW S4, 44(SP)
9D00BFA0  8FB30028   LW S3, 40(SP)
9D00BFA4  8FB20024   LW S2, 36(SP)
9D00BFA8  8FB10020   LW S1, 32(SP)
9D00BFAC  8FB0001C   LW S0, 28(SP)
9D00BFB0  03E00008   JR RA
9D00BFB4  27BD0040   ADDIU SP, SP, 64
555:                 
556:                 static char* cmd_edit(int tok_count, const char **tok_list){ // lance l'éditeur de texte
9D00B2B8  27BDFFE8   ADDIU SP, SP, -24
557:                     if (tok_count>1){
9D00B2BC  28840002   SLTI A0, A0, 2
9D00B2C0  14800005   BNE A0, ZERO, 0x9D00B2D8
9D00B2C4  AFBF0014   SW RA, 20(SP)
558:                         editor(tok_list[1]);
9D00B2C8  0F40274C   JAL editor
9D00B2CC  8CA40004   LW A0, 4(A1)
9D00B2D0  0B402CB9   J 0x9D00B2E4
9D00B2D4  00001021   ADDU V0, ZERO, ZERO
559:                     }else{
560:                         editor(NULL);
9D00B2D8  0F40274C   JAL editor
9D00B2DC  00002021   ADDU A0, ZERO, ZERO
561:                     }
562:                     return NULL;
563:                 }//f
9D00B2E0  00001021   ADDU V0, ZERO, ZERO
9D00B2E4  8FBF0014   LW RA, 20(SP)
9D00B2E8  03E00008   JR RA
9D00B2EC  27BD0018   ADDIU SP, SP, 24
564:                 
565:                 static char* cmd_mkdir(int tok_count, const char **tok_list){
9D00C008  27BDFFE0   ADDIU SP, SP, -32
9D00C00C  AFBF001C   SW RA, 28(SP)
9D00C010  AFB10018   SW S1, 24(SP)
9D00C014  AFB00014   SW S0, 20(SP)
9D00C018  00808021   ADDU S0, A0, ZERO
566:                     FRESULT error=FR_OK;
567:                     char *fmt;
568:                     if (!SDCardReady){
9D00C01C  8F8280B4   LW V0, -32588(GP)
9D00C020  1440000C   BNE V0, ZERO, 0x9D00C054
9D00C024  00A08821   ADDU S1, A1, ZERO
569:                         if (!mount(0)){
9D00C028  0F405908   JAL mount
9D00C02C  00002021   ADDU A0, ZERO, ZERO
9D00C030  54400007   BNEL V0, ZERO, 0x9D00C050
9D00C034  24020001   ADDIU V0, ZERO, 1
570:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D00C038  2404000C   ADDIU A0, ZERO, 12
9D00C03C  00002821   ADDU A1, ZERO, ZERO
9D00C040  0F402E37   JAL print_error_msg
9D00C044  00003021   ADDU A2, ZERO, ZERO
571:                             return;
572:                         }else{
573:                             SDCardReady=TRUE;
9D00C050  AF8280B4   SW V0, -32588(GP)
574:                         }
575:                     }
576:                     if (tok_count==2){
9D00C054  24020002   ADDIU V0, ZERO, 2
9D00C058  16020013   BNE S0, V0, 0x9D00C0A8
9D00C05C  24040005   ADDIU A0, ZERO, 5
577:                         fmt=malloc(CHAR_PER_LINE+1);
9D00C060  0F4064A8   JAL malloc
9D00C064  24040051   ADDIU A0, ZERO, 81
578:                         if (fmt && (error=f_mkdir(tok_list[1])==FR_OK)){
9D00C068  10400015   BEQ V0, ZERO, 0x9D00C0C0
9D00C06C  00408021   ADDU S0, V0, ZERO
9D00C070  0F401F8A   JAL f_mkdir
9D00C074  8E240004   LW A0, 4(S1)
9D00C078  14400017   BNE V0, ZERO, 0x9D00C0D8
9D00C07C  97848062   LHU A0, -32670(GP)
579:                             sprintf(fmt,"directory %s created\n",tok_list[1]);
9D00C080  02002021   ADDU A0, S0, ZERO
9D00C084  3C059D01   LUI A1, -25343
9D00C088  24A522EC   ADDIU A1, A1, 8940
9D00C08C  0F407973   JAL _sprintf_cdnopsuxX
9D00C090  8E260004   LW A2, 4(S1)
580:                             print(con,fmt);
9D00C094  97848062   LHU A0, -32670(GP)
9D00C098  0F404FCC   JAL print
9D00C09C  02002821   ADDU A1, S0, ZERO
9D00C0A0  0B40303A   J 0x9D00C0E8
9D00C0A4  00001021   ADDU V0, ZERO, ZERO
581:                         }else{
582:                             if (!fmt){
583:                                 print(con,ERR_MSG[ERR_ALLOC]);
9D00C0C0  97848062   LHU A0, -32670(GP)
9D00C0C4  3C059D01   LUI A1, -25343
9D00C0C8  0F404FCC   JAL print
9D00C0CC  24A52338   ADDIU A1, A1, 9016
9D00C0D0  0B40303A   J 0x9D00C0E8
9D00C0D4  00001021   ADDU V0, ZERO, ZERO
584:                             }else{
585:                                 print(con,ERR_MSG[ERR_MKDIR]);
9D00C0D8  3C059D01   LUI A1, -25343
9D00C0DC  0F404FCC   JAL print
9D00C0E0  24A52354   ADDIU A1, A1, 9044
9D00C0E4  00001021   ADDU V0, ZERO, ZERO
586:                             }
587:                         }
588:                     }else{
589:                         print_error_msg(ERR_USAGE,"mkdir create a directory, USAGE: mkdir dir_name\n",0);
9D00C0A8  3C059D01   LUI A1, -25343
9D00C0AC  24A52304   ADDIU A1, A1, 8964
9D00C0B0  0F402E37   JAL print_error_msg
9D00C0B4  00003021   ADDU A2, ZERO, ZERO
590:                     }
591:                     return NULL;
9D00C0B8  0B40303A   J 0x9D00C0E8
9D00C0BC  00001021   ADDU V0, ZERO, ZERO
592:                 }// mkdir()
9D00C048  0B40303B   J 0x9D00C0EC
9D00C04C  8FBF001C   LW RA, 28(SP)
9D00C0E8  8FBF001C   LW RA, 28(SP)
9D00C0EC  8FB10018   LW S1, 24(SP)
9D00C0F0  8FB00014   LW S0, 20(SP)
9D00C0F4  03E00008   JR RA
9D00C0F8  27BD0020   ADDIU SP, SP, 32
593:                 
594:                 static char* cmd_dir(int tok_count, const char **tok_list){
9D00C470  27BDFFA8   ADDIU SP, SP, -88
9D00C474  AFBF0054   SW RA, 84(SP)
9D00C478  AFB20050   SW S2, 80(SP)
9D00C47C  AFB1004C   SW S1, 76(SP)
9D00C480  AFB00048   SW S0, 72(SP)
9D00C484  00808021   ADDU S0, A0, ZERO
595:                     FRESULT error;
596:                     FIL *fh;
597:                     char fmt[55];
598:                     if (!SDCardReady){
9D00C488  8F8280B4   LW V0, -32588(GP)
9D00C48C  1440000C   BNE V0, ZERO, 0x9D00C4C0
9D00C490  00A08821   ADDU S1, A1, ZERO
599:                         if (!mount(0)){
9D00C494  0F405908   JAL mount
9D00C498  00002021   ADDU A0, ZERO, ZERO
9D00C49C  54400007   BNEL V0, ZERO, 0x9D00C4BC
9D00C4A0  24020001   ADDIU V0, ZERO, 1
600:                             print_error_msg(ERR_NO_SDCARD,NULL,0);
9D00C4A4  2404000C   ADDIU A0, ZERO, 12
9D00C4A8  00002821   ADDU A1, ZERO, ZERO
9D00C4AC  0F402E37   JAL print_error_msg
9D00C4B0  00003021   ADDU A2, ZERO, ZERO
601:                             return;
602:                         }else{
603:                             SDCardReady=TRUE;
9D00C4BC  AF8280B4   SW V0, -32588(GP)
604:                         }
605:                     }
606:                     if (tok_count>1){
9D00C4C0  2A100002   SLTI S0, S0, 2
9D00C4C4  16000020   BNE S0, ZERO, 0x9D00C548
9D00C4C8  3C049D01   LUI A0, -25343
607:                         error=listDir(tok_list[1]);
9D00C4CC  0F405941   JAL listDir
9D00C4D0  8E240004   LW A0, 4(S1)
9D00C4D4  00408021   ADDU S0, V0, ZERO
608:                         if (error==FR_NO_PATH){// not a directory, try file
9D00C4D8  24020005   ADDIU V0, ZERO, 5
9D00C4DC  1602001D   BNE S0, V0, 0x9D00C554
9D00C4E0  00000000   NOP
609:                             fh=malloc(sizeof(FIL));
9D00C4E4  0F4064A8   JAL malloc
9D00C4E8  2404002C   ADDIU A0, ZERO, 44
610:                             if (fh && ((error=f_open(fh,tok_list[1],FA_READ))==FR_OK)){
9D00C4EC  1040001B   BEQ V0, ZERO, 0x9D00C55C
9D00C4F0  00409021   ADDU S2, V0, ZERO
9D00C4F4  00402021   ADDU A0, V0, ZERO
9D00C4F8  8E250004   LW A1, 4(S1)
9D00C4FC  0F4018E7   JAL f_open
9D00C500  24060001   ADDIU A2, ZERO, 1
9D00C504  14400015   BNE V0, ZERO, 0x9D00C55C
9D00C508  00408021   ADDU S0, V0, ZERO
611:                                 sprintf(fmt,"File: %s, size %d bytes\n",tok_list[1],fh->fsize);
9D00C50C  27A40010   ADDIU A0, SP, 16
9D00C510  3C059D01   LUI A1, -25343
9D00C514  24A52398   ADDIU A1, A1, 9112
9D00C518  8E260004   LW A2, 4(S1)
9D00C51C  0F407973   JAL _sprintf_cdnopsuxX
9D00C520  8E47000C   LW A3, 12(S2)
612:                                 print(con,fmt);
9D00C524  97848062   LHU A0, -32670(GP)
9D00C528  0F404FCC   JAL print
9D00C52C  27A50010   ADDIU A1, SP, 16
613:                                 f_close(fh);
9D00C530  0F401BC6   JAL f_close
9D00C534  02402021   ADDU A0, S2, ZERO
614:                                 free(fh);
9D00C538  0F407BCB   JAL free
9D00C53C  02402021   ADDU A0, S2, ZERO
615:                             }
616:                         }
617:                     }else{
618:                         error=listDir(".");
9D00C548  0F405941   JAL listDir
9D00C54C  248423B4   ADDIU A0, A0, 9140
9D00C550  00408021   ADDU S0, V0, ZERO
619:                     }
620:                     if (error) print_error_msg(ERR_FIO,"",error);
9D00C554  12000007   BEQ S0, ZERO, 0x9D00C574
9D00C558  00001021   ADDU V0, ZERO, ZERO
9D00C55C  2404000B   ADDIU A0, ZERO, 11
9D00C560  3C059D01   LUI A1, -25343
9D00C564  24A523B8   ADDIU A1, A1, 9144
9D00C568  0F402E37   JAL print_error_msg
9D00C56C  02003021   ADDU A2, S0, ZERO
621:                     return NULL;
9D00C540  0B40315D   J 0x9D00C574
9D00C544  00001021   ADDU V0, ZERO, ZERO
9D00C570  00001021   ADDU V0, ZERO, ZERO
622:                 }//list_directory()
9D00C4B4  0B40315E   J 0x9D00C578
9D00C4B8  8FBF0054   LW RA, 84(SP)
9D00C574  8FBF0054   LW RA, 84(SP)
9D00C578  8FB20050   LW S2, 80(SP)
9D00C57C  8FB1004C   LW S1, 76(SP)
9D00C580  8FB00048   LW S0, 72(SP)
9D00C584  03E00008   JR RA
9D00C588  27BD0058   ADDIU SP, SP, 88
623:                 
624:                 static char* cmd_puts(int tok_count, const char **tok_list){
9D00AD6C  27BDFFE8   ADDIU SP, SP, -24
9D00AD70  AFBF0014   SW RA, 20(SP)
625:                     print(con, "puts, to be done.\n");
9D00AD74  97848062   LHU A0, -32670(GP)
9D00AD78  3C059D01   LUI A1, -25343
9D00AD7C  0F404FCC   JAL print
9D00AD80  24A51F4C   ADDIU A1, A1, 8012
626:                     return NULL;
627:                 }//puts()
9D00AD84  00001021   ADDU V0, ZERO, ZERO
9D00AD88  8FBF0014   LW RA, 20(SP)
9D00AD8C  03E00008   JR RA
9D00AD90  27BD0018   ADDIU SP, SP, 24
628:                 
629:                 static char* cmd_expr(int tok_count, const char **tok_list){
9D00AD94  27BDFFE8   ADDIU SP, SP, -24
9D00AD98  AFBF0014   SW RA, 20(SP)
630:                     print(con, "expr, to be done.\n");
9D00AD9C  97848062   LHU A0, -32670(GP)
9D00ADA0  3C059D01   LUI A1, -25343
9D00ADA4  0F404FCC   JAL print
9D00ADA8  24A51F60   ADDIU A1, A1, 8032
631:                     return NULL;
632:                 }//expr()
9D00ADAC  00001021   ADDU V0, ZERO, ZERO
9D00ADB0  8FBF0014   LW RA, 20(SP)
9D00ADB4  03E00008   JR RA
9D00ADB8  27BD0018   ADDIU SP, SP, 24
633:                 
634:                 //display heap status
635:                 static char* cmd_free(int tok_count, const char **tok_list){
9D00B26C  27BDFFE8   ADDIU SP, SP, -24
9D00B270  AFBF0014   SW RA, 20(SP)
9D00B274  AFB00010   SW S0, 16(SP)
636:                     char *free_ram;
637:                     free_ram=calloc(sizeof(char),80);
9D00B278  24040001   ADDIU A0, ZERO, 1
9D00B27C  0F407A79   JAL calloc
9D00B280  24050050   ADDIU A1, ZERO, 80
638:                     sprintf(free_ram,"free RAM %d/%d BYTES\n",free_heap(),heap_size);
9D00B284  0F4052E5   JAL free_heap
9D00B288  00408021   ADDU S0, V0, ZERO
9D00B28C  02002021   ADDU A0, S0, ZERO
9D00B290  3C059D01   LUI A1, -25343
9D00B294  24A51FB8   ADDIU A1, A1, 8120
9D00B298  00403021   ADDU A2, V0, ZERO
9D00B29C  0F407973   JAL _sprintf_cdnopsuxX
9D00B2A0  8F8780A4   LW A3, -32604(GP)
639:                     return free_ram;
640:                 }
9D00B2A4  02001021   ADDU V0, S0, ZERO
9D00B2A8  8FBF0014   LW RA, 20(SP)
9D00B2AC  8FB00010   LW S0, 16(SP)
9D00B2B0  03E00008   JR RA
9D00B2B4  27BD0018   ADDIU SP, SP, 24
641:                 
642:                 static void parse_time(char *time_str,stime_t *time){
9D00AFEC  27BDFFD8   ADDIU SP, SP, -40
9D00AFF0  AFBF0024   SW RA, 36(SP)
9D00AFF4  AFB30020   SW S3, 32(SP)
9D00AFF8  AFB2001C   SW S2, 28(SP)
9D00AFFC  AFB10018   SW S1, 24(SP)
9D00B000  AFB00014   SW S0, 20(SP)
9D00B004  00808821   ADDU S1, A0, ZERO
643:                     char *str;
644:                     unsigned short hr,min=0,sec=0;
9D00B058  00001021   ADDU V0, ZERO, ZERO
9D00B05C  00009821   ADDU S3, ZERO, ZERO
645:                     
646:                     hr=atoi(time_str);
9D00B008  0F407787   JAL atoi
9D00B00C  00A08021   ADDU S0, A1, ZERO
9D00B010  00409021   ADDU S2, V0, ZERO
647:                     str=strchr(time_str,':');
9D00B014  02202021   ADDU A0, S1, ZERO
9D00B018  0F407C03   JAL strchr
9D00B01C  2405003A   ADDIU A1, ZERO, 58
648:                     if (str){
9D00B020  1040000D   BEQ V0, ZERO, 0x9D00B058
9D00B024  24510001   ADDIU S1, V0, 1
649:                         min=atoi(++str);
9D00B028  0F407787   JAL atoi
9D00B02C  02202021   ADDU A0, S1, ZERO
9D00B030  3053FFFF   ANDI S3, V0, -1
650:                         str=strchr(str,':');
9D00B034  02202021   ADDU A0, S1, ZERO
9D00B038  0F407C03   JAL strchr
9D00B03C  2405003A   ADDIU A1, ZERO, 58
651:                         if (str) sec=atoi(++str);
9D00B040  50400007   BEQL V0, ZERO, 0x9D00B060
9D00B044  00001021   ADDU V0, ZERO, ZERO
9D00B048  0F407787   JAL atoi
9D00B04C  24440001   ADDIU A0, V0, 1
9D00B050  0B402C18   J 0x9D00B060
9D00B054  3042FFFF   ANDI V0, V0, -1
652:                     }
653:                     time->hour=hr;
9D00B060  8E030000   LW V1, 0(S0)
9D00B064  7E438304   INS V1, S2, 12, 5
654:                     time->min=min;
9D00B068  7E635984   INS V1, S3, 6, 6
655:                     time->sec=sec;
9D00B06C  7C432804   INS V1, V0, 0, 6
9D00B070  AE030000   SW V1, 0(S0)
656:                 }
9D00B074  8FBF0024   LW RA, 36(SP)
9D00B078  8FB30020   LW S3, 32(SP)
9D00B07C  8FB2001C   LW S2, 28(SP)
9D00B080  8FB10018   LW S1, 24(SP)
9D00B084  8FB00014   LW S0, 20(SP)
9D00B088  03E00008   JR RA
9D00B08C  27BD0028   ADDIU SP, SP, 40
657:                 
658:                 static void parse_date(char *date_str,sdate_t *date){
9D00B2F0  27BDFFD8   ADDIU SP, SP, -40
9D00B2F4  AFBF0024   SW RA, 36(SP)
9D00B2F8  AFB30020   SW S3, 32(SP)
9D00B2FC  AFB2001C   SW S2, 28(SP)
9D00B300  AFB10018   SW S1, 24(SP)
9D00B304  AFB00014   SW S0, 20(SP)
9D00B308  00808821   ADDU S1, A0, ZERO
659:                     unsigned y,m=1,d=1;    
9D00B368  24020001   ADDIU V0, ZERO, 1
9D00B36C  24130001   ADDIU S3, ZERO, 1
660:                     char *str;
661:                 
662:                     y=atoi(date_str);
9D00B30C  0F407787   JAL atoi
9D00B310  00A08021   ADDU S0, A1, ZERO
663:                     y+=y<100?2000:0;
9D00B314  2C520064   SLTIU S2, V0, 100
9D00B318  240307D0   ADDIU V1, ZERO, 2000
9D00B31C  0012180A   MOVZ V1, ZERO, S2
9D00B320  00629021   ADDU S2, V1, V0
664:                     str=strchr(date_str,'/');
9D00B324  02202021   ADDU A0, S1, ZERO
9D00B328  0F407C03   JAL strchr
9D00B32C  2405002F   ADDIU A1, ZERO, 47
665:                     if (str){
9D00B330  1040000D   BEQ V0, ZERO, 0x9D00B368
9D00B334  24510001   ADDIU S1, V0, 1
666:                         m=atoi(++str);
9D00B338  0F407787   JAL atoi
9D00B33C  02202021   ADDU A0, S1, ZERO
9D00B340  00409821   ADDU S3, V0, ZERO
667:                         str=strchr(str,'/');
9D00B344  02202021   ADDU A0, S1, ZERO
9D00B348  0F407C03   JAL strchr
9D00B34C  2405002F   ADDIU A1, ZERO, 47
668:                         if (str){
9D00B350  50400007   BEQL V0, ZERO, 0x9D00B370
9D00B354  24020001   ADDIU V0, ZERO, 1
669:                             d=atoi(++str);
9D00B358  0F407787   JAL atoi
9D00B35C  24440001   ADDIU A0, V0, 1
9D00B360  0B402CDD   J 0x9D00B374
9D00B364  8E030000   LW V1, 0(S0)
670:                         }else{
671:                             d=1;
672:                         }
673:                     }else{
674:                         m=1;
675:                     }
676:                     date->day=d;
9D00B370  8E030000   LW V1, 0(S0)
9D00B374  7C43C504   INS V1, V0, 20, 5
677:                     date->month=m;
9D00B378  7E639C04   INS V1, S3, 16, 4
9D00B37C  AE030000   SW V1, 0(S0)
678:                     date->year=y;
9D00B380  A6120000   SH S2, 0(S0)
679:                     date->wkday=day_of_week(date);
9D00B384  0F40377F   JAL day_of_week
9D00B388  02002021   ADDU A0, S0, ZERO
9D00B38C  8E030000   LW V1, 0(S0)
9D00B390  7C43DE44   INS V1, V0, 25, 3
9D00B394  AE030000   SW V1, 0(S0)
680:                 }
9D00B398  8FBF0024   LW RA, 36(SP)
9D00B39C  8FB30020   LW S3, 32(SP)
9D00B3A0  8FB2001C   LW S2, 28(SP)
9D00B3A4  8FB10018   LW S1, 24(SP)
9D00B3A8  8FB00014   LW S0, 20(SP)
9D00B3AC  03E00008   JR RA
9D00B3B0  27BD0028   ADDIU SP, SP, 40
681:                 
682:                 // affiche ou saisie de la date
683:                 // format saisie: [yy]yy/mm/dd
684:                 static char* cmd_date(int tok_count, const char **tok_list){
9D00B3B4  27BDFFD8   ADDIU SP, SP, -40
9D00B3B8  AFBF0024   SW RA, 36(SP)
9D00B3BC  AFB20020   SW S2, 32(SP)
9D00B3C0  AFB1001C   SW S1, 28(SP)
9D00B3C4  AFB00018   SW S0, 24(SP)
9D00B3C8  00808821   ADDU S1, A0, ZERO
9D00B3CC  00A09021   ADDU S2, A1, ZERO
685:                     char *fmt;
686:                     sdate_t date;
687:                     
688:                     fmt=calloc(sizeof(char),80);
9D00B3D0  24040001   ADDIU A0, ZERO, 1
9D00B3D4  0F407A79   JAL calloc
9D00B3D8  24050050   ADDIU A1, ZERO, 80
689:                     if (tok_count>1){
9D00B3DC  2A310002   SLTI S1, S1, 2
9D00B3E0  1620001A   BNE S1, ZERO, 0x9D00B44C
9D00B3E4  00408021   ADDU S0, V0, ZERO
690:                         parse_date((char*)tok_list[1],&date);
9D00B3E8  8E440004   LW A0, 4(S2)
9D00B3EC  0F402CBC   JAL parse_date
9D00B3F0  27A50010   ADDIU A1, SP, 16
691:                         rtcc_set_date(date);
9D00B3F4  0F403730   JAL rtcc_set_date
9D00B3F8  8FA40010   LW A0, 16(SP)
692:                         if (rtcc_error) sprintf(fmt,"rtcc_set_date() error.");
9D00B3FC  8F8280A8   LW V0, -32600(GP)
9D00B400  10400015   BEQ V0, ZERO, 0x9D00B458
9D00B404  02001021   ADDU V0, S0, ZERO
9D00B408  3C029D01   LUI V0, -25343
9D00B40C  8C471FD0   LW A3, 8144(V0)
9D00B410  24421FD0   ADDIU V0, V0, 8144
9D00B414  8C460004   LW A2, 4(V0)
9D00B418  8C450008   LW A1, 8(V0)
9D00B41C  8C44000C   LW A0, 12(V0)
9D00B420  8C430010   LW V1, 16(V0)
9D00B424  AE070000   SW A3, 0(S0)
9D00B428  AE060004   SW A2, 4(S0)
9D00B42C  AE050008   SW A1, 8(S0)
9D00B430  AE04000C   SW A0, 12(S0)
9D00B434  AE030010   SW V1, 16(S0)
9D00B438  94430014   LHU V1, 20(V0)
9D00B43C  A6030014   SH V1, 20(S0)
9D00B440  90420016   LBU V0, 22(V0)
9D00B444  0B402D15   J 0x9D00B454
9D00B448  A2020016   SB V0, 22(S0)
693:                     }else{
694:                         rtcc_get_date_str(fmt);
9D00B44C  0F40374A   JAL rtcc_get_date_str
9D00B450  00402021   ADDU A0, V0, ZERO
695:                     }
696:                     return fmt;
697:                 }
9D00B454  02001021   ADDU V0, S0, ZERO
9D00B458  8FBF0024   LW RA, 36(SP)
9D00B45C  8FB20020   LW S2, 32(SP)
9D00B460  8FB1001C   LW S1, 28(SP)
9D00B464  8FB00018   LW S0, 24(SP)
9D00B468  03E00008   JR RA
9D00B46C  27BD0028   ADDIU SP, SP, 40
698:                 
699:                 // affiche ou saisie de  l'heure
700:                 // format saisie:  hh:mm:ss
701:                 static char* cmd_time(int tok_count, const char **tok_list){
9D00B090  27BDFFD8   ADDIU SP, SP, -40
9D00B094  AFBF0024   SW RA, 36(SP)
9D00B098  AFB20020   SW S2, 32(SP)
9D00B09C  AFB1001C   SW S1, 28(SP)
9D00B0A0  AFB00018   SW S0, 24(SP)
9D00B0A4  00808821   ADDU S1, A0, ZERO
9D00B0A8  00A09021   ADDU S2, A1, ZERO
702:                     char *fmt;
703:                     stime_t t;
704:                     
705:                     fmt=calloc(sizeof(char),80);
9D00B0AC  24040001   ADDIU A0, ZERO, 1
9D00B0B0  0F407A79   JAL calloc
9D00B0B4  24050050   ADDIU A1, ZERO, 80
706:                     if (tok_count>1){
9D00B0B8  2A310002   SLTI S1, S1, 2
9D00B0BC  16200016   BNE S1, ZERO, 0x9D00B118
9D00B0C0  00408021   ADDU S0, V0, ZERO
707:                         parse_time((char*)tok_list[1],&t);
9D00B0C4  8E440004   LW A0, 4(S2)
9D00B0C8  0F402BFB   JAL parse_time
9D00B0CC  27A50010   ADDIU A1, SP, 16
708:                         rtcc_set_time(t);
9D00B0D0  0F4036FA   JAL rtcc_set_time
9D00B0D4  8FA40010   LW A0, 16(SP)
709:                         if (rtcc_error) sprintf(fmt,"error set_time");
9D00B0D8  8F8280A8   LW V0, -32600(GP)
9D00B0DC  10400011   BEQ V0, ZERO, 0x9D00B124
9D00B0E0  02001021   ADDU V0, S0, ZERO
9D00B0E4  3C029D01   LUI V0, -25343
9D00B0E8  8C451F8C   LW A1, 8076(V0)
9D00B0EC  24421F8C   ADDIU V0, V0, 8076
9D00B0F0  8C440004   LW A0, 4(V0)
9D00B0F4  8C430008   LW V1, 8(V0)
9D00B0F8  AE050000   SW A1, 0(S0)
9D00B0FC  AE040004   SW A0, 4(S0)
9D00B100  AE030008   SW V1, 8(S0)
9D00B104  9443000C   LHU V1, 12(V0)
9D00B108  A603000C   SH V1, 12(S0)
9D00B10C  9042000E   LBU V0, 14(V0)
9D00B110  0B402C48   J 0x9D00B120
9D00B114  A202000E   SB V0, 14(S0)
710:                     }else {
711:                         rtcc_get_time_str(fmt);
9D00B118  0F40376C   JAL rtcc_get_time_str
9D00B11C  00402021   ADDU A0, V0, ZERO
712:                     }
713:                     return fmt;
714:                 }
9D00B120  02001021   ADDU V0, S0, ZERO
9D00B124  8FBF0024   LW RA, 36(SP)
9D00B128  8FB20020   LW S2, 32(SP)
9D00B12C  8FB1001C   LW S1, 28(SP)
9D00B130  8FB00018   LW S0, 24(SP)
9D00B134  03E00008   JR RA
9D00B138  27BD0028   ADDIU SP, SP, 40
715:                 
716:                 static void report_alarms_state(){
717:                     char fmt[80];
718:                     int i,wkday;
719:                     
720:                     sdate_t date;
721:                     alm_state_t state[2];
722:                     rtcc_get_date(&date);
9D00B788  0F403710   JAL rtcc_get_date
9D00B78C  27A400F0   ADDIU A0, SP, 240
723:                     rtcc_get_alarms(state);
9D00B790  0F40380A   JAL rtcc_get_alarms
9D00B794  27A400A8   ADDIU A0, SP, 168
9D00B798  27B100AC   ADDIU S1, SP, 172
724:                     for (i=0;i<2;i++){
9D00B79C  00008021   ADDU S0, ZERO, ZERO
9D00B844  0B402E1A   J 0x9D00B868
9D00B848  26100001   ADDIU S0, S0, 1
9D00B864  26100001   ADDIU S0, S0, 1
9D00B868  24020002   ADDIU V0, ZERO, 2
9D00B86C  1602FFD1   BNE S0, V0, 0x9D00B7B4
9D00B870  26310024   ADDIU S1, S1, 36
725:                         if (state[i].enabled){
9D00B7B4  00101080   SLL V0, S0, 2
9D00B7B8  00101940   SLL V1, S0, 5
9D00B7BC  00431021   ADDU V0, V0, V1
9D00B7C0  03A21021   ADDU V0, SP, V0
9D00B7C4  8C4200A8   LW V0, 168(V0)
9D00B7C8  7C420740   EXT V0, V0, 29, 1
9D00B7CC  1040001F   BEQ V0, ZERO, 0x9D00B84C
9D00B7D0  27A40058   ADDIU A0, SP, 88
726:                             sprintf(fmt,"alarm %d set to %s %d/%02d/%02d %02d:%02d:%02d  %s\n",i,
9D00B7A8  3C13A000   LUI S3, -24576
9D00B7AC  267345B8   ADDIU S3, S3, 17848
9D00B7B0  3C129D01   LUI S2, -25343
9D00B7E8  2463FFFF   ADDIU V1, V1, -1
9D00B7EC  00031880   SLL V1, V1, 2
9D00B7F0  00731821   ADDU V1, V1, S3
9D00B7F4  8C670000   LW A3, 0(V1)
9D00B7F8  97A300F0   LHU V1, 240(SP)
9D00B7FC  AFA30010   SW V1, 16(SP)
9D00B800  7C431E40   EXT V1, V0, 25, 4
9D00B804  AFA30014   SW V1, 20(SP)
9D00B808  7C432500   EXT V1, V0, 20, 5
9D00B80C  AFA30018   SW V1, 24(SP)
9D00B810  7C432300   EXT V1, V0, 12, 5
9D00B814  AFA3001C   SW V1, 28(SP)
9D00B818  7C432980   EXT V1, V0, 6, 6
9D00B81C  AFA30020   SW V1, 32(SP)
9D00B820  3042003F   ANDI V0, V0, 63
9D00B824  AFA20024   SW V0, 36(SP)
9D00B828  AFB10028   SW S1, 40(SP)
9D00B82C  2645213C   ADDIU A1, S2, 8508
9D00B830  0F407973   JAL _sprintf_cdnopsuxX
9D00B834  02003021   ADDU A2, S0, ZERO
727:                                     weekdays[state[i].wkday-1],date.year,state[i].month,
9D00B7D4  00101080   SLL V0, S0, 2
9D00B7D8  00431021   ADDU V0, V0, V1
9D00B7DC  03A21021   ADDU V0, SP, V0
9D00B7E0  8C4200A8   LW V0, 168(V0)
9D00B7E4  7C431440   EXT V1, V0, 17, 3
728:                                     state[i].day,state[i].hour,state[i].min,state[i].sec,
729:                                     (char*)state[i].msg);
730:                             print(con,fmt);
9D00B838  97848062   LHU A0, -32670(GP)
9D00B83C  0F404FCC   JAL print
9D00B840  27A50058   ADDIU A1, SP, 88
731:                         }else{
732:                             sprintf(fmt,"alarm %d inactive\n",i);
9D00B7A0  3C149D01   LUI S4, -25343
9D00B7A4  26942170   ADDIU S4, S4, 8560
9D00B84C  02802821   ADDU A1, S4, ZERO
9D00B850  0F407973   JAL _sprintf_cdnopsuxX
9D00B854  02003021   ADDU A2, S0, ZERO
733:                             print(con,fmt);
9D00B858  97848062   LHU A0, -32670(GP)
9D00B85C  0F404FCC   JAL print
9D00B860  27A50058   ADDIU A1, SP, 88
734:                         }
735:                     }
736:                     
737:                 }
738:                 
739:                 static char* cmd_alarm(int tok_count, const char **tok_list){
9D00B6C0  27BDFEF0   ADDIU SP, SP, -272
9D00B6C4  AFBF010C   SW RA, 268(SP)
9D00B6C8  AFB40108   SW S4, 264(SP)
9D00B6CC  AFB30104   SW S3, 260(SP)
9D00B6D0  AFB20100   SW S2, 256(SP)
9D00B6D4  AFB100FC   SW S1, 252(SP)
9D00B6D8  AFB000F8   SW S0, 248(SP)
740:                     sdate_t date;
741:                     stime_t time;
742:                     char msg[32];
743:                     
744:                     switch (tok_count){
9D00B6DC  24020003   ADDIU V0, ZERO, 3
9D00B6E0  10820066   BEQ A0, V0, 0x9D00B87C
9D00B6E4  00A08021   ADDU S0, A1, ZERO
9D00B6E8  24020005   ADDIU V0, ZERO, 5
9D00B6EC  10820005   BEQ A0, V0, 0x9D00B704
9D00B6F0  24020002   ADDIU V0, ZERO, 2
9D00B6F4  5482006D   BNEL A0, V0, 0x9D00B8AC
9D00B6F8  97848062   LHU A0, -32670(GP)
745:                         case 5:
746:                             if (!strcmp(tok_list[1],"-s")){
9D00B704  8CA40004   LW A0, 4(A1)
9D00B708  3C059D01   LUI A1, -25343
9D00B70C  0F407138   JAL 0x9D01C4E0
9D00B710  24A52110   ADDIU A1, A1, 8464
9D00B714  54400017   BNEL V0, ZERO, 0x9D00B774
9D00B718  8E040004   LW A0, 4(S0)
747:                                 parse_date((char*)tok_list[2],&date);
9D00B71C  8E040008   LW A0, 8(S0)
9D00B720  0F402CBC   JAL parse_date
9D00B724  27A50030   ADDIU A1, SP, 48
748:                                 parse_time((char*)tok_list[3],&time);
9D00B728  8E04000C   LW A0, 12(S0)
9D00B72C  0F402BFB   JAL parse_time
9D00B730  27A50034   ADDIU A1, SP, 52
749:                                 strcpy(msg,tok_list[4]);
9D00B734  27A40038   ADDIU A0, SP, 56
9D00B738  0F406D40   JAL strcpy
9D00B73C  8E050010   LW A1, 16(S0)
750:                                 msg[31]=0;
9D00B740  A3A00057   SB ZERO, 87(SP)
751:                                 if (!rtcc_set_alarm(date,time,(uint8_t*)msg)){
9D00B744  8FA40030   LW A0, 48(SP)
9D00B748  8FA50034   LW A1, 52(SP)
9D00B74C  0F4037B9   JAL rtcc_set_alarm
9D00B750  27A60038   ADDIU A2, SP, 56
9D00B754  54400059   BNEL V0, ZERO, 0x9D00B8BC
9D00B758  00001021   ADDU V0, ZERO, ZERO
752:                                     print(con, "Failed to set alarm, none free.\n");
9D00B75C  97848062   LHU A0, -32670(GP)
9D00B760  3C059D01   LUI A1, -25343
9D00B764  0F404FCC   JAL print
9D00B768  24A52114   ADDIU A1, A1, 8468
753:                                 }
754:                                 break;
755:                             }
756:                         case 2:
757:                             if (!strcmp(tok_list[1],"-d")){
9D00B6FC  0B402DDD   J 0x9D00B774
9D00B700  8E040004   LW A0, 4(S0)
9D00B774  3C059D01   LUI A1, -25343
9D00B778  0F407138   JAL 0x9D01C4E0
9D00B77C  24A52138   ADDIU A1, A1, 8504
9D00B780  5440003F   BNEL V0, ZERO, 0x9D00B880
9D00B784  8E040004   LW A0, 4(S0)
758:                                 report_alarms_state();
759:                                 break;
760:                             }
761:                         case 3:
762:                             if (!strcmp(tok_list[1],"-c")){
9D00B87C  8E040004   LW A0, 4(S0)
9D00B880  3C059D01   LUI A1, -25343
9D00B884  0F407138   JAL 0x9D01C4E0
9D00B888  24A52184   ADDIU A1, A1, 8580
9D00B88C  14400007   BNE V0, ZERO, 0x9D00B8AC
9D00B890  97848062   LHU A0, -32670(GP)
763:                                 rtcc_cancel_alarm(atoi(tok_list[2]));
9D00B894  0F407787   JAL atoi
9D00B898  8E040008   LW A0, 8(S0)
9D00B89C  0F403853   JAL rtcc_cancel_alarm
9D00B8A0  304400FF   ANDI A0, V0, 255
764:                                 break;
9D00B8A4  0B402E2F   J 0x9D00B8BC
9D00B8A8  00001021   ADDU V0, ZERO, ZERO
765:                             }
766:                         default:
767:                             print(con,"USAGE: alarm []|[-c 0|1]|[-d ]|[-s date time \"message\"]\n");
9D00B8AC  3C059D01   LUI A1, -25343
9D00B8B0  0F404FCC   JAL print
9D00B8B4  24A52188   ADDIU A1, A1, 8584
768:                     }//switch
769:                     return NULL;
770:                 }
9D00B76C  0B402E2F   J 0x9D00B8BC
9D00B770  00001021   ADDU V0, ZERO, ZERO
9D00B874  0B402E2F   J 0x9D00B8BC
9D00B878  00001021   ADDU V0, ZERO, ZERO
9D00B8B8  00001021   ADDU V0, ZERO, ZERO
9D00B8BC  8FBF010C   LW RA, 268(SP)
9D00B8C0  8FB40108   LW S4, 264(SP)
9D00B8C4  8FB30104   LW S3, 260(SP)
9D00B8C8  8FB20100   LW S2, 256(SP)
9D00B8CC  8FB100FC   LW S1, 252(SP)
9D00B8D0  8FB000F8   LW S0, 248(SP)
9D00B8D4  03E00008   JR RA
9D00B8D8  27BD0110   ADDIU SP, SP, 272
771:                 
772:                 static char* cmd_echo(int tok_count, const char **tok_list){
9D00AE18  27BDFFE0   ADDIU SP, SP, -32
9D00AE1C  AFBF001C   SW RA, 28(SP)
9D00AE20  AFB20018   SW S2, 24(SP)
9D00AE24  AFB10014   SW S1, 20(SP)
9D00AE28  AFB00010   SW S0, 16(SP)
773:                     int j;
774:                     
775:                     for (j=1;j<tok_count;j++){
9D00AE2C  28820002   SLTI V0, A0, 2
9D00AE30  1440000C   BNE V0, ZERO, 0x9D00AE64
9D00AE34  00809021   ADDU S2, A0, ZERO
9D00AE38  24B10004   ADDIU S1, A1, 4
9D00AE3C  24100001   ADDIU S0, ZERO, 1
9D00AE58  26100001   ADDIU S0, S0, 1
9D00AE5C  1612FFF8   BNE S0, S2, 0x9D00AE40
9D00AE60  26310004   ADDIU S1, S1, 4
776:                         print(con,tok_list[j]);
9D00AE40  97848062   LHU A0, -32670(GP)
9D00AE44  0F404FCC   JAL print
9D00AE48  8E250000   LW A1, 0(S1)
777:                         spaces(con,1);
9D00AE4C  97848062   LHU A0, -32670(GP)
9D00AE50  0F404FDB   JAL spaces
9D00AE54  24050001   ADDIU A1, ZERO, 1
778:                     }
779:                     return NULL;
780:                 }
9D00AE64  00001021   ADDU V0, ZERO, ZERO
9D00AE68  8FBF001C   LW RA, 28(SP)
9D00AE6C  8FB20018   LW S2, 24(SP)
9D00AE70  8FB10014   LW S1, 20(SP)
9D00AE74  8FB00010   LW S0, 16(SP)
9D00AE78  03E00008   JR RA
9D00AE7C  27BD0020   ADDIU SP, SP, 32
781:                 
782:                 static char* cmd_reboot(int tok_count, const char **tok_list){
783:                     asm("lui $t0, 0xbfc0"); // _on_reset
9D00AD1C  3C08BFC0   LUI T0, -16448
784:                     asm("j  $t0\n nop");
9D00AD20  01000008   JR T0
9D00AD24  00000000   NOP
785:                 }
9D00AD28  03E00008   JR RA
9D00AD2C  00000000   NOP
786:                 
787:                 
788:                 static env_var_t *search_var(const char *name){
9D00AE80  27BDFFE0   ADDIU SP, SP, -32
9D00AE84  AFBF001C   SW RA, 28(SP)
9D00AE88  AFB10018   SW S1, 24(SP)
9D00AE8C  AFB00014   SW S0, 20(SP)
789:                     env_var_t *list;
790:                     list=shell_vars;
9D00AE90  8F908014   LW S0, -32748(GP)
791:                     while (list){
9D00AE94  12000009   BEQ S0, ZERO, 0x9D00AEBC
9D00AE98  00808821   ADDU S1, A0, ZERO
9D00AEB4  1600FFFA   BNE S0, ZERO, 0x9D00AEA0
9D00AEB8  02202021   ADDU A0, S1, ZERO
792:                         if (!strcmp(name,list->name)) break;
9D00AE9C  02202021   ADDU A0, S1, ZERO
9D00AEA0  0F407138   JAL 0x9D01C4E0
9D00AEA4  8E050004   LW A1, 4(S0)
9D00AEA8  10400005   BEQ V0, ZERO, 0x9D00AEC0
9D00AEAC  02001021   ADDU V0, S0, ZERO
793:                         list=list->link;
9D00AEB0  8E100000   LW S0, 0(S0)
794:                     }
795:                     return list;
796:                 }
9D00AEBC  02001021   ADDU V0, S0, ZERO
9D00AEC0  8FBF001C   LW RA, 28(SP)
9D00AEC4  8FB10018   LW S1, 24(SP)
9D00AEC8  8FB00014   LW S0, 20(SP)
9D00AECC  03E00008   JR RA
9D00AED0  27BD0020   ADDIU SP, SP, 32
797:                 
798:                 static void erase_var(env_var_t *var){
799:                     env_var_t *prev, *list;
800:                    
801:                     if (!(var && _is_ram_addr(var))) return;
9D00BA18  3C02BF88   LUI V0, -16504
9D00BA1C  8C432040   LW V1, 8256(V0)
9D00BA20  3C029FFF   LUI V0, -24577
9D00BA24  3442FFFF   ORI V0, V0, -1
9D00BA28  00621021   ADDU V0, V1, V0
9D00BA2C  0050102B   SLTU V0, V0, S0
9D00BA30  14400062   BNE V0, ZERO, 0x9D00BBBC
9D00BA34  8F838014   LW V1, -32748(GP)
802:                     prev=NULL;
803:                     list=shell_vars;
804:                     while (list && (list!=var)){
9D00BA38  5060000A   BEQL V1, ZERO, 0x9D00BA64
9D00BA3C  8E020000   LW V0, 0(S0)
9D00BA40  52030008   BEQL S0, V1, 0x9D00BA64
9D00BA44  8E020000   LW V0, 0(S0)
9D00BA4C  1040005D   BEQ V0, ZERO, 0x9D00BBC4
9D00BA50  00000000   NOP
9D00BA54  1202005F   BEQ S0, V0, 0x9D00BBD4
9D00BA58  00000000   NOP
805:                         prev=list;
806:                         list=list->link;
9D00BA48  8C620000   LW V0, 0(V1)
9D00BA5C  0B402E92   J 0x9D00BA48
9D00BA60  00401821   ADDU V1, V0, ZERO
807:                     }
808:                     if (!prev){
9D00BBC4  54600007   BNEL V1, ZERO, 0x9D00BBE4
9D00BBC8  00001021   ADDU V0, ZERO, ZERO
9D00BBD4  1460FFAC   BNE V1, ZERO, 0x9D00BA88
9D00BBD8  8E020000   LW V0, 0(S0)
809:                         shell_vars=var->link;
9D00BA64  AF828014   SW V0, -32748(GP)
9D00BBCC  0B402E99   J 0x9D00BA64
9D00BBD0  8E020000   LW V0, 0(S0)
9D00BBDC  0B402E9A   J 0x9D00BA68
9D00BBE0  AF828014   SW V0, -32748(GP)
810:                         free(var->name);
9D00BA68  0F407BCB   JAL free
9D00BA6C  8E040004   LW A0, 4(S0)
811:                         free(var->value);
9D00BA70  0F407BCB   JAL free
9D00BA74  8E040008   LW A0, 8(S0)
812:                         free(var);
9D00BA78  0F407BCB   JAL free
9D00BA7C  02002021   ADDU A0, S0, ZERO
813:                     }else if (list) {
814:                         prev->link=var->link;
9D00BA88  AC620000   SW V0, 0(V1)
815:                         free(var->name);
9D00BA8C  0F407BCB   JAL free
9D00BA90  8E040004   LW A0, 4(S0)
816:                         free(var->value);
9D00BA94  0F407BCB   JAL free
9D00BA98  8E040008   LW A0, 8(S0)
817:                         free(var);
9D00BA9C  0F407BCB   JAL free
9D00BAA0  02002021   ADDU A0, S0, ZERO
818:                     }
819:                 }
820:                 
821:                 static void list_vars(){
822:                     char *name, *value;
823:                     env_var_t *list;
824:                     list=shell_vars;
9D00BB78  8F908014   LW S0, -32748(GP)
825:                     while (list){
9D00BB7C  12000019   BEQ S0, ZERO, 0x9D00BBE4
9D00BBB4  5600FFF4   BNEL S0, ZERO, 0x9D00BB88
826:                         name=list->name;
9D00BB84  8E050004   LW A1, 4(S0)
827:                         if (name){
9D00BB88  50A0000A   BEQL A1, ZERO, 0x9D00BBB4
828:                             print(con,name);
9D00BB90  0F404FCC   JAL print
829:                             put_char(con,'=');
9D00BB98  97848062   LHU A0, -32670(GP)
830:                             println(con,list->value);
9D00BBA4  97848062   LHU A0, -32670(GP)
831:                         }
832:                         list=list->link;
9D00BBB0  8E100000   LW S0, 0(S0)
833:                     }
834:                 }
835:                 
836:                 static char* cmd_set(int tok_count, const char **tok_list){
9D00B984  27BDFFD8   ADDIU SP, SP, -40
9D00B988  AFBF0024   SW RA, 36(SP)
9D00B98C  AFB40020   SW S4, 32(SP)
9D00B990  AFB3001C   SW S3, 28(SP)
9D00B994  AFB20018   SW S2, 24(SP)
9D00B998  AFB10014   SW S1, 20(SP)
9D00B99C  AFB00010   SW S0, 16(SP)
837:                     env_var_t *var;
838:                     char *name, *value;
839:                     if (tok_count>=2){
9D00B9A0  28820002   SLTI V0, A0, 2
9D00B9A4  14400074   BNE V0, ZERO, cmd_set::list_vars
9D00B9A8  00808821   ADDU S1, A0, ZERO
9D00B9AC  00A09021   ADDU S2, A1, ZERO
840:                         var=search_var(tok_list[1]);
9D00B9B0  8CB30004   LW S3, 4(A1)
9D00B9B4  0F402BA0   JAL search_var
9D00B9B8  02602021   ADDU A0, S3, ZERO
841:                         if (var){
9D00B9BC  10400047   BEQ V0, ZERO, 0x9D00BADC
9D00B9C0  00408021   ADDU S0, V0, ZERO
842:                             if (!_is_ram_addr(var)){
9D00B9C4  3C02A000   LUI V0, -24576
9D00B9C8  0202102B   SLTU V0, S0, V0
9D00B9CC  5440000A   BNEL V0, ZERO, 0x9D00B9F8
9D00B9D0  2404000A   ADDIU A0, ZERO, 10
9D00B9D4  3C02BF88   LUI V0, -16504
9D00B9D8  8C432040   LW V1, 8256(V0)
9D00B9DC  3C029FFF   LUI V0, -24577
9D00B9E0  3442FFFF   ORI V0, V0, -1
9D00B9E4  00621021   ADDU V0, V1, V0
9D00B9E8  0050102B   SLTU V0, V0, S0
9D00B9EC  50400008   BEQL V0, ZERO, 0x9D00BA10
9D00B9F0  24020002   ADDIU V0, ZERO, 2
843:                                 print_error_msg(ERR_DENIED,"Read only variable.",0);
9D00B9F4  2404000A   ADDIU A0, ZERO, 10
9D00B9F8  3C059D01   LUI A1, -25343
9D00B9FC  24A521E8   ADDIU A1, A1, 8680
9D00BA00  0F402E37   JAL print_error_msg
9D00BA04  00003021   ADDU A2, ZERO, ZERO
9D00BA08  0B402EF9   J 0x9D00BBE4
9D00BA0C  00001021   ADDU V0, ZERO, ZERO
844:                             }else if (tok_count==2){
9D00BA10  56220026   BNEL S1, V0, 0x9D00BAAC
9D00BA14  8E520008   LW S2, 8(S2)
845:                                     erase_var(var);
846:                                 }else{
847:                                     value=malloc(strlen(tok_list[2])+1);
9D00BAAC  0F406EC2   JAL strlen
9D00BAB0  02402021   ADDU A0, S2, ZERO
9D00BAB4  0F4064A8   JAL malloc
9D00BAB8  24440001   ADDIU A0, V0, 1
9D00BABC  00408821   ADDU S1, V0, ZERO
848:                                     strcpy(value,tok_list[2]);
9D00BAC0  00402021   ADDU A0, V0, ZERO
9D00BAC4  0F406D40   JAL strcpy
9D00BAC8  02402821   ADDU A1, S2, ZERO
849:                                     free(var->value);
9D00BACC  0F407BCB   JAL free
9D00BAD0  8E040008   LW A0, 8(S0)
850:                                     var->value=value;
9D00BAD4  0B402EEF   J 0x9D00BBBC
9D00BAD8  AE110008   SW S1, 8(S0)
851:                                 }
852:                         }else if (tok_count==3){//nouvelle variable
9D00BADC  24020003   ADDIU V0, ZERO, 3
9D00BAE0  16220040   BNE S1, V0, 0x9D00BBE4
9D00BAE4  00001021   ADDU V0, ZERO, ZERO
853:                             var=malloc(sizeof(env_var_t));
9D00BAE8  0F4064A8   JAL malloc
9D00BAEC  2404000C   ADDIU A0, ZERO, 12
9D00BAF0  00408021   ADDU S0, V0, ZERO
854:                             name=malloc(strlen(tok_list[1])+1);
9D00BAF4  0F406EC2   JAL strlen
9D00BAF8  02602021   ADDU A0, S3, ZERO
9D00BAFC  0F4064A8   JAL malloc
9D00BB00  24440001   ADDIU A0, V0, 1
9D00BB04  0040A021   ADDU S4, V0, ZERO
855:                             value=malloc(strlen(tok_list[2])+1);
9D00BB08  0F406EC2   JAL strlen
9D00BB0C  8E440008   LW A0, 8(S2)
9D00BB10  0F4064A8   JAL malloc
9D00BB14  24440001   ADDIU A0, V0, 1
856:                             if (!(var && name && value)){
9D00BB18  12000005   BEQ S0, ZERO, 0x9D00BB30
9D00BB1C  00408821   ADDU S1, V0, ZERO
9D00BB20  12800004   BEQ S4, ZERO, 0x9D00BB34
9D00BB24  24040004   ADDIU A0, ZERO, 4
9D00BB28  14400008   BNE V0, ZERO, 0x9D00BB4C
9D00BB2C  02802021   ADDU A0, S4, ZERO
857:                                 print_error_msg(ERR_ALLOC,"insufficiant memory",0);
9D00BB30  24040004   ADDIU A0, ZERO, 4
9D00BB34  3C059D01   LUI A1, -25343
9D00BB38  24A521FC   ADDIU A1, A1, 8700
9D00BB3C  0F402E37   JAL print_error_msg
9D00BB40  00003021   ADDU A2, ZERO, ZERO
858:                                 return;
859:                             }
860:                             strcpy(name,tok_list[1]);
9D00BB4C  0F406D40   JAL strcpy
9D00BB50  02602821   ADDU A1, S3, ZERO
861:                             strcpy(value,tok_list[2]);
9D00BB54  02202021   ADDU A0, S1, ZERO
9D00BB58  0F406D40   JAL strcpy
9D00BB5C  8E450008   LW A1, 8(S2)
862:                             var->link=shell_vars;
9D00BB60  8F828014   LW V0, -32748(GP)
9D00BB64  AE020000   SW V0, 0(S0)
863:                             var->name=name;
9D00BB68  AE140004   SW S4, 4(S0)
864:                             var->value=value;
9D00BB6C  AE110008   SW S1, 8(S0)
865:                             shell_vars=var;
9D00BB70  0B402EEF   J 0x9D00BBBC
9D00BB74  AF908014   SW S0, -32748(GP)
866:                         }
867:                     }else{
868:                         list_vars();
869:                     }
870:                     return NULL;
9D00BA80  0B402EF9   J 0x9D00BBE4
9D00BA84  00001021   ADDU V0, ZERO, ZERO
9D00BAA4  0B402EF9   J 0x9D00BBE4
9D00BAA8  00001021   ADDU V0, ZERO, ZERO
9D00BBBC  0B402EF9   J 0x9D00BBE4
9D00BBC0  00001021   ADDU V0, ZERO, ZERO
871:                 }
9D00BB44  0B402EFA   J 0x9D00BBE8
9D00BB48  8FBF0024   LW RA, 36(SP)
9D00BBE4  8FBF0024   LW RA, 36(SP)
9D00BBE8  8FB40020   LW S4, 32(SP)
9D00BBEC  8FB3001C   LW S3, 28(SP)
9D00BBF0  8FB20018   LW S2, 24(SP)
9D00BBF4  8FB10014   LW S1, 20(SP)
9D00BBF8  8FB00010   LW S0, 16(SP)
9D00BBFC  03E00008   JR RA
9D00BC00  27BD0028   ADDIU SP, SP, 40
872:                 
873:                 static char *cmd_con(int tok_count, const char** tokens){
9D00B470  27BDFFE0   ADDIU SP, SP, -32
9D00B474  AFBF001C   SW RA, 28(SP)
9D00B478  AFB20018   SW S2, 24(SP)
9D00B47C  AFB10014   SW S1, 20(SP)
9D00B480  AFB00010   SW S0, 16(SP)
9D00B484  00808821   ADDU S1, A0, ZERO
9D00B488  00A09021   ADDU S2, A1, ZERO
874:                 #define DISPLAY_NAME (-2)
875:                     char *result;
876:                     int console_id=-1;
877:                     
878:                     result=malloc(80);
9D00B48C  0F4064A8   JAL malloc
9D00B490  24040050   ADDIU A0, ZERO, 80
9D00B494  00408021   ADDU S0, V0, ZERO
879:                     if (tok_count==2){
9D00B498  24020002   ADDIU V0, ZERO, 2
9D00B49C  1622004F   BNE S1, V0, 0x9D00B5DC
9D00B4A0  3C039D01   LUI V1, -25343
880:                         if (!strcmp("local",tokens[1])){
9D00B4A4  8E510004   LW S1, 4(S2)
9D00B4A8  3C049D01   LUI A0, -25343
9D00B4AC  24841FE8   ADDIU A0, A0, 8168
9D00B4B0  0F407138   JAL 0x9D01C4E0
9D00B4B4  02202821   ADDU A1, S1, ZERO
9D00B4B8  5040003A   BEQL V0, ZERO, 0x9D00B5A4
9D00B4BC  00008821   ADDU S1, ZERO, ZERO
881:                             console_id=VGA_CONSOLE;
882:                         }else if (!strcmp("serial",tokens[1])){
9D00B4C0  3C049D01   LUI A0, -25343
9D00B4C4  24841FF0   ADDIU A0, A0, 8176
9D00B4C8  0F407138   JAL 0x9D01C4E0
9D00B4CC  02202821   ADDU A1, S1, ZERO
9D00B4D0  14400017   BNE V0, ZERO, 0x9D00B530
9D00B4D4  3C049D01   LUI A0, -25343
883:                             if (vt_init()){
9D00B4D8  0F405C10   JAL vt_init
9D00B4DC  24110001   ADDIU S1, ZERO, 1
9D00B4E0  14400031   BNE V0, ZERO, 0x9D00B5A8
9D00B4E4  97828062   LHU V0, -32670(GP)
884:                                 console_id=SERIAL_CONSOLE;
885:                             }else{
886:                                 sprintf(result,"switching console failed, VT terminal not ready\n");
9D00B4E8  3C029D01   LUI V0, -25343
9D00B4EC  24421FF8   ADDIU V0, V0, 8184
9D00B4F0  02001821   ADDU V1, S0, ZERO
9D00B4F4  24440030   ADDIU A0, V0, 48
9D00B4F8  8C480000   LW T0, 0(V0)
9D00B4FC  8C470004   LW A3, 4(V0)
9D00B500  8C460008   LW A2, 8(V0)
9D00B504  8C45000C   LW A1, 12(V0)
9D00B508  AC680000   SW T0, 0(V1)
9D00B50C  AC670004   SW A3, 4(V1)
9D00B510  AC660008   SW A2, 8(V1)
9D00B514  AC65000C   SW A1, 12(V1)
9D00B518  24420010   ADDIU V0, V0, 16
9D00B51C  1444FFF6   BNE V0, A0, 0x9D00B4F8
9D00B520  24630010   ADDIU V1, V1, 16
9D00B524  90420000   LBU V0, 0(V0)
887:                                 return result;
9D00B528  0B402D8D   J 0x9D00B634
9D00B52C  A0620000   SB V0, 0(V1)
888:                             }
889:                         }else if (!strcmp("-n",tokens[1])){
9D00B530  2484202C   ADDIU A0, A0, 8236
9D00B534  0F407138   JAL 0x9D01C4E0
9D00B538  02202821   ADDU A1, S1, ZERO
9D00B53C  5040001E   BEQL V0, ZERO, 0x9D00B5B8
9D00B540  97838062   LHU V1, -32670(GP)
9D00B544  0B402D77   J 0x9D00B5DC
9D00B548  3C039D01   LUI V1, -25343
890:                             console_id=DISPLAY_NAME;
891:                         }
892:                     }
893:                     switch (console_id){
894:                         case VGA_CONSOLE:
895:                         case SERIAL_CONSOLE:
896:                             if (con!=console_id){
9D00B5A4  97828062   LHU V0, -32670(GP)
9D00B5A8  5451FFE8   BNEL V0, S1, 0x9D00B54C
9D00B5AC  00111080   SLL V0, S1, 2
9D00B5B0  0B402D8E   J 0x9D00B638
9D00B5B4  02001021   ADDU V0, S0, ZERO
897:                                 sprintf(result,"switched to %s console.",console_name[console_id]);
9D00B54C  3C129D01   LUI S2, -25343
9D00B550  265227E8   ADDIU S2, S2, 10216
9D00B554  00521021   ADDU V0, V0, S2
9D00B558  02002021   ADDU A0, S0, ZERO
9D00B55C  3C059D01   LUI A1, -25343
9D00B560  24A52030   ADDIU A1, A1, 8240
9D00B564  0F407973   JAL _sprintf_cdnopsuxX
9D00B568  8C460000   LW A2, 0(V0)
898:                                 println(con,result);
9D00B56C  97848062   LHU A0, -32670(GP)
9D00B570  0F405062   JAL println
9D00B574  02002821   ADDU A1, S0, ZERO
899:                                 con=console_id;
9D00B578  A7918062   SH S1, -32670(GP)
900:                                 sprintf(result,"new console %s",console_name[con]);
9D00B57C  3231FFFF   ANDI S1, S1, -1
9D00B580  00118880   SLL S1, S1, 2
9D00B584  02329021   ADDU S2, S1, S2
9D00B588  02002021   ADDU A0, S0, ZERO
9D00B58C  3C059D01   LUI A1, -25343
9D00B590  24A52048   ADDIU A1, A1, 8264
9D00B594  0F407973   JAL _sprintf_cdnopsuxX
9D00B598  8E460000   LW A2, 0(S2)
901:                             }
902:                             break;
903:                         case DISPLAY_NAME:
904:                             sprintf(result,"%s",console_name[con]);
9D00B5B8  00031880   SLL V1, V1, 2
9D00B5BC  3C029D01   LUI V0, -25343
9D00B5C0  244227E8   ADDIU V0, V0, 10216
9D00B5C4  00621021   ADDU V0, V1, V0
9D00B5C8  02002021   ADDU A0, S0, ZERO
9D00B5CC  0F406D40   JAL strcpy
9D00B5D0  8C450000   LW A1, 0(V0)
905:                             break;
9D00B5D4  0B402D8E   J 0x9D00B638
9D00B5D8  02001021   ADDU V0, S0, ZERO
906:                         default:
907:                             sprintf(result,"Select console\nUSAGE: con -n|local|serial.");
9D00B5DC  24632058   ADDIU V1, V1, 8280
9D00B5E0  02003021   ADDU A2, S0, ZERO
9D00B5E4  24620020   ADDIU V0, V1, 32
9D00B5E8  8C680000   LW T0, 0(V1)
9D00B5EC  8C670004   LW A3, 4(V1)
9D00B5F0  8C650008   LW A1, 8(V1)
9D00B5F4  8C64000C   LW A0, 12(V1)
9D00B5F8  ACC80000   SW T0, 0(A2)
9D00B5FC  ACC70004   SW A3, 4(A2)
9D00B600  ACC50008   SW A1, 8(A2)
9D00B604  ACC4000C   SW A0, 12(A2)
9D00B608  24630010   ADDIU V1, V1, 16
9D00B60C  1462FFF6   BNE V1, V0, 0x9D00B5E8
9D00B610  24C60010   ADDIU A2, A2, 16
9D00B614  8C640000   LW A0, 0(V1)
9D00B618  8C620004   LW V0, 4(V1)
9D00B61C  ACC40000   SW A0, 0(A2)
9D00B620  ACC20004   SW V0, 4(A2)
9D00B624  94620008   LHU V0, 8(V1)
9D00B628  A4C20008   SH V0, 8(A2)
9D00B62C  9062000A   LBU V0, 10(V1)
9D00B630  A0C2000A   SB V0, 10(A2)
908:                     }//switch
909:                     return result;
910:                 }
9D00B59C  0B402D8E   J 0x9D00B638
9D00B5A0  02001021   ADDU V0, S0, ZERO
9D00B634  02001021   ADDU V0, S0, ZERO
9D00B638  8FBF001C   LW RA, 28(SP)
9D00B63C  8FB20018   LW S2, 24(SP)
9D00B640  8FB10014   LW S1, 20(SP)
9D00B644  8FB00010   LW S0, 16(SP)
9D00B648  03E00008   JR RA
9D00B64C  27BD0020   ADDIU SP, SP, 32
911:                 
912:                 //charge compile et exécute
913:                 // un fichier basic
914:                 static char  *cmd_run(){
915:                 //    struct fat_file_struct *fh;
916:                 //    
917:                 //    parse_filter();
918:                 //    if (token.id==eNONE){
919:                 //        if (!program_loaded)
920:                 //            throw(eERR_MISSING_ARG);
921:                 //        else
922:                 //            run_it=true;
923:                 //        return;
924:                 //    }
925:                 //    if (strchr(token.str,'*')) throw(eERR_BAD_ARG);
926:                 //    if ((fh=fs_open_file(token.str))){
927:                 //        reader_init(&file_reader,eDEV_SDCARD,fh);
928:                 //        activ_reader=&file_reader;
929:                 //        cmd_clear();
930:                 //        compiler_msg(COMPILING,token.str);
931:                 //        line_count=1;
932:                 //        compile();
933:                 //        fs_close_file(fh);
934:                 //        activ_reader=&std_reader;
935:                 //        program_loaded=true;
936:                 //        program_end=dp;
937:                 //        run_it=true;
938:                 //        compiler_msg(COMP_END,NULL);
939:                 //    }else{
940:                 //        compiler_msg(COMP_FILE_ERROR,token.str);
941:                 //    }
942:                     return NULL;
943:                 }//f
9D00AD30  03E00008   JR RA
9D00AD34  00001021   ADDU V0, ZERO, ZERO
944:                 
945:                 
946:                 
947:                 static const shell_cmd_t commands[]={
948:                     {"alarm",cmd_alarm},
949:                     {"cd",cmd_cd},
950:                     {"clktrim",cmd_clktrim},
951:                     {"cls",cmd_cls},
952:                     {"con",cmd_con},
953:                     {"copy",cmd_copy},
954:                     {"date",cmd_date},
955:                     {"del",cmd_del},
956:                     {"dir",cmd_dir},
957:                     {"echo",cmd_echo},
958:                     {"edit",cmd_edit},
959:                     {"expr",cmd_expr},
960:                     {"free",cmd_free},
961:                     {"format",cmd_format},
962:                     {"basic",cmd_basic},
963:                     {"hdump",cmd_hdump},
964:                     {"help",cmd_help},
965:                     {"mkdir",cmd_mkdir},
966:                     {"mount",cmd_mount},
967:                     {"more",cmd_more},
968:                     {"puts",cmd_puts},
969:                     {"reboot",cmd_reboot},
970:                     {"receive",cmd_receive},
971:                     {"ren",cmd_ren},
972:                     {"send",cmd_send},
973:                     {"set",cmd_set},
974:                     {"time",cmd_time},
975:                     {"umount",cmd_umount},
976:                     {"uptime",cmd_uptime},
977:                     {"run",cmd_run}
978:                 };
979:                 
980:                 static int nbr_cmd=sizeof(commands)/sizeof(shell_cmd_t);
981:                 
982:                 
983:                 static char* execute_cmd(int tok_count, const char  **tok_list){
984:                     int cmd;
985:                         cmd=search_command(tok_list[0]);
9D00D124  8C530000   LW S3, 0(V0)
9D00D128  26522684   ADDIU S2, S2, 9860
986:                         if (cmd>=0){
9D00D15C  0600000A   BLTZ S0, 0x9D00D188
9D00D160  001080C0   SLL S0, S0, 3
987:                             return commands[cmd].fn(tok_count,tok_list);
9D00D164  3C029D01   LUI V0, -25343
9D00D168  2442259C   ADDIU V0, V0, 9628
9D00D16C  00501021   ADDU V0, V0, S0
9D00D170  8C420004   LW V0, 4(V0)
9D00D174  8FA4007C   LW A0, 124(SP)
9D00D178  0040F809   JALR V0
9D00D17C  02A02821   ADDU A1, S5, ZERO
9D00D180  0B403467   J 0x9D00D19C
9D00D184  00408021   ADDU S0, V0, ZERO
988:                         }else{
989:                             print_error_msg(ERR_NOT_CMD,tok_list[0],0);
9D00D154  0B403463   J 0x9D00D18C
9D00D158  24040001   ADDIU A0, ZERO, 1
9D00D188  24040001   ADDIU A0, ZERO, 1
9D00D18C  02602821   ADDU A1, S3, ZERO
9D00D190  0F402E37   JAL print_error_msg
9D00D194  00003021   ADDU A2, ZERO, ZERO
990:                             return NULL;
9D00D198  00008021   ADDU S0, ZERO, ZERO
991:                         }
992:                 }// execute_cmd()
993:                 
994:                 static const char *prompt="\n$";
995:                 
996:                 
997:                 static void free_tokens(int tok_count , char **tok_list){
9D00ADBC  27BDFFE0   ADDIU SP, SP, -32
9D00ADC0  AFBF001C   SW RA, 28(SP)
9D00ADC4  AFB20018   SW S2, 24(SP)
9D00ADC8  AFB10014   SW S1, 20(SP)
9D00ADCC  AFB00010   SW S0, 16(SP)
9D00ADD0  00808021   ADDU S0, A0, ZERO
998:                     while (tok_count>0){
9D00ADD4  18800008   BLEZ A0, 0x9D00ADF8
9D00ADD8  00A09021   ADDU S2, A1, ZERO
9D00ADDC  00048880   SLL S1, A0, 2
9D00ADE0  00B18821   ADDU S1, A1, S1
9D00ADF0  1600FFFC   BNE S0, ZERO, 0x9D00ADE4
9D00ADF4  2631FFFC   ADDIU S1, S1, -4
999:                         --tok_count;
9D00ADE4  2610FFFF   ADDIU S0, S0, -1
1000:                        free(tok_list[tok_count]);
9D00ADE8  0F407BCB   JAL free
9D00ADEC  8E24FFFC   LW A0, -4(S1)
1001:                    }
1002:                    free(tok_list);
9D00ADF8  0F407BCB   JAL free
9D00ADFC  02402021   ADDU A0, S2, ZERO
1003:                }//free_tokens()
9D00AE00  8FBF001C   LW RA, 28(SP)
9D00AE04  8FB20018   LW S2, 24(SP)
9D00AE08  8FB10014   LW S1, 20(SP)
9D00AE0C  8FB00010   LW S0, 16(SP)
9D00AE10  03E00008   JR RA
9D00AE14  27BD0020   ADDIU SP, SP, 32
1004:                
1005:                static char expect_char(parse_str_t *parse){
1006:                    if (parse->next>=parse->len){
9D00AD38  8C820008   LW V0, 8(A0)
9D00AD3C  8C830004   LW V1, 4(A0)
9D00AD40  0043282B   SLTU A1, V0, V1
9D00AD44  54A00004   BNEL A1, ZERO, 0x9D00AD58
9D00AD48  8C830000   LW V1, 0(A0)
1007:                        parse->err_pos=parse->len;
9D00AD4C  AC83000C   SW V1, 12(A0)
1008:                        return 0;
9D00AD50  03E00008   JR RA
9D00AD54  00001021   ADDU V0, ZERO, ZERO
1009:                    }else{
1010:                        return parse->script[parse->next++];
9D00AD58  24450001   ADDIU A1, V0, 1
9D00AD5C  AC850008   SW A1, 8(A0)
9D00AD60  00621021   ADDU V0, V1, V0
1011:                    }
1012:                }
9D00AD64  03E00008   JR RA
9D00AD68  80420000   LB V0, 0(V0)
1013:                
1014:                // skip() avance l'index parse->next jusqu'au premier caractère
1015:                // non compris dans l'ensemble skip.
1016:                static void skip(parse_str_t *parse, const char *skip){
1017:                    while (parse->next<parse->len && strchr(skip, parse->script[parse->next++]));
9D00CA4C  3C029D01   LUI V0, -25343
9D00CA50  244224A8   ADDIU V0, V0, 9384
9D00CA54  AFA20074   SW V0, 116(SP)
9D00CB54  8FB20060   LW S2, 96(SP)
9D00CB58  8FA20068   LW V0, 104(SP)
9D00CB5C  0050182B   SLTU V1, V0, S0
9D00CB60  10600008   BEQ V1, ZERO, 0x9D00CB84
9D00CB64  24430001   ADDIU V1, V0, 1
9D00CB68  AFA30068   SW V1, 104(SP)
9D00CB6C  02421021   ADDU V0, S2, V0
9D00CB70  8FA40074   LW A0, 116(SP)
9D00CB74  0F407C03   JAL strchr
9D00CB78  80450000   LB A1, 0(V0)
9D00CB7C  1440FFF7   BNE V0, ZERO, 0x9D00CB5C
9D00CB80  8FA20068   LW V0, 104(SP)
1018:                    parse->next--;
9D00CB84  8FA20068   LW V0, 104(SP)
9D00CB88  2442FFFF   ADDIU V0, V0, -1
9D00CB8C  AFA20068   SW V0, 104(SP)
1019:                }
1020:                
1021:                // scan() retourne la position du premier caractère faisant
1022:                // partie de l'ensemble target.
1023:                static int scan(parse_str_t *parse, const char *target){
1024:                    int pos;
1025:                    pos=parse->next;
1026:                    while (pos<parse->len && !strchr(target,parse->script[pos++]));
1027:                    return pos;
1028:                }
1029:                // parse_var() retourne la valeur d'une variable.
1030:                // le parser a rencontré le caractère '$' qui introduit
1031:                // le nom d'une variable.
1032:                // Les noms de variables commencent par une lette ou '_'
1033:                // suivie d'un nombre quelconque de lettres,chiffres et '_'
1034:                static char *parse_var(parse_str_t *parse){
1035:                    int first,len;
1036:                    char c, *var_name;
1037:                    env_var_t *var;
1038:                    
1039:                    if (parse->next>=parse->len){
9D00CC58  00C4182B   SLTU V1, A2, A0
9D00CC5C  14600003   BNE V1, ZERO, 0x9D00CC6C
9D00CC60  8FA70060   LW A3, 96(SP)
1040:                        parse->err_pos=parse->next;
9D00CC64  0B403477   J 0x9D00D1DC
9D00CC68  AFA6006C   SW A2, 108(SP)
1041:                        return NULL;
1042:                    }
1043:                    first=parse->next;
1044:                    c=parse->script[parse->next++];
9D00CC6C  24420002   ADDIU V0, V0, 2
9D00CC70  AFA20068   SW V0, 104(SP)
9D00CC74  00E61821   ADDU V1, A3, A2
9D00CC78  AFA30078   SW V1, 120(SP)
9D00CC7C  80630000   LB V1, 0(V1)
1045:                    if (!(isalpha(c)||(c=='_'))) {
9D00CBA4  3C029D02   LUI V0, -25342
9D00CBA8  0B40341D   J 0x9D00D074
9D00CBAC  2450CB59   ADDIU S0, V0, -13479
9D00CC80  00702821   ADDU A1, V1, S0
9D00CC84  90A50000   LBU A1, 0(A1)
9D00CC88  30A50003   ANDI A1, A1, 3
9D00CC8C  54A00005   BNEL A1, ZERO, 0x9D00CCA4
9D00CC90  0044182B   SLTU V1, V0, A0
9D00CC94  2405005F   ADDIU A1, ZERO, 95
9D00CC98  54650006   BNEL V1, A1, 0x9D00CCB4
9D00CC9C  AFA60068   SW A2, 104(SP)
1046:                        parse->err_pos=--parse->next;
9D00CCB4  0B403477   J 0x9D00D1DC
9D00CCB8  AFA6006C   SW A2, 108(SP)
9D00CCBC  00E21821   ADDU V1, A3, V0
1047:                        return NULL;
1048:                    }
1049:                    while ((parse->err_pos==-1) && (parse->next<parse->len) && 
9D00CCA0  0044182B   SLTU V1, V0, A0
9D00CCA4  14600005   BNE V1, ZERO, 0x9D00CCBC
9D00CCA8  2408005F   ADDIU T0, ZERO, 95
9D00CCCC  30A50007   ANDI A1, A1, 7
9D00CCD0  14A0013D   BNE A1, ZERO, 0x9D00D1C8
9D00CCD4  24420001   ADDIU V0, V0, 1
9D00D1C8  0044182B   SLTU V1, V0, A0
9D00D1CC  1460FEBB   BNE V1, ZERO, 0x9D00CCBC
9D00D1D0  AFA20068   SW V0, 104(SP)
1050:                            (isalnum((c=parse->script[parse->next]))|| (c=='_')))parse->next++;
9D00CCC0  80630000   LB V1, 0(V1)
9D00CCC4  00702821   ADDU A1, V1, S0
9D00CCC8  90A50000   LBU A1, 0(A1)
9D00CCD8  1068013C   BEQ V1, T0, 0x9D00D1CC
9D00CCDC  0044182B   SLTU V1, V0, A0
1051:                    len=parse->next-first;
9D00CCAC  0B403339   J 0x9D00CCE4
9D00CCB0  8FBE0068   LW S8, 104(SP)
9D00CCE0  8FBE0068   LW S8, 104(SP)
9D00CCE4  03C6F023   SUBU S8, S8, A2
9D00D1D4  0B403339   J 0x9D00CCE4
9D00D1D8  8FBE0068   LW S8, 104(SP)
1052:                    var_name=malloc(len+1);
9D00CCE8  0F4064A8   JAL malloc
9D00CCEC  27C40001   ADDIU A0, S8, 1
9D00CCF0  0040B821   ADDU S7, V0, ZERO
1053:                    memcpy(var_name,&parse->script[first],len);
9D00CCF4  00402021   ADDU A0, V0, ZERO
9D00CCF8  8FA50078   LW A1, 120(SP)
9D00CCFC  0F406E68   JAL memcpy
9D00CD00  03C03021   ADDU A2, S8, ZERO
1054:                    var_name[len]=0;
9D00CD04  02FEF021   ADDU S8, S7, S8
9D00CD08  A3C00000   SB ZERO, 0(S8)
1055:                    var=search_var(var_name);
9D00CD0C  0F402BA0   JAL search_var
9D00CD10  02E02021   ADDU A0, S7, ZERO
9D00CD14  0040F021   ADDU S8, V0, ZERO
1056:                    free(var_name);
9D00CD18  0F407BCB   JAL free
9D00CD1C  02E02021   ADDU A0, S7, ZERO
1057:                    if (var){
9D00CD20  13C0012F   BEQ S8, ZERO, 0x9D00D1E0
9D00CD24  02201821   ADDU V1, S1, ZERO
1058:                        return var->value;
9D00CD28  8FD70008   LW S7, 8(S8)
1059:                    }else{
1060:                        return NULL;
1061:                    }
1062:                }
1063:                
1064:                // extrait un mot délimité par des accolades
1065:                static void parse_brace(){
1066:                    int level=1;
1067:                    BOOL escape=FALSE;
1068:                    
1069:                    while (level){
1070:                        if (escape){
1071:                            
1072:                        }else{
1073:                            
1074:                        }
1075:                    }
1076:                }
1077:                
1078:                static const char bkslashed_char[]="abfnrtv";
1079:                static const char bkslashed_subst[]={0x7,0x8,0xc,0xa,0xd,0x9,0xb};
1080:                
1081:                static char parse_backslash(parse_str_t *parse){
1082:                    char n=0, c, *s;
1083:                    int i;
1084:                    c= expect_char(parse);
9D00CE04  0F402B4E   JAL expect_char
9D00CE08  27A40060   ADDIU A0, SP, 96
9D00CE0C  0040B821   ADDU S7, V0, ZERO
1085:                    switch (c){
9D00CE10  24020030   ADDIU V0, ZERO, 48
9D00CE14  12E20025   BEQ S7, V0, 0x9D00CEAC
9D00CE18  24020078   ADDIU V0, ZERO, 120
9D00CE1C  52E20005   BEQL S7, V0, 0x9D00CE34
9D00CE20  24170002   ADDIU S7, ZERO, 2
9D00CE24  16E00037   BNE S7, ZERO, 0x9D00CF04
9D00CE28  3C029D01   LUI V0, -25343
9D00CE34  00008821   ADDU S1, ZERO, ZERO
9D00CEAC  24170003   ADDIU S7, ZERO, 3
1086:                        case 0:
1087:                            return 0;
9D00CE2C  0B4033CD   J 0x9D00CF34
9D00CE30  00008821   ADDU S1, ZERO, ZERO
1088:                            break;
1089:                        case 'x':
1090:                            for (i=0;i<2;i++){
9D00CE80  16E0FFED   BNE S7, ZERO, 0x9D00CE38
9D00CE84  7C118C20   SEB S1, S1
9D00CE88  0B4033CD   J 0x9D00CF34
9D00CE8C  00000000   NOP
1091:                                c=expect_char(parse);
9D00CE38  0F402B4E   JAL expect_char
9D00CE3C  27A40060   ADDIU A0, SP, 96
1092:                                if (isxdigit(c)){
9D00CE40  005E1821   ADDU V1, V0, S8
9D00CE44  90630000   LBU V1, 0(V1)
9D00CE48  30630044   ANDI V1, V1, 68
9D00CE4C  10600010   BEQ V1, ZERO, 0x9D00CE90
9D00CE50  2443FFD0   ADDIU V1, V0, -48
1093:                                    n*=16;
9D00CE54  00118900   SLL S1, S1, 4
1094:                                    n+=(c-'0')>9?c-'0'+7:c-'0';
9D00CE58  2863000A   SLTI V1, V1, 10
9D00CE5C  14600004   BNE V1, ZERO, 0x9D00CE70
9D00CE60  323100FF   ANDI S1, S1, 255
9D00CE64  2442FFD7   ADDIU V0, V0, -41
9D00CE68  0B40339E   J 0x9D00CE78
9D00CE6C  304200FF   ANDI V0, V0, 255
9D00CE70  2442FFD0   ADDIU V0, V0, -48
9D00CE74  304200FF   ANDI V0, V0, 255
9D00CE78  00518821   ADDU S1, V0, S1
9D00CE7C  26F7FFFF   ADDIU S7, S7, -1
1095:                                }else{
1096:                                    if (c){
9D00CE90  10400028   BEQ V0, ZERO, 0x9D00CF34
9D00CE94  00008821   ADDU S1, ZERO, ZERO
1097:                                        parse->err_pos=--parse->next;
9D00CE98  8FA20068   LW V0, 104(SP)
9D00CE9C  2442FFFF   ADDIU V0, V0, -1
9D00CEA0  AFA20068   SW V0, 104(SP)
9D00CEA4  0B4033CD   J 0x9D00CF34
9D00CEA8  AFA2006C   SW V0, 108(SP)
1098:                                    }
1099:                                    return 0;
1100:                                }
1101:                            }
1102:                            return n;
1103:                        case '0':
1104:                            for (i=0;i<3;i++){
9D00CED8  16E0FFF5   BNE S7, ZERO, 0x9D00CEB0
9D00CEDC  00000000   NOP
9D00CEE0  0B4033CD   J 0x9D00CF34
9D00CEE4  00000000   NOP
1105:                                c=expect_char(parse);
9D00CEB0  0F402B4E   JAL expect_char
9D00CEB4  27A40060   ADDIU A0, SP, 96
1106:                                if (isdigit(c)&& (c<'8')){
9D00CDC8  3C059D02   LUI A1, -25342
9D00CDCC  0B4033DF   J 0x9D00CF7C
9D00CDD0  24BECB59   ADDIU S8, A1, -13479
9D00CEB8  005E1821   ADDU V1, V0, S8
9D00CEBC  90630000   LBU V1, 0(V1)
9D00CEC0  30630004   ANDI V1, V1, 4
9D00CEC4  306300FF   ANDI V1, V1, 255
9D00CEC8  10600007   BEQ V1, ZERO, 0x9D00CEE8
9D00CECC  28430038   SLTI V1, V0, 56
9D00CED0  10600005   BEQ V1, ZERO, 0x9D00CEE8
9D00CED4  26F7FFFF   ADDIU S7, S7, -1
1107:                                    n*=8;
1108:                                    n+=(c-'0');
1109:                                }else{
1110:                                    if (c){
9D00CEE8  10400012   BEQ V0, ZERO, 0x9D00CF34
9D00CEEC  00008821   ADDU S1, ZERO, ZERO
1111:                                        parse->err_pos=--parse->next;
9D00CEF0  8FA20068   LW V0, 104(SP)
9D00CEF4  2442FFFF   ADDIU V0, V0, -1
9D00CEF8  AFA20068   SW V0, 104(SP)
9D00CEFC  0B4033CD   J 0x9D00CF34
9D00CF00  AFA2006C   SW V0, 108(SP)
1112:                                    }
1113:                                    return 0;
1114:                                }
1115:                            }
1116:                            break;
1117:                        default:
1118:                            s=strchr(bkslashed_char,c);
9D00CF04  244424C4   ADDIU A0, V0, 9412
9D00CF08  0F407C03   JAL strchr
9D00CF0C  02E02821   ADDU A1, S7, ZERO
1119:                            if (s){
9D00CF10  10400007   BEQ V0, ZERO, 0x9D00CF30
9D00CF14  3C049D01   LUI A0, -25343
1120:                                return bkslashed_subst[s-bkslashed_char];
9D00CA58  3C029D01   LUI V0, -25343
9D00CA5C  244224BC   ADDIU V0, V0, 9404
9D00CA60  AFA2008C   SW V0, 140(SP)
9D00CF18  248324C4   ADDIU V1, A0, 9412
9D00CF1C  00431023   SUBU V0, V0, V1
9D00CF20  8FA5008C   LW A1, 140(SP)
9D00CF24  00451021   ADDU V0, V0, A1
9D00CF28  0B4033CD   J 0x9D00CF34
9D00CF2C  80510000   LB S1, 0(V0)
1121:                            }else{
1122:                                return c;
9D00CF30  02E08821   ADDU S1, S7, ZERO
1123:                            }
1124:                    }//switch
1125:                }
1126:                
1127:                static char *parse_quote(parse_str_t *parse){
1128:                    char c,*quote;
1129:                    int slen=0;
9D00CDC4  00009021   ADDU S2, ZERO, ZERO
9D00D1DC  02201821   ADDU V1, S1, ZERO
1130:                    BOOL loop=TRUE;
9D00CDC0  24100001   ADDIU S0, ZERO, 1
1131:                    
1132:                    quote=calloc(sizeof(char),80);
9D00CDB4  0F407A79   JAL calloc
9D00CDB8  24050050   ADDIU A1, ZERO, 80
9D00CDBC  0040A821   ADDU S5, V0, ZERO
1133:                    while (loop && (parse->err_pos==-1) && (parse->next<parse->len)){
9D00CF74  1200000B   BEQ S0, ZERO, 0x9D00CFA4
9D00CF78  00408021   ADDU S0, V0, ZERO
9D00CF7C  2402FFFF   ADDIU V0, ZERO, -1
9D00CF80  8FA3006C   LW V1, 108(SP)
9D00CF84  14620007   BNE V1, V0, 0x9D00CFA4
9D00CF88  8FA20068   LW V0, 104(SP)
9D00CF8C  8FA30064   LW V1, 100(SP)
9D00CF90  0043102B   SLTU V0, V0, V1
9D00CF94  1440FF8F   BNE V0, ZERO, 0x9D00CDD4
9D00CF98  02A02021   ADDU A0, S5, ZERO
9D00CF9C  0B4033F0   J 0x9D00CFC0
9D00CFA0  00000000   NOP
1134:                        c=expect_char(parse);
9D00CDD4  0F402B4E   JAL expect_char
9D00CDD8  27A40060   ADDIU A0, SP, 96
1135:                        switch(c){
9D00CDDC  24030022   ADDIU V1, ZERO, 34
9D00CDE0  10430070   BEQ V0, V1, 0x9D00CFA4
9D00CDE4  2403005C   ADDIU V1, ZERO, 92
9D00CDE8  10430006   BEQ V0, V1, 0x9D00CE04
9D00CDEC  00000000   NOP
9D00CDF0  1440005A   BNE V0, ZERO, 0x9D00CF5C
9D00CDF4  26430001   ADDIU V1, S2, 1
1136:                            case 0:
1137:                                parse->err_pos=parse->next;
9D00CDF8  8FA20068   LW V0, 104(SP)
9D00CDFC  0B4033E9   J 0x9D00CFA4
9D00CE00  AFA2006C   SW V0, 108(SP)
1138:                                loop=FALSE;
1139:                                break;
1140:                            case '\\':
1141:                                c=parse_backslash(parse);
1142:                                if (c){
9D00CF34  5220001C   BEQL S1, ZERO, 0x9D00CFA8
9D00CF38  8FA2006C   LW V0, 108(SP)
1143:                                    quote[slen++]=c;
9D00CF3C  26430001   ADDIU V1, S2, 1
9D00CF40  02B29021   ADDU S2, S5, S2
9D00CF44  A2510000   SB S1, 0(S2)
9D00CF54  0B4033DD   J 0x9D00CF74
9D00CF58  00609021   ADDU S2, V1, ZERO
1144:                                    quote[slen]=0;
9D00CF48  02A31021   ADDU V0, S5, V1
9D00CF4C  A0400000   SB ZERO, 0(V0)
9D00CF50  02001021   ADDU V0, S0, ZERO
1145:                                    break;
1146:                                }
1147:                            case '"':
1148:                                loop=FALSE;
1149:                                break;
1150:                            default:
1151:                                quote[slen++]=c;
9D00CF5C  02B29021   ADDU S2, S5, S2
9D00CF60  A2420000   SB V0, 0(S2)
9D00CF70  00609021   ADDU S2, V1, ZERO
1152:                                quote[slen]=0;
9D00CF64  02A31021   ADDU V0, S5, V1
9D00CF68  A0400000   SB ZERO, 0(V0)
9D00CF6C  02001021   ADDU V0, S0, ZERO
1153:                        }//switch
1154:                    }//while
1155:                    if (parse->err_pos>-1){
9D00CFA4  8FA2006C   LW V0, 108(SP)
9D00CFA8  04400005   BLTZ V0, 0x9D00CFC0
9D00CFAC  02A02021   ADDU A0, S5, ZERO
1156:                        free(quote);
9D00CFB0  0F407BCB   JAL free
9D00CFB4  02A02021   ADDU A0, S5, ZERO
9D00CFB8  0B4033F3   J 0x9D00CFCC
9D00CFBC  00000000   NOP
1157:                    }else{
1158:                        quote=realloc(quote,slen+1);
9D00CFC0  0F406F1C   JAL realloc
9D00CFC4  26450001   ADDIU A1, S2, 1
9D00CFC8  0040A821   ADDU S5, V0, ZERO
1159:                    }
1160:                    return quote;
1161:                }
1162:                
1163:                static char *next_token(parse_str_t *parse){
1164:                #define TOK_BUF_INCR (64)
1165:                #define _expand_token() if (buf_len<=(slen+strlen(xparsed))){\
1166:                                        buf_len=slen+strlen(xparsed)+TOK_BUF_INCR;\
1167:                                        token=(char*)realloc(token,buf_len);\
1168:                                    }
1169:                   
1170:                    unsigned char loop;
1171:                    char *token, *xparsed, c;
1172:                    int buf_len,slen;
1173:                    BOOL subst=TRUE;
1174:                    
1175:                    slen=0;
9D00CB90  00009821   ADDU S3, ZERO, ZERO
1176:                    buf_len=TOK_BUF_INCR;
9D00CB94  24050040   ADDIU A1, ZERO, 64
9D00CB98  AFA50070   SW A1, 112(SP)
1177:                    token=malloc(buf_len);
9D00CB44  0F4064A8   JAL malloc
9D00CB48  24040040   ADDIU A0, ZERO, 64
9D00CB4C  0040A021   ADDU S4, V0, ZERO
1178:                    token[0]=0;
9D00CB50  A0400000   SB ZERO, 0(V0)
1179:                    skip(parse," \t");
1180:                    loop=TRUE;
9D00CB9C  24120001   ADDIU S2, ZERO, 1
1181:                    while (loop && (parse->err_pos==-1) && (parse->next<parse->len)){
9D00CBA0  2415FFFF   ADDIU S5, ZERO, -1
9D00D064  1240000B   BEQ S2, ZERO, 0x9D00D094
9D00D068  02802021   ADDU A0, S4, ZERO
9D00D06C  00608821   ADDU S1, V1, ZERO
9D00D070  00409021   ADDU S2, V0, ZERO
9D00D074  8FA2006C   LW V0, 108(SP)
9D00D078  14550005   BNE V0, S5, 0x9D00D090
9D00D07C  8FA20068   LW V0, 104(SP)
9D00D080  8FA40064   LW A0, 100(SP)
9D00D084  0044182B   SLTU V1, V0, A0
9D00D088  1460FEC9   BNE V1, ZERO, 0x9D00CBB0
9D00D08C  24460001   ADDIU A2, V0, 1
1182:                        switch ((c=parse->script[parse->next++])){
9D00CAC4  3C039D01   LUI V1, -25343
9D00CAC8  0B4032C9   J 0x9D00CB24
9D00CACC  2476CBE8   ADDIU S6, V1, -13336
9D00CBB0  AFA60068   SW A2, 104(SP)
9D00CBB4  8FA30060   LW V1, 96(SP)
9D00CBB8  00621821   ADDU V1, V1, V0
9D00CBBC  80770000   LB S7, 0(V1)
9D00CBC0  26E3FFF7   ADDIU V1, S7, -9
9D00CBC4  306500FF   ANDI A1, V1, 255
9D00CBC8  2CA5001C   SLTIU A1, A1, 28
9D00CBCC  10A00114   BEQ A1, ZERO, 0x9D00D020
9D00CBD0  306300FF   ANDI V1, V1, 255
9D00CBD4  00031880   SLL V1, V1, 2
9D00CBD8  02C31821   ADDU V1, S6, V1
9D00CBDC  8C630000   LW V1, 0(V1)
9D00CBE0  00600008   JR V1
9D00CBE4  00000000   NOP
1183:                            case ' ':
1184:                            case 9: // TAB
1185:                                loop=FALSE;
1186:                                break;
1187:                //            case '{':
1188:                //                if (!escape){
1189:                //                    parse->next++;
1190:                //                    subst=FALSE;
1191:                //                    parse_brace();
1192:                //                }else{
1193:                //                    escape=FALSE;
1194:                //                }
1195:                //                break;
1196:                            case '$':
1197:                                if ((xparsed=parse_var(parse))){
9D00CD2C  12E000CD   BEQ S7, ZERO, 0x9D00D064
9D00CD30  02401021   ADDU V0, S2, ZERO
1198:                                    _expand_token();
9D00CD34  0F406EC2   JAL strlen
9D00CD38  02E02021   ADDU A0, S7, ZERO
9D00CD3C  00531021   ADDU V0, V0, S3
9D00CD40  8FA40070   LW A0, 112(SP)
9D00CD44  0044182B   SLTU V1, V0, A0
9D00CD48  14600007   BNE V1, ZERO, 0x9D00CD68
9D00CD4C  02802021   ADDU A0, S4, ZERO
9D00CD50  24420040   ADDIU V0, V0, 64
9D00CD54  AFA20070   SW V0, 112(SP)
9D00CD58  0F406F1C   JAL realloc
9D00CD5C  00402821   ADDU A1, V0, ZERO
9D00CD60  0040A021   ADDU S4, V0, ZERO
1199:                                    strcat(token,xparsed);
9D00CD64  02802021   ADDU A0, S4, ZERO
9D00CD68  0F407AC1   JAL strcat
9D00CD6C  02E02821   ADDU A1, S7, ZERO
1200:                                    xparsed=NULL;
1201:                                    slen=strlen(token);
9D00CD70  0F406EC2   JAL strlen
9D00CD74  02802021   ADDU A0, S4, ZERO
9D00CD78  00409821   ADDU S3, V0, ZERO
9D00CD7C  02201821   ADDU V1, S1, ZERO
9D00CD80  0B403419   J 0x9D00D064
9D00CD84  02401021   ADDU V0, S2, ZERO
1202:                                }
1203:                                break;
1204:                            case '#':
1205:                                loop=FALSE;
1206:                                parse->next=parse->len;
9D00CD88  0B403424   J 0x9D00D090
9D00CD8C  AFA40068   SW A0, 104(SP)
1207:                                break;
1208:                            case '"':
1209:                                if (slen){
9D00CD90  12600008   BEQ S3, ZERO, 0x9D00CDB4
9D00CD94  24040001   ADDIU A0, ZERO, 1
1210:                                    free(token);
9D00CD98  0F407BCB   JAL free
9D00CD9C  02802021   ADDU A0, S4, ZERO
1211:                                    parse->err_pos=--parse->next;
9D00CDA0  8FA20068   LW V0, 104(SP)
9D00CDA4  2442FFFF   ADDIU V0, V0, -1
9D00CDA8  AFA20068   SW V0, 104(SP)
9D00CDAC  0B403424   J 0x9D00D090
9D00CDB0  AFA2006C   SW V0, 108(SP)
1212:                                }else{
1213:                                   
1214:                                    if ((xparsed=parse_quote(parse))){
9D00CFCC  12A00031   BEQ S5, ZERO, 0x9D00D094
9D00CFD0  02802021   ADDU A0, S4, ZERO
1215:                                        _expand_token();
9D00CFD4  0F406EC2   JAL strlen
9D00CFD8  02A02021   ADDU A0, S5, ZERO
9D00CFDC  8FA40070   LW A0, 112(SP)
9D00CFE0  0044182B   SLTU V1, V0, A0
9D00CFE4  14600005   BNE V1, ZERO, 0x9D00CFFC
9D00CFE8  02802021   ADDU A0, S4, ZERO
9D00CFEC  0F406F1C   JAL realloc
9D00CFF0  24450040   ADDIU A1, V0, 64
9D00CFF4  0040A021   ADDU S4, V0, ZERO
1216:                                        strcat(token,xparsed);
9D00CFF8  02802021   ADDU A0, S4, ZERO
9D00CFFC  0F407AC1   JAL strcat
9D00D000  02A02821   ADDU A1, S5, ZERO
1217:                                        slen=strlen(token);
9D00D004  0F406EC2   JAL strlen
9D00D008  02802021   ADDU A0, S4, ZERO
9D00D00C  00409821   ADDU S3, V0, ZERO
1218:                                        free(xparsed);
9D00D010  0F407BCB   JAL free
9D00D014  02A02021   ADDU A0, S5, ZERO
1219:                                    }
1220:                                } 
1221:                                loop=FALSE;
1222:                                break;
1223:                            default:
1224:                                if (slen>=buf_len){
9D00D020  8FA50070   LW A1, 112(SP)
9D00D024  0265102A   SLT V0, S3, A1
9D00D028  54400007   BNEL V0, ZERO, 0x9D00D048
9D00D02C  26620001   ADDIU V0, S3, 1
1225:                                    buf_len+=TOK_BUF_INCR;
9D00D030  24A50040   ADDIU A1, A1, 64
9D00D034  AFA50070   SW A1, 112(SP)
1226:                                    token=(char*)realloc(token,buf_len);
9D00D038  0F406F1C   JAL realloc
9D00D03C  02802021   ADDU A0, S4, ZERO
9D00D040  0040A021   ADDU S4, V0, ZERO
1227:                                }
1228:                                token[slen++]=c;
9D00D044  26620001   ADDIU V0, S3, 1
9D00D048  02939821   ADDU S3, S4, S3
9D00D04C  A2770000   SB S7, 0(S3)
9D00D05C  00409821   ADDU S3, V0, ZERO
9D00D060  02401021   ADDU V0, S2, ZERO
1229:                                token[slen]=0;
9D00D050  02821821   ADDU V1, S4, V0
9D00D054  A0600000   SB ZERO, 0(V1)
9D00D058  02201821   ADDU V1, S1, ZERO
1230:                        }//switch
1231:                    } // while
1232:                    token=realloc(token,sizeof(char)*(slen+1));
9D00D018  0B403425   J 0x9D00D094
9D00D01C  02802021   ADDU A0, S4, ZERO
9D00D090  02802021   ADDU A0, S4, ZERO
9D00D094  0F406F1C   JAL realloc
9D00D098  26650001   ADDIU A1, S3, 1
1233:                    token[slen]=0;
9D00D09C  00539821   ADDU S3, V0, S3
1234:                    return token;
1235:                }//next_token()
1236:                
1237:                 // découpe la ligne d'entrée en mots
1238:                static char** tokenize(int *i,const char *script){
1239:                #define TOK_COUNT_INCR (5)
1240:                    
1241:                    int j, slen,array_size=TOK_COUNT_INCR;
9D00CAB8  24020005   ADDIU V0, ZERO, 5
9D00CABC  AFA20084   SW V0, 132(SP)
1242:                    char **tokens, *token;
1243:                    parse_str_t parse;
1244:                    
1245:                    parse.script=script;
9D00CA8C  27A40010   ADDIU A0, SP, 16
9D00CA90  AFA40060   SW A0, 96(SP)
1246:                    parse.next=0;
1247:                    parse.len=strlen(script);
9D00CA94  0F406EC2   JAL strlen
9D00CA98  AFA00068   SW ZERO, 104(SP)
9D00CA9C  AFA20064   SW V0, 100(SP)
1248:                    parse.err_pos=-1;
9D00CAA0  2402FFFF   ADDIU V0, ZERO, -1
9D00CAA4  AFA2006C   SW V0, 108(SP)
1249:                    j=0;
9D00CAC0  AFA0007C   SW ZERO, 124(SP)
1250:                    tokens=malloc(sizeof(char*)*array_size);
9D00CAA8  0F4064A8   JAL malloc
9D00CAAC  24040014   ADDIU A0, ZERO, 20
9D00CAB0  AFA20088   SW V0, 136(SP)
9D00CAB4  AFA00080   SW ZERO, 128(SP)
1251:                    while ((parse.next<parse.len) && (parse.err_pos==-1) && (token=next_token(&parse))){
9D00CB24  8FB00064   LW S0, 100(SP)
9D00CB28  8FA20068   LW V0, 104(SP)
9D00CB2C  0050102B   SLTU V0, V0, S0
9D00CB30  1040015D   BEQ V0, ZERO, 0x9D00D0A8
9D00CB34  2402FFFF   ADDIU V0, ZERO, -1
9D00CB38  8FA3006C   LW V1, 108(SP)
9D00CB3C  1462015B   BNE V1, V0, 0x9D00D0AC
9D00CB40  8FA2006C   LW V0, 108(SP)
9D00D0A0  1440FE8B   BNE V0, ZERO, 0x9D00CAD0
9D00D0A4  A2600000   SB ZERO, 0(S3)
1252:                        tokens[j++]=token;
9D00CAD0  8FA4007C   LW A0, 124(SP)
9D00CAD4  24840001   ADDIU A0, A0, 1
9D00CAD8  AFA4007C   SW A0, 124(SP)
9D00CADC  8FA50088   LW A1, 136(SP)
9D00CAE0  8FA40080   LW A0, 128(SP)
9D00CAE4  00A41821   ADDU V1, A1, A0
9D00CAE8  AC620000   SW V0, 0(V1)
1253:                        if (j>=array_size){
9D00CAEC  8FA5007C   LW A1, 124(SP)
9D00CAF0  8FA30084   LW V1, 132(SP)
9D00CAF4  00A3102A   SLT V0, A1, V1
9D00CAF8  14400008   BNE V0, ZERO, 0x9D00CB1C
9D00CAFC  8FA40080   LW A0, 128(SP)
1254:                            array_size+=TOK_COUNT_INCR;
9D00CB00  24630005   ADDIU V1, V1, 5
9D00CB04  AFA30084   SW V1, 132(SP)
1255:                            tokens=(char **)realloc(tokens,sizeof(char*)*array_size);
9D00CB08  8FA40088   LW A0, 136(SP)
9D00CB0C  0F406F1C   JAL realloc
9D00CB10  00032880   SLL A1, V1, 2
9D00CB14  AFA20088   SW V0, 136(SP)
9D00CB18  8FA40080   LW A0, 128(SP)
9D00CB1C  24840004   ADDIU A0, A0, 4
9D00CB20  AFA40080   SW A0, 128(SP)
1256:                        }
1257:                    }//while
1258:                    if (parse.err_pos>-1){
9D00D0A8  8FA2006C   LW V0, 108(SP)
9D00D0AC  04400015   BLTZ V0, 0x9D00D104
9D00D0B0  8FA40088   LW A0, 136(SP)
1259:                        println(con,"syntax error.");
9D00D0B4  97848062   LHU A0, -32670(GP)
9D00D0B8  3C059D01   LUI A1, -25343
9D00D0BC  0F405062   JAL println
9D00D0C0  24A524AC   ADDIU A1, A1, 9388
1260:                        println(con,script);
9D00D0C4  97848062   LHU A0, -32670(GP)
9D00D0C8  0F405062   JAL println
9D00D0CC  27A50010   ADDIU A1, SP, 16
1261:                        if (parse.err_pos){
9D00D0D0  8FA5006C   LW A1, 108(SP)
9D00D0D4  10A00004   BEQ A1, ZERO, 0x9D00D0E8
9D00D0D8  97848062   LHU A0, -32670(GP)
1262:                            spaces(con,parse.err_pos);
9D00D0DC  0F404FDB   JAL spaces
9D00D0E0  30A500FF   ANDI A1, A1, 255
1263:                        }
1264:                        put_char(con,'^');
9D00D0E4  97848062   LHU A0, -32670(GP)
9D00D0E8  0F404FC0   JAL put_char
9D00D0EC  2405005E   ADDIU A1, ZERO, 94
1265:                        free_tokens(j,tokens);
9D00D0F0  8FA4007C   LW A0, 124(SP)
9D00D0F4  0F402B6F   JAL free_tokens
9D00D0F8  8FA50088   LW A1, 136(SP)
1266:                        j=0;
1267:                        return NULL;
1268:                    }
1269:                    tokens=(char**)realloc(tokens,sizeof(char*)*j);
9D00D104  8FA2007C   LW V0, 124(SP)
9D00D108  0F406F1C   JAL realloc
9D00D10C  00022880   SLL A1, V0, 2
1270:                    *i=j;
1271:                    return tokens;
1272:                }//tokenize()
1273:                
1274:                static char* exec_script(const char *script){
1275:                    int tok_count;
1276:                    char *result, **tokens;
1277:                
1278:                    tokens=tokenize(&tok_count,script);
1279:                    if (tok_count && tokens) {
9D00D110  8FA3007C   LW V1, 124(SP)
9D00D114  1060FE53   BEQ V1, ZERO, 0x9D00CA64
9D00D118  0040A821   ADDU S5, V0, ZERO
9D00D11C  1040FE51   BEQ V0, ZERO, 0x9D00CA64
9D00D120  3C129D01   LUI S2, -25343
1280:                        result=execute_cmd(tok_count,(const char**)tokens);
1281:                        free_tokens(tok_count,tokens);
9D00D19C  8FA4007C   LW A0, 124(SP)
9D00D1A0  0F402B6F   JAL free_tokens
9D00D1A4  02A02821   ADDU A1, S5, ZERO
1282:                        return result;
1283:                    } // if
1284:                    return NULL;
1285:                }
1286:                
1287:                void shell(void){
9D00C9E8  27BDFF48   ADDIU SP, SP, -184
9D00C9EC  AFBF00B4   SW RA, 180(SP)
9D00C9F0  AFBE00B0   SW S8, 176(SP)
9D00C9F4  AFB700AC   SW S7, 172(SP)
9D00C9F8  AFB600A8   SW S6, 168(SP)
9D00C9FC  AFB500A4   SW S5, 164(SP)
9D00CA00  AFB400A0   SW S4, 160(SP)
9D00CA04  AFB3009C   SW S3, 156(SP)
9D00CA08  AFB20098   SW S2, 152(SP)
9D00CA0C  AFB10094   SW S1, 148(SP)
9D00CA10  AFB00090   SW S0, 144(SP)
1288:                    char *str, cmd_line[CHAR_PER_LINE];
1289:                    int len;
1290:                    str=malloc(32);
9D00CA14  0F4064A8   JAL malloc
9D00CA18  24040020   ADDIU A0, ZERO, 32
9D00CA1C  00408021   ADDU S0, V0, ZERO
1291:                    sprintf(str,"\nVPC-32 shell version %s \n",_version);
9D00CA20  00402021   ADDU A0, V0, ZERO
9D00CA24  3C059D01   LUI A1, -25343
9D00CA28  24A52488   ADDIU A1, A1, 9352
9D00CA2C  3C069D01   LUI A2, -25343
9D00CA30  0F407973   JAL _sprintf_cdnopsuxX
9D00CA34  24C627F0   ADDIU A2, A2, 10224
1292:                    print(con,str);
9D00CA38  97848062   LHU A0, -32670(GP)
9D00CA3C  0F404FCC   JAL print
9D00CA40  02002821   ADDU A1, S0, ZERO
1293:                    free(str);
9D00CA44  0F407BCB   JAL free
9D00CA48  02002021   ADDU A0, S0, ZERO
1294:                    while (1){
1295:                        print(con,prompt);
9D00CA64  97848062   LHU A0, -32670(GP)
9D00CA68  3C059D01   LUI A1, -25343
9D00CA6C  0F404FCC   JAL print
9D00CA70  24A524A4   ADDIU A1, A1, 9380
9D00D0FC  0B40329A   J 0x9D00CA68
9D00D100  97848062   LHU A0, -32670(GP)
9D00D1C0  0B40329A   J 0x9D00CA68
9D00D1C4  97848062   LHU A0, -32670(GP)
1296:                        len=read_line(con,cmd_line,CHAR_PER_LINE);
9D00CA74  97848062   LHU A0, -32670(GP)
9D00CA78  27A50010   ADDIU A1, SP, 16
9D00CA7C  0F404F93   JAL read_line
9D00CA80  24060050   ADDIU A2, ZERO, 80
1297:                        if (len){
9D00CA84  5040FFF8   BEQL V0, ZERO, 0x9D00CA68
9D00CA88  97848062   LHU A0, -32670(GP)
1298:                            str=exec_script((const char*)cmd_line);
1299:                            if (str){
9D00D1A8  1200FE2F   BEQ S0, ZERO, 0x9D00CA68
9D00D1AC  97848062   LHU A0, -32670(GP)
1300:                                print(con,str);
9D00D1B0  0F404FCC   JAL print
9D00D1B4  02002821   ADDU A1, S0, ZERO
1301:                                free(str);
9D00D1B8  0F407BCB   JAL free
9D00D1BC  02002021   ADDU A0, S0, ZERO
9D00D1C0  0B40329A   J 0x9D00CA68
9D00D1C4  97848062   LHU A0, -32670(GP)
9D00D1C8  0044182B   SLTU V1, V0, A0
9D00D1CC  1460FEBB   BNE V1, ZERO, 0x9D00CCBC
9D00D1D0  AFA20068   SW V0, 104(SP)
9D00D1D4  0B403339   J 0x9D00CCE4
9D00D1D8  8FBE0068   LW S8, 104(SP)
9D00D1DC  02201821   ADDU V1, S1, ZERO
9D00D1E0  0B403419   J 0x9D00D064
9D00D1E4  02401021   ADDU V0, S2, ZERO
1302:                            }//if
1303:                        }// if
1304:                    }//while(1)
1305:                    asm("lui $t0, 0xbfc0"); // _on_reset
1306:                    asm("j  $t0");
1307:                }//shell()
1308:                
---  /home/jacques/github/vpc-32vga/reader.c  -----------------------------------------------------------
1:                   /*
2:                    * Copyright 2015, 2016, Jacques Deschenes
3:                    * 
4:                    * This file is part of PV16SOG project.
5:                    * 
6:                    * ***  LICENCE ****
7:                    * This program is free software; you can redistribute it and/or modify
8:                    * it under the terms of the GNU General Public License as published by
9:                    * the Free Software Foundation; either version 3 of the License, or
10:                   * (at your option) any later version.
11:                   * 
12:                   * This program is distributed in the hope that it will be useful,
13:                   * but WITHOUT ANY WARRANTY; without even the implied warranty of
14:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
15:                   * GNU General Public License for more details.
16:                   * 
17:                   * You should have received a copy of the GNU General Public License
18:                   * along with this program; See 'copying.txt' in root directory of source.
19:                   * If not, write to the Free Software Foundation,
20:                   * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
21:                   *  
22:                   * to contact the author:  jd_temp@yahoo.fr
23:                   * 
24:                   */
25:                  
26:                  /*
27:                   * File: reader.c
28:                   * Description: lit une ligne à partir de la source spécifiée.
29:                   * Date: 2016-02-10 
30:                   */
31:                  
32:                  #include <stdlib.h>
33:                  //#include <stdint.h>
34:                  #include <stdbool.h>
35:                  #include <string.h>
36:                  #include <ctype.h>
37:                  
38:                  #include "hardware/HardwareProfile.h"
39:                  #include "hardware/spiram/spiram.h"
40:                  #include "hardware/Pinguino/fileio.h"
41:                  #include "hardware/Pinguino/ff.h"
42:                  #include "console.h"
43:                  #include "reader.h"
44:                  #include "font.h"
45:                  
46:                  
47:                  
48:                  
49:                  int complevel=0;
50:                  
51:                  static void display_prompt(){
52:                      int i;
53:                      crlf(con);
9D01A1A4  0F404FF3   JAL crlf
54:                      for(i=0;i<=complevel;i++) put_char(con,'>');
9D01A1AC  8F828064   LW V0, -32668(GP)
9D01A1B0  04400009   BLTZ V0, 0x9D01A1D8
9D01A1B4  00008821   ADDU S1, ZERO, ZERO
9D01A1B8  97848062   LHU A0, -32670(GP)
9D01A1BC  0F404FC0   JAL put_char
9D01A1C0  2405003E   ADDIU A1, ZERO, 62
9D01A1C4  26310001   ADDIU S1, S1, 1
9D01A1C8  8F828064   LW V0, -32668(GP)
9D01A1CC  0051102A   SLT V0, V0, S1
9D01A1D0  1040FFFA   BEQ V0, ZERO, 0x9D01A1BC
9D01A1D4  97848062   LHU A0, -32670(GP)
55:                  }//f
56:                  
57:                  //rempli le buffer
58:                  static bool read_sram(reader_t *reader){
9D01A0A0  27BDFFE8   ADDIU SP, SP, -24
9D01A0A4  AFBF0014   SW RA, 20(SP)
9D01A0A8  AFB00010   SW S0, 16(SP)
59:                      if (sram_pos(reader->handle)==sram_fsize(reader->handle)){
9D01A0AC  8C820110   LW V0, 272(A0)
9D01A0B0  8C430004   LW V1, 4(V0)
9D01A0B4  8C460008   LW A2, 8(V0)
9D01A0B8  14660005   BNE V1, A2, 0x9D01A0D0
9D01A0BC  00808021   ADDU S0, A0, ZERO
60:                          reader->eof=true;
9D01A0C0  24020001   ADDIU V0, ZERO, 1
9D01A0C4  AC82010C   SW V0, 268(A0)
61:                          return false;
9D01A0C8  0B406845   J 0x9D01A114
9D01A0CC  00001021   ADDU V0, ZERO, ZERO
62:                      }
63:                      reader->count=min(READER_BUFFER_SIZE,sram_left(reader->handle));
9D01A0D0  00C33023   SUBU A2, A2, V1
9D01A0D4  2CC40101   SLTIU A0, A2, 257
9D01A0D8  24030100   ADDIU V1, ZERO, 256
9D01A0DC  0064300A   MOVZ A2, V1, A0
9D01A0E0  AE060104   SW A2, 260(S0)
64:                      sram_read_block(sram_addr(reader->handle),(uint8_t*)reader->buffer,reader->count);
9D01A0E4  8C440004   LW A0, 4(V0)
9D01A0E8  8C420000   LW V0, 0(V0)
9D01A0EC  00822021   ADDU A0, A0, V0
9D01A0F0  0F404E81   JAL sram_read_block
9D01A0F4  26050004   ADDIU A1, S0, 4
65:                      reader->inp=0;
9D01A0F8  AE000108   SW ZERO, 264(S0)
66:                      sram_pos(reader->handle)+=reader->count;
9D01A0FC  8E020110   LW V0, 272(S0)
9D01A100  8C440004   LW A0, 4(V0)
9D01A104  8E030104   LW V1, 260(S0)
9D01A108  00831821   ADDU V1, A0, V1
9D01A10C  AC430004   SW V1, 4(V0)
67:                      return true;
9D01A110  24020001   ADDIU V0, ZERO, 1
68:                  }
9D01A114  8FBF0014   LW RA, 20(SP)
9D01A118  8FB00010   LW S0, 16(SP)
9D01A11C  03E00008   JR RA
9D01A120  27BD0018   ADDIU SP, SP, 24
69:                  
70:                  static bool fill_buffer(reader_t *reader){
71:                      FRESULT result;
72:                      switch (reader->device){
9D01A17C  8C820000   LW V0, 0(A0)
9D01A180  24030001   ADDIU V1, ZERO, 1
9D01A184  1043001F   BEQ V0, V1, 0x9D01A204
9D01A188  00000000   NOP
9D01A18C  10400005   BEQ V0, ZERO, display_prompt
9D01A190  24030002   ADDIU V1, ZERO, 2
9D01A194  5043001F   BEQL V0, V1, 0x9D01A214
9D01A198  8C840110   LW A0, 272(A0)
73:                          case eDEV_KBD:
74:                              display_prompt();
75:                              reader->count=read_line(con,reader->buffer,CHAR_PER_LINE);
9D01A1D8  97848062   LHU A0, -32670(GP)
9D01A1DC  26050004   ADDIU A1, S0, 4
9D01A1E0  0F404F93   JAL read_line
9D01A1E4  24060050   ADDIU A2, ZERO, 80
76:                              reader->buffer[reader->count++]='\r';
9D01A1E8  24430001   ADDIU V1, V0, 1
9D01A1EC  AE030104   SW V1, 260(S0)
9D01A1F0  02021021   ADDU V0, S0, V0
9D01A1F4  2403000D   ADDIU V1, ZERO, 13
9D01A1F8  A0430004   SB V1, 4(V0)
77:                              reader->inp=0;
9D01A1FC  0B406894   J 0x9D01A250
9D01A200  AE000108   SW ZERO, 264(S0)
78:                              return true;
79:                              break;
80:                          case eDEV_SPIRAM:
81:                              return read_sram(reader);
9D01A204  0F406828   JAL read_sram
9D01A208  00000000   NOP
9D01A20C  0B406892   J 0x9D01A248
9D01A210  00401821   ADDU V1, V0, ZERO
82:                              break;
83:                          case eDEV_SDCARD:
84:                              result=f_read(reader->handle,(uint8_t*)reader->buffer,READER_BUFFER_SIZE,&reader->count);
9D01A214  26050004   ADDIU A1, S0, 4
9D01A218  24060100   ADDIU A2, ZERO, 256
9D01A21C  0F401A00   JAL f_read
9D01A220  26070104   ADDIU A3, S0, 260
85:                              reader->inp=0;
9D01A224  AE000108   SW ZERO, 264(S0)
86:                              if (reader->count<=0){
9D01A228  8E020104   LW V0, 260(S0)
9D01A22C  5C400009   BGTZL V0, 0x9D01A254
9D01A230  8E020108   LW V0, 264(S0)
87:                                  reader->count=0;
9D01A234  AE000104   SW ZERO, 260(S0)
88:                                  reader->eof=true;
9D01A238  24020001   ADDIU V0, ZERO, 1
9D01A23C  AE02010C   SW V0, 268(S0)
89:                                  return false;
90:                              }
91:                              return true;
92:                              break;
93:                          case eDEV_FLASH:
94:                              break;
95:                      }
96:                      return false;
9D01A19C  0B406892   J 0x9D01A248
9D01A1A0  00001821   ADDU V1, ZERO, ZERO
97:                  }//f()
98:                  
99:                  void reader_init(reader_t *reader, reader_src_t device, void *handle){
100:                     reader->inp=0;
9D01A124  AC800108   SW ZERO, 264(A0)
101:                     reader->count=0;
9D01A128  AC800104   SW ZERO, 260(A0)
102:                     reader->eof=false;
9D01A12C  AC80010C   SW ZERO, 268(A0)
103:                     reader->device=device;
9D01A130  AC850000   SW A1, 0(A0)
104:                     reader->handle=handle;
9D01A134  03E00008   JR RA
9D01A138  AC860110   SW A2, 272(A0)
105:                 }//f()
106:                 
107:                 char reader_getc(reader_t *reader){
9D01A13C  27BDFFE0   ADDIU SP, SP, -32
9D01A140  AFBF001C   SW RA, 28(SP)
9D01A144  AFB10018   SW S1, 24(SP)
9D01A148  AFB00014   SW S0, 20(SP)
108:                     char c=-1;
9D01A240  0B40689B   J 0x9D01A26C
9D01A244  2402FFFF   ADDIU V0, ZERO, -1
109:                     if (reader->eof) return c;
9D01A14C  8C82010C   LW V0, 268(A0)
9D01A150  14400045   BNE V0, ZERO, 0x9D01A268
9D01A154  00808021   ADDU S0, A0, ZERO
9D01A268  2402FFFF   ADDIU V0, ZERO, -1
110:                     if (reader->inp < reader->count){
9D01A158  8C820108   LW V0, 264(A0)
9D01A15C  8C830104   LW V1, 260(A0)
9D01A160  0043182A   SLT V1, V0, V1
9D01A164  10600005   BEQ V1, ZERO, 0x9D01A17C
9D01A168  24430001   ADDIU V1, V0, 1
111:                         c=reader->buffer[reader->inp++];
9D01A16C  AC830108   SW V1, 264(A0)
9D01A170  00828021   ADDU S0, A0, V0
9D01A174  0B40689B   J 0x9D01A26C
9D01A178  82020004   LB V0, 4(S0)
112:                     }else if (fill_buffer(reader)){
9D01A248  10600008   BEQ V1, ZERO, 0x9D01A26C
9D01A24C  2402FFFF   ADDIU V0, ZERO, -1
113:                         c=reader->buffer[reader->inp++];
9D01A250  8E020108   LW V0, 264(S0)
9D01A254  24430001   ADDIU V1, V0, 1
9D01A258  AE030108   SW V1, 264(S0)
9D01A25C  02028021   ADDU S0, S0, V0
9D01A260  0B40689B   J 0x9D01A26C
9D01A264  82020004   LB V0, 4(S0)
114:                     }
115:                     return c;
116:                 }
9D01A26C  8FBF001C   LW RA, 28(SP)
9D01A270  8FB10018   LW S1, 24(SP)
9D01A274  8FB00014   LW S0, 20(SP)
9D01A278  03E00008   JR RA
9D01A27C  27BD0020   ADDIU SP, SP, 32
117:                 
118:                 inline void reader_ungetc(reader_t *reader){
119:                     reader->inp--;
9D01A280  8C820108   LW V0, 264(A0)
9D01A284  2442FFFF   ADDIU V0, V0, -1
9D01A288  03E00008   JR RA
9D01A28C  AC820108   SW V0, 264(A0)
120:                 }
121:                 
122:                 // positionne le pointeur de lecture dans le fichier
123:                 uint32_t reader_seek(reader_t *reader,uint32_t pos){
9D01A2A0  27BDFFE8   ADDIU SP, SP, -24
9D01A2A4  AFBF0014   SW RA, 20(SP)
124:                     switch(reader->device){
9D01A290  8C830000   LW V1, 0(A0)
9D01A294  24020001   ADDIU V0, ZERO, 1
9D01A298  14620008   BNE V1, V0, 0x9D01A2BC
9D01A29C  00000000   NOP
125:                         case eDEV_KBD:
126:                             return 0;
127:                         case eDEV_SPIRAM:
128:                             sram_pos(reader->handle)=pos;
9D01A2A8  8C820110   LW V0, 272(A0)
129:                             read_sram(reader);
9D01A2AC  0F406828   JAL read_sram
9D01A2B0  AC450004   SW A1, 4(V0)
130:                             break;
131:                         case eDEV_FLASH:
132:                             return 0;
133:                             break;
134:                         case eDEV_SDCARD:
135:                             return 0;
136:                             break;
137:                         default:
138:                             return 0;
139:                                     
140:                     }
141:                 }
9D01A2B4  0B4068B1   J 0x9D01A2C4
9D01A2B8  8FBF0014   LW RA, 20(SP)
9D01A2BC  03E00008   JR RA
9D01A2C0  00001021   ADDU V0, ZERO, ZERO
9D01A2C4  03E00008   JR RA
9D01A2C8  27BD0018   ADDIU SP, SP, 24
142:                 
143:                 // retourne la longueur de la chaîne ou -1 pour fin de fichier
144:                 // chaîne terminée par CR, LF, CRLF, \0
145:                 //int reader_gets(reader_t *reader, char *buffer, int len){
146:                 //    char c=-1;
147:                 //    int i=0;
148:                 //    
149:                 //    if (reader->eof) return -1;
150:                 //    while (!reader->eof && i<len && c){
151:                 //        c=reader_getc(reader);
152:                 //        switch(c){
153:                 //            case '\r':
154:                 //                c=reader_getc(reader);
155:                 //                if (c!='\n') reader_ungetc(reader);
156:                 //            case '\n':
157:                 //                c=0;
158:                 //                break;
159:                 //            default:
160:                 //                if (c<32) buffer[i++]=' '; else buffer[i++]=c;
161:                 //        }//switch
162:                 //    }//while
163:                 //    buffer[i]=0;
164:                 //    return i;
165:                 //}//f
166:                 
---  /home/jacques/github/vpc-32vga/hardware/tvout/vga.c  -----------------------------------------------
1:                   /*
2:                   * Copyright 2013,2017,2018 Jacques Deschênes
3:                   * This file is part of VPC-32vga.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32vga.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /* 
19:                   * File:   vga.c
20:                   * Author: Jacques Deschênes
21:                   * Description: VGA video signal generator and display fonctions.
22:                   * Created on 20 août 2013, 08:48
23:                   * rev: 2018-02-17
24:                   */
25:                  
26:                  #include <stdio.h>
27:                  #include <stdlib.h>
28:                  #include <string.h>
29:                  #include <sys/attribs.h>
30:                  #include <plib.h>
31:                  #include "../HardwareProfile.h"
32:                  #include "vga.h"
33:                  #include "../serial_comm/serial_comm.h"
34:                  
35:                  /*
36:                   * The generator use an output compare to generate a regular train of pulses
37:                   * for HSync signal. The vertical VSync signal in generated in software inside
38:                   * the TIMER2 interrupt. TIMER2 is used as the horizontal period timer and as
39:                   * the output compare reference clock for HSync output compare.
40:                   * The video pixel are serialized using an SPI channel and DMA channel. This
41:                   * way the total time used by the MCU to generate the video signal is a small
42:                   * fraction of total MCU time.
43:                   */
44:                  /* USING DMA channel 0 and SPI1
45:                   *  The SPI is configured in frame mode with is SS line connected to a second
46:                   *  Output compare that generate the frame signal.
47:                   *  The SPI interrupt trigger the DMA channel which send video data to SPI transmit
48:                   *  buffer.
49:                   */
50:                  
51:                  #define PWM_PERIOD (SYSCLK/31469)-1 // horizontal line duration.
52:                  #define HSYNC  (3813/PBCLK_PER)-1  // 3,813µSec  horizontal sync. pulse duration.
53:                  #define FIRST_LINE (34)   //First video output line
54:                  #define LAST_LINE (FIRST_LINE+2*VRES+1)  // Disable video output for this frame.
55:                  #define BITCLK ((int)(HRES * 1000000L/25)) // bit clock for SPI serializer.
56:                  #define SPI_DLY 95 // video outpout delay after end of HSync pulse.
57:                  #define _enable_video_out()  PPSOutput(3,RPB6,SDO1);SPI1CONbits.ON=1;
58:                  #define _disable_video_out() PPSOutput(3,RPB6,NULL);SPI1CONbits.ON=0;
59:                  
60:                  unsigned int video_bmp[VRES][HRES/32]; // video bitmap buffer
61:                  volatile static int *dma_source; // pointer for DMA source.
62:                  
63:                  // indicateurs booléens
64:                  #define CUR_SHOW 1  // curseur actif
65:                  #define CUR_VIS  2  // curseur visible
66:                  #define INV_VID  4  // inverse vidéo
67:                  
68:                  static unsigned short cx=0, cy=0;  // coordonnée courante du curseur texte en pixels.
69:                  static unsigned char tab_width=TAB_WIDTH;
70:                  static cursor_t cur_shape=CR_UNDER;
71:                  static volatile unsigned short flags=0;
72:                  
73:                  
74:                  #define BLINK_DELAY (40) // 40/60 secondes
75:                  
76:                  volatile static cursor_timer_t cursor_timer={FALSE,0,NULL};
77:                  
78:                  
79:                  
80:                  // configure video generator.
81:                  // use TIMER2 as horizontal period timer.
82:                  int vga_init(void){
9D00E440  27BDFFD8   ADDIU SP, SP, -40
9D00E444  AFBF0024   SW RA, 36(SP)
9D00E448  AFB10020   SW S1, 32(SP)
9D00E44C  AFB0001C   SW S0, 28(SP)
83:                      T2CON = 0;
9D00E450  3C02BF80   LUI V0, -16512
9D00E454  AC400800   SW ZERO, 2048(V0)
84:                      PR2=PWM_PERIOD;
9D00E458  240304F6   ADDIU V1, ZERO, 1270
9D00E45C  3C02BF80   LUI V0, -16512
9D00E460  AC430820   SW V1, 2080(V0)
85:                      OC2CONbits.OCM = 5; // pulse train mode (HSync)
9D00E464  3C02BF80   LUI V0, -16512
9D00E468  94433200   LHU V1, 12800(V0)
9D00E46C  24110005   ADDIU S1, ZERO, 5
9D00E470  7E231004   INS V1, S1, 0, 3
9D00E474  A4433200   SH V1, 12800(V0)
86:                      OC2RS = 0; 
9D00E478  3C03BF80   LUI V1, -16512
9D00E47C  AC603220   SW ZERO, 12832(V1)
87:                      OC2R = HSYNC;
9D00E480  24040097   ADDIU A0, ZERO, 151
9D00E484  3C03BF80   LUI V1, -16512
9D00E488  AC643210   SW A0, 12816(V1)
88:                      IFS0bits.T2IF=0;
9D00E48C  3C03BF88   LUI V1, -16504
9D00E490  8C641030   LW A0, 4144(V1)
9D00E494  7C044A44   INS A0, ZERO, 9, 1
9D00E498  AC641030   SW A0, 4144(V1)
89:                      IEC0bits.T2IE=1;
9D00E49C  3C03BF88   LUI V1, -16504
9D00E4A0  8C641060   LW A0, 4192(V1)
9D00E4A4  24100001   ADDIU S0, ZERO, 1
9D00E4A8  7E044A44   INS A0, S0, 9, 1
9D00E4AC  AC641060   SW A0, 4192(V1)
90:                      IPC2bits.T2IP=7;
9D00E4B0  3C03BF88   LUI V1, -16504
9D00E4B4  8C6410B0   LW A0, 4272(V1)
9D00E4B8  24050007   ADDIU A1, ZERO, 7
9D00E4BC  7CA42084   INS A0, A1, 2, 3
9D00E4C0  AC6410B0   SW A0, 4272(V1)
91:                      IPC2bits.T2IS=3;
9D00E4C4  8C6410B0   LW A0, 4272(V1)
9D00E4C8  24050003   ADDIU A1, ZERO, 3
9D00E4CC  7CA40804   INS A0, A1, 0, 2
9D00E4D0  AC6410B0   SW A0, 4272(V1)
92:                      OC2CONbits.ON =1;  // enable output compare
9D00E4D4  94433200   LHU V1, 12800(V0)
9D00E4D8  7E037BC4   INS V1, S0, 15, 1
9D00E4DC  A4433200   SH V1, 12800(V0)
93:                      T2CONbits.ON=1;  // enable TIMER2
9D00E4E0  3C02BF80   LUI V0, -16512
9D00E4E4  94430800   LHU V1, 2048(V0)
9D00E4E8  7E037BC4   INS V1, S0, 15, 1
9D00E4EC  A4430800   SH V1, 2048(V0)
94:                      // using OC4 as frame trigger for SPI1
95:                      OC4CONbits.OCM = 5; //pulse train mode.
9D00E4F0  3C02BF80   LUI V0, -16512
9D00E4F4  94433600   LHU V1, 13824(V0)
9D00E4F8  7E231004   INS V1, S1, 0, 3
9D00E4FC  A4433600   SH V1, 13824(V0)
96:                      OC4RS=0;
9D00E500  3C03BF80   LUI V1, -16512
9D00E504  AC603620   SW ZERO, 13856(V1)
97:                      OC4R=HSYNC+SPI_DLY;
9D00E508  240400F6   ADDIU A0, ZERO, 246
9D00E50C  3C03BF80   LUI V1, -16512
9D00E510  AC643610   SW A0, 13840(V1)
98:                      OC4CONbits.ON=1;
9D00E514  94433600   LHU V1, 13824(V0)
9D00E518  7E037BC4   INS V1, S0, 15, 1
9D00E51C  A4433600   SH V1, 13824(V0)
99:                      // configure  DMA channel 0.
100:                     // triggered by SPI1 TX interrupt.
101:                     DmaChnOpen(0,0,DMA_OPEN_DEFAULT);
9D00E520  00002021   ADDU A0, ZERO, ZERO
9D00E524  00002821   ADDU A1, ZERO, ZERO
9D00E528  0F407396   JAL DmaChnOpen
9D00E52C  00003021   ADDU A2, ZERO, ZERO
102:                     DmaChnSetEventControl(0,DMA_EV_START_IRQ_EN|
9D00E530  00002021   ADDU A0, ZERO, ZERO
9D00E534  0F407BA7   JAL DmaChnWriteEventControlFlags
9D00E538  24052610   ADDIU A1, ZERO, 9744
103:                                           DMA_EV_START_IRQ(_SPI1_TX_IRQ));
104:                     DmaChnSetTxfer(0,(void *)dma_source,(void *)&SPI1BUF,HRES/8,4,4);
9D00E53C  24020004   ADDIU V0, ZERO, 4
9D00E540  AFA20010   SW V0, 16(SP)
9D00E544  AFA20014   SW V0, 20(SP)
9D00E548  00002021   ADDU A0, ZERO, ZERO
9D00E54C  8F858054   LW A1, -32684(GP)
9D00E550  3C06BF80   LUI A2, -16512
9D00E554  24C65820   ADDIU A2, A2, 22560
9D00E558  0F4077D9   JAL DmaChnSetTxfer
9D00E55C  2407003C   ADDIU A3, ZERO, 60
105:                     // configuredu SPI1 
106:                     SPI1CONbits.DISSDI=1; // SDI not used
9D00E560  3C02BF80   LUI V0, -16512
9D00E564  8C435800   LW V1, 22528(V0)
9D00E568  7E032104   INS V1, S0, 4, 1
9D00E56C  AC435800   SW V1, 22528(V0)
107:                     SPI1CONbits.FRMEN=1; // frame mode
9D00E570  8C435800   LW V1, 22528(V0)
9D00E574  7E03FFC4   INS V1, S0, 31, 1
9D00E578  AC435800   SW V1, 22528(V0)
108:                     SPI1CONbits.FRMCNT=5; // 32 bytes per frame.
9D00E57C  8C435800   LW V1, 22528(V0)
9D00E580  7E23D604   INS V1, S1, 24, 3
9D00E584  AC435800   SW V1, 22528(V0)
109:                     SPI1CONbits.FRMPOL=1; // sync on rising edge
9D00E588  8C435800   LW V1, 22528(V0)
9D00E58C  7E03EF44   INS V1, S0, 29, 1
9D00E590  AC435800   SW V1, 22528(V0)
110:                     SPI1CONbits.FRMSYNC=1; // slave synchronization
9D00E594  8C435800   LW V1, 22528(V0)
9D00E598  7E03F784   INS V1, S0, 30, 1
9D00E59C  AC435800   SW V1, 22528(V0)
111:                     SPI1CONbits.MSTEN=1; // SPI as master
9D00E5A0  8C435800   LW V1, 22528(V0)
9D00E5A4  7E032944   INS V1, S0, 5, 1
9D00E5A8  AC435800   SW V1, 22528(V0)
112:                     SPI1CONbits.MODE32=1; // 32 bits mode
9D00E5AC  8C435800   LW V1, 22528(V0)
9D00E5B0  7E035AC4   INS V1, S0, 11, 1
9D00E5B4  AC435800   SW V1, 22528(V0)
113:                     SPI1CONbits.STXISEL=1; // interrupt on TBE
9D00E5B8  8C435800   LW V1, 22528(V0)
9D00E5BC  7E031884   INS V1, S0, 2, 2
9D00E5C0  AC435800   SW V1, 22528(V0)
114:                     SpiChnSetBitRate(SPI_CHANNEL1, PBCLK, BITCLK); // bit rate
9D00E5C4  24040001   ADDIU A0, ZERO, 1
9D00E5C8  3C050262   LUI A1, 610
9D00E5CC  24A55A00   ADDIU A1, A1, 23040
9D00E5D0  3C060124   LUI A2, 292
9D00E5D4  0F407B02   JAL SpiChnSetBitRate
9D00E5D8  34C6F800   ORI A2, A2, -2048
115:                     return 0;
116:                 }//init_video()
9D00E5DC  00001021   ADDU V0, ZERO, ZERO
9D00E5E0  8FBF0024   LW RA, 36(SP)
9D00E5E4  8FB10020   LW S1, 32(SP)
9D00E5E8  8FB0001C   LW S0, 28(SP)
9D00E5EC  03E00008   JR RA
9D00E5F0  27BD0028   ADDIU SP, SP, 40
117:                 
118:                 void vga_clear_screen(){
9D00E5F4  27BDFFE8   ADDIU SP, SP, -24
9D00E5F8  AFBF0014   SW RA, 20(SP)
119:                     if (flags&INV_VID){
9D00E5FC  97828048   LHU V0, -32696(GP)
9D00E600  30420004   ANDI V0, V0, 4
9D00E604  3042FFFF   ANDI V0, V0, -1
9D00E608  10400007   BEQ V0, ZERO, 0x9D00E628
9D00E60C  3C04A000   LUI A0, -24576
120:                         memset(video_bmp,255,HRES/8*VRES);
9D00E610  248400C0   ADDIU A0, A0, 192
9D00E614  240500FF   ADDIU A1, ZERO, 255
9D00E618  0F40775D   JAL memset
9D00E61C  24063840   ADDIU A2, ZERO, 14400
9D00E620  0B40398F   J 0x9D00E63C
9D00E624  A7808052   SH ZERO, -32686(GP)
121:                     }else{
122:                         memset(video_bmp,0,HRES/8*VRES);
9D00E628  248400C0   ADDIU A0, A0, 192
9D00E62C  00002821   ADDU A1, ZERO, ZERO
9D00E630  0F40775D   JAL memset
9D00E634  24063840   ADDIU A2, ZERO, 14400
123:                     }
124:                     cx=0;
9D00E638  A7808052   SH ZERO, -32686(GP)
125:                     cy=0;
9D00E63C  A7808050   SH ZERO, -32688(GP)
126:                 } // vga_clear_screen()
9D00E640  8FBF0014   LW RA, 20(SP)
9D00E644  03E00008   JR RA
9D00E648  27BD0018   ADDIU SP, SP, 24
127:                 
128:                 
129:                 //efface ligne, laisse le curseur au début.
130:                 void vga_clear_line(unsigned line){
9D00EF58  27BDFFE8   ADDIU SP, SP, -24
9D00EF5C  AFBF0014   SW RA, 20(SP)
9D00EF60  AFB00010   SW S0, 16(SP)
9D00EF64  00808021   ADDU S0, A0, ZERO
131:                     uint8_t* addr;
132:                     
133:                     addr=(uint8_t*)video_bmp;
134:                     addr+=line*CHAR_HEIGHT*BPL;
9D00EF68  00041140   SLL V0, A0, 5
9D00EF6C  00042240   SLL A0, A0, 9
9D00EF70  00821023   SUBU V0, A0, V0
9D00EF74  3C04A000   LUI A0, -24576
9D00EF78  248400C0   ADDIU A0, A0, 192
9D00EF7C  00822021   ADDU A0, A0, V0
135:                     if (flags&INV_VID){
9D00EF80  97828048   LHU V0, -32696(GP)
9D00EF84  30420004   ANDI V0, V0, 4
9D00EF88  3042FFFF   ANDI V0, V0, -1
9D00EF8C  10400006   BEQ V0, ZERO, 0x9D00EFA8
9D00EF90  00002821   ADDU A1, ZERO, ZERO
136:                         memset(addr,255,BPL*CHAR_HEIGHT);
9D00EF94  240500FF   ADDIU A1, ZERO, 255
9D00EF98  0F40775D   JAL memset
9D00EF9C  240601E0   ADDIU A2, ZERO, 480
9D00EFA0  0B403BED   J 0x9D00EFB4
9D00EFA4  00002021   ADDU A0, ZERO, ZERO
137:                     }else{
138:                         memset(addr,0,BPL*CHAR_HEIGHT);
9D00EFA8  0F40775D   JAL memset
9D00EFAC  240601E0   ADDIU A2, ZERO, 480
139:                     }
140:                     vga_set_curpos(0,line);
9D00EFB0  00002021   ADDU A0, ZERO, ZERO
9D00EFB4  0F403BB2   JAL vga_set_curpos
9D00EFB8  3205FFFF   ANDI A1, S0, -1
141:                 }
9D00EFBC  8FBF0014   LW RA, 20(SP)
9D00EFC0  8FB00010   LW S0, 16(SP)
9D00EFC4  03E00008   JR RA
9D00EFC8  27BD0018   ADDIU SP, SP, 24
142:                 
143:                 
144:                 void vga_scroll_up(){
9D00E64C  27BDFFE8   ADDIU SP, SP, -24
9D00E650  AFBF0014   SW RA, 20(SP)
145:                     char *src, *dst;
146:                     dst = (char*)video_bmp;
147:                     src = (char*)video_bmp +(CHAR_HEIGHT)*HRES/8;
148:                     memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*HRES/8);
9D00E654  3C04A000   LUI A0, -24576
9D00E658  248400C0   ADDIU A0, A0, 192
9D00E65C  3C05A000   LUI A1, -24576
9D00E660  24A502A0   ADDIU A1, A1, 672
9D00E664  0F4079A7   JAL memmove
9D00E668  24063660   ADDIU A2, ZERO, 13920
149:                     dst= (char*)video_bmp+(CHAR_HEIGHT*(LINE_PER_SCREEN-1))*HRES/8;
150:                     memset(dst,0,HRES/8*CHAR_HEIGHT);
9D00E66C  3C04A000   LUI A0, -24576
9D00E670  24843720   ADDIU A0, A0, 14112
9D00E674  00002821   ADDU A1, ZERO, ZERO
9D00E678  0F40775D   JAL memset
9D00E67C  240601E0   ADDIU A2, ZERO, 480
151:                 }//vga_scroll_up();
9D00E680  8FBF0014   LW RA, 20(SP)
9D00E684  03E00008   JR RA
9D00E688  27BD0018   ADDIU SP, SP, 24
152:                 
153:                 void vga_scroll_down(){
9D00E68C  27BDFFE8   ADDIU SP, SP, -24
9D00E690  AFBF0014   SW RA, 20(SP)
9D00E694  AFB00010   SW S0, 16(SP)
154:                     char *src, *dst;
155:                     src = (char*)video_bmp;
156:                     dst = (char*)video_bmp+(CHAR_HEIGHT)*HRES/8;
157:                     memmove(dst,src,(LINE_PER_SCREEN-1)*CHAR_HEIGHT*HRES/8);
9D00E698  3C04A000   LUI A0, -24576
9D00E69C  248402A0   ADDIU A0, A0, 672
9D00E6A0  3C10A000   LUI S0, -24576
9D00E6A4  260500C0   ADDIU A1, S0, 192
9D00E6A8  0F4079A7   JAL memmove
9D00E6AC  24063660   ADDIU A2, ZERO, 13920
158:                     dst=(char*)video_bmp;
159:                     memset(dst,0,HRES/8*CHAR_HEIGHT);
9D00E6B0  260400C0   ADDIU A0, S0, 192
9D00E6B4  00002821   ADDU A1, ZERO, ZERO
9D00E6B8  0F40775D   JAL memset
9D00E6BC  240601E0   ADDIU A2, ZERO, 480
160:                 }//vga_scroll_down()
9D00E6C0  8FBF0014   LW RA, 20(SP)
9D00E6C4  8FB00010   LW S0, 16(SP)
9D00E6C8  03E00008   JR RA
9D00E6CC  27BD0018   ADDIU SP, SP, 24
161:                 
162:                 
163:                 void vga_cursor_right(){
9D00E6D0  27BDFFE8   ADDIU SP, SP, -24
9D00E6D4  AFBF0014   SW RA, 20(SP)
164:                     cx += CHAR_WIDTH;
9D00E6D8  97828052   LHU V0, -32686(GP)
9D00E6DC  24420006   ADDIU V0, V0, 6
9D00E6E0  3042FFFF   ANDI V0, V0, -1
9D00E6F0  0B4039C7   J 0x9D00E71C
9D00E6F4  A7828052   SH V0, -32686(GP)
165:                     if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
9D00E6E4  2C4301E0   SLTIU V1, V0, 480
9D00E6E8  50600003   BEQL V1, ZERO, 0x9D00E6F8
9D00E6EC  A7808052   SH ZERO, -32686(GP)
166:                         cx = 0;
167:                         if (cy>=((LINE_PER_SCREEN-1)*CHAR_HEIGHT)){
9D00E6F8  97828050   LHU V0, -32688(GP)
9D00E6FC  2C4300E8   SLTIU V1, V0, 232
9D00E700  14600005   BNE V1, ZERO, 0x9D00E718
9D00E704  24420008   ADDIU V0, V0, 8
168:                             vga_scroll_up();
9D00E708  0F403993   JAL vga_scroll_up
9D00E70C  00000000   NOP
9D00E710  0B4039C8   J 0x9D00E720
9D00E714  8FBF0014   LW RA, 20(SP)
169:                         }else{
170:                             cy += CHAR_HEIGHT;
9D00E718  A7828050   SH V0, -32688(GP)
171:                         }
172:                     }
173:                 } // vga_cursor_right()
9D00E71C  8FBF0014   LW RA, 20(SP)
9D00E720  03E00008   JR RA
9D00E724  27BD0018   ADDIU SP, SP, 24
174:                 
175:                 void vga_cursor_left(){
9D00E728  27BDFFE8   ADDIU SP, SP, -24
9D00E72C  AFBF0014   SW RA, 20(SP)
176:                     if (cx>=(CHAR_WIDTH)){
9D00E730  97828052   LHU V0, -32686(GP)
9D00E734  2C430006   SLTIU V1, V0, 6
9D00E738  54600004   BNEL V1, ZERO, 0x9D00E74C
9D00E73C  2402004F   ADDIU V0, ZERO, 79
177:                         cx -= CHAR_WIDTH;
9D00E740  2442FFFA   ADDIU V0, V0, -6
9D00E744  0B4039DC   J 0x9D00E770
9D00E748  A7828052   SH V0, -32686(GP)
178:                     }else{
179:                         cx = (CHAR_PER_LINE-1);
9D00E74C  A7828052   SH V0, -32686(GP)
180:                         if (cy>=CHAR_HEIGHT){
9D00E750  97828050   LHU V0, -32688(GP)
9D00E754  2C430008   SLTIU V1, V0, 8
9D00E758  14600003   BNE V1, ZERO, 0x9D00E768
9D00E75C  2442FFF8   ADDIU V0, V0, -8
9D00E760  0B4039DC   J 0x9D00E770
9D00E764  A7828050   SH V0, -32688(GP)
181:                             cy -= CHAR_HEIGHT;
182:                         }else{
183:                             vga_scroll_down();
9D00E768  0F4039A3   JAL vga_scroll_down
9D00E76C  00000000   NOP
184:                         }
185:                     }
186:                 }// vga_cursor_left()
9D00E770  8FBF0014   LW RA, 20(SP)
9D00E774  03E00008   JR RA
9D00E778  27BD0018   ADDIU SP, SP, 24
187:                 
188:                 void vga_cursor_up(){
9D00E77C  27BDFFE8   ADDIU SP, SP, -24
9D00E780  AFBF0014   SW RA, 20(SP)
189:                     if (cy>=CHAR_HEIGHT){
9D00E784  97828050   LHU V0, -32688(GP)
9D00E788  2C430008   SLTIU V1, V0, 8
9D00E78C  14600003   BNE V1, ZERO, 0x9D00E79C
9D00E790  2442FFF8   ADDIU V0, V0, -8
9D00E794  0B4039E9   J 0x9D00E7A4
9D00E798  A7828050   SH V0, -32688(GP)
190:                         cy -= CHAR_HEIGHT;
191:                     }else{
192:                         vga_scroll_down();
9D00E79C  0F4039A3   JAL vga_scroll_down
9D00E7A0  00000000   NOP
193:                     }
194:                 }// vga_cursor_up()
9D00E7A4  8FBF0014   LW RA, 20(SP)
9D00E7A8  03E00008   JR RA
9D00E7AC  27BD0018   ADDIU SP, SP, 24
195:                 
196:                 void vga_cursor_down(){
9D00E7B0  27BDFFE8   ADDIU SP, SP, -24
9D00E7B4  AFBF0014   SW RA, 20(SP)
197:                     if (cy<=((CHAR_HEIGHT*(LINE_PER_SCREEN-2)))){
9D00E7B8  97828050   LHU V0, -32688(GP)
9D00E7BC  2C4300E1   SLTIU V1, V0, 225
9D00E7C0  10600003   BEQ V1, ZERO, 0x9D00E7D0
9D00E7C4  24420008   ADDIU V0, V0, 8
9D00E7C8  0B4039F6   J 0x9D00E7D8
9D00E7CC  A7828050   SH V0, -32688(GP)
198:                         cy += CHAR_HEIGHT;
199:                     }else{
200:                         vga_scroll_up();
9D00E7D0  0F403993   JAL vga_scroll_up
9D00E7D4  00000000   NOP
201:                     }
202:                 }//vga_cursor_down()
9D00E7D8  8FBF0014   LW RA, 20(SP)
9D00E7DC  03E00008   JR RA
9D00E7E0  27BD0018   ADDIU SP, SP, 24
203:                 
204:                 void vga_crlf(){
9D00E7E4  27BDFFE8   ADDIU SP, SP, -24
9D00E7E8  AFBF0014   SW RA, 20(SP)
205:                     cx=0;
9D00E7EC  A7808052   SH ZERO, -32686(GP)
206:                     if (cy==((LINE_PER_SCREEN-1)*CHAR_HEIGHT)){
9D00E7F0  97828050   LHU V0, -32688(GP)
9D00E7F4  240300E8   ADDIU V1, ZERO, 232
9D00E7F8  14430005   BNE V0, V1, 0x9D00E810
9D00E7FC  24420008   ADDIU V0, V0, 8
207:                         vga_scroll_up();
9D00E800  0F403993   JAL vga_scroll_up
9D00E804  00000000   NOP
9D00E808  0B403A06   J 0x9D00E818
9D00E80C  8FBF0014   LW RA, 20(SP)
208:                     }else{
209:                         cy += CHAR_HEIGHT;
9D00E810  A7828050   SH V0, -32688(GP)
210:                     }
211:                 }//vga_crlf()
9D00E814  8FBF0014   LW RA, 20(SP)
9D00E818  03E00008   JR RA
9D00E81C  27BD0018   ADDIU SP, SP, 24
212:                 
213:                 void vga_put_char(char c){
9D00E820  27BDFFE8   ADDIU SP, SP, -24
9D00E824  AFBF0014   SW RA, 20(SP)
214:                     register int i,l,r,b,x,y;
215:                     x=cx;
9D00E828  97858052   LHU A1, -32686(GP)
216:                     y=cy;
217:                     switch (c){
9D00E82C  2482FFF8   ADDIU V0, A0, -8
9D00E830  304300FF   ANDI V1, V0, 255
9D00E834  2C630006   SLTIU V1, V1, 6
9D00E838  10600038   BEQ V1, ZERO, 0x9D00E91C
9D00E83C  97878050   LHU A3, -32688(GP)
9D00E840  304200FF   ANDI V0, V0, 255
9D00E844  00021080   SLL V0, V0, 2
9D00E848  3C039D01   LUI V1, -25343
9D00E84C  2463E860   ADDIU V1, V1, -6048
9D00E850  00621021   ADDU V0, V1, V0
9D00E854  8C420000   LW V0, 0(V0)
9D00E858  00400008   JR V0
9D00E85C  00000000   NOP
218:                         case CR:
219:                         case NL:
220:                             vga_crlf();
9D00E878  0F4039F9   JAL vga_crlf
9D00E87C  00000000   NOP
221:                             break;
9D00E880  0B403AA0   J 0x9D00EA80
9D00E884  8FBF0014   LW RA, 20(SP)
222:                         case TAB:
223:                             i=cx%(CHAR_WIDTH*tab_width);
9D00E888  93828011   LBU V0, -32751(GP)
9D00E88C  00021840   SLL V1, V0, 1
9D00E890  000220C0   SLL A0, V0, 3
9D00E894  00831823   SUBU V1, A0, V1
9D00E898  00A3001A   DIV A1, V1
9D00E89C  006001F4   TEQ V1, ZERO
9D00E8A0  00001810   MFHI V1
224:                             cx += i?i:tab_width*CHAR_WIDTH;
9D00E8A4  14600005   BNE V1, ZERO, 0x9D00E8BC
9D00E8A8  3064FFFF   ANDI A0, V1, -1
9D00E8AC  00021040   SLL V0, V0, 1
9D00E8B0  00022080   SLL A0, V0, 2
9D00E8B4  00821023   SUBU V0, A0, V0
9D00E8B8  3044FFFF   ANDI A0, V0, -1
9D00E8BC  00852021   ADDU A0, A0, A1
9D00E8C0  3084FFFF   ANDI A0, A0, -1
9D00E8D0  0B403A9F   J 0x9D00EA7C
9D00E8D4  A7848052   SH A0, -32686(GP)
225:                             if (cx>=(CHAR_PER_LINE*CHAR_WIDTH)){
9D00E8C4  2C8201E0   SLTIU V0, A0, 480
9D00E8C8  10400003   BEQ V0, ZERO, 0x9D00E8D8
9D00E8CC  240200E8   ADDIU V0, ZERO, 232
226:                                 cx = 0;
227:                                 if (cy==((LINE_PER_SCREEN-1)*CHAR_HEIGHT)){
9D00E8D8  14E20005   BNE A3, V0, 0x9D00E8F0
9D00E8DC  A7808052   SH ZERO, -32686(GP)
228:                                     vga_scroll_up();
9D00E8E0  0F403993   JAL vga_scroll_up
9D00E8E4  00000000   NOP
9D00E8E8  0B403AA0   J 0x9D00EA80
9D00E8EC  8FBF0014   LW RA, 20(SP)
229:                                 }else{
230:                                     cy += CHAR_HEIGHT;
9D00E8F0  24E70008   ADDIU A3, A3, 8
9D00E8F4  0B403A9F   J 0x9D00EA7C
9D00E8F8  A7878050   SH A3, -32688(GP)
231:                                 }
232:                             }
233:                             break;
234:                         case FF:
235:                             vga_clear_screen();
9D00E8FC  0F40397D   JAL vga_clear_screen
9D00E900  00000000   NOP
236:                             break;
9D00E904  0B403AA0   J 0x9D00EA80
9D00E908  8FBF0014   LW RA, 20(SP)
237:                         case '\b':
238:                             vga_cursor_left();
9D00E90C  0F4039CA   JAL vga_cursor_left
9D00E910  00000000   NOP
239:                             break;
9D00E914  0B403AA0   J 0x9D00EA80
9D00E918  8FBF0014   LW RA, 20(SP)
240:                         default:
241:                             if ((c<32) || (c>(FONT_SIZE+32))) break;
9D00E91C  28820020   SLTI V0, A0, 32
9D00E920  14400056   BNE V0, ZERO, 0x9D00EA7C
9D00E924  2488FFE0   ADDIU T0, A0, -32
242:                             c -=32;
9D00E928  7C084420   SEB T0, T0
243:                             b=x>>5; // position index ligne video_bmp
9D00E92C  00051143   SRA V0, A1, 5
244:                             r=0;
245:                             l=(32-CHAR_WIDTH)-(x&0x1f); // décalage  à l'intérieur de l'entier
9D00E930  30A5001F   ANDI A1, A1, 31
9D00E934  2403001A   ADDIU V1, ZERO, 26
9D00E938  00652823   SUBU A1, V1, A1
246:                             if (l<0){
247:                                 r=-l;
9D00E93C  00051823   SUBU V1, ZERO, A1
9D00E940  28A60000   SLTI A2, A1, 0
9D00E944  0006180A   MOVZ V1, ZERO, A2
9D00E948  00603021   ADDU A2, V1, ZERO
248:                             }
249:                             for (i=0;i<8;i++){
9D00EA6C  1487FFCD   BNE A0, A3, 0x9D00E9A4
9D00EA70  24630001   ADDIU V1, V1, 1
250:                                 if (r){
9D00E9A4  10C0001E   BEQ A2, ZERO, 0x9D00EA20
9D00E9A8  00000000   NOP
251:                                     if (flags & INV_VID){
9D00E9AC  97888048   LHU T0, -32696(GP)
9D00E9B0  31080004   ANDI T0, T0, 4
9D00E9B4  3108FFFF   ANDI T0, T0, -1
9D00E9B8  1100000E   BEQ T0, ZERO, 0x9D00E9F4
9D00E9BC  90680000   LBU T0, 0(V1)
252:                                         video_bmp[y][b] |= (0x3f>>r);
9D00E94C  240A003F   ADDIU T2, ZERO, 63
9D00E950  006A6007   SRAV T4, T2, V1
9D00E9C8  8C4D0000   LW T5, 0(V0)
9D00E9CC  018D6825   OR T5, T4, T5
253:                                         video_bmp[y][b] &=~(font6x8[c][i]>>r);
9D00E9C0  00C8C807   SRAV T9, T0, A2
9D00E9C4  0019C827   NOR T9, ZERO, T9
9D00E9D0  032D6824   AND T5, T9, T5
9D00E9D4  AC4D0000   SW T5, 0(V0)
254:                                         video_bmp[y][b+1] |= (0x3f<<32-r);
9D00E954  24090020   ADDIU T1, ZERO, 32
9D00E958  01234823   SUBU T1, T1, V1
9D00E95C  012A5804   SLLV T3, T2, T1
9D00E9E0  8C4D0004   LW T5, 4(V0)
9D00E9E4  016D6825   OR T5, T3, T5
255:                                         video_bmp[y][b+1] &= ~(font6x8[c][i]<<(32-r));
9D00E9D8  01284004   SLLV T0, T0, T1
9D00E9DC  00084027   NOR T0, ZERO, T0
9D00E9E8  010D4024   AND T0, T0, T5
9D00E9EC  0B403A99   J 0x9D00EA64
9D00E9F0  AC480004   SW T0, 4(V0)
256:                                     }else{
257:                                         video_bmp[y][b] &= ~(0x3f>>r);
9D00E960  000C7827   NOR T7, ZERO, T4
9D00E9F8  8C4D0000   LW T5, 0(V0)
9D00E9FC  01ED6824   AND T5, T7, T5
258:                                         video_bmp[y][b] |= font6x8[c][i]>>r;
9D00E9F4  00C8C807   SRAV T9, T0, A2
9D00EA00  032D6825   OR T5, T9, T5
9D00EA04  AC4D0000   SW T5, 0(V0)
259:                                         video_bmp[y][b+1] &= ~(0x3f<<32-r);
9D00E964  000B7027   NOR T6, ZERO, T3
9D00EA0C  8C4D0004   LW T5, 4(V0)
9D00EA10  01CD6824   AND T5, T6, T5
260:                                         video_bmp[y][b+1] |= font6x8[c][i]<<(32-r);
9D00EA08  01284004   SLLV T0, T0, T1
9D00EA14  010D4025   OR T0, T0, T5
9D00EA18  0B403A99   J 0x9D00EA64
9D00EA1C  AC480004   SW T0, 4(V0)
261:                                     }
262:                                     y++;
263:                                 } else{
264:                                     if (flags & INV_VID){
9D00EA20  97888048   LHU T0, -32696(GP)
9D00EA24  31080004   ANDI T0, T0, 4
9D00EA28  3108FFFF   ANDI T0, T0, -1
9D00EA2C  11000008   BEQ T0, ZERO, 0x9D00EA50
9D00EA30  906D0000   LBU T5, 0(V1)
265:                                         video_bmp[y][b] |= (0x3f<<l);
9D00E968  00AA5004   SLLV T2, T2, A1
9D00EA3C  8C480000   LW T0, 0(V0)
9D00EA40  01484025   OR T0, T2, T0
266:                                         video_bmp[y++][b] &=~(font6x8[c][i]<<l);
9D00EA34  00AD6804   SLLV T5, T5, A1
9D00EA38  000D6827   NOR T5, ZERO, T5
9D00EA44  01A84024   AND T0, T5, T0
9D00EA48  0B403A99   J 0x9D00EA64
9D00EA4C  AC480000   SW T0, 0(V0)
267:                                     }else{
268:                                         video_bmp[y][b] &= ~(0x3f<<l);
9D00E96C  000AC027   NOR T8, ZERO, T2
9D00E970  24E40001   ADDIU A0, A3, 1
9D00E974  00071900   SLL V1, A3, 4
9D00E978  00671823   SUBU V1, V1, A3
9D00E97C  00621821   ADDU V1, V1, V0
9D00E980  00031880   SLL V1, V1, 2
9D00E984  3C02A000   LUI V0, -24576
9D00E988  244200C0   ADDIU V0, V0, 192
9D00E98C  00431021   ADDU V0, V0, V1
9D00E990  000840C0   SLL T0, T0, 3
9D00E994  3C039D02   LUI V1, -25342
9D00E998  246384C0   ADDIU V1, V1, -31552
9D00E99C  00681821   ADDU V1, V1, T0
9D00E9A0  24E70009   ADDIU A3, A3, 9
9D00EA54  8C480000   LW T0, 0(V0)
9D00EA58  03084024   AND T0, T8, T0
269:                                         video_bmp[y++][b] |= font6x8[c][i]<<l;
9D00EA50  00AD6804   SLLV T5, T5, A1
9D00EA5C  01A84025   OR T0, T5, T0
9D00EA60  AC480000   SW T0, 0(V0)
9D00EA64  24840001   ADDIU A0, A0, 1
9D00EA68  2442003C   ADDIU V0, V0, 60
270:                                     }
271:                                 }
272:                             }
273:                             vga_cursor_right();
9D00EA74  0F4039B4   JAL vga_cursor_right
9D00EA78  00000000   NOP
274:                     }//switch(c)
275:                 }//vga_put_char()
9D00EA7C  8FBF0014   LW RA, 20(SP)
9D00EA80  03E00008   JR RA
9D00EA84  27BD0018   ADDIU SP, SP, 24
276:                 
277:                 void vga_print(const char *text){
9D00EA88  27BDFFE8   ADDIU SP, SP, -24
9D00EA8C  AFBF0014   SW RA, 20(SP)
9D00EA90  AFB00010   SW S0, 16(SP)
9D00EA94  00808021   ADDU S0, A0, ZERO
278:                     while (*text){
9D00EA98  80840000   LB A0, 0(A0)
9D00EA9C  10800006   BEQ A0, ZERO, 0x9D00EAB8
9D00EAA0  8FBF0014   LW RA, 20(SP)
9D00EAAC  82040000   LB A0, 0(S0)
9D00EAB0  1480FFFC   BNE A0, ZERO, 0x9D00EAA4
9D00EAB4  8FBF0014   LW RA, 20(SP)
279:                         vga_put_char(*text++);
9D00EAA4  0F403A08   JAL vga_put_char
9D00EAA8  26100001   ADDIU S0, S0, 1
280:                     }
281:                 }// vga_print()
9D00EAB8  8FB00010   LW S0, 16(SP)
9D00EABC  03E00008   JR RA
9D00EAC0  27BD0018   ADDIU SP, SP, 24
282:                 
283:                 void vga_println( const char *str){
9D00EAC4  27BDFFE8   ADDIU SP, SP, -24
9D00EAC8  AFBF0014   SW RA, 20(SP)
284:                     vga_print(str);
9D00EACC  0F403AA2   JAL vga_print
9D00EAD0  00000000   NOP
285:                     vga_crlf();
9D00EAD4  0F4039F9   JAL vga_crlf
9D00EAD8  00000000   NOP
286:                 }// vga_println
9D00EADC  8FBF0014   LW RA, 20(SP)
9D00EAE0  03E00008   JR RA
9D00EAE4  27BD0018   ADDIU SP, SP, 24
287:                 
288:                 void vga_set_tab_width(unsigned char width){
289:                     tab_width=width;
9D00EAE8  03E00008   JR RA
9D00EAEC  A3848011   SB A0, -32751(GP)
290:                 }// vga_set_tab_width()
291:                 
292:                 int vga_get_tab_width(){
293:                     return tab_width;
294:                 }
9D00EAF0  03E00008   JR RA
9D00EAF4  93828011   LBU V0, -32751(GP)
295:                 
296:                 void vga_clear_eol(void){
9D00EAF8  27BDFFE0   ADDIU SP, SP, -32
9D00EAFC  AFBF001C   SW RA, 28(SP)
9D00EB00  AFB20018   SW S2, 24(SP)
9D00EB04  AFB10014   SW S1, 20(SP)
9D00EB08  AFB00010   SW S0, 16(SP)
297:                     int x,y;
298:                     
299:                     y=cy;
9D00EB0C  97928050   LHU S2, -32688(GP)
300:                     while (y<(cy+CHAR_HEIGHT)){
9D00EB10  26420008   ADDIU V0, S2, 8
9D00EB14  0242102A   SLT V0, S2, V0
9D00EB18  1040001C   BEQ V0, ZERO, 0x9D00EB8C
9D00EB1C  8FBF001C   LW RA, 28(SP)
9D00EB74  97828050   LHU V0, -32688(GP)
9D00EB78  24420008   ADDIU V0, V0, 8
9D00EB7C  0242102A   SLT V0, S2, V0
9D00EB80  1440FFE8   BNE V0, ZERO, 0x9D00EB24
9D00EB84  97908052   LHU S0, -32686(GP)
301:                         x=cx;
9D00EB20  97908052   LHU S0, -32686(GP)
302:                         while (x<HRES){
9D00EB24  2A0201E0   SLTI V0, S0, 480
9D00EB28  10400011   BEQ V0, ZERO, 0x9D00EB70
9D00EB2C  26100001   ADDIU S0, S0, 1
9D00EB30  2604FFFF   ADDIU A0, S0, -1
9D00EB64  2A3101E0   SLTI S1, S1, 480
9D00EB68  1620FFF2   BNE S1, ZERO, 0x9D00EB34
9D00EB6C  2604FFFF   ADDIU A0, S0, -1
303:                             if (flags & INV_VID)
9D00EB34  97828048   LHU V0, -32696(GP)
9D00EB38  30420004   ANDI V0, V0, 4
9D00EB3C  3042FFFF   ANDI V0, V0, -1
9D00EB40  10400005   BEQ V0, ZERO, 0x9D00EB58
9D00EB44  02008821   ADDU S1, S0, ZERO
304:                                 setPixel(x++,y);
9D00EB48  0F404580   JAL setPixel
9D00EB4C  02402821   ADDU A1, S2, ZERO
9D00EB50  0B403AD9   J 0x9D00EB64
9D00EB54  26100001   ADDIU S0, S0, 1
305:                             else
306:                                 clearPixel(x++,y);
9D00EB58  0F40459C   JAL clearPixel
9D00EB5C  02402821   ADDU A1, S2, ZERO
9D00EB60  26100001   ADDIU S0, S0, 1
307:                         }
308:                         y++;
9D00EB70  26520001   ADDIU S2, S2, 1
309:                     }
310:                 }// vga_clear_eol()
9D00EB88  8FBF001C   LW RA, 28(SP)
9D00EB8C  8FB20018   LW S2, 24(SP)
9D00EB90  8FB10014   LW S1, 20(SP)
9D00EB94  8FB00010   LW S0, 16(SP)
9D00EB98  03E00008   JR RA
9D00EB9C  27BD0020   ADDIU SP, SP, 32
311:                 
312:                 text_coord_t vga_get_curpos(){
9D00EBA0  00801021   ADDU V0, A0, ZERO
313:                     text_coord_t cpos;
314:                     cpos.x = cx/CHAR_WIDTH;
9D00EBAC  97858052   LHU A1, -32686(GP)
9D00EBB0  3C04AAAA   LUI A0, -21846
9D00EBB4  3484AAAB   ORI A0, A0, -21845
9D00EBB8  00A40019   MULTU 0, A1, A0
9D00EBBC  00002010   MFHI A0
9D00EBC0  00042082   SRL A0, A0, 2
315:                     cpos.y = cy/CHAR_HEIGHT;
9D00EBA4  97838050   LHU V1, -32688(GP)
9D00EBA8  000318C2   SRL V1, V1, 3
316:                     return cpos;
9D00EBC4  A4440000   SH A0, 0(V0)
317:                 } // vga_get_cursor_pos()
9D00EBC8  03E00008   JR RA
9D00EBCC  A4430002   SH V1, 2(V0)
318:                 
319:                 void vga_set_curpos(unsigned short x, unsigned short y){// {x,y} coordonnée caractère
9D00EEC8  27BDFFE0   ADDIU SP, SP, -32
9D00EECC  AFBF001C   SW RA, 28(SP)
9D00EED0  AFB10018   SW S1, 24(SP)
9D00EED4  AFB00014   SW S0, 20(SP)
320:                     BOOL active;
321:                     if (x>(CHAR_PER_LINE-1) || y>(LINE_PER_SCREEN-1)){
9D00EED8  2C820050   SLTIU V0, A0, 80
9D00EEDC  10400019   BEQ V0, ZERO, 0x9D00EF44
9D00EEE0  00808021   ADDU S0, A0, ZERO
9D00EEE4  2CA2001E   SLTIU V0, A1, 30
9D00EEE8  10400016   BEQ V0, ZERO, 0x9D00EF44
9D00EEEC  00A08821   ADDU S1, A1, ZERO
322:                         return;
323:                     }
324:                     if ((active=vga_is_cursor_active())){
9D00EEF4  30420001   ANDI V0, V0, 1
9D00EEF8  5040000D   BEQL V0, ZERO, 0x9D00EF30
9D00EEFC  00048040   SLL S0, A0, 1
325:                         vga_show_cursor(FALSE);
9D00EF00  0F403B8F   JAL vga_show_cursor
9D00EF04  00002021   ADDU A0, ZERO, ZERO
326:                     }
327:                     cx=x*CHAR_WIDTH;
9D00EF08  00108040   SLL S0, S0, 1
9D00EF0C  00101080   SLL V0, S0, 2
9D00EF10  00508023   SUBU S0, V0, S0
9D00EF14  A7908052   SH S0, -32686(GP)
9D00EF30  00101080   SLL V0, S0, 2
9D00EF34  00508023   SUBU S0, V0, S0
9D00EF38  A7908052   SH S0, -32686(GP)
328:                     cy=y*CHAR_HEIGHT;
9D00EF18  001188C0   SLL S1, S1, 3
9D00EF1C  A7918050   SH S1, -32688(GP)
9D00EF3C  000588C0   SLL S1, A1, 3
9D00EF40  A7918050   SH S1, -32688(GP)
329:                     if (active){
330:                         vga_show_cursor(TRUE);
9D00EF20  0F403B8F   JAL vga_show_cursor
9D00EF24  24040001   ADDIU A0, ZERO, 1
331:                     }
332:                 }//vga_set_curpos()
9D00EF28  0B403BD2   J 0x9D00EF48
9D00EF2C  8FBF001C   LW RA, 28(SP)
9D00EF44  8FBF001C   LW RA, 28(SP)
9D00EF48  8FB10018   LW S1, 24(SP)
9D00EF4C  8FB00014   LW S0, 20(SP)
9D00EF50  03E00008   JR RA
9D00EF54  27BD0020   ADDIU SP, SP, 32
333:                 
334:                 // inverse vidéo du caractère à la position courante
335:                 void vga_invert_char(){
336:                     register int i,l,r,b,x,y;
337:                     x=cx;
9D00EBD0  97878052   LHU A3, -32686(GP)
338:                     y=cy;
9D00EBD4  97858050   LHU A1, -32688(GP)
339:                     b=x>>5;
9D00EBD8  00071143   SRA V0, A3, 5
340:                     r=0;
341:                     l=(32-CHAR_WIDTH)-(x&0x1f);
9D00EBDC  30E7001F   ANDI A3, A3, 31
9D00EBE0  2403001A   ADDIU V1, ZERO, 26
9D00EBE4  00673823   SUBU A3, V1, A3
342:                     if (l<0){
343:                         r=-l;
9D00EBE8  00071823   SUBU V1, ZERO, A3
9D00EBEC  28E40000   SLTI A0, A3, 0
9D00EBF0  0004180A   MOVZ V1, ZERO, A0
9D00EBF4  00602021   ADDU A0, V1, ZERO
344:                     }
345:                     for (i=9;i;i--){
9D00EC5C  1465FFF4   BNE V1, A1, 0x9D00EC30
9D00EC60  2442003C   ADDIU V0, V0, 60
346:                         if (r){
9D00EC30  10800007   BEQ A0, ZERO, 0x9D00EC50
9D00EC34  8C460000   LW A2, 0(V0)
347:                             video_bmp[y][b] ^= (0x3f>>r);
9D00EBF8  2403003F   ADDIU V1, ZERO, 63
9D00EBFC  00834807   SRAV T1, V1, A0
9D00EC38  00C93026   XOR A2, A2, T1
9D00EC3C  AC460000   SW A2, 0(V0)
348:                             video_bmp[y][b+1] ^= (0x3f<<32-r);
9D00EC00  00044023   SUBU T0, ZERO, A0
9D00EC04  01034004   SLLV T0, V1, T0
9D00EC40  8C460004   LW A2, 4(V0)
9D00EC44  00C83026   XOR A2, A2, T0
9D00EC48  0B403B16   J 0x9D00EC58
9D00EC4C  AC460004   SW A2, 4(V0)
349:                             y++;
350:                         } else{
351:                             video_bmp[y++][b] ^= (0x3f<<l);
9D00EC08  00E33804   SLLV A3, V1, A3
9D00EC0C  24A30001   ADDIU V1, A1, 1
9D00EC10  00053100   SLL A2, A1, 4
9D00EC14  00C53023   SUBU A2, A2, A1
9D00EC18  00C23021   ADDU A2, A2, V0
9D00EC1C  00063080   SLL A2, A2, 2
9D00EC20  3C02A000   LUI V0, -24576
9D00EC24  244200C0   ADDIU V0, V0, 192
9D00EC28  00461021   ADDU V0, V0, A2
9D00EC2C  24A5000A   ADDIU A1, A1, 10
9D00EC50  00C73026   XOR A2, A2, A3
9D00EC54  AC460000   SW A2, 0(V0)
9D00EC58  24630001   ADDIU V1, V1, 1
352:                         }
353:                     }
354:                 }//vga_invert_char()
9D00EC64  03E00008   JR RA
9D00EC68  00000000   NOP
355:                 
356:                 static void vga_toggle_underscore(){
357:                     register int l,r,b,x;
358:                     x=cx;
359:                     b=x>>5;
9D00EC94  00022143   SRA A0, V0, 5
360:                     r=0;
361:                     l=(32-CHAR_WIDTH)-(x&0x1f);
9D00EC98  3042001F   ANDI V0, V0, 31
9D00EC9C  2403001A   ADDIU V1, ZERO, 26
9D00ECA0  00621823   SUBU V1, V1, V0
362:                     if (l<0){
9D00ECA4  0463001D   BGEZL V1, 0x9D00ED1C
9D00ECA8  97828050   LHU V0, -32688(GP)
363:                         r=-l;
9D00ECAC  00034023   SUBU T0, ZERO, V1
364:                     }
365:                     if (r){
9D00ECB0  11000019   BEQ T0, ZERO, 0x9D00ED18
9D00ECB4  97868050   LHU A2, -32688(GP)
366:                         video_bmp[cy+CHAR_HEIGHT-1][b] ^= (0x3f>>r);
9D00ECB8  24C60007   ADDIU A2, A2, 7
9D00ECBC  00061900   SLL V1, A2, 4
9D00ECC0  00663023   SUBU A2, V1, A2
9D00ECC4  00C43821   ADDU A3, A2, A0
9D00ECC8  00073880   SLL A3, A3, 2
9D00ECCC  3C05A000   LUI A1, -24576
9D00ECD0  24A500C0   ADDIU A1, A1, 192
9D00ECD4  00E53821   ADDU A3, A3, A1
9D00ECD8  2403003F   ADDIU V1, ZERO, 63
9D00ECDC  01034007   SRAV T0, V1, T0
9D00ECE0  8CE90000   LW T1, 0(A3)
9D00ECE4  01094026   XOR T0, T0, T1
9D00ECE8  ACE80000   SW T0, 0(A3)
367:                         video_bmp[cy+CHAR_HEIGHT-1][b+1] ^= (0x3f<<32-r);
9D00ECEC  24840001   ADDIU A0, A0, 1
9D00ECF0  00C42021   ADDU A0, A2, A0
9D00ECF4  00042080   SLL A0, A0, 2
9D00ECF8  00852021   ADDU A0, A0, A1
9D00ECFC  2405003A   ADDIU A1, ZERO, 58
9D00ED00  00A21023   SUBU V0, A1, V0
9D00ED04  00431804   SLLV V1, V1, V0
9D00ED08  8C850000   LW A1, 0(A0)
9D00ED0C  00651826   XOR V1, V1, A1
9D00ED10  0B403B54   J 0x9D00ED50
9D00ED14  AC830000   SW V1, 0(A0)
368:                     } else{
369:                         video_bmp[cy+CHAR_HEIGHT-1][b] ^= (0x3f<<l);
9D00ED18  97828050   LHU V0, -32688(GP)
9D00ED1C  24420007   ADDIU V0, V0, 7
9D00ED20  00022900   SLL A1, V0, 4
9D00ED24  00A21023   SUBU V0, A1, V0
9D00ED28  00442021   ADDU A0, V0, A0
9D00ED2C  00042080   SLL A0, A0, 2
9D00ED30  3C05A000   LUI A1, -24576
9D00ED34  24A500C0   ADDIU A1, A1, 192
9D00ED38  00852021   ADDU A0, A0, A1
9D00ED3C  2402003F   ADDIU V0, ZERO, 63
9D00ED40  00621804   SLLV V1, V0, V1
9D00ED44  8C820000   LW V0, 0(A0)
9D00ED48  00621826   XOR V1, V1, V0
9D00ED4C  AC830000   SW V1, 0(A0)
370:                     }
371:                 }//vga_toggle_underscore()
372:                 
373:                 // cette fonction ne doit-être appellée
374:                 // que par l'interruption du TIMER2 lorsque le cursor est actif.
375:                 void vga_toggle_cursor(){
9D00EC6C  27BDFFE8   ADDIU SP, SP, -24
9D00EC70  AFBF0014   SW RA, 20(SP)
376:                     if (cur_shape==CR_BLOCK){
9D00EC74  24020001   ADDIU V0, ZERO, 1
9D00EC78  8F83804C   LW V1, -32692(GP)
9D00EC7C  14620005   BNE V1, V0, 0x9D00EC94
9D00EC80  97828052   LHU V0, -32686(GP)
377:                         vga_invert_char();
9D00EC84  0F403AF4   JAL vga_invert_char
9D00EC88  00000000   NOP
9D00EC8C  0B403B54   J 0x9D00ED50
9D00EC90  00000000   NOP
378:                     }else{
379:                         vga_toggle_underscore();
380:                     }
381:                     flags ^=CUR_VIS;
9D00ED50  97828048   LHU V0, -32696(GP)
9D00ED54  3042FFFF   ANDI V0, V0, -1
9D00ED58  38420002   XORI V0, V0, 2
9D00ED5C  A7828048   SH V0, -32696(GP)
382:                 }// vga_toggle_cursor()
9D00ED60  8FBF0014   LW RA, 20(SP)
9D00ED64  03E00008   JR RA
9D00ED68  27BD0018   ADDIU SP, SP, 24
383:                 
384:                 
385:                 void vga_show_cursor(BOOL show){
9D00EE3C  27BDFFE8   ADDIU SP, SP, -24
386:                     if (show){
9D00EE40  1080000E   BEQ A0, ZERO, 0x9D00EE7C
9D00EE44  AFBF0014   SW RA, 20(SP)
387:                         flags |= CUR_SHOW;
9D00EE48  97828048   LHU V0, -32696(GP)
9D00EE4C  3042FFFF   ANDI V0, V0, -1
9D00EE50  34420001   ORI V0, V0, 1
9D00EE54  A7828048   SH V0, -32696(GP)
388:                         flags &= ~CUR_VIS;
9D00EE58  97828048   LHU V0, -32696(GP)
9D00EE5C  3042FFFD   ANDI V0, V0, -3
9D00EE60  A7828048   SH V0, -32696(GP)
389:                         enable_cursor_timer(TRUE,(cursor_tmr_callback_f)vga_toggle_cursor);
9D00EE64  24040001   ADDIU A0, ZERO, 1
9D00EE68  3C059D01   LUI A1, -25343
9D00EE6C  0F403B7D   JAL enable_cursor_timer
9D00EE70  24A5EC6C   ADDIU A1, A1, -5012
9D00EE74  0B403BB0   J 0x9D00EEC0
9D00EE78  8FBF0014   LW RA, 20(SP)
390:                     }else{
391:                         enable_cursor_timer(FALSE,NULL);
9D00EE7C  00002021   ADDU A0, ZERO, ZERO
9D00EE80  0F403B7D   JAL enable_cursor_timer
9D00EE84  00002821   ADDU A1, ZERO, ZERO
392:                         flags &= ~CUR_SHOW;
9D00EE88  97828048   LHU V0, -32696(GP)
9D00EE8C  3042FFFE   ANDI V0, V0, -2
9D00EE90  A7828048   SH V0, -32696(GP)
393:                         if (flags & CUR_VIS){
9D00EE94  97828048   LHU V0, -32696(GP)
9D00EE98  30420002   ANDI V0, V0, 2
9D00EE9C  3042FFFF   ANDI V0, V0, -1
9D00EEA0  10400007   BEQ V0, ZERO, 0x9D00EEC0
9D00EEA4  8FBF0014   LW RA, 20(SP)
394:                             vga_toggle_cursor();
9D00EEA8  0F403B1B   JAL vga_toggle_cursor
9D00EEAC  00000000   NOP
395:                             flags &= ~CUR_VIS;
9D00EEB0  97828048   LHU V0, -32696(GP)
9D00EEB4  3042FFFD   ANDI V0, V0, -3
9D00EEB8  A7828048   SH V0, -32696(GP)
396:                         }
397:                     }
398:                 }// vga_show_cursor()
9D00EEBC  8FBF0014   LW RA, 20(SP)
9D00EEC0  03E00008   JR RA
9D00EEC4  27BD0018   ADDIU SP, SP, 24
399:                 
400:                 
401:                 BOOL vga_is_cursor_active(){
402:                     return flags&CUR_SHOW;
9D00ED6C  97828048   LHU V0, -32696(GP)
9D00EEF0  97828048   LHU V0, -32696(GP)
9D00EEF4  30420001   ANDI V0, V0, 1
9D00EEF8  5040000D   BEQL V0, ZERO, 0x9D00EF30
9D00EEFC  00048040   SLL S0, A0, 1
9D00EF00  0F403B8F   JAL vga_show_cursor
9D00EF04  00002021   ADDU A0, ZERO, ZERO
9D00EF08  00108040   SLL S0, S0, 1
9D00EF0C  00101080   SLL V0, S0, 2
9D00EF10  00508023   SUBU S0, V0, S0
9D00EF14  A7908052   SH S0, -32686(GP)
9D00EF18  001188C0   SLL S1, S1, 3
9D00EF1C  A7918050   SH S1, -32688(GP)
9D00EF20  0F403B8F   JAL vga_show_cursor
9D00EF24  24040001   ADDIU A0, ZERO, 1
9D00EF28  0B403BD2   J 0x9D00EF48
9D00EF2C  8FBF001C   LW RA, 28(SP)
9D00EF30  00101080   SLL V0, S0, 2
9D00EF34  00508023   SUBU S0, V0, S0
9D00EF38  A7908052   SH S0, -32686(GP)
9D00EF3C  000588C0   SLL S1, A1, 3
9D00EF40  A7918050   SH S1, -32688(GP)
9D00EF44  8FBF001C   LW RA, 28(SP)
9D00EF48  8FB10018   LW S1, 24(SP)
9D00EF4C  8FB00014   LW S0, 20(SP)
9D00EF50  03E00008   JR RA
9D00EF54  27BD0020   ADDIU SP, SP, 32
403:                 }// vga_is_cursor_active()
9D00ED70  03E00008   JR RA
9D00ED74  30420001   ANDI V0, V0, 1
404:                 
405:                 void vga_set_cursor(cursor_t shape){
9D00EFCC  27BDFFE8   ADDIU SP, SP, -24
9D00EFD0  AFBF0014   SW RA, 20(SP)
9D00EFD4  AFB00010   SW S0, 16(SP)
9D00EFD8  00808021   ADDU S0, A0, ZERO
406:                     if (flags & CUR_VIS){
9D00EFDC  97828048   LHU V0, -32696(GP)
9D00EFE0  30420002   ANDI V0, V0, 2
9D00EFE4  3042FFFF   ANDI V0, V0, -1
9D00EFE8  50400008   BEQL V0, ZERO, 0x9D00F00C
9D00EFEC  AF84804C   SW A0, -32692(GP)
407:                         vga_show_cursor(FALSE);
9D00EFF0  0F403B8F   JAL vga_show_cursor
9D00EFF4  00002021   ADDU A0, ZERO, ZERO
408:                         cur_shape=shape;
9D00EFF8  AF90804C   SW S0, -32692(GP)
409:                         vga_show_cursor(TRUE);
9D00EFFC  0F403B8F   JAL vga_show_cursor
9D00F000  24040001   ADDIU A0, ZERO, 1
9D00F004  0B403C04   J 0x9D00F010
9D00F008  8FBF0014   LW RA, 20(SP)
410:                     }else{
411:                         cur_shape=shape;
412:                     }
413:                 }// vga_set_cursor()
9D00F00C  8FBF0014   LW RA, 20(SP)
9D00F010  8FB00010   LW S0, 16(SP)
9D00F014  03E00008   JR RA
9D00F018  27BD0018   ADDIU SP, SP, 24
414:                 
415:                 void vga_invert_video(unsigned char invert){
416:                     if (invert){
9D00ED78  10800007   BEQ A0, ZERO, 0x9D00ED98
9D00ED7C  00000000   NOP
417:                         flags |= INV_VID;
9D00ED80  97828048   LHU V0, -32696(GP)
9D00ED84  3042FFFF   ANDI V0, V0, -1
9D00ED88  34420004   ORI V0, V0, 4
9D00ED8C  A7828048   SH V0, -32696(GP)
9D00ED90  03E00008   JR RA
9D00ED94  00000000   NOP
418:                     }else{
419:                         flags &= ~INV_VID;
9D00ED98  97828048   LHU V0, -32696(GP)
9D00ED9C  3042FFFB   ANDI V0, V0, -5
9D00EDA0  A7828048   SH V0, -32696(GP)
9D00EDA4  03E00008   JR RA
9D00EDA8  00000000   NOP
420:                     }
421:                 }//vga_invert_video()
422:                 
423:                 // renvoie le mode video
424:                 BOOL vga_is_invert_video(){
425:                     return flags&INV_VID;
9D00EDAC  97828048   LHU V0, -32696(GP)
426:                 }//vga_is_invert_video()
9D00EDB0  03E00008   JR RA
9D00EDB4  30420004   ANDI V0, V0, 4
427:                 
428:                 
429:                 void vga_spaces(unsigned char count){
9D00EDB8  27BDFFE8   ADDIU SP, SP, -24
9D00EDBC  AFBF0014   SW RA, 20(SP)
9D00EDC0  AFB00010   SW S0, 16(SP)
430:                     while (count){
9D00EDC4  10800007   BEQ A0, ZERO, 0x9D00EDE4
9D00EDC8  00808021   ADDU S0, A0, ZERO
9D00EDDC  1600FFFB   BNE S0, ZERO, 0x9D00EDCC
9D00EDE0  00000000   NOP
431:                         vga_put_char(' ');
9D00EDCC  0F403A08   JAL vga_put_char
9D00EDD0  24040020   ADDIU A0, ZERO, 32
432:                         count--;
9D00EDD4  2610FFFF   ADDIU S0, S0, -1
9D00EDD8  321000FF   ANDI S0, S0, 255
433:                     }
434:                 }//vga_spaces()
9D00EDE4  8FBF0014   LW RA, 20(SP)
9D00EDE8  8FB00010   LW S0, 16(SP)
9D00EDEC  03E00008   JR RA
9D00EDF0  27BD0018   ADDIU SP, SP, 24
435:                 
436:                 
437:                 void enable_cursor_timer(BOOL enable, cursor_tmr_callback_f cb){
438:                     if (enable && cb){
9D00EDF4  1080000E   BEQ A0, ZERO, 0x9D00EE30
9D00EDF8  3C02A000   LUI V0, -24576
9D00EDFC  10A0000C   BEQ A1, ZERO, 0x9D00EE30
9D00EE00  00000000   NOP
439:                         if (!cursor_timer.active){
9D00EE04  8C424628   LW V0, 17960(V0)
9D00EE08  14400007   BNE V0, ZERO, 0x9D00EE28
9D00EE0C  3C02A000   LUI V0, -24576
440:                             cursor_timer.period=BLINK_DELAY;
9D00EE10  24434628   ADDIU V1, V0, 17960
9D00EE14  24040028   ADDIU A0, ZERO, 40
9D00EE18  AC640004   SW A0, 4(V1)
441:                             cursor_timer.cb=cb;
9D00EE1C  AC650008   SW A1, 8(V1)
442:                             cursor_timer.active=TRUE;
9D00EE20  24030001   ADDIU V1, ZERO, 1
9D00EE24  AC434628   SW V1, 17960(V0)
9D00EE28  03E00008   JR RA
9D00EE2C  00000000   NOP
443:                         }
444:                     }else{
445:                         cursor_timer.active=FALSE;
9D00EE30  AC404628   SW ZERO, 17960(V0)
9D00EE34  03E00008   JR RA
9D00EE38  00000000   NOP
446:                     }
447:                 }
448:                 
449:                 // interruption qui assure le fonctionnement du 
450:                 // générateur vidéo.
451:                 void __ISR(_TIMER_2_VECTOR,IPL7AUTO) tmr2_isr(void){
9D00F01C  415DE800   RDPGPR SP, SP
9D00F020  401B7000   MFC0 K1, EPC
9D00F024  401A6002   MFC0 K0, SRSCtl
9D00F028  27BDFF88   ADDIU SP, SP, -120
9D00F02C  401B6000   MFC0 K1, Status
9D00F030  AFBA0070   SW K0, 112(SP)
9D00F034  AFBB0074   SW K1, 116(SP)
9D00F038  7C1B7844   INS K1, ZERO, 1, 15
9D00F03C  377B1C00   ORI K1, K1, 7168
9D00F040  409B6000   MTC0 K1, Status
9D00F044  AFA3001C   SW V1, 28(SP)
9D00F048  AFA20018   SW V0, 24(SP)
9D00F04C  8FA30070   LW V1, 112(SP)
9D00F050  3063000F   ANDI V1, V1, 15
9D00F054  14600012   BNE V1, ZERO, 0x9D00F0A0
9D00F058  00000000   NOP
9D00F05C  AFBF005C   SW RA, 92(SP)
9D00F060  AFB90058   SW T9, 88(SP)
9D00F064  AFB80054   SW T8, 84(SP)
9D00F068  AFB00050   SW S0, 80(SP)
9D00F06C  AFAF004C   SW T7, 76(SP)
9D00F070  AFAE0048   SW T6, 72(SP)
9D00F074  AFAD0044   SW T5, 68(SP)
9D00F078  AFAC0040   SW T4, 64(SP)
9D00F07C  AFAB003C   SW T3, 60(SP)
9D00F080  AFAA0038   SW T2, 56(SP)
9D00F084  AFA90034   SW T1, 52(SP)
9D00F088  AFA80030   SW T0, 48(SP)
9D00F08C  AFA7002C   SW A3, 44(SP)
9D00F090  AFA60028   SW A2, 40(SP)
9D00F094  AFA50024   SW A1, 36(SP)
9D00F098  AFA40020   SW A0, 32(SP)
9D00F09C  AFA10014   SW AT, 20(SP)
9D00F0A0  00001012   MFLO V0
9D00F0A4  AFA20064   SW V0, 100(SP)
9D00F0A8  00001810   MFHI V1
9D00F0AC  AFA30060   SW V1, 96(SP)
452:                     _disable_video_out();
9D00F0B0  3C02BF81   LUI V0, -16511
9D00F0B4  9043FB44   LBU V1, -1212(V0)
9D00F0B8  7C031804   INS V1, ZERO, 0, 4
9D00F0BC  A043FB44   SB V1, -1212(V0)
9D00F0C0  3C02BF80   LUI V0, -16512
9D00F0C4  8C435800   LW V1, 22528(V0)
9D00F0C8  7C037BC4   INS V1, ZERO, 15, 1
9D00F0CC  AC435800   SW V1, 22528(V0)
453:                     static int ln_cnt=0;
454:                     static char video=0;
455:                     static char even=1;
456:                     
457:                     ln_cnt++;
9D00F0D0  8F838044   LW V1, -32700(GP)
9D00F0D4  24620001   ADDIU V0, V1, 1
458:                     switch (ln_cnt){
9D00F0D8  24040004   ADDIU A0, ZERO, 4
9D00F0DC  1044001C   BEQ V0, A0, 0x9D00F150
9D00F0E0  AF828044   SW V0, -32700(GP)
9D00F0E4  28440005   SLTI A0, V0, 5
9D00F0E8  10800008   BEQ A0, ZERO, 0x9D00F10C
9D00F0EC  24040203   ADDIU A0, ZERO, 515
9D00F0F0  24040001   ADDIU A0, ZERO, 1
9D00F0F4  1044000D   BEQ V0, A0, 0x9D00F12C
9D00F0F8  24040003   ADDIU A0, ZERO, 3
9D00F0FC  50440010   BEQL V0, A0, 0x9D00F140
9D00F100  24030010   ADDIU V1, ZERO, 16
9D00F10C  10440029   BEQ V0, A0, 0x9D00F1B4
9D00F110  2404020D   ADDIU A0, ZERO, 525
9D00F114  10440029   BEQ V0, A0, 0x9D00F1BC
9D00F118  24040022   ADDIU A0, ZERO, 34
9D00F11C  54440029   BNEL V0, A0, 0x9D00F1C4
9D00F120  83828040   LB V0, -32704(GP)
459:                         case 1:
460:                             PORTBCLR =VSYNC_OUT;
9D00F12C  24030010   ADDIU V1, ZERO, 16
9D00F130  3C02BF88   LUI V0, -16504
9D00F134  AC436124   SW V1, 24868(V0)
461:                             break;
9D00F138  0B403CA1   J 0x9D00F284
9D00F13C  24030200   ADDIU V1, ZERO, 512
462:                         case 3:
463:                             PORTBSET=VSYNC_OUT;
9D00F140  3C02BF88   LUI V0, -16504
9D00F144  AC436128   SW V1, 24872(V0)
464:                             break;
9D00F148  0B403CA1   J 0x9D00F284
9D00F14C  24030200   ADDIU V1, ZERO, 512
465:                         case 4:
466:                             if (cursor_timer.active){
9D00F150  3C02A000   LUI V0, -24576
9D00F154  8C424628   LW V0, 17960(V0)
9D00F158  10400049   BEQ V0, ZERO, 0x9D00F280
9D00F15C  3C02A000   LUI V0, -24576
467:                                 cursor_timer.period--;
9D00F160  24424628   ADDIU V0, V0, 17960
9D00F164  8C430004   LW V1, 4(V0)
9D00F168  2463FFFF   ADDIU V1, V1, -1
9D00F16C  AC430004   SW V1, 4(V0)
468:                                 if (!cursor_timer.period){
9D00F170  8C420004   LW V0, 4(V0)
9D00F174  54400043   BNEL V0, ZERO, 0x9D00F284
9D00F178  24030200   ADDIU V1, ZERO, 512
469:                                     cursor_timer.cb();
9D00F17C  3C10A000   LUI S0, -24576
9D00F180  26104628   ADDIU S0, S0, 17960
9D00F184  8E020008   LW V0, 8(S0)
9D00F188  0040F809   JALR V0
9D00F18C  00000000   NOP
470:                                     cursor_timer.period=BLINK_DELAY;
9D00F190  24020028   ADDIU V0, ZERO, 40
9D00F194  AE020004   SW V0, 4(S0)
471:                                 }
472:                             }
473:                             break;
474:                         case FIRST_LINE:
475:                             video=1;
9D00F124  0B403C68   J 0x9D00F1A0
9D00F128  24020001   ADDIU V0, ZERO, 1
9D00F1A0  A3828040   SB V0, -32704(GP)
476:                             dma_source=(void*)&video_bmp[0];
9D00F1A4  3C02A000   LUI V0, -24576
9D00F1A8  244200C0   ADDIU V0, V0, 192
477:                             break;
9D00F1AC  0B403CA0   J 0x9D00F280
9D00F1B0  AF828054   SW V0, -32684(GP)
478:                         case LAST_LINE:
479:                             video=0;
480:                             break;
9D00F1B4  0B403CA0   J 0x9D00F280
9D00F1B8  A3808040   SB ZERO, -32704(GP)
481:                         case FRAME_LINES:
482:                             ln_cnt=0;
483:                             break;
9D00F1BC  0B403CA0   J 0x9D00F280
9D00F1C0  AF808044   SW ZERO, -32700(GP)
484:                         default:
485:                             if (video){
9D00F104  0B403C71   J 0x9D00F1C4
9D00F108  83828040   LB V0, -32704(GP)
9D00F1C4  5040002F   BEQL V0, ZERO, 0x9D00F284
9D00F1C8  24030200   ADDIU V1, ZERO, 512
486:                                 asm volatile(// jitter cancel code.
9D00F1CC  3C02BF80   LUI V0, -16512
9D00F1D0  24420810   ADDIU V0, V0, 2064
9D00F1D4  94440000   LHU A0, 0(V0)
9D00F1D8  30840007   ANDI A0, A0, 7
9D00F1DC  00042080   SLL A0, A0, 2
9D00F1E0  3C029D01   LUI V0, -25343
9D00F1E4  2442F1F4   ADDIU V0, V0, -3596
9D00F1E8  00822021   ADDU A0, A0, V0
9D00F1EC  00800008   JR A0
9D00F1F0  00000000   NOP
9D00F1F4  00000000   NOP
9D00F1F8  00000000   NOP
9D00F1FC  00000000   NOP
9D00F200  00000000   NOP
9D00F204  00000000   NOP
9D00F208  00000000   NOP
9D00F20C  00000000   NOP
9D00F210  00000000   NOP
487:                                 "la $v0,%0\n"
488:                                 "lhu $a0, 0($v0)\n"
489:                                 "andi $a0,$a0,7\n"
490:                                 "sll $a0,$a0,2\n"
491:                                 "la $v0, jit\n"
492:                                 "addu $a0,$v0\n"
493:                                 "jr $a0\n"
494:                                 "jit:\n"
495:                                 "nop\n nop\n nop\n nop\n nop\n nop\n nop\n nop\n"
496:                                 ::"i"(&TMR2)
497:                                 );
498:                                 _enable_video_out();
9D00F214  3C02BF81   LUI V0, -16511
9D00F218  9044FB44   LBU A0, -1212(V0)
9D00F21C  24050003   ADDIU A1, ZERO, 3
9D00F220  7CA41804   INS A0, A1, 0, 4
9D00F224  A044FB44   SB A0, -1212(V0)
9D00F228  3C02BF80   LUI V0, -16512
9D00F22C  8C445800   LW A0, 22528(V0)
9D00F230  24050001   ADDIU A1, ZERO, 1
9D00F234  7CA47BC4   INS A0, A1, 15, 1
9D00F238  AC445800   SW A0, 22528(V0)
499:                                 IFS1bits.SPI1TXIF=1;
9D00F23C  3C02BF88   LUI V0, -16504
9D00F240  8C441040   LW A0, 4160(V0)
9D00F244  7CA43184   INS A0, A1, 6, 1
9D00F248  AC441040   SW A0, 4160(V0)
500:                                 DCH0SSA=KVA_TO_PA((void *)dma_source);
9D00F24C  8F828054   LW V0, -32684(GP)
9D00F250  7C45E000   EXT A1, V0, 0, 29
9D00F254  3C04BF88   LUI A0, -16504
9D00F258  AC853090   SW A1, 12432(A0)
501:                                 if ((ln_cnt+1)&1) dma_source +=HRES/32;
9D00F25C  30630001   ANDI V1, V1, 1
9D00F260  50600004   BEQL V1, ZERO, 0x9D00F274
9D00F264  3C02BF88   LUI V0, -16504
9D00F268  2442003C   ADDIU V0, V0, 60
9D00F26C  AF828054   SW V0, -32684(GP)
502:                                 DCH0CON |=128; // Enable DMA channel 0.
9D00F270  3C02BF88   LUI V0, -16504
9D00F274  8C433060   LW V1, 12384(V0)
9D00F278  34630080   ORI V1, V1, 128
9D00F27C  AC433060   SW V1, 12384(V0)
503:                             }
504:                     }//switch (ln_cnt)
505:                     mT2ClearIntFlag();
9D00F198  0B403CA1   J 0x9D00F284
9D00F19C  24030200   ADDIU V1, ZERO, 512
9D00F280  24030200   ADDIU V1, ZERO, 512
9D00F284  3C02BF88   LUI V0, -16504
9D00F288  AC431034   SW V1, 4148(V0)
506:                 }//tmr2_isr()
9D00F28C  8FA20064   LW V0, 100(SP)
9D00F290  00400013   MTLO V0
9D00F294  8FA30060   LW V1, 96(SP)
9D00F298  00600011   MTHI V1
9D00F29C  8FA20070   LW V0, 112(SP)
9D00F2A0  3042000F   ANDI V0, V0, 15
9D00F2A4  14400014   BNE V0, ZERO, 0x9D00F2F8
9D00F2A8  00000000   NOP
9D00F2AC  8FBF005C   LW RA, 92(SP)
9D00F2B0  8FB90058   LW T9, 88(SP)
9D00F2B4  8FB80054   LW T8, 84(SP)
9D00F2B8  8FB00050   LW S0, 80(SP)
9D00F2BC  8FAF004C   LW T7, 76(SP)
9D00F2C0  8FAE0048   LW T6, 72(SP)
9D00F2C4  8FAD0044   LW T5, 68(SP)
9D00F2C8  8FAC0040   LW T4, 64(SP)
9D00F2CC  8FAB003C   LW T3, 60(SP)
9D00F2D0  8FAA0038   LW T2, 56(SP)
9D00F2D4  8FA90034   LW T1, 52(SP)
9D00F2D8  8FA80030   LW T0, 48(SP)
9D00F2DC  8FA7002C   LW A3, 44(SP)
9D00F2E0  8FA60028   LW A2, 40(SP)
9D00F2E4  8FA50024   LW A1, 36(SP)
9D00F2E8  8FA40020   LW A0, 32(SP)
9D00F2EC  8FA3001C   LW V1, 28(SP)
9D00F2F0  8FA20018   LW V0, 24(SP)
9D00F2F4  8FA10014   LW AT, 20(SP)
9D00F2F8  8FBB0074   LW K1, 116(SP)
9D00F2FC  8FBA0070   LW K0, 112(SP)
9D00F300  27BD0078   ADDIU SP, SP, 120
9D00F304  409A6002   MTC0 K0, SRSCtl
9D00F308  41DDE800   WRPGPR SP, SP
9D00F30C  409B6000   MTC0 K1, Status
9D00F310  42000018   ERET
507:                 
---  /home/jacques/github/vpc-32vga/hardware/syscall.c  -------------------------------------------------
1:                   
2:                   #include "syscall.h"
3:                   
4:                   
5:                   
6:                   int __attribute__((address(0x9d000000))) syscall (service_t service, arg_t *arg_list){
7:                       unsigned int val=-1;
8:                       switch (service){
9:                           case PUTCHAR:
10:                  //            put_char(arg_list[0].i,arg_list[1].c);
11:                              break;
12:                          case GETCHAR:
13:                  //            val=get_key(arg_list[0].i);
14:                              break;
15:                          case WAITCHAR:
16:                  //            val=wait_key(arg_list[0].i);
17:                              break;
18:                          case PRINT:
19:                  //            print(arg_list[0].i,arg_list[1].cstr);
20:                              break;
21:                      }
22:                      return val;
23:                  }
9D000000  03E00008   JR RA
9D000004  2402FFFF   ADDIU V0, ZERO, -1
24:                  
25:                  
26:                  
---  /home/jacques/github/vpc-32vga/hardware/store/store_spi.c  -----------------------------------------
1:                   /*
2:                   * Copyright 2013,2014,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   store_spi.c
21:                   * Author: jacques Deschênes
22:                   * Description: shared SPI interface used by SDcard and SPIRAM
23:                   *
24:                   * Created on 25 novembre 2014, 15:40
25:                   * rev: 2017-07-31
26:                   */
27:                  
28:                  #include <peripheral/ports.h>
29:                  #include "store_spi.h"
30:                  
31:                  unsigned char store_initialized=0; // set to 1 by store_spi_init
32:                  
33:                  // set SPI interface clock frequency
34:                  // input:
35:                  //      freq  frequency Hertz
36:                  void spi_clock_freq(int freq){
37:                      STORE_SPICON &= ~BIT_15;
9D01D870  3C02BF80   LUI V0, -16512
9D01D874  8C435A00   LW V1, 23040(V0)
9D01D878  7C037BC4   INS V1, ZERO, 15, 1
9D01D87C  AC435A00   SW V1, 23040(V0)
38:                      STORE_SPIBRG = (mGetPeripheralClock() / (freq<<1)) - 1;
9D01D880  00042040   SLL A0, A0, 1
9D01D884  3C030262   LUI V1, 610
9D01D888  24635A00   ADDIU V1, V1, 23040
9D01D88C  0064001A   DIV V1, A0
9D01D890  008001F4   TEQ A0, ZERO
9D01D894  00002012   MFLO A0
9D01D898  2484FFFF   ADDIU A0, A0, -1
9D01D89C  3C05BF80   LUI A1, -16512
9D01D8A0  ACA45A30   SW A0, 23088(A1)
39:                      STORE_SPICON |= BIT_15;
9D01D8A4  8C435A00   LW V1, 23040(V0)
9D01D8A8  34638000   ORI V1, V1, -32768
9D01D8AC  AC435A00   SW V1, 23040(V0)
9D01D8B0  03E00008   JR RA
9D01D8B4  00000000   NOP
40:                  }
41:                  
42:                  // configure SPI port
43:                  void store_spi_init(){
9D01D8B8  27BDFFE8   ADDIU SP, SP, -24
9D01D8BC  AFBF0014   SW RA, 20(SP)
9D01D8C0  AFB00010   SW S0, 16(SP)
44:                      _sdc_deselect();
9D01D8C4  24030008   ADDIU V1, ZERO, 8
9D01D8C8  3C02BF88   LUI V0, -16504
9D01D8CC  AC436128   SW V1, 24872(V0)
45:                      _sram_deselect();
9D01D8D0  24100001   ADDIU S0, ZERO, 1
9D01D8D4  3C02BF88   LUI V0, -16504
9D01D8D8  AC506028   SW S0, 24616(V0)
46:                      STORE_SPICON = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
9D01D8DC  34038120   ORI V1, ZERO, -32480
9D01D8E0  3C02BF80   LUI V0, -16512
9D01D8E4  AC435A00   SW V1, 23040(V0)
47:                      spi_clock_freq(FAST_CLOCK);
9D01D8E8  3C040131   LUI A0, 305
9D01D8EC  0F40761C   JAL spi_clock_freq
9D01D8F0  24842D00   ADDIU A0, A0, 11520
48:                      store_initialized=1;
9D01D8F4  A390803C   SB S0, -32708(GP)
49:                  }
9D01D8F8  8FBF0014   LW RA, 20(SP)
9D01D8FC  8FB00010   LW S0, 16(SP)
9D01D900  03E00008   JR RA
9D01D904  27BD0018   ADDIU SP, SP, 24
50:                  
51:                  
52:                  // send one byte of data and receive one back at the same time
53:                  // input:
54:                  //      b  char to send
55:                  // output:
56:                  //      char reveived from interface
57:                  unsigned char writeSPI(unsigned char b)
58:                  {
59:                  	STORE_SPIBUF = b;
9D01D908  3C02BF80   LUI V0, -16512
9D01D90C  AC445A20   SW A0, 23072(V0)
60:                  	while(!STORE_SPISTATbits.SPIRBF); // wait transfer complete
9D01D910  3C03BF80   LUI V1, -16512
9D01D914  8C625A10   LW V0, 23056(V1)
9D01D918  30420001   ANDI V0, V0, 1
9D01D91C  1040FFFD   BEQ V0, ZERO, 0x9D01D914
9D01D920  3C02BF80   LUI V0, -16512
61:                  	return STORE_SPIBUF; // read the received value
9D01D924  8C425A20   LW V0, 23072(V0)
62:                  }// writeSPI
9D01D928  03E00008   JR RA
9D01D92C  304200FF   ANDI V0, V0, 255
63:                  
---  /home/jacques/github/vpc-32vga/hardware/spiram/spiram.c  -------------------------------------------
1:                   /*
2:                   * Copyright 2013,2014,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  #include "../HardwareProfile.h"
20:                  #include "spiram.h"
21:                  #include "../Pinguino/sdmmc.h"
22:                  
23:                  /* File:   spiram.c
24:                   * Author: jacques Deschênes
25:                   * description: Low level SPI RAM interface
26:                   * rev: 2017-07-31
27:                  */
28:                  
29:                  // send command to SPI RAM
30:                  // input:
31:                  //      cmd  commmand code
32:                  //      addr address
33:                  static void sram_cmd(unsigned char cmd, unsigned addr){
9D0137B8  27BDFFE8   ADDIU SP, SP, -24
9D0137BC  AFBF0014   SW RA, 20(SP)
9D0137C0  AFB00010   SW S0, 16(SP)
34:                      writeSPI(cmd);
9D0137C4  0F407642   JAL writeSPI
9D0137C8  00A08021   ADDU S0, A1, ZERO
35:                  #if defined BIG_SRAM    
36:                      writeSPI(addr>>16);
37:                  #endif    
38:                      writeSPI(addr>>8);
9D0137CC  0F407642   JAL writeSPI
9D0137D0  7E043A00   EXT A0, S0, 8, 8
39:                      writeSPI(addr&0xff);
9D0137D4  0F407642   JAL writeSPI
9D0137D8  320400FF   ANDI A0, S0, 255
40:                  }
9D0137DC  8FBF0014   LW RA, 20(SP)
9D0137E0  8FB00010   LW S0, 16(SP)
9D0137E4  03E00008   JR RA
9D0137E8  27BD0018   ADDIU SP, SP, 24
41:                  
42:                  // sram_write_mode
43:                  //   select write operating mode {byte,page,sequential}
44:                  // input:
45:                  //   mode operating mode {SRAM_BTMOD,SRAM_PGMOD,SRAM_SQMOD}
46:                  // output:
47:                  //   none
48:                  void sram_write_mode(unsigned char mode){
9D0137EC  27BDFFE0   ADDIU SP, SP, -32
9D0137F0  AFBF001C   SW RA, 28(SP)
9D0137F4  AFB10018   SW S1, 24(SP)
9D0137F8  AFB00014   SW S0, 20(SP)
9D0137FC  00808821   ADDU S1, A0, ZERO
49:                      _sram_select();
9D013800  24100001   ADDIU S0, ZERO, 1
9D013804  3C02BF88   LUI V0, -16504
9D013808  AC506024   SW S0, 24612(V0)
50:                      writeSPI(SRAM_WRMR);
9D01380C  0F407642   JAL writeSPI
9D013810  24040001   ADDIU A0, ZERO, 1
51:                      writeSPI(mode);
9D013814  0F407642   JAL writeSPI
9D013818  02202021   ADDU A0, S1, ZERO
52:                      _sram_deselect();
9D01381C  3C02BF88   LUI V0, -16504
9D013820  AC506028   SW S0, 24616(V0)
53:                  }
9D013824  8FBF001C   LW RA, 28(SP)
9D013828  8FB10018   LW S1, 24(SP)
9D01382C  8FB00014   LW S0, 20(SP)
9D013830  03E00008   JR RA
9D013834  27BD0020   ADDIU SP, SP, 32
54:                  
55:                  // sram_read_mode()
56:                  //      Read operation mode {byte,page,sequential}
57:                  // input:
58:                  //   none
59:                  // output:
60:                  //   char  Operating mode {SRAM_BTMOD,SRAM_PGMOD,SRAM_SQMOD}
61:                  unsigned char sram_read_mode(){
9D013838  27BDFFE8   ADDIU SP, SP, -24
9D01383C  AFBF0014   SW RA, 20(SP)
9D013840  AFB00010   SW S0, 16(SP)
62:                      unsigned char mode;
63:                      _sram_select();
9D013844  24100001   ADDIU S0, ZERO, 1
9D013848  3C02BF88   LUI V0, -16504
9D01384C  AC506024   SW S0, 24612(V0)
64:                      writeSPI(SRAM_RDMR);
9D013850  0F407642   JAL writeSPI
9D013854  24040005   ADDIU A0, ZERO, 5
65:                      mode=writeSPI(0);
9D013858  0F407642   JAL writeSPI
9D01385C  00002021   ADDU A0, ZERO, ZERO
66:                      _sram_deselect();
9D013860  3C03BF88   LUI V1, -16504
9D013864  AC706028   SW S0, 24616(V1)
67:                      return mode;
68:                  }
9D013868  8FBF0014   LW RA, 20(SP)
9D01386C  8FB00010   LW S0, 16(SP)
9D013870  03E00008   JR RA
9D013874  27BD0018   ADDIU SP, SP, 24
69:                  
70:                  // initialize SPI RAM operating mode
71:                  // use sequencial mode, SPI interface.
72:                  int sram_init(){
9D013878  27BDFFE8   ADDIU SP, SP, -24
9D01387C  AFBF0014   SW RA, 20(SP)
73:                      if (!store_initialized) store_spi_init();
9D013880  9382803C   LBU V0, -32708(GP)
9D013884  14400003   BNE V0, ZERO, 0x9D013894
9D013888  00000000   NOP
9D01388C  0F40762E   JAL store_spi_init
9D013890  00000000   NOP
74:                      sram_write_mode(SRAM_SQMD);
9D013894  0F404DFB   JAL sram_write_mode
9D013898  24040040   ADDIU A0, ZERO, 64
75:                      return 0;
76:                  }
9D01389C  00001021   ADDU V0, ZERO, ZERO
9D0138A0  8FBF0014   LW RA, 20(SP)
9D0138A4  03E00008   JR RA
9D0138A8  27BD0018   ADDIU SP, SP, 24
77:                  
78:                  // sram_clear()
79:                  //      Clear RAM to zero.
80:                  // input:
81:                  //      none
82:                  // output:
83:                  //      none
84:                  void sram_clear(){
9D0138AC  27BDFFE8   ADDIU SP, SP, -24
9D0138B0  AFBF0014   SW RA, 20(SP)
9D0138B4  AFB00010   SW S0, 16(SP)
85:                      unsigned i;
86:                      _sram_select();
9D0138B8  24030001   ADDIU V1, ZERO, 1
9D0138BC  3C02BF88   LUI V0, -16504
9D0138C0  AC436024   SW V1, 24612(V0)
87:                      sram_cmd(SRAM_WRITE,0);
9D0138C4  24040002   ADDIU A0, ZERO, 2
9D0138C8  0F404DEE   JAL sram_cmd
9D0138CC  00002821   ADDU A1, ZERO, ZERO
9D0138D0  3C100001   LUI S0, 1
88:                      for (i=0;i<SRAM_SIZE;i++) writeSPI(0);
9D0138D4  0F407642   JAL writeSPI
9D0138D8  00002021   ADDU A0, ZERO, ZERO
9D0138DC  2610FFFF   ADDIU S0, S0, -1
9D0138E0  1600FFFC   BNE S0, ZERO, 0x9D0138D4
9D0138E4  24030001   ADDIU V1, ZERO, 1
89:                      _sram_deselect();
9D0138E8  3C02BF88   LUI V0, -16504
9D0138EC  AC436028   SW V1, 24616(V0)
90:                  }
9D0138F0  8FBF0014   LW RA, 20(SP)
9D0138F4  8FB00010   LW S0, 16(SP)
9D0138F8  03E00008   JR RA
9D0138FC  27BD0018   ADDIU SP, SP, 24
91:                  
92:                  // sram_clear_block()
93:                  //      Clear to zero a block in SPI RAM
94:                  // input:
95:                  //      addr  Start address
96:                  //      size  Size in byte to zeroes.
97:                  // output:
98:                  //      none
99:                  void sram_clear_block(unsigned addr, unsigned size){
9D013900  27BDFFE0   ADDIU SP, SP, -32
9D013904  AFBF001C   SW RA, 28(SP)
9D013908  AFB10018   SW S1, 24(SP)
9D01390C  AFB00014   SW S0, 20(SP)
9D013910  00801021   ADDU V0, A0, ZERO
9D013914  00A08821   ADDU S1, A1, ZERO
100:                     int i;
101:                     _sram_select();
9D013918  24040001   ADDIU A0, ZERO, 1
9D01391C  3C03BF88   LUI V1, -16504
9D013920  AC646024   SW A0, 24612(V1)
102:                     sram_cmd(SRAM_WRITE,addr);
9D013924  24040002   ADDIU A0, ZERO, 2
9D013928  0F404DEE   JAL sram_cmd
9D01392C  00402821   ADDU A1, V0, ZERO
103:                     for(i=0;i<size;i++)writeSPI(0);
9D013930  12200006   BEQ S1, ZERO, 0x9D01394C
9D013934  00008021   ADDU S0, ZERO, ZERO
9D013938  0F407642   JAL writeSPI
9D01393C  00002021   ADDU A0, ZERO, ZERO
9D013940  26100001   ADDIU S0, S0, 1
9D013944  1611FFFC   BNE S0, S1, 0x9D013938
9D013948  00000000   NOP
104:                     _sram_deselect();
9D01394C  24030001   ADDIU V1, ZERO, 1
9D013950  3C02BF88   LUI V0, -16504
9D013954  AC436028   SW V1, 24616(V0)
105:                 }
9D013958  8FBF001C   LW RA, 28(SP)
9D01395C  8FB10018   LW S1, 24(SP)
9D013960  8FB00014   LW S0, 20(SP)
9D013964  03E00008   JR RA
9D013968  27BD0020   ADDIU SP, SP, 32
106:                 
107:                 // sram_read_byte()
108:                 //      Read a single byte from SPI RAM
109:                 // input:
110:                 //      addr  Adress to read.
111:                 // output:
112:                 //      char  byte read.
113:                 unsigned char sram_read_byte(unsigned addr){
9D01396C  27BDFFE8   ADDIU SP, SP, -24
9D013970  AFBF0014   SW RA, 20(SP)
9D013974  AFB00010   SW S0, 16(SP)
9D013978  00802821   ADDU A1, A0, ZERO
114:                     unsigned char b;
115:                 
116:                     _sram_select();
9D01397C  24100001   ADDIU S0, ZERO, 1
9D013980  3C02BF88   LUI V0, -16504
9D013984  AC506024   SW S0, 24612(V0)
117:                     sram_cmd(SRAM_READ,addr);
9D013988  0F404DEE   JAL sram_cmd
9D01398C  24040003   ADDIU A0, ZERO, 3
118:                     b=writeSPI(0);
9D013990  0F407642   JAL writeSPI
9D013994  00002021   ADDU A0, ZERO, ZERO
119:                     _sram_deselect();
9D013998  3C03BF88   LUI V1, -16504
9D01399C  AC706028   SW S0, 24616(V1)
120:                     return b;
121:                 }
9D0139A0  8FBF0014   LW RA, 20(SP)
9D0139A4  8FB00010   LW S0, 16(SP)
9D0139A8  03E00008   JR RA
9D0139AC  27BD0018   ADDIU SP, SP, 24
122:                 
123:                 // sram_write_byte()
124:                 //      Write a byte to SPI RAM
125:                 // input:
126:                 //      addr  Adresse to write.
127:                 //      byte  Value to write
128:                 // ouput:
129:                 //      none    
130:                 void sram_write_byte(unsigned addr, unsigned char byte){
9D0139B0  27BDFFE0   ADDIU SP, SP, -32
9D0139B4  AFBF001C   SW RA, 28(SP)
9D0139B8  AFB10018   SW S1, 24(SP)
9D0139BC  AFB00014   SW S0, 20(SP)
9D0139C0  00801021   ADDU V0, A0, ZERO
9D0139C4  00A08821   ADDU S1, A1, ZERO
131:                     _sram_select();
9D0139C8  24100001   ADDIU S0, ZERO, 1
9D0139CC  3C03BF88   LUI V1, -16504
9D0139D0  AC706024   SW S0, 24612(V1)
132:                     sram_cmd(SRAM_WRITE,addr);
9D0139D4  24040002   ADDIU A0, ZERO, 2
9D0139D8  0F404DEE   JAL sram_cmd
9D0139DC  00402821   ADDU A1, V0, ZERO
133:                     writeSPI(byte);
9D0139E0  0F407642   JAL writeSPI
9D0139E4  02202021   ADDU A0, S1, ZERO
134:                     _sram_deselect();
9D0139E8  3C02BF88   LUI V0, -16504
9D0139EC  AC506028   SW S0, 24616(V0)
135:                 }
9D0139F0  8FBF001C   LW RA, 28(SP)
9D0139F4  8FB10018   LW S1, 24(SP)
9D0139F8  8FB00014   LW S0, 20(SP)
9D0139FC  03E00008   JR RA
9D013A00  27BD0020   ADDIU SP, SP, 32
136:                 
137:                 // sram_read_block()
138:                 //      Read a range of adress in SPI RAM
139:                 // input:
140:                 //      addr  Adressse first byte.
141:                 //      buffer Buffer to store data.
142:                 //      count  Number of bytes to read.
143:                 // output:
144:                 //      none  Except for buffer[] content.
145:                 void sram_read_block(unsigned addr, unsigned char buffer[], unsigned count){
9D013A04  27BDFFE0   ADDIU SP, SP, -32
9D013A08  AFBF001C   SW RA, 28(SP)
9D013A0C  AFB20018   SW S2, 24(SP)
9D013A10  AFB10014   SW S1, 20(SP)
9D013A14  AFB00010   SW S0, 16(SP)
9D013A18  00801021   ADDU V0, A0, ZERO
9D013A1C  00A09021   ADDU S2, A1, ZERO
9D013A20  00C08821   ADDU S1, A2, ZERO
146:                     unsigned i;
147:                     _sram_select();
9D013A24  24040001   ADDIU A0, ZERO, 1
9D013A28  3C03BF88   LUI V1, -16504
9D013A2C  AC646024   SW A0, 24612(V1)
148:                     sram_cmd(SRAM_READ,addr);
9D013A30  24040003   ADDIU A0, ZERO, 3
9D013A34  0F404DEE   JAL sram_cmd
9D013A38  00402821   ADDU A1, V0, ZERO
149:                     for (i=0;i<count;i++) buffer[i]=writeSPI(0);
9D013A3C  12200008   BEQ S1, ZERO, 0x9D013A60
9D013A40  02408021   ADDU S0, S2, ZERO
9D013A44  02518821   ADDU S1, S2, S1
9D013A48  0F407642   JAL writeSPI
9D013A4C  00002021   ADDU A0, ZERO, ZERO
9D013A50  A2020000   SB V0, 0(S0)
9D013A54  26100001   ADDIU S0, S0, 1
9D013A58  1611FFFB   BNE S0, S1, 0x9D013A48
9D013A5C  00000000   NOP
150:                     _sram_deselect();
9D013A60  24030001   ADDIU V1, ZERO, 1
9D013A64  3C02BF88   LUI V0, -16504
9D013A68  AC436028   SW V1, 24616(V0)
151:                 }
9D013A6C  8FBF001C   LW RA, 28(SP)
9D013A70  8FB20018   LW S2, 24(SP)
9D013A74  8FB10014   LW S1, 20(SP)
9D013A78  8FB00010   LW S0, 16(SP)
9D013A7C  03E00008   JR RA
9D013A80  27BD0020   ADDIU SP, SP, 32
152:                 
153:                 // sram_write_block()
154:                 //      Write a range of byte to SPI RAM
155:                 // input:
156:                 //      addr Adresse of first byte location.
157:                 //      buffer  Buffer that contain data to write.
158:                 //      count  Number of bytes to write.
159:                 // output:
160:                 //      none
161:                 void sram_write_block(unsigned addr, const char buffer[],unsigned count){
9D013A84  27BDFFE0   ADDIU SP, SP, -32
9D013A88  AFBF001C   SW RA, 28(SP)
9D013A8C  AFB20018   SW S2, 24(SP)
9D013A90  AFB10014   SW S1, 20(SP)
9D013A94  AFB00010   SW S0, 16(SP)
9D013A98  00801021   ADDU V0, A0, ZERO
9D013A9C  00A09021   ADDU S2, A1, ZERO
9D013AA0  00C08821   ADDU S1, A2, ZERO
162:                     unsigned i;
163:                     _sram_select();
9D013AA4  24040001   ADDIU A0, ZERO, 1
9D013AA8  3C03BF88   LUI V1, -16504
9D013AAC  AC646024   SW A0, 24612(V1)
164:                     sram_cmd(SRAM_WRITE,addr);
9D013AB0  24040002   ADDIU A0, ZERO, 2
9D013AB4  0F404DEE   JAL sram_cmd
9D013AB8  00402821   ADDU A1, V0, ZERO
165:                     for (i=0;i<count;i++) writeSPI(buffer[i]);
9D013ABC  12200007   BEQ S1, ZERO, 0x9D013ADC
9D013AC0  02408021   ADDU S0, S2, ZERO
9D013AC4  02518821   ADDU S1, S2, S1
9D013AC8  0F407642   JAL writeSPI
9D013ACC  92040000   LBU A0, 0(S0)
9D013AD0  26100001   ADDIU S0, S0, 1
9D013AD4  1611FFFC   BNE S0, S1, 0x9D013AC8
9D013AD8  00000000   NOP
166:                     _sram_deselect();
9D013ADC  24030001   ADDIU V1, ZERO, 1
9D013AE0  3C02BF88   LUI V0, -16504
9D013AE4  AC436028   SW V1, 24616(V0)
167:                 }
9D013AE8  8FBF001C   LW RA, 28(SP)
9D013AEC  8FB20018   LW S2, 24(SP)
9D013AF0  8FB10014   LW S1, 20(SP)
9D013AF4  8FB00010   LW S0, 16(SP)
9D013AF8  03E00008   JR RA
9D013AFC  27BD0020   ADDIU SP, SP, 32
168:                 
169:                 // sram_write_string()
170:                 //      Write a zero terminated string to SPI RAM
171:                 // input:
172:                 //      addr  Start adress in SPI RAM
173:                 //      *str  Pointer to asciiz string
174:                 // output:
175:                 //      none
176:                 void sram_write_string(unsigned addr, const char *str){
9D013B00  27BDFFE8   ADDIU SP, SP, -24
9D013B04  AFBF0014   SW RA, 20(SP)
9D013B08  AFB00010   SW S0, 16(SP)
9D013B0C  00801021   ADDU V0, A0, ZERO
9D013B10  00A08021   ADDU S0, A1, ZERO
177:                     _sram_select();
9D013B14  24040001   ADDIU A0, ZERO, 1
9D013B18  3C03BF88   LUI V1, -16504
9D013B1C  AC646024   SW A0, 24612(V1)
178:                     sram_cmd(SRAM_WRITE,addr);
9D013B20  24040002   ADDIU A0, ZERO, 2
9D013B24  0F404DEE   JAL sram_cmd
9D013B28  00402821   ADDU A1, V0, ZERO
179:                     while (*str) writeSPI(*str++);
9D013B2C  82040000   LB A0, 0(S0)
9D013B30  10800006   BEQ A0, ZERO, 0x9D013B4C
9D013B34  26100001   ADDIU S0, S0, 1
9D013B38  0F407642   JAL writeSPI
9D013B3C  308400FF   ANDI A0, A0, 255
9D013B40  82040000   LB A0, 0(S0)
9D013B44  1480FFFC   BNE A0, ZERO, 0x9D013B38
9D013B48  26100001   ADDIU S0, S0, 1
180:                     writeSPI(0);
9D013B4C  0F407642   JAL writeSPI
9D013B50  00002021   ADDU A0, ZERO, ZERO
181:                     _sram_deselect();
9D013B54  24030001   ADDIU V1, ZERO, 1
9D013B58  3C02BF88   LUI V0, -16504
9D013B5C  AC436028   SW V1, 24616(V0)
182:                 }
9D013B60  8FBF0014   LW RA, 20(SP)
9D013B64  8FB00010   LW S0, 16(SP)
9D013B68  03E00008   JR RA
9D013B6C  27BD0018   ADDIU SP, SP, 24
183:                 
184:                 // sram_read_string()
185:                 //      Read a asciiz str from SPI RAM
186:                 // input:
187:                 //      addr Adresse to read from.
188:                 //      *buffer Buffer to receive str.
189:                 //      size  Maximum length to read.
190:                 // output:
191:                 //      len  Length of string read
192:                 int sram_read_string(unsigned addr, char *buffer,unsigned size){
9D013B70  27BDFFD0   ADDIU SP, SP, -48
9D013B74  AFBF002C   SW RA, 44(SP)
9D013B78  AFB50028   SW S5, 40(SP)
9D013B7C  AFB40024   SW S4, 36(SP)
9D013B80  AFB30020   SW S3, 32(SP)
9D013B84  AFB2001C   SW S2, 28(SP)
9D013B88  AFB10018   SW S1, 24(SP)
9D013B8C  AFB00014   SW S0, 20(SP)
9D013B90  00801021   ADDU V0, A0, ZERO
9D013B94  00A09821   ADDU S3, A1, ZERO
9D013B98  00C0A821   ADDU S5, A2, ZERO
193:                     int i=0;
9D013BC0  0B404EF5   J 0x9D013BD4
9D013BC4  00008021   ADDU S0, ZERO, ZERO
9D013C20  0B404F00   J 0x9D013C00
9D013C24  00008021   ADDU S0, ZERO, ZERO
194:                 
195:                     _sram_select();
9D013B9C  24040001   ADDIU A0, ZERO, 1
9D013BA0  3C03BF88   LUI V1, -16504
9D013BA4  AC646024   SW A0, 24612(V1)
196:                     sram_cmd(SRAM_READ,addr);
9D013BA8  24040003   ADDIU A0, ZERO, 3
9D013BAC  0F404DEE   JAL sram_cmd
9D013BB0  00402821   ADDU A1, V0, ZERO
197:                     while (i<size && (buffer[i]=writeSPI(0xff))) i++;
9D013BB4  12A00017   BEQ S5, ZERO, 0x9D013C14
9D013BB8  02A0A021   ADDU S4, S5, ZERO
9D013BBC  00008821   ADDU S1, ZERO, ZERO
9D013BC8  26100001   ADDIU S0, S0, 1
9D013BCC  12140007   BEQ S0, S4, 0x9D013BEC
9D013BD0  02008821   ADDU S1, S0, ZERO
9D013BD4  02719021   ADDU S2, S3, S1
9D013BD8  0F407642   JAL writeSPI
9D013BDC  240400FF   ADDIU A0, ZERO, 255
9D013BE0  7C021420   SEB V0, V0
9D013BE4  1440FFF8   BNE V0, ZERO, 0x9D013BC8
9D013BE8  A2420000   SB V0, 0(S2)
198:                     _sram_deselect();
9D013BEC  24030001   ADDIU V1, ZERO, 1
9D013BF0  3C02BF88   LUI V0, -16504
9D013BF4  AC436028   SW V1, 24616(V0)
9D013C14  24030001   ADDIU V1, ZERO, 1
9D013C18  3C02BF88   LUI V0, -16504
9D013C1C  AC436028   SW V1, 24616(V0)
199:                     if (i==size)buffer[--i]=0;
9D013BF8  5635000B   BNEL S1, S5, 0x9D013C28
9D013BFC  2602FFFF   ADDIU V0, S0, -1
9D013C00  2610FFFF   ADDIU S0, S0, -1
9D013C04  02709821   ADDU S3, S3, S0
9D013C08  A2600000   SB ZERO, 0(S3)
200:                     return --i;
9D013C0C  0B404F0A   J 0x9D013C28
9D013C10  2602FFFF   ADDIU V0, S0, -1
201:                 }
9D013C28  8FBF002C   LW RA, 44(SP)
9D013C2C  8FB50028   LW S5, 40(SP)
9D013C30  8FB40024   LW S4, 36(SP)
9D013C34  8FB30020   LW S3, 32(SP)
9D013C38  8FB2001C   LW S2, 28(SP)
9D013C3C  8FB10018   LW S1, 24(SP)
9D013C40  8FB00014   LW S0, 20(SP)
9D013C44  03E00008   JR RA
9D013C48  27BD0030   ADDIU SP, SP, 48
202:                 
203:                 static void move_up(unsigned dest,unsigned src, unsigned size){
204:                 #define BUF_SIZE (64)
205:                     
206:                     uint8_t buf[BUF_SIZE];
207:                     unsigned count;
208:                     while (size){
9D013C7C  10C0002B   BEQ A2, ZERO, 0x9D013D2C
9D013CBC  1600FFF1   BNE S0, ZERO, 0x9D013C84
209:                         count=min(BUF_SIZE,size);
9D013C84  2E110041   SLTIU S1, S0, 65
210:                         sram_read_block(src,buf,count);
9D013C94  02402021   ADDU A0, S2, ZERO
211:                         sram_write_block(dest,buf,count);
9D013CA4  02602021   ADDU A0, S3, ZERO
212:                         size-=count;
9D013CB4  02118023   SUBU S0, S0, S1
213:                         src+=count;
9D013CB8  02519021   ADDU S2, S2, S1
9D013CBC  1600FFF1   BNE S0, ZERO, 0x9D013C84
9D013CC0  02719821   ADDU S3, S3, S1
214:                         dest+=count;
215:                     }
216:                 }
217:                 
218:                 static void move_down(unsigned dest,unsigned src, unsigned size){
219:                 #define BUF_SIZE (64)
220:                     uint8_t buf[BUF_SIZE];
221:                     unsigned count;
222:                     
223:                     dest+=size;
9D013CD8  00869821   ADDU S3, A0, A2
224:                     src+=size;
225:                     while (size){
9D013CDC  10C00014   BEQ A2, ZERO, 0x9D013D30
9D013D24  1600FFF1   BNE S0, ZERO, 0x9D013CEC
226:                         count=min(BUF_SIZE,size);
9D013CE4  24140040   ADDIU S4, ZERO, 64
227:                         sram_read_block(src-count,buf,count);
9D013CF8  02429023   SUBU S2, S2, V0
228:                         sram_write_block(dest-count,buf,count);
9D013D0C  02719823   SUBU S3, S3, S1
229:                         size-=count;
9D013D20  02118023   SUBU S0, S0, S1
9D013D24  1600FFF1   BNE S0, ZERO, 0x9D013CEC
9D013D28  2E110041   SLTIU S1, S0, 65
230:                         src-=count;
231:                         dest-=count;
232:                     }
233:                 }
234:                 
235:                 // sram_move()
236:                 //  move a block from src to dest.
237:                 // input:
238:                 //  dest    address destination
239:                 //  src     address source   
240:                 //  size    count of bytes to move
241:                 void sram_move(unsigned dest, unsigned src, unsigned size){
9D013C4C  27BDFF98   ADDIU SP, SP, -104
9D013C50  AFBF0064   SW RA, 100(SP)
9D013C54  AFB40060   SW S4, 96(SP)
9D013C58  AFB3005C   SW S3, 92(SP)
9D013C5C  AFB20058   SW S2, 88(SP)
9D013C60  AFB10054   SW S1, 84(SP)
9D013C64  AFB00050   SW S0, 80(SP)
9D013C68  00809821   ADDU S3, A0, ZERO
9D013C6C  00A09021   ADDU S2, A1, ZERO
242:                     if (dest<src){
9D013C70  0085102B   SLTU V0, A0, A1
9D013C74  10400015   BEQ V0, ZERO, 0x9D013CCC
9D013C78  00C08021   ADDU S0, A2, ZERO
243:                         move_up(dest,src,size);
244:                     }else if (dest>src){
9D013CCC  00A4102B   SLTU V0, A1, A0
9D013CD0  10400017   BEQ V0, ZERO, 0x9D013D30
9D013CD4  8FBF0064   LW RA, 100(SP)
245:                         move_down(dest,src,size);
246:                     }
247:                 }
9D013CC4  0B404F4C   J 0x9D013D30
9D013CC8  8FBF0064   LW RA, 100(SP)
9D013D2C  8FBF0064   LW RA, 100(SP)
9D013D30  8FB40060   LW S4, 96(SP)
9D013D34  8FB3005C   LW S3, 92(SP)
9D013D38  8FB20058   LW S2, 88(SP)
9D013D3C  8FB10054   LW S1, 84(SP)
9D013D40  8FB00050   LW S0, 80(SP)
9D013D44  03E00008   JR RA
9D013D48  27BD0068   ADDIU SP, SP, 104
---  /home/jacques/github/vpc-32vga/hardware/sound/sound.c  ---------------------------------------------
1:                   /*
2:                   * Copyright 2013,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   sound.c
20:                   * Author: Jacques Deschênes
21:                   *
22:                   * Created on 13 septembre 2013, 20:42
23:                   * rev: 2017-07-31
24:                   */
25:                  
26:                  
27:                  #include <plib.h>
28:                  #include "../HardwareProfile.h"
29:                  #include "sound.h"
30:                  
31:                  
32:                  volatile unsigned char fSound=0; // flags
33:                  volatile unsigned int duration;
34:                  volatile static unsigned int *tones_list;
35:                  
36:                  int sound_init(){
37:                      OC3CONbits.OCM = 5; // PWM mode
9D0181BC  3C02BF80   LUI V0, -16512
9D0181C0  94433400   LHU V1, 13312(V0)
9D0181C4  24040005   ADDIU A0, ZERO, 5
9D0181C8  7C831004   INS V1, A0, 0, 3
9D0181CC  A4433400   SH V1, 13312(V0)
38:                      OC3CONbits.OCTSEL=1; // use TIMER3
9D0181D0  94433400   LHU V1, 13312(V0)
9D0181D4  24040001   ADDIU A0, ZERO, 1
9D0181D8  7C8318C4   INS V1, A0, 3, 1
9D0181DC  A4433400   SH V1, 13312(V0)
39:                      T3CON=(3<<4); // timer 3 prescale 1/8.
9D0181E0  24030030   ADDIU V1, ZERO, 48
9D0181E4  3C02BF80   LUI V0, -16512
9D0181E8  AC430A00   SW V1, 2560(V0)
40:                      IPC3bits.T3IP=2; // timer interrupt priority
9D0181EC  3C02BF88   LUI V0, -16504
9D0181F0  8C4310C0   LW V1, 4288(V0)
9D0181F4  24040002   ADDIU A0, ZERO, 2
9D0181F8  7C832084   INS V1, A0, 2, 3
9D0181FC  AC4310C0   SW V1, 4288(V0)
41:                      IPC3bits.T3IS=0; // sub-priority
9D018200  8C4310C0   LW V1, 4288(V0)
9D018204  7C030804   INS V1, ZERO, 0, 2
9D018208  AC4310C0   SW V1, 4288(V0)
42:                      return 0;
43:                  }
9D01820C  03E00008   JR RA
9D018210  00001021   ADDU V0, ZERO, ZERO
44:                  
45:                  void tone(unsigned int freq, // frequency hertz
46:                            unsigned int msec){ // duration  milliseconds
47:                          //config OC3 for tone generation
48:                          OC3RS=0;
9D018214  3C02BF80   LUI V0, -16512
9D018218  AC403420   SW ZERO, 13344(V0)
49:                          T3CONbits.ON=0;
9D01821C  3C02BF80   LUI V0, -16512
9D018220  94430A00   LHU V1, 2560(V0)
9D018224  7C037BC4   INS V1, ZERO, 15, 1
9D018228  A4430A00   SH V1, 2560(V0)
50:                          PR3=(SYSCLK/8/freq)-1; // 50% duty cycle
9D01822C  3C03004C   LUI V1, 76
9D018230  24634B40   ADDIU V1, V1, 19264
9D018234  0064001B   DIVU V1, A0
9D018238  008001F4   TEQ A0, ZERO
9D01823C  00001812   MFLO V1
9D018240  2463FFFF   ADDIU V1, V1, -1
9D018244  3C06BF80   LUI A2, -16512
9D018248  ACC30A20   SW V1, 2592(A2)
51:                          OC3R=SYSCLK/16/freq;
9D01824C  3C030026   LUI V1, 38
9D018250  246325A0   ADDIU V1, V1, 9632
9D018254  0064001B   DIVU V1, A0
9D018258  008001F4   TEQ A0, ZERO
9D01825C  00002012   MFLO A0
9D018260  3C06BF80   LUI A2, -16512
9D018264  ACC43410   SW A0, 13328(A2)
52:                          duration=msec;
9D018268  AF8580AC   SW A1, -32596(GP)
53:                          fSound |=TONE_ON;
9D01826C  93838038   LBU V1, -32712(GP)
9D018270  306300FF   ANDI V1, V1, 255
9D018274  34630001   ORI V1, V1, 1
9D018278  A3838038   SB V1, -32712(GP)
54:                          mTone_on();
9D01827C  3C03BF80   LUI V1, -16512
9D018280  94653400   LHU A1, 13312(V1)
9D018284  24040001   ADDIU A0, ZERO, 1
9D018288  7C857BC4   INS A1, A0, 15, 1
9D01828C  A4653400   SH A1, 13312(V1)
55:                          T3CONbits.ON=1;
9D018290  94430A00   LHU V1, 2560(V0)
9D018294  7C837BC4   INS V1, A0, 15, 1
9D018298  A4430A00   SH V1, 2560(V0)
9D01829C  03E00008   JR RA
9D0182A0  00000000   NOP
56:                  } //tone();
57:                  
58:                  // play a sequence of tones
59:                  void tune(const unsigned int *buffer){
9D0182BC  27BDFFE8   ADDIU SP, SP, -24
9D0182C0  AFBF0014   SW RA, 20(SP)
60:                      if (*buffer && *(buffer+1)){
9D0182A4  8C820000   LW V0, 0(A0)
9D0182A8  1040001A   BEQ V0, ZERO, 0x9D018314
9D0182AC  00000000   NOP
9D0182B0  8C820004   LW V0, 4(A0)
9D0182B4  10400017   BEQ V0, ZERO, 0x9D018314
9D0182B8  3C02BF88   LUI V0, -16504
61:                          tones_list=(unsigned int *)buffer;
62:                          IFS0bits.T3IF=0;
9D0182C4  8C431030   LW V1, 4144(V0)
9D0182C8  7C037384   INS V1, ZERO, 14, 1
9D0182CC  AC431030   SW V1, 4144(V0)
63:                          IEC0bits.T3IE=1;
9D0182D0  3C02BF88   LUI V0, -16504
9D0182D4  8C431060   LW V1, 4192(V0)
9D0182D8  24050001   ADDIU A1, ZERO, 1
9D0182DC  7CA37384   INS V1, A1, 14, 1
9D0182E0  AC431060   SW V1, 4192(V0)
64:                          fSound |= PLAY_TUNE;
9D0182E4  93828038   LBU V0, -32712(GP)
9D0182E8  304200FF   ANDI V0, V0, 255
9D0182EC  34420002   ORI V0, V0, 2
9D0182F0  A3828038   SB V0, -32712(GP)
65:                          tone(*tones_list++,*tones_list++);
9D0182F4  8C820000   LW V0, 0(A0)
9D0182F8  24830008   ADDIU V1, A0, 8
9D0182FC  AF838034   SW V1, -32716(GP)
9D018300  8C850004   LW A1, 4(A0)
9D018304  0F406085   JAL tone
9D018308  00402021   ADDU A0, V0, ZERO
66:                      }
67:                  }//tune()
9D01830C  8FBF0014   LW RA, 20(SP)
9D018310  27BD0018   ADDIU SP, SP, 24
9D018314  03E00008   JR RA
9D018318  00000000   NOP
68:                  
69:                  
70:                  // TIMER3 interrupt service routine
71:                  // select next note to play
72:                  void __ISR(_TIMER_3_VECTOR, IPL2SOFT)  T3Handler(void){
9D01831C  415DE800   RDPGPR SP, SP
9D018320  401A7000   MFC0 K0, EPC
9D018324  401B6000   MFC0 K1, Status
9D018328  27BDFF90   ADDIU SP, SP, -112
9D01832C  AFBA006C   SW K0, 108(SP)
9D018330  401A6002   MFC0 K0, SRSCtl
9D018334  AFBB0068   SW K1, 104(SP)
9D018338  AFBA0064   SW K0, 100(SP)
9D01833C  7C1B7844   INS K1, ZERO, 1, 15
9D018340  377B0800   ORI K1, K1, 2048
9D018344  409B6000   MTC0 K1, Status
9D018348  AFBF0054   SW RA, 84(SP)
9D01834C  AFB90050   SW T9, 80(SP)
9D018350  AFB8004C   SW T8, 76(SP)
9D018354  AFAF0048   SW T7, 72(SP)
9D018358  AFAE0044   SW T6, 68(SP)
9D01835C  AFAD0040   SW T5, 64(SP)
9D018360  AFAC003C   SW T4, 60(SP)
9D018364  AFAB0038   SW T3, 56(SP)
9D018368  AFAA0034   SW T2, 52(SP)
9D01836C  AFA90030   SW T1, 48(SP)
9D018370  AFA8002C   SW T0, 44(SP)
9D018374  AFA70028   SW A3, 40(SP)
9D018378  AFA60024   SW A2, 36(SP)
9D01837C  AFA50020   SW A1, 32(SP)
9D018380  AFA4001C   SW A0, 28(SP)
9D018384  AFA30018   SW V1, 24(SP)
9D018388  AFA20014   SW V0, 20(SP)
9D01838C  AFA10010   SW AT, 16(SP)
9D018390  00001012   MFLO V0
9D018394  AFA2005C   SW V0, 92(SP)
9D018398  00001810   MFHI V1
9D01839C  AFA30058   SW V1, 88(SP)
73:                      unsigned int f,d;
74:                         mT3ClearIntFlag();
9D0183A0  24034000   ADDIU V1, ZERO, 16384
9D0183A4  3C02BF88   LUI V0, -16504
9D0183A8  AC431034   SW V1, 4148(V0)
75:                         if ((fSound&(TONE_ON|PLAY_TUNE))==PLAY_TUNE){
9D0183AC  93838038   LBU V1, -32712(GP)
9D0183B0  30630003   ANDI V1, V1, 3
9D0183B4  24020002   ADDIU V0, ZERO, 2
9D0183B8  14620020   BNE V1, V0, 0x9D01843C
9D0183BC  8F828034   LW V0, -32716(GP)
76:                             f=*tones_list++;
9D0183C0  8C440000   LW A0, 0(V0)
77:                             d=*tones_list++;
9D0183C4  24430008   ADDIU V1, V0, 8
9D0183C8  AF838034   SW V1, -32716(GP)
9D0183CC  8C450004   LW A1, 4(V0)
78:                             if (d){
9D0183D0  10A0000F   BEQ A1, ZERO, 0x9D018410
9D0183D4  00000000   NOP
79:                                  if (f){
9D0183D8  10800005   BEQ A0, ZERO, 0x9D0183F0
9D0183DC  00000000   NOP
80:                                      tone(f,d);
9D0183E0  0F406085   JAL tone
9D0183E4  00000000   NOP
9D0183E8  0B40610F   J 0x9D01843C
9D0183EC  00000000   NOP
81:                                  }else{
82:                                      duration=(*tones_list);
9D0183F0  8C420008   LW V0, 8(V0)
9D0183F4  AF8280AC   SW V0, -32596(GP)
83:                                      fSound |= TONE_ON;
9D0183F8  93828038   LBU V0, -32712(GP)
9D0183FC  304200FF   ANDI V0, V0, 255
9D018400  34420001   ORI V0, V0, 1
9D018404  A3828038   SB V0, -32712(GP)
9D018408  0B40610F   J 0x9D01843C
9D01840C  00000000   NOP
84:                                  }
85:                              }else{
86:                                 fSound&=~PLAY_TUNE;
9D018410  93828038   LBU V0, -32712(GP)
9D018414  304200FD   ANDI V0, V0, 253
9D018418  A3828038   SB V0, -32712(GP)
87:                                 IEC0bits.T3IE=0;
9D01841C  3C02BF88   LUI V0, -16504
9D018420  8C431060   LW V1, 4192(V0)
9D018424  7C037384   INS V1, ZERO, 14, 1
9D018428  AC431060   SW V1, 4192(V0)
88:                                 T3CONbits.ON=0;
9D01842C  3C02BF80   LUI V0, -16512
9D018430  94430A00   LHU V1, 2560(V0)
9D018434  7C037BC4   INS V1, ZERO, 15, 1
9D018438  A4430A00   SH V1, 2560(V0)
89:                             } // if 
90:                         }//if 
91:                  }// T3Handler
9D01843C  8FA2005C   LW V0, 92(SP)
9D018440  00400013   MTLO V0
9D018444  8FA30058   LW V1, 88(SP)
9D018448  00600011   MTHI V1
9D01844C  8FBF0054   LW RA, 84(SP)
9D018450  8FB90050   LW T9, 80(SP)
9D018454  8FB8004C   LW T8, 76(SP)
9D018458  8FAF0048   LW T7, 72(SP)
9D01845C  8FAE0044   LW T6, 68(SP)
9D018460  8FAD0040   LW T5, 64(SP)
9D018464  8FAC003C   LW T4, 60(SP)
9D018468  8FAB0038   LW T3, 56(SP)
9D01846C  8FAA0034   LW T2, 52(SP)
9D018470  8FA90030   LW T1, 48(SP)
9D018474  8FA8002C   LW T0, 44(SP)
9D018478  8FA70028   LW A3, 40(SP)
9D01847C  8FA60024   LW A2, 36(SP)
9D018480  8FA50020   LW A1, 32(SP)
9D018484  8FA4001C   LW A0, 28(SP)
9D018488  8FA30018   LW V1, 24(SP)
9D01848C  8FA20014   LW V0, 20(SP)
9D018490  8FA10010   LW AT, 16(SP)
9D018494  41606000   DI ZERO
9D018498  000000C0   EHB
9D01849C  8FBA006C   LW K0, 108(SP)
9D0184A0  8FBB0068   LW K1, 104(SP)
9D0184A4  409A7000   MTC0 K0, EPC
9D0184A8  8FBA0064   LW K0, 100(SP)
9D0184AC  27BD0070   ADDIU SP, SP, 112
9D0184B0  409A6002   MTC0 K0, SRSCtl
9D0184B4  41DDE800   WRPGPR SP, SP
9D0184B8  409B6000   MTC0 K1, Status
9D0184BC  42000018   ERET
---  /home/jacques/github/vpc-32vga/hardware/serial_comm/serial_comm.c  ---------------------------------
1:                   /*
2:                   * Copyright 2013,2017 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * File:   uart.h
20:                   * Author: Jacques Deschênes
21:                   * Description: fonctions de bas niveau pour communication UART avec le PC
22:                   * Created on 17 avril 2013, 14:48
23:                   * rev: 2017-07-321
24:                   */
25:                  
26:                  #include <stdbool.h>
27:                  #include <plib.h>
28:                  #include "serial_comm.h"
29:                  #include "../HardwareProfile.h"
30:                  
31:                  #define QUEUE_SIZE (32)
32:                  
33:                  volatile static int head,tail,count;
34:                  volatile static char rx_queue[QUEUE_SIZE];
35:                  volatile static bool rx_off;
36:                  
37:                  // ajuste la vitesse de transmission du port sériel.
38:                  void ser_set_baud(int baudrate){
9D015224  27BDFFE8   ADDIU SP, SP, -24
9D015228  AFBF0014   SW RA, 20(SP)
9D01522C  00803021   ADDU A2, A0, ZERO
39:                     UARTSetDataRate(SERIO, mGetPeripheralClock(), baudrate);
9D015230  24040001   ADDIU A0, ZERO, 1
9D015234  3C050262   LUI A1, 610
9D015238  0F407A39   JAL UARTSetDataRate
9D01523C  24A55A00   ADDIU A1, A1, 23040
40:                  }
9D015240  8FBF0014   LW RA, 20(SP)
9D015244  03E00008   JR RA
9D015248  27BD0018   ADDIU SP, SP, 24
41:                  
42:                  
43:                  // serial port config
44:                  int ser_init(int baudrate, UART_LINE_CONTROL_MODE LineCtrl){
9D01524C  27BDFFE8   ADDIU SP, SP, -24
9D015250  AFBF0014   SW RA, 20(SP)
9D015254  00803021   ADDU A2, A0, ZERO
45:                  //   UARTConfigure(SERIO, UART_ENABLE_PINS_TX_RX_ONLY); // no hardware control.
46:                  //   UARTSetLineControl(SERIO, LineCtrl);
47:                     UARTSetDataRate(SERIO, mGetPeripheralClock(), baudrate);
9D015258  24040001   ADDIU A0, ZERO, 1
9D01525C  3C050262   LUI A1, 610
9D015260  0F407A39   JAL UARTSetDataRate
9D015264  24A55A00   ADDIU A1, A1, 23040
48:                     // enable peripheral
49:                  //   UARTEnable(SERIO, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
50:                     U2RXR=3; // RX on PB11
9D015268  24040003   ADDIU A0, ZERO, 3
9D01526C  3C02BF81   LUI V0, -16511
9D015270  AC44FA58   SW A0, -1448(V0)
51:                     RPB10R=2; // TX on PB10
9D015274  24030002   ADDIU V1, ZERO, 2
9D015278  3C02BF81   LUI V0, -16511
9D01527C  AC43FB54   SW V1, -1196(V0)
52:                     U2STA=(1<<10)|(1<<12); //RXEN|TXEN
9D015280  24031400   ADDIU V1, ZERO, 5120
9D015284  3C02BF80   LUI V0, -16512
9D015288  AC436210   SW V1, 25104(V0)
53:                     head=0;
9D01528C  AF808030   SW ZERO, -32720(GP)
54:                     tail=0;
9D015290  AF80802C   SW ZERO, -32724(GP)
55:                     count=0;
9D015294  AF808028   SW ZERO, -32728(GP)
56:                     // activation interruption sur réception ou erreur réception.
57:                     IPC9bits.U2IP=3;
9D015298  3C02BF88   LUI V0, -16504
9D01529C  8C431120   LW V1, 4384(V0)
9D0152A0  7C836284   INS V1, A0, 10, 3
9D0152A4  AC431120   SW V1, 4384(V0)
58:                     IPC9bits.U2IS=0;
9D0152A8  8C431120   LW V1, 4384(V0)
9D0152AC  7C034A04   INS V1, ZERO, 8, 2
9D0152B0  AC431120   SW V1, 4384(V0)
59:                     IFS1bits.U2EIF=0;
9D0152B4  3C02BF88   LUI V0, -16504
9D0152B8  8C431040   LW V1, 4160(V0)
9D0152BC  7C03AD44   INS V1, ZERO, 21, 1
9D0152C0  AC431040   SW V1, 4160(V0)
60:                     IFS1bits.U2RXIF=0;
9D0152C4  8C431040   LW V1, 4160(V0)
9D0152C8  7C03B584   INS V1, ZERO, 22, 1
9D0152CC  AC431040   SW V1, 4160(V0)
61:                     IEC1bits.U2EIE=1;
9D0152D0  3C02BF88   LUI V0, -16504
9D0152D4  8C441070   LW A0, 4208(V0)
9D0152D8  24030001   ADDIU V1, ZERO, 1
9D0152DC  7C64AD44   INS A0, V1, 21, 1
9D0152E0  AC441070   SW A0, 4208(V0)
62:                     IEC1bits.U2RXIE=1;
9D0152E4  8C441070   LW A0, 4208(V0)
9D0152E8  7C64B584   INS A0, V1, 22, 1
9D0152EC  AC441070   SW A0, 4208(V0)
63:                     U2MODEbits.ON=1;
9D0152F0  3C02BF80   LUI V0, -16512
9D0152F4  94446200   LHU A0, 25088(V0)
9D0152F8  7C647BC4   INS A0, V1, 15, 1
9D0152FC  A4446200   SH A0, 25088(V0)
64:                     UARTSendDataByte(SERIO,FF);
65:                     return 0;
66:                  };
9D015310  00001021   ADDU V0, ZERO, ZERO
9D015314  8FBF0014   LW RA, 20(SP)
9D015318  03E00008   JR RA
9D01531C  27BD0018   ADDIU SP, SP, 24
67:                  
68:                  // get character from serial port
69:                  // return 0 if none available
70:                  char ser_get_char(){
71:                      char c=0;
72:                      if (count){
9D015320  8F828028   LW V0, -32728(GP)
9D015324  50400015   BEQL V0, ZERO, 0x9D01537C
9D015328  3C02BF88   LUI V0, -16504
73:                          c=rx_queue[head++];
9D01532C  8F828030   LW V0, -32720(GP)
9D015330  24430001   ADDIU V1, V0, 1
9D015334  AF838030   SW V1, -32720(GP)
9D015338  3C03A000   LUI V1, -24576
9D01533C  24634578   ADDIU V1, V1, 17784
9D015340  00431021   ADDU V0, V0, V1
9D015344  90420000   LBU V0, 0(V0)
9D015348  7C021420   SEB V0, V0
74:                          head%=QUEUE_SIZE;
9D01534C  8F848030   LW A0, -32720(GP)
9D015350  00041FC3   SRA V1, A0, 31
9D015354  00031EC2   SRL V1, V1, 27
9D015358  00832021   ADDU A0, A0, V1
9D01535C  3084001F   ANDI A0, A0, 31
9D015360  00831823   SUBU V1, A0, V1
9D015364  AF838030   SW V1, -32720(GP)
75:                          count--;
9D015368  8F838028   LW V1, -32728(GP)
9D01536C  2463FFFF   ADDIU V1, V1, -1
9D015370  AF838028   SW V1, -32728(GP)
9D015374  03E00008   JR RA
9D015378  00000000   NOP
76:                      }else{
77:                          IEC1bits.U2RXIE=0;
9D01537C  8C431070   LW V1, 4208(V0)
9D015380  7C03B584   INS V1, ZERO, 22, 1
9D015384  AC431070   SW V1, 4208(V0)
78:                          if (rx_off){
9D015388  93828024   LBU V0, -32732(GP)
9D01538C  304200FF   ANDI V0, V0, 255
9D015390  50400007   BEQL V0, ZERO, 0x9D0153B0
9D015394  3C02BF88   LUI V0, -16504
79:                              UARTSendDataByte(SERIO, XON);
80:                              rx_off=false;
9D0153A8  A3808024   SB ZERO, -32732(GP)
81:                          }
82:                          IEC1bits.U2RXIE=1;
9D0153AC  3C02BF88   LUI V0, -16504
9D0153B0  8C431070   LW V1, 4208(V0)
9D0153B4  24040001   ADDIU A0, ZERO, 1
9D0153B8  7C83B584   INS V1, A0, 22, 1
9D0153BC  AC431070   SW V1, 4208(V0)
83:                      }
84:                      return c;
85:                  };
9D0153C0  03E00008   JR RA
9D0153C4  00001021   ADDU V0, ZERO, ZERO
86:                  
87:                  // Attend un caractère du port sériel
88:                  char ser_wait_char(){
9D0153C8  27BDFFE8   ADDIU SP, SP, -24
9D0153CC  AFBF0014   SW RA, 20(SP)
89:                      char c;
90:                      while (!(c=ser_get_char()));
9D0153D0  0F4054C8   JAL ser_get_char
9D0153D4  00000000   NOP
9D0153D8  1040FFFD   BEQ V0, ZERO, 0x9D0153D0
9D0153DC  8FBF0014   LW RA, 20(SP)
91:                      return c;
92:                  }
9D0153E0  03E00008   JR RA
9D0153E4  27BD0018   ADDIU SP, SP, 24
93:                  
94:                  // send a character to serial port
95:                  void ser_put_char(char c){
96:                      while(!UARTTransmitterIsReady(SERIO));
9D0153F8  1440FFFD   BNE V0, ZERO, 0x9D0153F0
9D0153FC  00000000   NOP
97:                        UARTSendDataByte(SERIO, c);
98:                  };
99:                  
100:                 // send a string to serial port.
101:                 void ser_print(const char* str){
102:                    while(*str != (char)0)
9D015410  80850000   LB A1, 0(A0)
9D015414  10A0000C   BEQ A1, ZERO, ser_print::UARTTransmissionHasCompleted
9D015418  3C029D02   LUI V0, -25342
9D01543C  80850000   LB A1, 0(A0)
9D015440  14A0FFF7   BNE A1, ZERO, 0x9D015420
9D015444  00000000   NOP
103:                    {
104:                       while(!UARTTransmitterIsReady(SERIO));
9D015428  1440FFFD   BNE V0, ZERO, 0x9D015420
9D01542C  00000000   NOP
105:                       UARTSendDataByte(SERIO, *str++);
9D015430  24840001   ADDIU A0, A0, 1
106:                    }
107:                    while(!UARTTransmissionHasCompleted(SERIO));
9D015458  1040FFFD   BEQ V0, ZERO, 0x9D015450
9D01545C  00000000   NOP
108:                 };
9D015460  03E00008   JR RA
9D015464  00000000   NOP
109:                 
110:                 // read a line from serial port
111:                 int ser_read_line(char *buffer, int buff_len){
9D015468  27BDFFD0   ADDIU SP, SP, -48
9D01546C  AFBF002C   SW RA, 44(SP)
9D015470  AFB60028   SW S6, 40(SP)
9D015474  AFB50024   SW S5, 36(SP)
9D015478  AFB40020   SW S4, 32(SP)
9D01547C  AFB3001C   SW S3, 28(SP)
9D015480  AFB20018   SW S2, 24(SP)
9D015484  AFB10014   SW S1, 20(SP)
9D015488  AFB00010   SW S0, 16(SP)
9D01548C  00808821   ADDU S1, A0, ZERO
112:                     int count=0;
9D01549C  00008021   ADDU S0, ZERO, ZERO
9D015520  00008021   ADDU S0, ZERO, ZERO
113:                     char c;
114:                     BOOL loop=TRUE;
115:                     
116:                     *buffer=(char)0;
117:                     while (loop && (count < (buff_len-1))){
9D015490  24B5FFFF   ADDIU S5, A1, -1
9D015494  1AA00022   BLEZ S5, 0x9D015520
9D015498  A0800000   SB ZERO, 0(A0)
9D0154F0  0B405544   J 0x9D015510
9D0154F4  0215102A   SLT V0, S0, S5
9D01550C  0215102A   SLT V0, S0, S5
9D015510  1440FFE7   BNE V0, ZERO, 0x9D0154B0
9D015514  00000000   NOP
9D015518  0B40554A   J 0x9D015528
9D01551C  A2200000   SB ZERO, 0(S1)
118:                         switch((c=ser_wait_char())){
9D0154A0  24120008   ADDIU S2, ZERO, 8
9D0154AC  2413000D   ADDIU S3, ZERO, 13
9D0154B0  0F4054F2   JAL ser_wait_char
9D0154B4  00000000   NOP
9D0154B8  10520007   BEQ V0, S2, 0x9D0154D8
9D0154BC  00000000   NOP
9D0154C0  1453000D   BNE V0, S3, 0x9D0154F8
9D0154C4  26340001   ADDIU S4, S1, 1
119:                             case CR:
120:                                 ser_put_char('\r'); 
9D0154C8  0F4054FA   JAL ser_put_char
9D0154CC  2404000D   ADDIU A0, ZERO, 13
121:                                 loop=FALSE;
122:                                 break;
123:                             case BS:
124:                                 if (count){
9D0154D8  1200FFF5   BEQ S0, ZERO, 0x9D0154B0
9D0154DC  00000000   NOP
125:                                     buffer--;
9D0154E0  2631FFFF   ADDIU S1, S1, -1
126:                                     count--;
9D0154E4  2610FFFF   ADDIU S0, S0, -1
127:                                     ser_print("\b \b");
9D0154A4  3C169D02   LUI S6, -25342
9D0154A8  26D6F25C   ADDIU S6, S6, -3492
9D0154E8  0F405504   JAL ser_print
9D0154EC  02C02021   ADDU A0, S6, ZERO
128:                                 }
129:                                 break;
130:                             default:
131:                                 *buffer++=c;
9D0154F8  A2220000   SB V0, 0(S1)
9D015508  02808821   ADDU S1, S4, ZERO
132:                                 count++;
9D0154FC  26100001   ADDIU S0, S0, 1
133:                                 ser_put_char(c);
9D015500  0F4054FA   JAL ser_put_char
9D015504  00402021   ADDU A0, V0, ZERO
134:                         }//swtich
135:                     }//while
136:                     *buffer = (char)0;
9D0154D0  0B40554A   J 0x9D015528
9D0154D4  A2200000   SB ZERO, 0(S1)
9D015524  A2200000   SB ZERO, 0(S1)
137:                     return count;
138:                 }
9D015528  02001021   ADDU V0, S0, ZERO
9D01552C  8FBF002C   LW RA, 44(SP)
9D015530  8FB60028   LW S6, 40(SP)
9D015534  8FB50024   LW S5, 36(SP)
9D015538  8FB40020   LW S4, 32(SP)
9D01553C  8FB3001C   LW S3, 28(SP)
9D015540  8FB20018   LW S2, 24(SP)
9D015544  8FB10014   LW S1, 20(SP)
9D015548  8FB00010   LW S0, 16(SP)
9D01554C  03E00008   JR RA
9D015550  27BD0030   ADDIU SP, SP, 48
139:                 
140:                 void ser_flush_queue(){
141:                     IEC1bits.U2RXIE=0;
9D015554  3C02BF88   LUI V0, -16504
9D015558  8C431070   LW V1, 4208(V0)
9D01555C  7C03B584   INS V1, ZERO, 22, 1
9D015560  AC431070   SW V1, 4208(V0)
142:                     head=0;
9D015564  AF808030   SW ZERO, -32720(GP)
143:                     tail=0;
9D015568  AF80802C   SW ZERO, -32724(GP)
144:                     count=0;
9D01556C  AF808028   SW ZERO, -32728(GP)
145:                     IEC1bits.U2RXIE=1;
9D015570  8C431070   LW V1, 4208(V0)
9D015574  24040001   ADDIU A0, ZERO, 1
9D015578  7C83B584   INS V1, A0, 22, 1
9D01557C  AC431070   SW V1, 4208(V0)
9D015580  03E00008   JR RA
9D015584  00000000   NOP
146:                 }
147:                 
148:                 #define ERROR_BITS (7<<1)
149:                 // interruption sur réception ou erreur réception port sériel.
150:                 void __ISR(_UART_2_VECTOR,IPL3SOFT) serial_rx_isr(void){
9D015588  415DE800   RDPGPR SP, SP
9D01558C  401A7000   MFC0 K0, EPC
9D015590  401B6000   MFC0 K1, Status
9D015594  27BDFFE0   ADDIU SP, SP, -32
9D015598  AFBA001C   SW K0, 28(SP)
9D01559C  401A6002   MFC0 K0, SRSCtl
9D0155A0  AFBB0018   SW K1, 24(SP)
9D0155A4  AFBA0014   SW K0, 20(SP)
9D0155A8  7C1B7844   INS K1, ZERO, 1, 15
9D0155AC  377B0C00   ORI K1, K1, 3072
9D0155B0  409B6000   MTC0 K1, Status
9D0155B4  AFA4000C   SW A0, 12(SP)
9D0155B8  AFA30008   SW V1, 8(SP)
9D0155BC  AFA20004   SW V0, 4(SP)
151:                     if (U2STA&ERROR_BITS){
9D0155C0  3C02BF80   LUI V0, -16512
9D0155C4  8C426210   LW V0, 25104(V0)
9D0155C8  3042000E   ANDI V0, V0, 14
9D0155CC  1040000E   BEQ V0, ZERO, 0x9D015608
9D0155D0  3C02BF80   LUI V0, -16512
152:                         U2MODEbits.ON=0;
9D0155D4  94436200   LHU V1, 25088(V0)
9D0155D8  7C037BC4   INS V1, ZERO, 15, 1
9D0155DC  A4436200   SH V1, 25088(V0)
153:                         U2MODEbits.ON=1;
9D0155E0  94436200   LHU V1, 25088(V0)
9D0155E4  24040001   ADDIU A0, ZERO, 1
9D0155E8  7C837BC4   INS V1, A0, 15, 1
9D0155EC  A4436200   SH V1, 25088(V0)
154:                         IFS1bits.U2EIF=0;
9D0155F0  3C02BF88   LUI V0, -16504
9D0155F4  8C431040   LW V1, 4160(V0)
9D0155F8  7C03AD44   INS V1, ZERO, 21, 1
9D0155FC  AC431040   SW V1, 4160(V0)
9D015600  0B4055A4   J 0x9D015690
9D015604  00000000   NOP
155:                     }else{
156:                         rx_queue[tail++]=U2RXREG;
9D015608  8F82802C   LW V0, -32724(GP)
9D01560C  24430001   ADDIU V1, V0, 1
9D015610  AF83802C   SW V1, -32724(GP)
9D015614  3C03BF80   LUI V1, -16512
9D015618  8C636230   LW V1, 25136(V1)
9D01561C  7C031C20   SEB V1, V1
9D015620  3C04A000   LUI A0, -24576
9D015624  24844578   ADDIU A0, A0, 17784
9D015628  00441021   ADDU V0, V0, A0
9D01562C  A0430000   SB V1, 0(V0)
157:                         tail%=QUEUE_SIZE;
9D015630  8F83802C   LW V1, -32724(GP)
9D015634  000317C3   SRA V0, V1, 31
9D015638  000216C2   SRL V0, V0, 27
9D01563C  00621821   ADDU V1, V1, V0
9D015640  3063001F   ANDI V1, V1, 31
9D015644  00621023   SUBU V0, V1, V0
9D015648  AF82802C   SW V0, -32724(GP)
158:                         count++;
9D01564C  8F828028   LW V0, -32728(GP)
9D015650  24420001   ADDIU V0, V0, 1
9D015654  AF828028   SW V0, -32728(GP)
159:                         if (count>(QUEUE_SIZE/3)){
9D015658  8F828028   LW V0, -32728(GP)
9D01565C  2842000B   SLTI V0, V0, 11
9D015660  14400008   BNE V0, ZERO, 0x9D015684
9D015664  3C02BF88   LUI V0, -16504
160:                             UARTSendDataByte(SERIO,XOFF);
161:                             rx_off=true;
9D015678  24020001   ADDIU V0, ZERO, 1
9D01567C  A3828024   SB V0, -32732(GP)
162:                         }
163:                         IFS1bits.U2RXIF=0;
9D015680  3C02BF88   LUI V0, -16504
9D015684  8C431040   LW V1, 4160(V0)
9D015688  7C03B584   INS V1, ZERO, 22, 1
9D01568C  AC431040   SW V1, 4160(V0)
164:                     }
165:                 } // serial_rx_isr()
9D015690  8FA4000C   LW A0, 12(SP)
166:                 
---  /home/jacques/github/vpc-32vga/hardware/rtcc/rtcc.c  -----------------------------------------------
1:                   /*
2:                    * Real Time Clock Calendar
3:                    * interface avec le composant MCP7940N   
4:                    * Création: 2018-01-29 
5:                    */
6:                   
7:                   #include <stdio.h>
8:                   #include <stdlib.h>
9:                   #include <string.h>
10:                  #include <setjmp.h>
11:                  #include <plib.h>
12:                  
13:                  #include "../HardwareProfile.h"
14:                  #include "rtcc.h"
15:                  #include "../serial_comm/serial_comm.h"
16:                  #include "../ps2_kbd/keyboard.h"
17:                  #include "../tvout/vga.h"
18:                  #include "../sound/sound.h"
19:                  
20:                  
21:                  #define I2C_CTRL_BYTE (0xDE)
22:                  #define RTCC_READ (1)
23:                  #define RTCC_WRITE (0)
24:                  #define _set_scl_high()  RTCC_SCL_LATSET=RTCC_SCL_PIN
25:                  #define _set_scl_low()   RTCC_SCL_LATCLR=RTCC_SCL_PIN
26:                  #define _set_sda_high()  RTCC_SDA_LATSET=RTCC_SDA_PIN
27:                  #define _set_sda_low()   RTCC_SDA_LATCLR=RTCC_SDA_PIN
28:                  #define _set_sda_as_input() RTCC_SDA_TRISSET=RTCC_SDA_PIN
29:                  #define _set_sda_as_output() RTCC_SDA_LATSET=RTCC_SDA_PIN;\
30:                                               RTCC_SDA_TRISCLR=RTCC_SDA_PIN
31:                  
32:                  #define I2C_CLK_PER (5)
33:                  
34:                  BOOL rtcc_error;
35:                  static jmp_buf  env;
36:                  
37:                  // envoie 1 clock pulse I2C
38:                  // condition initiale
39:                  // SCL low
40:                  // SDA x
41:                  // sortie:
42:                  // SCL low
43:                  // SDA x
44:                  static void i2c_clock(){
45:                      asm volatile ("nop\n nop\n nop\n nop");
9D00D1E8  00000000   NOP
9D00D1EC  00000000   NOP
9D00D1F0  00000000   NOP
9D00D1F4  00000000   NOP
46:                      asm volatile ("nop\n nop\n nop\n nop");
9D00D1F8  00000000   NOP
9D00D1FC  00000000   NOP
9D00D200  00000000   NOP
9D00D204  00000000   NOP
47:                      _set_scl_high();
9D00D208  24030001   ADDIU V1, ZERO, 1
9D00D20C  3C02BF88   LUI V0, -16504
9D00D210  AC436138   SW V1, 24888(V0)
48:                      _usec_delay(I2C_CLK_PER);
9D00D214  34080064   ORI T0, ZERO, 100
9D00D218  1500FFFF   BNE T0, ZERO, 0x9D00D218
9D00D21C  2508FFFF   ADDIU T0, T0, -1
49:                      _set_scl_low();
9D00D220  3C02BF88   LUI V0, -16504
9D00D224  AC436134   SW V1, 24884(V0)
50:                      _usec_delay(I2C_CLK_PER);
9D00D228  34080064   ORI T0, ZERO, 100
9D00D22C  1500FFFF   BNE T0, ZERO, 0x9D00D22C
9D00D230  2508FFFF   ADDIU T0, T0, -1
9D00D234  03E00008   JR RA
9D00D238  00000000   NOP
51:                  }
52:                  
53:                  // réception d'un bit
54:                  // condition initiale
55:                  // SCL low
56:                  // SDA x en input mode
57:                  static uint8_t i2c_receive_bit(){
58:                       uint8_t bit;
59:                       
60:                      _set_sda_as_input();
9D00D23C  24030002   ADDIU V1, ZERO, 2
9D00D240  3C02BF88   LUI V0, -16504
9D00D244  AC436018   SW V1, 24600(V0)
61:                      _set_scl_high();
9D00D248  24030001   ADDIU V1, ZERO, 1
9D00D24C  3C02BF88   LUI V0, -16504
9D00D250  AC436138   SW V1, 24888(V0)
62:                      _usec_delay(I2C_CLK_PER);
9D00D254  34080064   ORI T0, ZERO, 100
9D00D258  1500FFFF   BNE T0, ZERO, 0x9D00D258
9D00D25C  2508FFFF   ADDIU T0, T0, -1
63:                      bit=(RTCC_SDA_PORT&RTCC_SDA_PIN)>>RTCC_SDA_SHIFT;
9D00D260  3C02BF88   LUI V0, -16504
9D00D264  8C426020   LW V0, 24608(V0)
64:                      _set_scl_low();
9D00D268  24040001   ADDIU A0, ZERO, 1
9D00D26C  3C03BF88   LUI V1, -16504
9D00D270  AC646134   SW A0, 24884(V1)
65:                      _usec_delay(I2C_CLK_PER);
9D00D274  34080064   ORI T0, ZERO, 100
9D00D278  1500FFFF   BNE T0, ZERO, 0x9D00D278
9D00D27C  2508FFFF   ADDIU T0, T0, -1
66:                      _set_sda_as_output();
9D00D280  24030002   ADDIU V1, ZERO, 2
9D00D284  3C04BF88   LUI A0, -16504
9D00D288  AC836038   SW V1, 24632(A0)
9D00D28C  3C04BF88   LUI A0, -16504
9D00D290  AC836014   SW V1, 24596(A0)
67:                      return bit;
68:                  }
9D00D294  03E00008   JR RA
9D00D298  7C420040   EXT V0, V0, 1, 1
69:                  
70:                  // envoie un bit sur l'interface I2C
71:                  // condition initiale
72:                  // SDA en mode sortie
73:                  // SCL high
74:                  // SDA x
75:                  static void i2c_send_bit(BOOL bit){
76:                      if (bit){
9D00D5B4  02131024   AND V0, S0, S3
77:                          _set_sda_high();
9D00D5B0  3C15BF88   LUI S5, -16504
9D00D5C0  AEB26038   SW S2, 24632(S5)
78:                      }else{
79:                          _set_sda_low();
9D00D38C  3C02BF88   LUI V0, -16504
9D00D5A8  3C14BF88   LUI S4, -16504
9D00D5CC  AE926034   SW S2, 24628(S4)
80:                      }
81:                      i2c_clock();
9D00D394  0F40347A   JAL i2c_clock
9D00D5D0  0F40347A   JAL i2c_clock
9D00D5D4  00108042   SRL S0, S0, 1
9D00D5D8  2631FFFF   ADDIU S1, S1, -1
82:                  }
83:                  
84:                  
85:                  // initialise le bus I2C pour un début de transaction
86:                  // condition initiale
87:                  // SDA high
88:                  // SCL high
89:                  static void i2c_start_bit(){
90:                      _set_sda_high();
9D00D29C  3C03BF88   LUI V1, -16504
9D00D2A0  24020002   ADDIU V0, ZERO, 2
9D00D2A4  AC626038   SW V0, 24632(V1)
91:                      _set_sda_as_output();
9D00D2A8  AC626038   SW V0, 24632(V1)
9D00D2AC  3C03BF88   LUI V1, -16504
9D00D2B0  AC626014   SW V0, 24596(V1)
92:                      _set_scl_high();
9D00D2B4  24030001   ADDIU V1, ZERO, 1
9D00D2B8  3C02BF88   LUI V0, -16504
9D00D2BC  AC436138   SW V1, 24888(V0)
93:                      _usec_delay(1);
9D00D2C0  34080014   ORI T0, ZERO, 20
9D00D2C4  1500FFFF   BNE T0, ZERO, 0x9D00D2C4
9D00D2C8  2508FFFF   ADDIU T0, T0, -1
94:                      _set_sda_low();
9D00D2CC  24030002   ADDIU V1, ZERO, 2
9D00D2D0  3C02BF88   LUI V0, -16504
9D00D2D4  AC436034   SW V1, 24628(V0)
95:                      _usec_delay(I2C_CLK_PER);
9D00D2D8  34080064   ORI T0, ZERO, 100
9D00D2DC  1500FFFF   BNE T0, ZERO, 0x9D00D2DC
9D00D2E0  2508FFFF   ADDIU T0, T0, -1
96:                      _set_scl_low();
9D00D2E4  24030001   ADDIU V1, ZERO, 1
9D00D2E8  3C02BF88   LUI V0, -16504
9D00D2EC  AC436134   SW V1, 24884(V0)
97:                      _usec_delay(I2C_CLK_PER);
9D00D2F0  34080064   ORI T0, ZERO, 100
9D00D2F4  1500FFFF   BNE T0, ZERO, 0x9D00D2F4
9D00D2F8  2508FFFF   ADDIU T0, T0, -1
9D00D2FC  03E00008   JR RA
9D00D300  00000000   NOP
98:                  }
99:                  
100:                 // termine la transaction sur le bus I2C
101:                 // condition initiale
102:                 // SDA x
103:                 // SCL high
104:                 static void i2c_stop_bit(){
105:                     _set_scl_high();
9D00D304  24030001   ADDIU V1, ZERO, 1
9D00D308  3C02BF88   LUI V0, -16504
9D00D30C  AC436138   SW V1, 24888(V0)
106:                     _set_sda_low();
9D00D310  24020002   ADDIU V0, ZERO, 2
9D00D314  3C03BF88   LUI V1, -16504
9D00D318  AC626034   SW V0, 24628(V1)
107:                     _set_sda_as_output();
9D00D31C  3C03BF88   LUI V1, -16504
9D00D320  AC626038   SW V0, 24632(V1)
9D00D324  3C04BF88   LUI A0, -16504
9D00D328  AC826014   SW V0, 24596(A0)
108:                     _set_sda_high();
9D00D32C  AC626038   SW V0, 24632(V1)
109:                     _usec_delay(I2C_CLK_PER);
9D00D330  34080064   ORI T0, ZERO, 100
9D00D334  1500FFFF   BNE T0, ZERO, 0x9D00D334
9D00D338  2508FFFF   ADDIU T0, T0, -1
9D00D33C  03E00008   JR RA
9D00D340  00000000   NOP
110:                 }
111:                 
112:                 // le MCU envoie un ACK bit au MCP7940N
113:                 // condition initiale
114:                 // SCL low
115:                 // SDA x
116:                 static void i2c_send_ack_bit(){
117:                     _set_sda_low();
118:                     i2c_clock();
119:                 }
120:                 
121:                 // retourne le ACK bit envoyé par le MCP7940N
122:                 // doit-être 0.
123:                 // condition initiale
124:                 // SCL low
125:                 // sda x
126:                 static BOOL i2c_receive_ack_bit(){
127:                     BOOL ack;
128:                 
129:                     ack=(BOOL)i2c_receive_bit();
9D00D5E4  0F40348F   JAL i2c_receive_bit
130:                     if (ack){
9D00D5EC  10400005   BEQ V0, ZERO, 0x9D00D604
131:                         longjmp(env,1);
9D00D5F4  3C04A000   LUI A0, -24576
9D00D5F8  248443B0   ADDIU A0, A0, 17328
9D00D5FC  0F407964   JAL longjmp
9D00D600  24050001   ADDIU A1, ZERO, 1
132:                     }
133:                     return ack;
134:                 }
135:                 
136:                 //envoie un octet au MCP7940N
137:                 // condition initiale
138:                 // la condition start est déjà initiée.
139:                 // SCL high
140:                 // SDA x
141:                 static void i2c_send_byte(uint8_t byte){
9D00D57C  27BDFFD0   ADDIU SP, SP, -48
9D00D580  AFBF002C   SW RA, 44(SP)
9D00D584  AFB50028   SW S5, 40(SP)
9D00D588  AFB40024   SW S4, 36(SP)
9D00D58C  AFB30020   SW S3, 32(SP)
9D00D590  AFB2001C   SW S2, 28(SP)
9D00D594  AFB10018   SW S1, 24(SP)
9D00D598  AFB00014   SW S0, 20(SP)
9D00D59C  00809821   ADDU S3, A0, ZERO
9D00D5A0  24110008   ADDIU S1, ZERO, 8
142:                     uint8_t i;
143:                     for (i=128;i;i>>=1){
9D00D5A4  24100080   ADDIU S0, ZERO, 128
9D00D5DC  1620FFF6   BNE S1, ZERO, 0x9D00D5B8
9D00D5E0  02131024   AND V0, S0, S3
144:                         i2c_send_bit(byte&i);
145:                     }
146:                     i2c_receive_ack_bit();
147:                 }
9D00D604  8FB50028   LW S5, 40(SP)
9D00D608  8FB40024   LW S4, 36(SP)
9D00D60C  8FB30020   LW S3, 32(SP)
9D00D610  8FB2001C   LW S2, 28(SP)
9D00D614  8FB10018   LW S1, 24(SP)
9D00D618  8FB00014   LW S0, 20(SP)
9D00D61C  03E00008   JR RA
9D00D620  27BD0030   ADDIU SP, SP, 48
148:                 
149:                 //reçoie un octet du MCP7940N
150:                 // condition initiale
151:                 // le préambule est déjà initiée.
152:                 // SCL high
153:                 // SDA mode entrée
154:                 static uint8_t i2c_receive_byte(BOOL send_ack){
9D00D344  27BDFFE0   ADDIU SP, SP, -32
9D00D348  AFBF001C   SW RA, 28(SP)
9D00D34C  AFB20018   SW S2, 24(SP)
9D00D350  AFB10014   SW S1, 20(SP)
9D00D354  AFB00010   SW S0, 16(SP)
9D00D358  00809021   ADDU S2, A0, ZERO
9D00D35C  24100008   ADDIU S0, ZERO, 8
155:                     uint8_t i, byte=0;
9D00D360  00008821   ADDU S1, ZERO, ZERO
156:                     
157:                     for (i=0;i<8;i++){
9D00D37C  1600FFF9   BNE S0, ZERO, 0x9D00D364
9D00D380  305100FF   ANDI S1, V0, 255
158:                         byte<<=1;
9D00D364  00118840   SLL S1, S1, 1
159:                         byte+=i2c_receive_bit();
9D00D368  0F40348F   JAL i2c_receive_bit
9D00D36C  323100FF   ANDI S1, S1, 255
9D00D370  00511021   ADDU V0, V0, S1
9D00D374  2610FFFF   ADDIU S0, S0, -1
9D00D378  321000FF   ANDI S0, S0, 255
160:                     }
161:                     if (send_ack){
9D00D384  12400007   BEQ S2, ZERO, 0x9D00D3A4
9D00D388  24030002   ADDIU V1, ZERO, 2
162:                         i2c_send_bit(0);
163:                     }else{
164:                         i2c_stop_bit();
9D00D3A4  0F4034C1   JAL i2c_stop_bit
9D00D3A8  00000000   NOP
165:                     }
166:                     return byte;
167:                 }
9D00D39C  0B4034EC   J 0x9D00D3B0
9D00D3A0  02201021   ADDU V0, S1, ZERO
9D00D3AC  02201021   ADDU V0, S1, ZERO
9D00D3B0  8FBF001C   LW RA, 28(SP)
9D00D3B4  8FB20018   LW S2, 24(SP)
9D00D3B8  8FB10014   LW S1, 20(SP)
9D00D3BC  8FB00010   LW S0, 16(SP)
9D00D3C0  03E00008   JR RA
9D00D3C4  27BD0020   ADDIU SP, SP, 32
168:                 
169:                 static uint8_t rtcc_read_next(){
170:                     uint8_t byte;
171:                     rtcc_error=FALSE;
172:                     if (!setjmp(env)){
173:                         i2c_start_bit();
174:                         i2c_send_byte(I2C_CTRL_BYTE|RTCC_READ);
175:                         byte=i2c_receive_byte(FALSE);
176:                         return byte;
177:                     }else{
178:                         i2c_stop_bit();
179:                         rtcc_error=TRUE;
180:                     }
181:                 }
182:                 
183:                 static void rtcc_read_buf(uint8_t addr,uint8_t *buf, uint8_t size){
9D00D718  27BDFFE8   ADDIU SP, SP, -24
9D00D71C  AFBF0014   SW RA, 20(SP)
9D00D720  AFB00010   SW S0, 16(SP)
9D00D724  AFA40018   SW A0, 24(SP)
9D00D728  AFA5001C   SW A1, 28(SP)
184:                     uint8_t dummy;
185:                     if (!size) return;
9D00D72C  10C0002C   BEQ A2, ZERO, 0x9D00D7E0
9D00D730  AFA60020   SW A2, 32(SP)
186:                     rtcc_error=FALSE;
9D00D734  AF8080A8   SW ZERO, -32600(GP)
187:                     if (!setjmp(env)){
9D00D738  3C04A000   LUI A0, -24576
9D00D73C  0F407957   JAL setjmp
9D00D740  248443B0   ADDIU A0, A0, 17328
9D00D744  14400022   BNE V0, ZERO, 0x9D00D7D0
9D00D748  00000000   NOP
188:                         i2c_start_bit();
9D00D74C  0F4034A7   JAL i2c_start_bit
9D00D750  00000000   NOP
189:                         i2c_send_byte(I2C_CTRL_BYTE|RTCC_WRITE);
9D00D754  0F40355F   JAL i2c_send_byte
9D00D758  240400DE   ADDIU A0, ZERO, 222
190:                         i2c_send_byte(addr);
9D00D75C  0F40355F   JAL i2c_send_byte
9D00D760  8FA40018   LW A0, 24(SP)
191:                         i2c_start_bit();
9D00D764  0F4034A7   JAL i2c_start_bit
9D00D768  00000000   NOP
192:                         i2c_send_byte(I2C_CTRL_BYTE|RTCC_READ);
9D00D76C  0F40355F   JAL i2c_send_byte
9D00D770  240400DF   ADDIU A0, ZERO, 223
193:                         while (size>1){
9D00D774  8FA30020   LW V1, 32(SP)
9D00D778  2C620002   SLTIU V0, V1, 2
9D00D77C  1440000F   BNE V0, ZERO, 0x9D00D7BC
9D00D780  2470FFFE   ADDIU S0, V1, -2
9D00D784  321000FF   ANDI S0, S0, 255
9D00D788  26100001   ADDIU S0, S0, 1
9D00D78C  8FA2001C   LW V0, 28(SP)
9D00D790  00508021   ADDU S0, V0, S0
9D00D7AC  1470FFF9   BNE V1, S0, 0x9D00D794
9D00D7B0  A062FFFF   SB V0, -1(V1)
9D00D7B4  0B4035F0   J 0x9D00D7C0
9D00D7B8  00000000   NOP
9D00D7BC  8FB0001C   LW S0, 28(SP)
194:                             *buf++=i2c_receive_byte(TRUE);
9D00D794  8FA3001C   LW V1, 28(SP)
9D00D798  24630001   ADDIU V1, V1, 1
9D00D79C  AFA3001C   SW V1, 28(SP)
9D00D7A0  0F4034D1   JAL i2c_receive_byte
9D00D7A4  24040001   ADDIU A0, ZERO, 1
9D00D7A8  8FA3001C   LW V1, 28(SP)
195:                             size--;
196:                         }
197:                         *buf=i2c_receive_byte(FALSE);
9D00D7C0  0F4034D1   JAL i2c_receive_byte
9D00D7C4  00002021   ADDU A0, ZERO, ZERO
9D00D7C8  0B4035F8   J 0x9D00D7E0
9D00D7CC  A2020000   SB V0, 0(S0)
198:                     }else{
199:                         i2c_stop_bit();
9D00D7D0  0F4034C1   JAL i2c_stop_bit
9D00D7D4  00000000   NOP
200:                         rtcc_error=TRUE;
9D00D7D8  24020001   ADDIU V0, ZERO, 1
9D00D7DC  AF8280A8   SW V0, -32600(GP)
201:                     }
202:                 }
9D00D7E0  8FBF0014   LW RA, 20(SP)
9D00D7E4  8FB00010   LW S0, 16(SP)
9D00D7E8  03E00008   JR RA
9D00D7EC  27BD0018   ADDIU SP, SP, 24
203:                 
204:                 static uint8_t rtcc_read_byte(uint8_t addr){
9D00D6A0  27BDFFE8   ADDIU SP, SP, -24
9D00D6A4  AFBF0014   SW RA, 20(SP)
9D00D6A8  AFA40018   SW A0, 24(SP)
205:                     uint8_t byte;
206:                     
207:                     rtcc_error=FALSE;
9D00D6AC  AF8080A8   SW ZERO, -32600(GP)
208:                     if (!setjmp(env)){
9D00D6B0  3C04A000   LUI A0, -24576
9D00D6B4  0F407957   JAL setjmp
9D00D6B8  248443B0   ADDIU A0, A0, 17328
9D00D6BC  1440000F   BNE V0, ZERO, 0x9D00D6FC
9D00D6C0  00000000   NOP
209:                         i2c_start_bit();
9D00D6C4  0F4034A7   JAL i2c_start_bit
9D00D6C8  00000000   NOP
210:                         i2c_send_byte(I2C_CTRL_BYTE|RTCC_WRITE);
9D00D6CC  0F40355F   JAL i2c_send_byte
9D00D6D0  240400DE   ADDIU A0, ZERO, 222
211:                         i2c_send_byte(addr);
9D00D6D4  0F40355F   JAL i2c_send_byte
9D00D6D8  8FA40018   LW A0, 24(SP)
212:                         i2c_start_bit();
9D00D6DC  0F4034A7   JAL i2c_start_bit
9D00D6E0  00000000   NOP
213:                         i2c_send_byte(I2C_CTRL_BYTE|RTCC_READ);
9D00D6E4  0F40355F   JAL i2c_send_byte
9D00D6E8  240400DF   ADDIU A0, ZERO, 223
214:                         byte=i2c_receive_byte(FALSE);
9D00D6EC  0F4034D1   JAL i2c_receive_byte
9D00D6F0  00002021   ADDU A0, ZERO, ZERO
215:                         return byte;
216:                     }else{
217:                         i2c_stop_bit();
9D00D6FC  0F4034C1   JAL i2c_stop_bit
9D00D700  00000000   NOP
218:                         rtcc_error=TRUE;
9D00D704  24020001   ADDIU V0, ZERO, 1
9D00D708  AF8280A8   SW V0, -32600(GP)
219:                     }
220:                 }
9D00D6F4  0B4035C4   J 0x9D00D710
9D00D6F8  8FBF0014   LW RA, 20(SP)
9D00D70C  8FBF0014   LW RA, 20(SP)
9D00D710  03E00008   JR RA
9D00D714  27BD0018   ADDIU SP, SP, 24
221:                 
222:                 static void rtcc_write_buf(uint8_t addr,uint8_t *buf, uint8_t size){
9D00D7F0  27BDFFE8   ADDIU SP, SP, -24
9D00D7F4  AFBF0014   SW RA, 20(SP)
9D00D7F8  AFB00010   SW S0, 16(SP)
9D00D7FC  AFA40018   SW A0, 24(SP)
9D00D800  AFA5001C   SW A1, 28(SP)
9D00D804  AFA60020   SW A2, 32(SP)
223:                     rtcc_error=FALSE;
9D00D808  AF8080A8   SW ZERO, -32600(GP)
224:                     if (!setjmp(env)){
9D00D80C  3C04A000   LUI A0, -24576
9D00D810  0F407957   JAL setjmp
9D00D814  248443B0   ADDIU A0, A0, 17328
9D00D818  1440001A   BNE V0, ZERO, 0x9D00D884
9D00D81C  00000000   NOP
225:                         i2c_start_bit();
9D00D820  0F4034A7   JAL i2c_start_bit
9D00D824  00000000   NOP
226:                         i2c_send_byte(I2C_CTRL_BYTE|RTCC_WRITE);
9D00D828  0F40355F   JAL i2c_send_byte
9D00D82C  240400DE   ADDIU A0, ZERO, 222
227:                         i2c_send_byte(addr);
9D00D830  0F40355F   JAL i2c_send_byte
9D00D834  8FA40018   LW A0, 24(SP)
228:                         while (size){
9D00D838  8FA20020   LW V0, 32(SP)
9D00D83C  1040000D   BEQ V0, ZERO, 0x9D00D874
9D00D840  2450FFFF   ADDIU S0, V0, -1
9D00D844  321000FF   ANDI S0, S0, 255
9D00D848  26100001   ADDIU S0, S0, 1
9D00D84C  8FA2001C   LW V0, 28(SP)
9D00D850  00508021   ADDU S0, V0, S0
9D00D868  8FA2001C   LW V0, 28(SP)
9D00D86C  1450FFFB   BNE V0, S0, 0x9D00D85C
9D00D870  24420001   ADDIU V0, V0, 1
229:                             i2c_send_byte(*buf++);
9D00D854  8FA2001C   LW V0, 28(SP)
9D00D858  24420001   ADDIU V0, V0, 1
9D00D85C  AFA2001C   SW V0, 28(SP)
9D00D860  0F40355F   JAL i2c_send_byte
9D00D864  9044FFFF   LBU A0, -1(V0)
230:                             size--;
231:                         }
232:                         i2c_stop_bit();
9D00D874  0F4034C1   JAL i2c_stop_bit
9D00D878  00000000   NOP
9D00D87C  0B403628   J 0x9D00D8A0
9D00D880  8FBF0014   LW RA, 20(SP)
233:                     }else{
234:                         i2c_clock();
9D00D884  0F40347A   JAL i2c_clock
9D00D888  00000000   NOP
235:                         i2c_stop_bit();
9D00D88C  0F4034C1   JAL i2c_stop_bit
9D00D890  00000000   NOP
236:                         rtcc_error=TRUE;
9D00D894  24020001   ADDIU V0, ZERO, 1
9D00D898  AF8280A8   SW V0, -32600(GP)
237:                     }
238:                 }
9D00D89C  8FBF0014   LW RA, 20(SP)
9D00D8A0  8FB00010   LW S0, 16(SP)
9D00D8A4  03E00008   JR RA
9D00D8A8  27BD0018   ADDIU SP, SP, 24
239:                 
240:                 static void rtcc_write_byte(uint8_t addr, uint8_t byte){
9D00D624  27BDFFE8   ADDIU SP, SP, -24
9D00D628  AFBF0014   SW RA, 20(SP)
9D00D62C  AFA40018   SW A0, 24(SP)
9D00D630  AFA5001C   SW A1, 28(SP)
241:                     rtcc_error=FALSE;
9D00D634  AF8080A8   SW ZERO, -32600(GP)
242:                     if (!setjmp(env)){
9D00D638  3C04A000   LUI A0, -24576
9D00D63C  0F407957   JAL setjmp
9D00D640  248443B0   ADDIU A0, A0, 17328
9D00D644  1440000D   BNE V0, ZERO, 0x9D00D67C
9D00D648  00000000   NOP
243:                         i2c_start_bit();
9D00D64C  0F4034A7   JAL i2c_start_bit
9D00D650  00000000   NOP
244:                         i2c_send_byte(I2C_CTRL_BYTE|RTCC_WRITE);
9D00D654  0F40355F   JAL i2c_send_byte
9D00D658  240400DE   ADDIU A0, ZERO, 222
245:                         i2c_send_byte(addr);
9D00D65C  0F40355F   JAL i2c_send_byte
9D00D660  8FA40018   LW A0, 24(SP)
246:                         i2c_send_byte(byte);
9D00D664  0F40355F   JAL i2c_send_byte
9D00D668  8FA4001C   LW A0, 28(SP)
247:                         i2c_stop_bit();
9D00D66C  0F4034C1   JAL i2c_stop_bit
9D00D670  00000000   NOP
9D00D674  0B4035A6   J 0x9D00D698
9D00D678  8FBF0014   LW RA, 20(SP)
248:                     }else{
249:                         i2c_clock();
9D00D67C  0F40347A   JAL i2c_clock
9D00D680  00000000   NOP
250:                         i2c_stop_bit();
9D00D684  0F4034C1   JAL i2c_stop_bit
9D00D688  00000000   NOP
251:                         rtcc_error=TRUE;
9D00D68C  24020001   ADDIU V0, ZERO, 1
9D00D690  AF8280A8   SW V0, -32600(GP)
252:                     }
253:                 };
9D00D694  8FBF0014   LW RA, 20(SP)
9D00D698  03E00008   JR RA
9D00D69C  27BD0018   ADDIU SP, SP, 24
254:                 
255:                 rtcc_error_t rtcc_init(){
9D00D8AC  27BDFFE0   ADDIU SP, SP, -32
9D00D8B0  AFBF001C   SW RA, 28(SP)
9D00D8B4  AFB10018   SW S1, 24(SP)
9D00D8B8  AFB00014   SW S0, 20(SP)
256:                     uint8_t byte,tries;
257:                     // l'entrée alarme recevant le signal du MCP7940N
258:                     // la sortie sur le RTCC est open drain
259:                     // on active le weak pullup sur l'entrée du MCU.
260:                     RTCC_ALRM_WPUSET=RTCC_ALRM_PIN;
9D00D8BC  24020002   ADDIU V0, ZERO, 2
9D00D8C0  3C03BF88   LUI V1, -16504
9D00D8C4  AC626158   SW V0, 24920(V1)
261:                     // le signal clock de l'interface I2C avec le MCP7940N
262:                     // on l'initialise en mode sortie open drain 
263:                     // en haute impédance
264:                 //    RTCC_SCL_ODCSET=RTCC_SCL_PIN;
265:                     RTCC_SCL_LATSET=RTCC_SCL_PIN;
9D00D8C8  24030001   ADDIU V1, ZERO, 1
9D00D8CC  3C04BF88   LUI A0, -16504
9D00D8D0  AC836138   SW V1, 24888(A0)
266:                     RTCC_SCL_TRISCLR=RTCC_SCL_PIN;
9D00D8D4  3C04BF88   LUI A0, -16504
9D00D8D8  AC836114   SW V1, 24852(A0)
267:                     // le signal data de l'interface I2C avec le MCP7940N
268:                     // on l'initialise en mode sortie open drain.
269:                     // en haute impédance
270:                     RTCC_SDA_ODCSET=RTCC_SDA_PIN;
9D00D8DC  3C03BF88   LUI V1, -16504
9D00D8E0  AC626048   SW V0, 24648(V1)
271:                     _set_sda_high();
9D00D8E4  3C03BF88   LUI V1, -16504
9D00D8E8  AC626038   SW V0, 24632(V1)
272:                     _set_sda_as_output();
9D00D8EC  AC626038   SW V0, 24632(V1)
9D00D8F0  3C03BF88   LUI V1, -16504
9D00D8F4  AC626014   SW V0, 24596(V1)
273:                     _usec_delay(5);
9D00D8F8  34080064   ORI T0, ZERO, 100
9D00D8FC  1500FFFF   BNE T0, ZERO, 0x9D00D8FC
9D00D900  2508FFFF   ADDIU T0, T0, -1
274:                     byte=rtcc_read_byte(RTC_WKDAY);
9D00D904  0F4035A8   JAL rtcc_read_byte
9D00D908  24040003   ADDIU A0, ZERO, 3
275:                     if (!rtcc_error){
9D00D90C  8F8480A8   LW A0, -32600(GP)
9D00D910  14800074   BNE A0, ZERO, 0x9D00DAE4
9D00D914  24030001   ADDIU V1, ZERO, 1
276:                         tries=3;
277:                         while (tries && !(byte&OSCRUN_MSK)){ // oscillateur inactif
9D00D918  30430020   ANDI V1, V0, 32
9D00D91C  306300FF   ANDI V1, V1, 255
9D00D920  10600063   BEQ V1, ZERO, 0x9D00DAB0
9D00D924  3C049D02   LUI A0, -25342
9D00D95C  52000007   BEQL S0, ZERO, 0x9D00D97C
9D00D960  30440020   ANDI A0, V0, 32
9D00D964  30430020   ANDI V1, V0, 32
9D00D968  306300FF   ANDI V1, V1, 255
9D00D96C  1060FFF0   BEQ V1, ZERO, 0x9D00D930
9D00D970  30420008   ANDI V0, V0, 8
9D00D974  0B403664   J 0x9D00D990
9D00D978  304200FF   ANDI V0, V0, 255
278:                             ser_print("rtcc oscillator not running.\r");
9D00D930  0F405504   JAL ser_print
9D00D934  02202021   ADDU A0, S1, ZERO
9D00DAB0  0F405504   JAL ser_print
9D00DAB4  2484C3E0   ADDIU A0, A0, -15392
9D00DAD8  3C119D02   LUI S1, -25342
9D00DADC  0B403659   J 0x9D00D964
9D00DAE0  2631C3E0   ADDIU S1, S1, -15392
279:                             rtcc_write_byte(RTC_SEC,128); //activation oscillateur
9D00D938  00002021   ADDU A0, ZERO, ZERO
9D00D93C  0F403589   JAL rtcc_write_byte
9D00D940  24050080   ADDIU A1, ZERO, 128
9D00DAB8  00002021   ADDU A0, ZERO, ZERO
9D00DABC  0F403589   JAL rtcc_write_byte
9D00DAC0  24050080   ADDIU A1, ZERO, 128
280:                             delay_ms(5);
9D00D944  0F4052A0   JAL delay_ms
9D00D948  24040005   ADDIU A0, ZERO, 5
9D00DAC4  0F4052A0   JAL delay_ms
9D00DAC8  24040005   ADDIU A0, ZERO, 5
281:                             byte=rtcc_read_byte(RTC_WKDAY);
9D00D94C  0F4035A8   JAL rtcc_read_byte
9D00D950  24040003   ADDIU A0, ZERO, 3
9D00D954  2610FFFF   ADDIU S0, S0, -1
9D00D958  321000FF   ANDI S0, S0, 255
9D00DACC  0F4035A8   JAL rtcc_read_byte
9D00DAD0  24040003   ADDIU A0, ZERO, 3
9D00DAD4  24100002   ADDIU S0, ZERO, 2
282:                             tries--;
283:                         }
284:                         if (!(byte&OSCRUN_MSK)){return RTCC_ERR_OSCRUN;}
9D00D97C  308400FF   ANDI A0, A0, 255
9D00D980  10800058   BEQ A0, ZERO, 0x9D00DAE4
9D00D984  24030002   ADDIU V1, ZERO, 2
285:                         tries=3;
286:                         while (tries && !(byte&VBATEN_MSK)){// support pile désactivé.
9D00D928  0B403663   J 0x9D00D98C
9D00D92C  30420008   ANDI V0, V0, 8
9D00D988  30420008   ANDI V0, V0, 8
9D00D98C  304200FF   ANDI V0, V0, 255
9D00D990  5040003A   BEQL V0, ZERO, 0x9D00DA7C
9D00D994  3C049D02   LUI A0, -25342
9D00D9CC  52000007   BEQL S0, ZERO, 0x9D00D9EC
9D00D9D0  30420008   ANDI V0, V0, 8
9D00D9D4  30420008   ANDI V0, V0, 8
9D00D9D8  304200FF   ANDI V0, V0, 255
9D00D9DC  1040FFF0   BEQ V0, ZERO, 0x9D00D9A0
9D00D9E0  3C02BF88   LUI V0, -16504
9D00D9E4  0B40367F   J 0x9D00D9FC
9D00D9E8  00000000   NOP
287:                             ser_print("rtcc battery disabled.\r");
9D00D9A0  0F405504   JAL ser_print
9D00D9A4  02202021   ADDU A0, S1, ZERO
9D00DA7C  0F405504   JAL ser_print
9D00DA80  2484C400   ADDIU A0, A0, -15360
9D00DAA4  3C119D02   LUI S1, -25342
9D00DAA8  0B403675   J 0x9D00D9D4
9D00DAAC  2631C400   ADDIU S1, S1, -15360
288:                             rtcc_write_byte(RTC_WKDAY,(1<<3)); // activation support pile.
9D00D9A8  24040003   ADDIU A0, ZERO, 3
9D00D9AC  0F403589   JAL rtcc_write_byte
9D00D9B0  24050008   ADDIU A1, ZERO, 8
9D00DA84  24040003   ADDIU A0, ZERO, 3
9D00DA88  0F403589   JAL rtcc_write_byte
9D00DA8C  24050008   ADDIU A1, ZERO, 8
289:                             delay_ms(5);
9D00D9B4  0F4052A0   JAL delay_ms
9D00D9B8  24040005   ADDIU A0, ZERO, 5
9D00DA90  0F4052A0   JAL delay_ms
9D00DA94  24040005   ADDIU A0, ZERO, 5
290:                             byte=rtcc_read_byte(RTC_WKDAY);
9D00D9BC  0F4035A8   JAL rtcc_read_byte
9D00D9C0  24040003   ADDIU A0, ZERO, 3
9D00D9C4  2610FFFF   ADDIU S0, S0, -1
9D00D9C8  321000FF   ANDI S0, S0, 255
9D00DA98  0F4035A8   JAL rtcc_read_byte
9D00DA9C  24040003   ADDIU A0, ZERO, 3
9D00DAA0  24100002   ADDIU S0, ZERO, 2
291:                             tries--;
292:                         };
293:                         if (!(byte&VBATEN_MSK)){return RTCC_ERR_VBATEN;}
9D00D9EC  304200FF   ANDI V0, V0, 255
9D00D9F0  1040003C   BEQ V0, ZERO, 0x9D00DAE4
9D00D9F4  24030003   ADDIU V1, ZERO, 3
294:                     }else{
295:                         return RTCC_ERR_COMM;
296:                     }
297:                     // interruption lorsque la broche alarm descend à zéro.
298:                     CNCONBbits.ON=1;
9D00D998  0B40367F   J 0x9D00D9FC
9D00D99C  3C02BF88   LUI V0, -16504
9D00D9F8  3C02BF88   LUI V0, -16504
9D00D9FC  94446170   LHU A0, 24944(V0)
9D00DA00  24030001   ADDIU V1, ZERO, 1
9D00DA04  7C647BC4   INS A0, V1, 15, 1
9D00DA08  A4446170   SH A0, 24944(V0)
299:                     CNENBbits.CNIEB1=1;
9D00DA0C  3C02BF88   LUI V0, -16504
9D00DA10  94446180   LHU A0, 24960(V0)
9D00DA14  7C640844   INS A0, V1, 1, 1
9D00DA18  A4446180   SH A0, 24960(V0)
300:                     IPC8bits.CNIP=1;
9D00DA1C  3C02BF88   LUI V0, -16504
9D00DA20  8C441110   LW A0, 4368(V0)
9D00DA24  7C64A484   INS A0, V1, 18, 3
9D00DA28  AC441110   SW A0, 4368(V0)
301:                     IPC8bits.CNIS=1;
9D00DA2C  8C441110   LW A0, 4368(V0)
9D00DA30  7C648C04   INS A0, V1, 16, 2
9D00DA34  AC441110   SW A0, 4368(V0)
302:                     byte=rtcc_read_byte(RTC_CONTROL);
9D00DA38  0F4035A8   JAL rtcc_read_byte
9D00DA3C  24040007   ADDIU A0, ZERO, 7
303:                     if (byte&(ALM0EN_MSK|ALM1EN_MSK)){
9D00DA40  30420030   ANDI V0, V0, 48
9D00DA44  5040000B   BEQL V0, ZERO, 0x9D00DA74
9D00DA48  AF8080A8   SW ZERO, -32600(GP)
304:                         IFS1bits.CNBIF=0;
9D00DA4C  3C02BF88   LUI V0, -16504
9D00DA50  8C431040   LW V1, 4160(V0)
9D00DA54  7C037384   INS V1, ZERO, 14, 1
9D00DA58  AC431040   SW V1, 4160(V0)
305:                         IEC1bits.CNBIE=1;
9D00DA5C  3C02BF88   LUI V0, -16504
9D00DA60  8C431070   LW V1, 4208(V0)
9D00DA64  24040001   ADDIU A0, ZERO, 1
9D00DA68  7C837384   INS V1, A0, 14, 1
9D00DA6C  AC431070   SW V1, 4208(V0)
306:                     }
307:                     rtcc_error=0;
9D00DA70  AF8080A8   SW ZERO, -32600(GP)
308:                     return RTCC_ERR_NONE;
9D00DA74  0B4036B9   J 0x9D00DAE4
9D00DA78  00001821   ADDU V1, ZERO, ZERO
309:                 }
9D00DAE4  00601021   ADDU V0, V1, ZERO
9D00DAE8  8FBF001C   LW RA, 28(SP)
9D00DAEC  8FB10018   LW S1, 24(SP)
9D00DAF0  8FB00014   LW S0, 20(SP)
9D00DAF4  03E00008   JR RA
9D00DAF8  27BD0020   ADDIU SP, SP, 32
310:                 
311:                 
312:                 
313:                 
314:                 /////////////////////////////////////////////////////
315:                 
316:                 int rtcc_calibration(int trim){
9D00DAFC  27BDFFE0   ADDIU SP, SP, -32
9D00DB00  AFBF001C   SW RA, 28(SP)
9D00DB04  AFB10018   SW S1, 24(SP)
9D00DB08  AFB00014   SW S0, 20(SP)
9D00DB0C  00808021   ADDU S0, A0, ZERO
317:                     uint8_t osctrim, sign=0;
9D00DB2C  00108FC2   SRL S1, S0, 31
318:                     int old_value;
319:                 
320:                     osctrim=rtcc_read_byte(RTC_OSCTRIM);
9D00DB10  0F4035A8   JAL rtcc_read_byte
9D00DB14  24040008   ADDIU A0, ZERO, 8
321:                     old_value=osctrim&0x7f;
9D00DB18  3043007F   ANDI V1, V0, 127
322:                     if (osctrim&128) old_value=-old_value;
9D00DB1C  00032023   SUBU A0, ZERO, V1
9D00DB20  7C4201C0   EXT V0, V0, 7, 1
9D00DB24  0082180B   MOVN V1, A0, V0
323:                     trim=old_value+trim;
9D00DB28  00708021   ADDU S0, V1, S0
324:                     if (trim<0){
325:                         sign=1;
326:                     }
327:                     trim=abs(trim)&0x7f;
9D00DB30  001017C3   SRA V0, S0, 31
9D00DB34  00508026   XOR S0, V0, S0
9D00DB38  02028023   SUBU S0, S0, V0
9D00DB3C  3210007F   ANDI S0, S0, 127
328:                     osctrim=(sign<<7)+trim;
9D00DB40  001129C0   SLL A1, S1, 7
9D00DB44  02052821   ADDU A1, S0, A1
329:                     rtcc_write_byte(RTC_OSCTRIM,osctrim);
9D00DB48  24040008   ADDIU A0, ZERO, 8
9D00DB4C  0F403589   JAL rtcc_write_byte
9D00DB50  30A500FF   ANDI A1, A1, 255
330:                     return sign?-trim:trim;
9D00DB54  00101023   SUBU V0, ZERO, S0
331:                 }
9D00DB58  0211100A   MOVZ V0, S0, S1
9D00DB5C  8FBF001C   LW RA, 28(SP)
9D00DB60  8FB10018   LW S1, 24(SP)
9D00DB64  8FB00014   LW S0, 20(SP)
9D00DB68  03E00008   JR RA
9D00DB6C  27BD0020   ADDIU SP, SP, 32
332:                 
333:                 
334:                 static uint8_t bcd2dec(uint8_t hb){
335:                     return (hb>>4)*10+(hb&0xf);
9D00D3C8  00041102   SRL V0, A0, 4
9D00D3CC  00021040   SLL V0, V0, 1
9D00D3D0  00021880   SLL V1, V0, 2
9D00D3D4  00431021   ADDU V0, V0, V1
9D00D3D8  3084000F   ANDI A0, A0, 15
9D00D3DC  00441021   ADDU V0, V0, A0
336:                 }
9D00D3E0  03E00008   JR RA
9D00D3E4  304200FF   ANDI V0, V0, 255
337:                 
338:                 static uint8_t dec2bcd(uint8_t dec){
339:                     return dec%10+((dec/10)<<4);
9D00D3E8  3C03CCCC   LUI V1, -13108
9D00D3EC  3463CCCD   ORI V1, V1, -13107
9D00D3F0  00830019   MULTU 0, A0, V1
9D00D3F4  00001810   MFHI V1
9D00D3F8  000318C2   SRL V1, V1, 3
9D00D3FC  00031100   SLL V0, V1, 4
9D00D400  00032840   SLL A1, V1, 1
9D00D404  000318C0   SLL V1, V1, 3
9D00D408  00A31821   ADDU V1, A1, V1
9D00D40C  00832023   SUBU A0, A0, V1
9D00D410  00441021   ADDU V0, V0, A0
340:                 }
9D00D414  03E00008   JR RA
9D00D418  304200FF   ANDI V0, V0, 255
341:                 
342:                 
343:                 void rtcc_get_time(stime_t* time){
9D00DB70  27BDFFD8   ADDIU SP, SP, -40
9D00DB74  AFBF0024   SW RA, 36(SP)
9D00DB78  AFB10020   SW S1, 32(SP)
9D00DB7C  AFB0001C   SW S0, 28(SP)
9D00DB80  00808021   ADDU S0, A0, ZERO
344:                     uint8_t buf[3];
345:                     rtcc_read_buf(RTC_SEC,buf,3);
9D00DB84  00002021   ADDU A0, ZERO, ZERO
9D00DB88  27A50010   ADDIU A1, SP, 16
9D00DB8C  0F4035C6   JAL rtcc_read_buf
9D00DB90  24060003   ADDIU A2, ZERO, 3
346:                     time->sec=bcd2dec(buf[0]&0x7f);
9D00DB94  93A40010   LBU A0, 16(SP)
9D00DB98  0F4034F2   JAL bcd2dec
9D00DB9C  3084007F   ANDI A0, A0, 127
9D00DBA0  8E110000   LW S1, 0(S0)
9D00DBA4  7C512804   INS S1, V0, 0, 6
9D00DBA8  AE110000   SW S1, 0(S0)
347:                     time->min=bcd2dec(buf[1]&0x7f);
9D00DBAC  93A40011   LBU A0, 17(SP)
9D00DBB0  0F4034F2   JAL bcd2dec
9D00DBB4  3084007F   ANDI A0, A0, 127
9D00DBB8  7C515984   INS S1, V0, 6, 6
9D00DBBC  AE110000   SW S1, 0(S0)
348:                     time->hour=bcd2dec(buf[2]&0x3f);
9D00DBC0  93A40012   LBU A0, 18(SP)
9D00DBC4  0F4034F2   JAL bcd2dec
9D00DBC8  3084003F   ANDI A0, A0, 63
9D00DBCC  7C518304   INS S1, V0, 12, 5
9D00DBD0  AE110000   SW S1, 0(S0)
349:                 
350:                 }
9D00DBD4  8FBF0024   LW RA, 36(SP)
9D00DBD8  8FB10020   LW S1, 32(SP)
9D00DBDC  8FB0001C   LW S0, 28(SP)
9D00DBE0  03E00008   JR RA
9D00DBE4  27BD0028   ADDIU SP, SP, 40
351:                 
352:                 void rtcc_set_time(stime_t time){
9D00DBE8  27BDFFE0   ADDIU SP, SP, -32
9D00DBEC  AFBF001C   SW RA, 28(SP)
9D00DBF0  AFB00018   SW S0, 24(SP)
9D00DBF4  00808021   ADDU S0, A0, ZERO
353:                     uint8_t byte[3];
354:                     byte[0]=128+dec2bcd(time.sec);
9D00DBF8  0F4034FA   JAL dec2bcd
9D00DBFC  3084003F   ANDI A0, A0, 63
9D00DC00  2442FF80   ADDIU V0, V0, -128
9D00DC04  A3A20010   SB V0, 16(SP)
355:                     byte[1]=dec2bcd(time.min);
9D00DC08  0F4034FA   JAL dec2bcd
9D00DC0C  7E042980   EXT A0, S0, 6, 6
9D00DC10  A3A20011   SB V0, 17(SP)
356:                     byte[2]=dec2bcd(time.hour);
9D00DC14  0F4034FA   JAL dec2bcd
9D00DC18  7E042300   EXT A0, S0, 12, 5
9D00DC1C  A3A20012   SB V0, 18(SP)
357:                     rtcc_write_buf(RTC_SEC,byte,3);
9D00DC20  00002021   ADDU A0, ZERO, ZERO
9D00DC24  27A50010   ADDIU A1, SP, 16
9D00DC28  0F4035FC   JAL rtcc_write_buf
9D00DC2C  24060003   ADDIU A2, ZERO, 3
358:                 }
9D00DC30  8FBF001C   LW RA, 28(SP)
9D00DC34  8FB00018   LW S0, 24(SP)
9D00DC38  03E00008   JR RA
9D00DC3C  27BD0020   ADDIU SP, SP, 32
359:                 
360:                 void rtcc_get_date(sdate_t* date){
9D00DC40  27BDFFD8   ADDIU SP, SP, -40
9D00DC44  AFBF0024   SW RA, 36(SP)
9D00DC48  AFB10020   SW S1, 32(SP)
9D00DC4C  AFB0001C   SW S0, 28(SP)
9D00DC50  00808021   ADDU S0, A0, ZERO
361:                     uint8_t buf[4];
362:                     rtcc_read_buf(RTC_WKDAY,buf,4);
9D00DC54  24040003   ADDIU A0, ZERO, 3
9D00DC58  27A50010   ADDIU A1, SP, 16
9D00DC5C  0F4035C6   JAL rtcc_read_buf
9D00DC60  24060004   ADDIU A2, ZERO, 4
363:                     date->wkday=buf[0]&7;
9D00DC64  8E110000   LW S1, 0(S0)
9D00DC68  93A20010   LBU V0, 16(SP)
9D00DC6C  7C51DE44   INS S1, V0, 25, 3
9D00DC70  AE110000   SW S1, 0(S0)
364:                     date->day=bcd2dec(buf[1]&0x3f);
9D00DC74  93A40011   LBU A0, 17(SP)
9D00DC78  0F4034F2   JAL bcd2dec
9D00DC7C  3084003F   ANDI A0, A0, 63
9D00DC80  7C51C504   INS S1, V0, 20, 5
9D00DC84  AE110000   SW S1, 0(S0)
365:                     date->month=bcd2dec(buf[2]&0x1f);
9D00DC88  93A40012   LBU A0, 18(SP)
9D00DC8C  0F4034F2   JAL bcd2dec
9D00DC90  3084001F   ANDI A0, A0, 31
9D00DC94  7C519C04   INS S1, V0, 16, 4
9D00DC98  AE110000   SW S1, 0(S0)
366:                     date->year=2000+bcd2dec(buf[3]);
9D00DC9C  0F4034F2   JAL bcd2dec
9D00DCA0  93A40013   LBU A0, 19(SP)
9D00DCA4  244207D0   ADDIU V0, V0, 2000
9D00DCA8  A6020000   SH V0, 0(S0)
367:                 }
9D00DCAC  8FBF0024   LW RA, 36(SP)
9D00DCB0  8FB10020   LW S1, 32(SP)
9D00DCB4  8FB0001C   LW S0, 28(SP)
9D00DCB8  03E00008   JR RA
9D00DCBC  27BD0028   ADDIU SP, SP, 40
368:                 
369:                 
370:                 void rtcc_set_date(sdate_t date){
9D00DCC0  27BDFFE0   ADDIU SP, SP, -32
9D00DCC4  AFBF001C   SW RA, 28(SP)
9D00DCC8  AFB00018   SW S0, 24(SP)
9D00DCCC  00808021   ADDU S0, A0, ZERO
371:                     uint8_t byte[4];
372:                     byte[0]=8+dec2bcd(date.wkday);
9D00DCD0  0F4034FA   JAL dec2bcd
9D00DCD4  7C841640   EXT A0, A0, 25, 3
9D00DCD8  24420008   ADDIU V0, V0, 8
9D00DCDC  A3A20010   SB V0, 16(SP)
373:                     byte[1]=dec2bcd(date.day);
9D00DCE0  0F4034FA   JAL dec2bcd
9D00DCE4  7E042500   EXT A0, S0, 20, 5
9D00DCE8  A3A20011   SB V0, 17(SP)
374:                     byte[2]=dec2bcd(date.month);
9D00DCEC  0F4034FA   JAL dec2bcd
9D00DCF0  7E041C00   EXT A0, S0, 16, 4
9D00DCF4  A3A20012   SB V0, 18(SP)
375:                     byte[3]=dec2bcd(date.year-2000);
9D00DCF8  26040030   ADDIU A0, S0, 48
9D00DCFC  0F4034FA   JAL dec2bcd
9D00DD00  308400FF   ANDI A0, A0, 255
9D00DD04  A3A20013   SB V0, 19(SP)
376:                     rtcc_write_buf(RTC_WKDAY,byte,4);
9D00DD08  24040003   ADDIU A0, ZERO, 3
9D00DD0C  27A50010   ADDIU A1, SP, 16
9D00DD10  0F4035FC   JAL rtcc_write_buf
9D00DD14  24060004   ADDIU A2, ZERO, 4
377:                 }
9D00DD18  8FBF001C   LW RA, 28(SP)
9D00DD1C  8FB00018   LW S0, 24(SP)
9D00DD20  03E00008   JR RA
9D00DD24  27BD0020   ADDIU SP, SP, 32
378:                 
379:                 const char *weekdays[7]={"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"};
380:                 
381:                 void rtcc_get_date_str(char *date_str){
9D00DD28  27BDFFD8   ADDIU SP, SP, -40
9D00DD2C  AFBF0024   SW RA, 36(SP)
9D00DD30  AFB00020   SW S0, 32(SP)
9D00DD34  00808021   ADDU S0, A0, ZERO
382:                     sdate_t d;
383:                     rtcc_get_date(&d);
9D00DD38  0F403710   JAL rtcc_get_date
9D00DD3C  27A40018   ADDIU A0, SP, 24
384:                     if (d.wkday<1) d.wkday=1;
9D00DD40  8FA20018   LW V0, 24(SP)
9D00DD44  7C421640   EXT V0, V0, 25, 3
9D00DD48  1C400005   BGTZ V0, 0x9D00DD60
9D00DD4C  8FA20018   LW V0, 24(SP)
9D00DD50  24030001   ADDIU V1, ZERO, 1
9D00DD54  7C62DE44   INS V0, V1, 25, 3
9D00DD58  AFA20018   SW V0, 24(SP)
385:                     sprintf(date_str,"%s %4d/%02d/%02d ",weekdays[d.wkday-1],d.year,d.month,d.day);
9D00DD5C  8FA20018   LW V0, 24(SP)
9D00DD60  7C431640   EXT V1, V0, 25, 3
9D00DD64  2463FFFF   ADDIU V1, V1, -1
9D00DD68  00031880   SLL V1, V1, 2
9D00DD6C  3C04A000   LUI A0, -24576
9D00DD70  248445B8   ADDIU A0, A0, 17848
9D00DD74  00641821   ADDU V1, V1, A0
9D00DD78  8C660000   LW A2, 0(V1)
9D00DD7C  97A70018   LHU A3, 24(SP)
9D00DD80  7C431C00   EXT V1, V0, 16, 4
9D00DD84  AFA30010   SW V1, 16(SP)
9D00DD88  7C422500   EXT V0, V0, 20, 5
9D00DD8C  AFA20014   SW V0, 20(SP)
9D00DD90  02002021   ADDU A0, S0, ZERO
9D00DD94  3C059D02   LUI A1, -25342
9D00DD98  0F407973   JAL _sprintf_cdnopsuxX
9D00DD9C  24A5C418   ADDIU A1, A1, -15336
386:                 }
9D00DDA0  8FBF0024   LW RA, 36(SP)
9D00DDA4  8FB00020   LW S0, 32(SP)
9D00DDA8  03E00008   JR RA
9D00DDAC  27BD0028   ADDIU SP, SP, 40
387:                 
388:                 void  rtcc_get_time_str(char *time_str){
9D00DDB0  27BDFFD8   ADDIU SP, SP, -40
9D00DDB4  AFBF0024   SW RA, 36(SP)
9D00DDB8  AFB00020   SW S0, 32(SP)
9D00DDBC  00808021   ADDU S0, A0, ZERO
389:                     stime_t t;
390:                     rtcc_get_time(&t);
9D00DDC0  0F4036DC   JAL rtcc_get_time
9D00DDC4  27A40018   ADDIU A0, SP, 24
391:                     sprintf(time_str,"%02d:%02d:%02d ",t.hour,t.min,t.sec);
9D00DDC8  8FA70018   LW A3, 24(SP)
9D00DDCC  30E2003F   ANDI V0, A3, 63
9D00DDD0  AFA20010   SW V0, 16(SP)
9D00DDD4  02002021   ADDU A0, S0, ZERO
9D00DDD8  3C059D02   LUI A1, -25342
9D00DDDC  24A5C42C   ADDIU A1, A1, -15316
9D00DDE0  7CE62300   EXT A2, A3, 12, 5
9D00DDE4  0F407973   JAL _sprintf_cdnopsuxX
9D00DDE8  7CE72980   EXT A3, A3, 6, 6
392:                 }
9D00DDEC  8FBF0024   LW RA, 36(SP)
9D00DDF0  8FB00020   LW S0, 32(SP)
9D00DDF4  03E00008   JR RA
9D00DDF8  27BD0028   ADDIU SP, SP, 40
393:                 
394:                 // retourne le jour de la semaine à partir de la date
395:                 // REF: https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Implementation-dependent_methods
396:                 // méthode de Sakamoto
397:                 // dimanche=1,samedi=7
398:                 uint8_t day_of_week(sdate_t *date){
399:                 const   static int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
400:                     int y;
401:                     uint8_t dow;
402:                     y=date->month < 3?date->year-1:date->year;
9D00DDFC  8C830000   LW V1, 0(A0)
9D00DE00  7C631C00   EXT V1, V1, 16, 4
9D00DE04  28620003   SLTI V0, V1, 3
9D00DE08  10400002   BEQ V0, ZERO, 0x9D00DE14
9D00DE0C  94820000   LHU V0, 0(A0)
9D00DE10  2442FFFF   ADDIU V0, V0, -1
403:                     dow=1+((y + y/4 - y/100 + y/400 + t[date->month-1] + date->day) % 7);
9D00DE14  24450003   ADDIU A1, V0, 3
9D00DE18  28460000   SLTI A2, V0, 0
9D00DE1C  0046280A   MOVZ A1, V0, A2
9D00DE20  00053083   SRA A2, A1, 2
9D00DE24  00463021   ADDU A2, V0, A2
9D00DE28  3C0551EB   LUI A1, 20971
9D00DE2C  34A5851F   ORI A1, A1, -31457
9D00DE30  00450018   MULT 0, V0, A1
9D00DE34  00002810   MFHI A1
9D00DE38  00053943   SRA A3, A1, 5
9D00DE3C  000217C3   SRA V0, V0, 31
9D00DE40  00E23823   SUBU A3, A3, V0
9D00DE44  00C73023   SUBU A2, A2, A3
9D00DE48  000529C3   SRA A1, A1, 7
9D00DE4C  00A21023   SUBU V0, A1, V0
9D00DE50  00C21021   ADDU V0, A2, V0
9D00DE54  2463FFFF   ADDIU V1, V1, -1
9D00DE58  00031880   SLL V1, V1, 2
9D00DE5C  3C059D02   LUI A1, -25342
9D00DE60  24A5C46C   ADDIU A1, A1, -15252
9D00DE64  00651821   ADDU V1, V1, A1
9D00DE68  8C630000   LW V1, 0(V1)
9D00DE6C  00431021   ADDU V0, V0, V1
9D00DE70  8C830000   LW V1, 0(A0)
9D00DE74  7C632500   EXT V1, V1, 20, 5
9D00DE78  00431021   ADDU V0, V0, V1
9D00DE7C  3C039249   LUI V1, -28087
9D00DE80  24632493   ADDIU V1, V1, 9363
9D00DE84  00430018   MULT 0, V0, V1
9D00DE88  00001810   MFHI V1
9D00DE8C  00621821   ADDU V1, V1, V0
9D00DE90  00031883   SRA V1, V1, 2
9D00DE94  000227C3   SRA A0, V0, 31
9D00DE98  00641823   SUBU V1, V1, A0
9D00DE9C  000320C0   SLL A0, V1, 3
9D00DEA0  00831823   SUBU V1, A0, V1
9D00DEA4  00431023   SUBU V0, V0, V1
9D00DEA8  24420001   ADDIU V0, V0, 1
404:                     return dow;
405:                 }
9D00DEAC  03E00008   JR RA
9D00DEB0  304200FF   ANDI V0, V0, 255
406:                 
407:                 // détermine si l'année est bisextile
408:                 // REF: https://fr.wikipedia.org/wiki/Ann%C3%A9e_bissextile#R%C3%A8gle_actuelle
409:                 BOOL leap_year(unsigned short year){
9D00DEBC  27BDFFE8   ADDIU SP, SP, -24
9D00DEC0  AFBF0014   SW RA, 20(SP)
410:                     uint8_t byte;
411:                     if (!year){
9D00DEB4  14800009   BNE A0, ZERO, 0x9D00DEDC
9D00DEB8  2C820190   SLTIU V0, A0, 400
412:                         byte=rtcc_read_byte(RTC_MTH);
9D00DEC4  0F4035A8   JAL rtcc_read_byte
9D00DEC8  24040005   ADDIU A0, ZERO, 5
413:                         return byte&(1<<5);
9D00DECC  30420020   ANDI V0, V0, 32
9D00DED0  304200FF   ANDI V0, V0, 255
414:                     }else{
415:                         return (!(year/4) && (year/100)) || !(year/400); 
416:                     }
417:                 }
9D00DED4  8FBF0014   LW RA, 20(SP)
9D00DED8  27BD0018   ADDIU SP, SP, 24
9D00DEDC  03E00008   JR RA
9D00DEE0  00000000   NOP
418:                 
419:                 BOOL rtcc_set_alarm(sdate_t date, stime_t time, uint8_t *msg){
9D00DEE4  27BDFFD0   ADDIU SP, SP, -48
9D00DEE8  AFBF002C   SW RA, 44(SP)
9D00DEEC  AFB30028   SW S3, 40(SP)
9D00DEF0  AFB20024   SW S2, 36(SP)
9D00DEF4  AFB10020   SW S1, 32(SP)
9D00DEF8  AFB0001C   SW S0, 28(SP)
9D00DEFC  00808821   ADDU S1, A0, ZERO
9D00DF00  00A09021   ADDU S2, A1, ZERO
9D00DF04  00C09821   ADDU S3, A2, ZERO
420:                     uint8_t byte, buf[6];
421:                     
422:                     byte=rtcc_read_byte(RTC_CONTROL);
9D00DF08  0F4035A8   JAL rtcc_read_byte
9D00DF0C  24040007   ADDIU A0, ZERO, 7
9D00DF10  00408021   ADDU S0, V0, ZERO
423:                     if ((byte&(ALM0EN_MSK|ALM1EN_MSK))==(ALM0EN_MSK|ALM1EN_MSK)){ return FALSE;} // pas d'alarme disponible.
9D00DF14  30430030   ANDI V1, V0, 48
9D00DF18  24020030   ADDIU V0, ZERO, 48
9D00DF1C  1062003B   BEQ V1, V0, 0x9D00E00C
9D00DF20  00001021   ADDU V0, ZERO, ZERO
424:                     buf[0]=dec2bcd(time.sec);
9D00DF24  0F4034FA   JAL dec2bcd
9D00DF28  3244003F   ANDI A0, S2, 63
9D00DF2C  A3A20010   SB V0, 16(SP)
425:                     buf[1]=dec2bcd(time.min);
9D00DF30  0F4034FA   JAL dec2bcd
9D00DF34  7E442980   EXT A0, S2, 6, 6
9D00DF38  A3A20011   SB V0, 17(SP)
426:                     buf[2]=dec2bcd(time.hour);
9D00DF3C  0F4034FA   JAL dec2bcd
9D00DF40  7E442300   EXT A0, S2, 12, 5
9D00DF44  A3A20012   SB V0, 18(SP)
427:                     buf[3]=dec2bcd(date.wkday)|(MODE_ALLFIELDS);
9D00DF48  0F4034FA   JAL dec2bcd
9D00DF4C  7E241640   EXT A0, S1, 25, 3
9D00DF50  34420070   ORI V0, V0, 112
9D00DF54  A3A20013   SB V0, 19(SP)
428:                     buf[4]=dec2bcd(date.day);
9D00DF58  0F4034FA   JAL dec2bcd
9D00DF5C  7E242500   EXT A0, S1, 20, 5
9D00DF60  A3A20014   SB V0, 20(SP)
429:                     buf[5]=dec2bcd(date.month);
9D00DF64  0F4034FA   JAL dec2bcd
9D00DF68  7E241C00   EXT A0, S1, 16, 4
9D00DF6C  A3A20015   SB V0, 21(SP)
430:                     if (!(byte & (ALM0EN_MSK))){ // alarme 0 disponible
9D00DF70  32020010   ANDI V0, S0, 16
9D00DF74  304200FF   ANDI V0, V0, 255
9D00DF78  1440000C   BNE V0, ZERO, 0x9D00DFAC
9D00DF7C  24040040   ADDIU A0, ZERO, 64
431:                         rtcc_write_buf(0x20,(uint8_t*)msg,32);
9D00DF80  24040020   ADDIU A0, ZERO, 32
9D00DF84  02602821   ADDU A1, S3, ZERO
9D00DF88  0F4035FC   JAL rtcc_write_buf
9D00DF8C  24060020   ADDIU A2, ZERO, 32
432:                         rtcc_write_buf(RTC_ALM0SEC,buf,6);
9D00DF90  2404000A   ADDIU A0, ZERO, 10
9D00DF94  27A50010   ADDIU A1, SP, 16
9D00DF98  0F4035FC   JAL rtcc_write_buf
9D00DF9C  24060006   ADDIU A2, ZERO, 6
433:                         byte|=(1<<4);
9D00DFA0  36100010   ORI S0, S0, 16
9D00DFA4  0B4037F4   J 0x9D00DFD0
9D00DFA8  321000FF   ANDI S0, S0, 255
434:                     }else{ // alarme 1 disponible
435:                         rtcc_write_buf(0x40,(uint8_t*)msg,32);
9D00DFAC  02602821   ADDU A1, S3, ZERO
9D00DFB0  0F4035FC   JAL rtcc_write_buf
9D00DFB4  24060020   ADDIU A2, ZERO, 32
436:                         rtcc_write_buf(RTC_ALM1SEC,buf,6);
9D00DFB8  24040011   ADDIU A0, ZERO, 17
9D00DFBC  27A50010   ADDIU A1, SP, 16
9D00DFC0  0F4035FC   JAL rtcc_write_buf
9D00DFC4  24060006   ADDIU A2, ZERO, 6
437:                         byte|=(1<<5);
9D00DFC8  36100020   ORI S0, S0, 32
9D00DFCC  321000FF   ANDI S0, S0, 255
438:                     }
439:                     rtcc_write_byte(RTC_CONTROL,byte);
9D00DFD0  24040007   ADDIU A0, ZERO, 7
9D00DFD4  0F403589   JAL rtcc_write_byte
9D00DFD8  02002821   ADDU A1, S0, ZERO
440:                     if (byte&(ALM0EN_MSK|ALM1EN_MSK)){
9D00DFDC  32100030   ANDI S0, S0, 48
9D00DFE0  1200000B   BEQ S0, ZERO, 0x9D00E010
9D00DFE4  8FBF002C   LW RA, 44(SP)
441:                         IFS1bits.CNBIF=0;
9D00DFE8  3C02BF88   LUI V0, -16504
9D00DFEC  8C431040   LW V1, 4160(V0)
9D00DFF0  7C037384   INS V1, ZERO, 14, 1
9D00DFF4  AC431040   SW V1, 4160(V0)
442:                         IEC1bits.CNBIE=1;
9D00DFF8  3C02BF88   LUI V0, -16504
9D00DFFC  8C431070   LW V1, 4208(V0)
9D00E000  24040001   ADDIU A0, ZERO, 1
9D00E004  7C837384   INS V1, A0, 14, 1
9D00E008  AC431070   SW V1, 4208(V0)
443:                     }
444:                 }
9D00E00C  8FBF002C   LW RA, 44(SP)
9D00E010  8FB30028   LW S3, 40(SP)
9D00E014  8FB20024   LW S2, 36(SP)
9D00E018  8FB10020   LW S1, 32(SP)
9D00E01C  8FB0001C   LW S0, 28(SP)
9D00E020  03E00008   JR RA
9D00E024  27BD0030   ADDIU SP, SP, 48
445:                 
446:                 // rapporte l'état des 2 alarmes
447:                 void rtcc_get_alarms(alm_state_t *alm_st){
9D00E028  27BDFFC8   ADDIU SP, SP, -56
9D00E02C  AFBF0034   SW RA, 52(SP)
9D00E030  AFB60030   SW S6, 48(SP)
9D00E034  AFB5002C   SW S5, 44(SP)
9D00E038  AFB40028   SW S4, 40(SP)
9D00E03C  AFB30024   SW S3, 36(SP)
9D00E040  AFB20020   SW S2, 32(SP)
9D00E044  AFB1001C   SW S1, 28(SP)
9D00E048  AFB00018   SW S0, 24(SP)
9D00E04C  00808021   ADDU S0, A0, ZERO
448:                 static const int alarm[2]={RTC_ALM0SEC,RTC_ALM1SEC};
449:                 static const int enable[2]={ALM0EN_MSK,ALM1EN_MSK};
450:                     uint8_t ctrl_byte, alm_regs[6];
451:                     int i;
452:                     ctrl_byte=rtcc_read_byte(RTC_CONTROL);
9D00E050  0F4035A8   JAL rtcc_read_byte
9D00E054  24040007   ADDIU A0, ZERO, 7
9D00E058  0040B021   ADDU S6, V0, ZERO
9D00E05C  00008821   ADDU S1, ZERO, ZERO
9D00E060  3C159D02   LUI S5, -25342
9D00E064  26B5C464   ADDIU S5, S5, -15260
9D00E068  3C149D02   LUI S4, -25342
9D00E06C  2694C45C   ADDIU S4, S4, -15268
453:                     for (i=0;i<2;i++){
9D00E070  24130008   ADDIU S3, ZERO, 8
9D00E074  02B11021   ADDU V0, S5, S1
9D00E11C  1633FFD5   BNE S1, S3, 0x9D00E074
9D00E120  26100024   ADDIU S0, S0, 36
454:                         rtcc_read_buf(alarm[i],alm_regs,6);
9D00E078  90440000   LBU A0, 0(V0)
9D00E07C  27A50010   ADDIU A1, SP, 16
9D00E080  0F4035C6   JAL rtcc_read_buf
9D00E084  24060006   ADDIU A2, ZERO, 6
9D00E088  02911021   ADDU V0, S4, S1
455:                         alm_st[i].enabled=ctrl_byte&enable[i]?1:0;
9D00E08C  8C420000   LW V0, 0(V0)
9D00E090  02C21024   AND V0, S6, V0
9D00E094  0002102B   SLTU V0, ZERO, V0
9D00E098  8E120000   LW S2, 0(S0)
9D00E09C  7C52EF44   INS S2, V0, 29, 1
9D00E0A0  AE120000   SW S2, 0(S0)
456:                         alm_st[i].sec=bcd2dec(alm_regs[0]);
9D00E0A4  0F4034F2   JAL bcd2dec
9D00E0A8  93A40010   LBU A0, 16(SP)
9D00E0AC  7C522804   INS S2, V0, 0, 6
9D00E0B0  AE120000   SW S2, 0(S0)
457:                         alm_st[i].min=bcd2dec(alm_regs[1]);
9D00E0B4  0F4034F2   JAL bcd2dec
9D00E0B8  93A40011   LBU A0, 17(SP)
9D00E0BC  7C525984   INS S2, V0, 6, 6
9D00E0C0  AE120000   SW S2, 0(S0)
458:                         alm_st[i].hour=bcd2dec(alm_regs[2]&0x3f);
9D00E0C4  93A40012   LBU A0, 18(SP)
9D00E0C8  0F4034F2   JAL bcd2dec
9D00E0CC  3084003F   ANDI A0, A0, 63
9D00E0D0  7C528304   INS S2, V0, 12, 5
459:                         alm_st[i].wkday=alm_regs[3]&7;
9D00E0D4  93A20013   LBU V0, 19(SP)
9D00E0D8  7C529C44   INS S2, V0, 17, 3
9D00E0DC  AE120000   SW S2, 0(S0)
460:                         alm_st[i].day=bcd2dec(alm_regs[4]);
9D00E0E0  0F4034F2   JAL bcd2dec
9D00E0E4  93A40014   LBU A0, 20(SP)
9D00E0E8  7C52C504   INS S2, V0, 20, 5
9D00E0EC  AE120000   SW S2, 0(S0)
461:                         alm_st[i].month=bcd2dec(alm_regs[5]);
9D00E0F0  0F4034F2   JAL bcd2dec
9D00E0F4  93A40015   LBU A0, 21(SP)
9D00E0F8  7C52E644   INS S2, V0, 25, 4
9D00E0FC  AE120000   SW S2, 0(S0)
9D00E100  26240004   ADDIU A0, S1, 4
9D00E104  000420C0   SLL A0, A0, 3
462:                         rtcc_read_buf(0x20*(i+1),(uint8_t*)&alm_st[i].msg,32);
9D00E108  308400F8   ANDI A0, A0, 248
9D00E10C  26050004   ADDIU A1, S0, 4
9D00E110  0F4035C6   JAL rtcc_read_buf
9D00E114  24060020   ADDIU A2, ZERO, 32
9D00E118  26310004   ADDIU S1, S1, 4
463:                     }
464:                 }
9D00E124  8FBF0034   LW RA, 52(SP)
9D00E128  8FB60030   LW S6, 48(SP)
9D00E12C  8FB5002C   LW S5, 44(SP)
9D00E130  8FB40028   LW S4, 40(SP)
9D00E134  8FB30024   LW S3, 36(SP)
9D00E138  8FB20020   LW S2, 32(SP)
9D00E13C  8FB1001C   LW S1, 28(SP)
9D00E140  8FB00018   LW S0, 24(SP)
9D00E144  03E00008   JR RA
9D00E148  27BD0038   ADDIU SP, SP, 56
465:                 
466:                 void rtcc_cancel_alarm(uint8_t n){
9D00E14C  27BDFFE8   ADDIU SP, SP, -24
9D00E150  AFBF0014   SW RA, 20(SP)
9D00E154  AFB00010   SW S0, 16(SP)
9D00E158  00808021   ADDU S0, A0, ZERO
467:                     uint8_t ctrl_byte;
468:                     ctrl_byte=rtcc_read_byte(RTC_CONTROL);
9D00E15C  0F4035A8   JAL rtcc_read_byte
9D00E160  24040007   ADDIU A0, ZERO, 7
469:                     if (!n){
470:                         ctrl_byte&=~ALM0EN_MSK;
9D00E164  304300EF   ANDI V1, V0, 239
9D00E168  304200DF   ANDI V0, V0, 223
9D00E16C  00602821   ADDU A1, V1, ZERO
9D00E170  0050280B   MOVN A1, V0, S0
471:                     }else{
472:                         ctrl_byte&=~ALM1EN_MSK;
473:                     }
474:                     rtcc_write_byte(RTC_CONTROL,ctrl_byte);
9D00E174  0F403589   JAL rtcc_write_byte
9D00E178  24040007   ADDIU A0, ZERO, 7
475:                 }
9D00E17C  8FBF0014   LW RA, 20(SP)
9D00E180  8FB00010   LW S0, 16(SP)
9D00E184  03E00008   JR RA
9D00E188  27BD0018   ADDIU SP, SP, 24
476:                 
477:                 void rtcc_power_down_stamp(alm_state_t *pdown){
9D00E18C  27BDFFD8   ADDIU SP, SP, -40
9D00E190  AFBF0024   SW RA, 36(SP)
9D00E194  AFB20020   SW S2, 32(SP)
9D00E198  AFB1001C   SW S1, 28(SP)
9D00E19C  AFB00018   SW S0, 24(SP)
9D00E1A0  00808021   ADDU S0, A0, ZERO
478:                     uint8_t wkday, buf[4];
479:                     rtcc_read_buf(RTC_PWRDNMIN,buf,4); 
9D00E1A4  24040018   ADDIU A0, ZERO, 24
9D00E1A8  27A50010   ADDIU A1, SP, 16
9D00E1AC  0F4035C6   JAL rtcc_read_buf
9D00E1B0  24060004   ADDIU A2, ZERO, 4
480:                     pdown->min=bcd2dec(buf[0]);
9D00E1B4  0F4034F2   JAL bcd2dec
9D00E1B8  93A40010   LBU A0, 16(SP)
9D00E1BC  8E110000   LW S1, 0(S0)
9D00E1C0  7C515984   INS S1, V0, 6, 6
9D00E1C4  AE110000   SW S1, 0(S0)
481:                     pdown->hour=bcd2dec(buf[1]);
9D00E1C8  0F4034F2   JAL bcd2dec
9D00E1CC  93A40011   LBU A0, 17(SP)
9D00E1D0  7C518304   INS S1, V0, 12, 5
9D00E1D4  AE110000   SW S1, 0(S0)
482:                     pdown->day=bcd2dec(buf[2]);
9D00E1D8  0F4034F2   JAL bcd2dec
9D00E1DC  93A40012   LBU A0, 18(SP)
9D00E1E0  7C51C504   INS S1, V0, 20, 5
9D00E1E4  AE110000   SW S1, 0(S0)
483:                     pdown->month=bcd2dec(buf[3]&0x1f);
9D00E1E8  93B20013   LBU S2, 19(SP)
9D00E1EC  0F4034F2   JAL bcd2dec
9D00E1F0  3244001F   ANDI A0, S2, 31
9D00E1F4  7C51E644   INS S1, V0, 25, 4
484:                     wkday=buf[3]>>5;
9D00E1F8  00121142   SRL V0, S2, 5
485:                     if (wkday){ wkday--;}
9D00E1FC  10400003   BEQ V0, ZERO, 0x9D00E20C
9D00E200  AE110000   SW S1, 0(S0)
9D00E204  2442FFFF   ADDIU V0, V0, -1
9D00E208  304200FF   ANDI V0, V0, 255
486:                     pdown->wkday=wkday;
9D00E20C  8E030000   LW V1, 0(S0)
9D00E210  7C439C44   INS V1, V0, 17, 3
9D00E214  AE030000   SW V1, 0(S0)
487:                     wkday=rtcc_read_byte(RTC_WKDAY);
9D00E218  0F4035A8   JAL rtcc_read_byte
9D00E21C  24040003   ADDIU A0, ZERO, 3
488:                     wkday&=~PWRFAIL_MSK;
489:                     rtcc_write_byte(RTC_WKDAY,wkday);
9D00E220  24040003   ADDIU A0, ZERO, 3
9D00E224  0F403589   JAL rtcc_write_byte
9D00E228  304500EF   ANDI A1, V0, 239
490:                 }
9D00E22C  8FBF0024   LW RA, 36(SP)
9D00E230  8FB20020   LW S2, 32(SP)
9D00E234  8FB1001C   LW S1, 28(SP)
9D00E238  8FB00018   LW S0, 24(SP)
9D00E23C  03E00008   JR RA
9D00E240  27BD0028   ADDIU SP, SP, 40
491:                 
492:                 static void alarm_msg(char *msg){
9D00D41C  27BDFDF8   ADDIU SP, SP, -520
9D00D420  AFBF0204   SW RA, 516(SP)
9D00D424  AFB20200   SW S2, 512(SP)
9D00D428  AFB101FC   SW S1, 508(SP)
9D00D42C  AFB001F8   SW S0, 504(SP)
493:                 static  const unsigned int ring_tone[8]={329,250,523,250,329,250,0,0};
494:                     text_coord_t cpos;
495:                     uint8_t scr_save[HRES];
496:                     BOOL active,invert;
497:                 #define print_msg(s) vga_print(s)
498:                     
499:                     if ((active=vga_is_cursor_active())){
9D00D430  0F403B5B   JAL vga_is_cursor_active
9D00D434  00808821   ADDU S1, A0, ZERO
9D00D438  10400003   BEQ V0, ZERO, 0x9D00D448
9D00D43C  00408021   ADDU S0, V0, ZERO
500:                         vga_show_cursor(FALSE);
9D00D440  0F403B8F   JAL vga_show_cursor
9D00D444  00002021   ADDU A0, ZERO, ZERO
501:                     }
502:                     invert=vga_is_invert_video();
9D00D448  0F403B6B   JAL vga_is_invert_video
9D00D44C  00000000   NOP
9D00D450  00409021   ADDU S2, V0, ZERO
503:                     vga_invert_video(TRUE);
9D00D454  0F403B5E   JAL vga_invert_video
9D00D458  24040001   ADDIU A0, ZERO, 1
504:                     tune(ring_tone);
9D00D45C  3C049D02   LUI A0, -25342
9D00D460  0F4060A9   JAL tune
9D00D464  2484C43C   ADDIU A0, A0, -15300
505:                     msg[31]=0;
9D00D468  A220001F   SB ZERO, 31(S1)
506:                     memcpy((void*)scr_save,video_bmp,HRES);
9D00D46C  3C03A000   LUI V1, -24576
9D00D470  246300C0   ADDIU V1, V1, 192
9D00D474  27A50014   ADDIU A1, SP, 20
9D00D478  246401E0   ADDIU A0, V1, 480
9D00D47C  8C680000   LW T0, 0(V1)
9D00D480  8C670004   LW A3, 4(V1)
9D00D484  8C660008   LW A2, 8(V1)
9D00D488  8C62000C   LW V0, 12(V1)
9D00D48C  ACA80000   SW T0, 0(A1)
9D00D490  ACA70004   SW A3, 4(A1)
9D00D494  ACA60008   SW A2, 8(A1)
9D00D498  ACA2000C   SW V0, 12(A1)
9D00D49C  24630010   ADDIU V1, V1, 16
9D00D4A0  1464FFF6   BNE V1, A0, 0x9D00D47C
9D00D4A4  24A50010   ADDIU A1, A1, 16
507:                     cpos=vga_get_curpos();
9D00D4A8  0F403AE8   JAL vga_get_curpos
9D00D4AC  27A40010   ADDIU A0, SP, 16
508:                     vga_set_curpos(0,0);
9D00D4B0  00002021   ADDU A0, ZERO, ZERO
9D00D4B4  0F403BB2   JAL vga_set_curpos
9D00D4B8  00002821   ADDU A1, ZERO, ZERO
509:                     vga_clear_eol();
9D00D4BC  0F403ABE   JAL vga_clear_eol
9D00D4C0  00000000   NOP
510:                     print_msg("ALARM: ");
9D00D4C4  3C049D02   LUI A0, -25342
9D00D4C8  0F403AA2   JAL vga_print
9D00D4CC  2484C3C0   ADDIU A0, A0, -15424
511:                     print_msg(msg);
9D00D4D0  0F403AA2   JAL vga_print
9D00D4D4  02202021   ADDU A0, S1, ZERO
512:                     print_msg("  <any key> to exit\r");
9D00D4D8  3C049D02   LUI A0, -25342
9D00D4DC  0F403AA2   JAL vga_print
9D00D4E0  2484C3C8   ADDIU A0, A0, -15416
513:                     kbd_wait_key();
9D00D4E4  0F405FE2   JAL kbd_wait_key
9D00D4E8  00000000   NOP
514:                     memcpy(video_bmp,(void*)scr_save,HRES);
9D00D4EC  27A30014   ADDIU V1, SP, 20
9D00D4F0  3C04A000   LUI A0, -24576
9D00D4F4  248400C0   ADDIU A0, A0, 192
9D00D4F8  27A201F4   ADDIU V0, SP, 500
9D00D4FC  8C680000   LW T0, 0(V1)
9D00D500  8C670004   LW A3, 4(V1)
9D00D504  8C660008   LW A2, 8(V1)
9D00D508  8C65000C   LW A1, 12(V1)
9D00D50C  AC880000   SW T0, 0(A0)
9D00D510  AC870004   SW A3, 4(A0)
9D00D514  AC860008   SW A2, 8(A0)
9D00D518  AC85000C   SW A1, 12(A0)
9D00D51C  24630010   ADDIU V1, V1, 16
9D00D520  1462FFF6   BNE V1, V0, 0x9D00D4FC
9D00D524  24840010   ADDIU A0, A0, 16
515:                     if (!invert){
9D00D528  16400004   BNE S2, ZERO, 0x9D00D53C
9D00D52C  97A40010   LHU A0, 16(SP)
516:                         vga_invert_video(FALSE);
9D00D530  0F403B5E   JAL vga_invert_video
9D00D534  00002021   ADDU A0, ZERO, ZERO
517:                     }
518:                     vga_set_curpos(cpos.x,cpos.y);
9D00D538  97A40010   LHU A0, 16(SP)
9D00D53C  0F403BB2   JAL vga_set_curpos
9D00D540  97A50012   LHU A1, 18(SP)
519:                     if (active){
9D00D544  12000005   BEQ S0, ZERO, 0x9D00D55C
9D00D548  00000000   NOP
520:                         vga_show_cursor(TRUE);
9D00D54C  0F403B8F   JAL vga_show_cursor
9D00D550  24040001   ADDIU A0, ZERO, 1
9D00D554  0B40355A   J 0x9D00D568
9D00D558  8FBF0204   LW RA, 516(SP)
521:                     }else{
522:                         vga_show_cursor(FALSE);
9D00D55C  0F403B8F   JAL vga_show_cursor
9D00D560  00002021   ADDU A0, ZERO, ZERO
523:                     }
524:                     
525:                 }
9D00D564  8FBF0204   LW RA, 516(SP)
9D00D568  8FB20200   LW S2, 512(SP)
9D00D56C  8FB101FC   LW S1, 508(SP)
9D00D570  8FB001F8   LW S0, 504(SP)
9D00D574  03E00008   JR RA
9D00D578  27BD0208   ADDIU SP, SP, 520
526:                 
527:                 
528:                 __ISR (_CHANGE_NOTICE_VECTOR,IPL1SOFT) alarm(){
9D00E244  415DE800   RDPGPR SP, SP
9D00E248  401A7000   MFC0 K0, EPC
9D00E24C  401B6000   MFC0 K1, Status
9D00E250  27BDFF68   ADDIU SP, SP, -152
9D00E254  AFBA0094   SW K0, 148(SP)
9D00E258  401A6002   MFC0 K0, SRSCtl
9D00E25C  AFBB0090   SW K1, 144(SP)
9D00E260  AFBA008C   SW K0, 140(SP)
9D00E264  7C1B7844   INS K1, ZERO, 1, 15
9D00E268  377B0400   ORI K1, K1, 1024
9D00E26C  409B6000   MTC0 K1, Status
9D00E270  AFBF007C   SW RA, 124(SP)
9D00E274  AFB90078   SW T9, 120(SP)
9D00E278  AFB80074   SW T8, 116(SP)
9D00E27C  AFB00070   SW S0, 112(SP)
9D00E280  AFAF006C   SW T7, 108(SP)
9D00E284  AFAE0068   SW T6, 104(SP)
9D00E288  AFAD0064   SW T5, 100(SP)
9D00E28C  AFAC0060   SW T4, 96(SP)
9D00E290  AFAB005C   SW T3, 92(SP)
9D00E294  AFAA0058   SW T2, 88(SP)
9D00E298  AFA90054   SW T1, 84(SP)
9D00E29C  AFA80050   SW T0, 80(SP)
9D00E2A0  AFA7004C   SW A3, 76(SP)
9D00E2A4  AFA60048   SW A2, 72(SP)
9D00E2A8  AFA50044   SW A1, 68(SP)
9D00E2AC  AFA40040   SW A0, 64(SP)
9D00E2B0  AFA3003C   SW V1, 60(SP)
9D00E2B4  AFA20038   SW V0, 56(SP)
9D00E2B8  AFA10034   SW AT, 52(SP)
9D00E2BC  00001012   MFLO V0
9D00E2C0  AFA20084   SW V0, 132(SP)
9D00E2C4  00001810   MFHI V1
9D00E2C8  AFA30080   SW V1, 128(SP)
529:                    uint8_t byte,wkday, msg[32];
530:                 
531:                    if (CNSTATBbits.CNSTATB1 && !(RTCC_ALRM_PORT&RTCC_ALRM_PIN)){
9D00E2CC  3C02BF88   LUI V0, -16504
9D00E2D0  8C426190   LW V0, 24976(V0)
9D00E2D4  30420002   ANDI V0, V0, 2
9D00E2D8  10400033   BEQ V0, ZERO, 0x9D00E3A8
9D00E2DC  3C02BF88   LUI V0, -16504
9D00E2E0  8C426120   LW V0, 24864(V0)
9D00E2E4  30420002   ANDI V0, V0, 2
9D00E2E8  14400030   BNE V0, ZERO, 0x9D00E3AC
9D00E2EC  3C02BF88   LUI V0, -16504
532:                         byte=rtcc_read_byte(RTC_CONTROL);
9D00E2F0  0F4035A8   JAL rtcc_read_byte
9D00E2F4  24040007   ADDIU A0, ZERO, 7
9D00E2F8  00408021   ADDU S0, V0, ZERO
533:                         if (byte & ALM0EN_MSK){ // alarme 0 active?
9D00E2FC  30420010   ANDI V0, V0, 16
9D00E300  304200FF   ANDI V0, V0, 255
9D00E304  1040000F   BEQ V0, ZERO, 0x9D00E344
9D00E308  32020020   ANDI V0, S0, 32
534:                             wkday=rtcc_read_byte(RTC_ALM0WKDAY);
9D00E30C  0F4035A8   JAL rtcc_read_byte
9D00E310  2404000D   ADDIU A0, ZERO, 13
535:                             if (wkday&ALMIF){
9D00E314  30420008   ANDI V0, V0, 8
9D00E318  304200FF   ANDI V0, V0, 255
9D00E31C  10400009   BEQ V0, ZERO, 0x9D00E344
9D00E320  32020020   ANDI V0, S0, 32
536:                                 byte&=~ALM0EN_MSK;
9D00E324  321000EF   ANDI S0, S0, 239
537:                                 rtcc_read_buf(0x20,msg,32);
9D00E328  24040020   ADDIU A0, ZERO, 32
9D00E32C  27A50010   ADDIU A1, SP, 16
9D00E330  0F4035C6   JAL rtcc_read_buf
9D00E334  24060020   ADDIU A2, ZERO, 32
538:                                 alarm_msg(msg);
9D00E338  0F403507   JAL alarm_msg
9D00E33C  27A40010   ADDIU A0, SP, 16
539:                             }
540:                         }
541:                         if (byte & ALM1EN_MSK){ // alarme 1 active?
9D00E340  32020020   ANDI V0, S0, 32
9D00E344  304200FF   ANDI V0, V0, 255
9D00E348  1040000F   BEQ V0, ZERO, 0x9D00E388
9D00E34C  24040007   ADDIU A0, ZERO, 7
542:                             wkday=rtcc_read_byte(RTC_ALM1WKDAY);
9D00E350  0F4035A8   JAL rtcc_read_byte
9D00E354  24040014   ADDIU A0, ZERO, 20
543:                             if (wkday&ALMIF){
9D00E358  30420008   ANDI V0, V0, 8
9D00E35C  304200FF   ANDI V0, V0, 255
9D00E360  50400009   BEQL V0, ZERO, 0x9D00E388
9D00E364  24040007   ADDIU A0, ZERO, 7
544:                                 byte&=~ALM1EN_MSK;
9D00E368  321000DF   ANDI S0, S0, 223
545:                                 rtcc_read_buf(0x40,msg,32);
9D00E36C  24040040   ADDIU A0, ZERO, 64
9D00E370  27A50010   ADDIU A1, SP, 16
9D00E374  0F4035C6   JAL rtcc_read_buf
9D00E378  24060020   ADDIU A2, ZERO, 32
546:                                 alarm_msg(msg);
9D00E37C  0F403507   JAL alarm_msg
9D00E380  27A40010   ADDIU A0, SP, 16
547:                             }
548:                         }
549:                         rtcc_write_byte(RTC_CONTROL,byte);
9D00E384  24040007   ADDIU A0, ZERO, 7
9D00E388  0F403589   JAL rtcc_write_byte
9D00E38C  02002821   ADDU A1, S0, ZERO
550:                         if (!(byte&(ALM0EN_MSK|ALM1EN_MSK))){
9D00E390  32100030   ANDI S0, S0, 48
9D00E394  16000004   BNE S0, ZERO, 0x9D00E3A8
9D00E398  3C02BF88   LUI V0, -16504
551:                             IEC1bits.CNBIE=0;
9D00E39C  8C431070   LW V1, 4208(V0)
9D00E3A0  7C037384   INS V1, ZERO, 14, 1
9D00E3A4  AC431070   SW V1, 4208(V0)
552:                         }
553:                    }
554:                    IFS1bits.CNBIF=0;
9D00E3A8  3C02BF88   LUI V0, -16504
9D00E3AC  8C431040   LW V1, 4160(V0)
9D00E3B0  7C037384   INS V1, ZERO, 14, 1
9D00E3B4  AC431040   SW V1, 4160(V0)
555:                 }
9D00E3B8  8FA20084   LW V0, 132(SP)
9D00E3BC  00400013   MTLO V0
9D00E3C0  8FA30080   LW V1, 128(SP)
9D00E3C4  00600011   MTHI V1
9D00E3C8  8FBF007C   LW RA, 124(SP)
9D00E3CC  8FB90078   LW T9, 120(SP)
9D00E3D0  8FB80074   LW T8, 116(SP)
9D00E3D4  8FB00070   LW S0, 112(SP)
9D00E3D8  8FAF006C   LW T7, 108(SP)
9D00E3DC  8FAE0068   LW T6, 104(SP)
9D00E3E0  8FAD0064   LW T5, 100(SP)
9D00E3E4  8FAC0060   LW T4, 96(SP)
9D00E3E8  8FAB005C   LW T3, 92(SP)
9D00E3EC  8FAA0058   LW T2, 88(SP)
9D00E3F0  8FA90054   LW T1, 84(SP)
9D00E3F4  8FA80050   LW T0, 80(SP)
9D00E3F8  8FA7004C   LW A3, 76(SP)
9D00E3FC  8FA60048   LW A2, 72(SP)
9D00E400  8FA50044   LW A1, 68(SP)
9D00E404  8FA40040   LW A0, 64(SP)
9D00E408  8FA3003C   LW V1, 60(SP)
9D00E40C  8FA20038   LW V0, 56(SP)
9D00E410  8FA10034   LW AT, 52(SP)
9D00E414  41606000   DI ZERO
9D00E418  000000C0   EHB
9D00E41C  8FBA0094   LW K0, 148(SP)
9D00E420  8FBB0090   LW K1, 144(SP)
9D00E424  409A7000   MTC0 K0, EPC
9D00E428  8FBA008C   LW K0, 140(SP)
9D00E42C  27BD0098   ADDIU SP, SP, 152
9D00E430  409A6002   MTC0 K0, SRSCtl
9D00E434  41DDE800   WRPGPR SP, SP
9D00E438  409B6000   MTC0 K1, Status
9D00E43C  42000018   ERET
556:                 
---  /home/jacques/github/vpc-32vga/hardware/ps2_kbd/keyboard.c  ----------------------------------------
1:                   /*
2:                   * Copyright 2013,2017,2018 Jacques Deschênes
3:                   * This file is part of VPC-32vga.
4:                   *
5:                   *     VPC-32vga is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32vga is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32vga.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   * Name: keyboard.c
20:                   * Author: Jacques Deschênes
21:                   * Description:  PS/2 keyboard low level interface
22:                   * REF: http://www.computer-engineering.org/ps2protocol/
23:                   * Date: 2013-08-26
24:                   * rev: 2017-07-30
25:                   */
26:                  #include <p32xxxx.h>
27:                  #include <plib.h>
28:                  #include <stdint.h>
29:                  #include <stdbool.h>
30:                  #include "../HardwareProfile.h"
31:                  #include "keyboard.h"
32:                  #include "../serial_comm/serial_comm.h"
33:                  
34:                  // using circular queues for received scan codes and translated codes.
35:                  #define KBD_QUEUE_SIZE (32)
36:                  static  unsigned char kbd_queue[KBD_QUEUE_SIZE]; // keyboard translated codes queue
37:                  volatile static unsigned char kbd_head=0, kbd_tail=0; // kbd_queue head and tail pointer
38:                  
39:                  // initialize UART1 keyboard receive character.
40:                  int kbd_init(){
41:                      U1BRG=PBCLK/16/9600-1;
9D017E9C  24030103   ADDIU V1, ZERO, 259
9D017EA0  3C02BF80   LUI V0, -16512
9D017EA4  AC436040   SW V1, 24640(V0)
42:                      U1RXR=KBD_RP_FN;
9D017EA8  24030004   ADDIU V1, ZERO, 4
9D017EAC  3C02BF81   LUI V0, -16511
9D017EB0  AC43FA50   SW V1, -1456(V0)
43:                      U1STA=(1<<12); //RXEN
9D017EB4  24031000   ADDIU V1, ZERO, 4096
9D017EB8  3C02BF80   LUI V0, -16512
9D017EBC  AC436010   SW V1, 24592(V0)
44:                      IPC8bits.U1IP=3;
9D017EC0  3C02BF88   LUI V0, -16504
9D017EC4  8C431110   LW V1, 4368(V0)
9D017EC8  24040003   ADDIU A0, ZERO, 3
9D017ECC  7C832084   INS V1, A0, 2, 3
9D017ED0  AC431110   SW V1, 4368(V0)
45:                      IPC8bits.U1IS=0;
9D017ED4  8C431110   LW V1, 4368(V0)
9D017ED8  7C030804   INS V1, ZERO, 0, 2
9D017EDC  AC431110   SW V1, 4368(V0)
46:                      IFS1bits.U1EIF=0;
9D017EE0  3C02BF88   LUI V0, -16504
9D017EE4  8C431040   LW V1, 4160(V0)
9D017EE8  7C0339C4   INS V1, ZERO, 7, 1
9D017EEC  AC431040   SW V1, 4160(V0)
47:                      IFS1bits.U1RXIF=0;
9D017EF0  8C431040   LW V1, 4160(V0)
9D017EF4  7C034204   INS V1, ZERO, 8, 1
9D017EF8  AC431040   SW V1, 4160(V0)
48:                      IEC1bits.U1EIE=1;
9D017EFC  3C02BF88   LUI V0, -16504
9D017F00  8C431070   LW V1, 4208(V0)
9D017F04  24040001   ADDIU A0, ZERO, 1
9D017F08  7C8339C4   INS V1, A0, 7, 1
9D017F0C  AC431070   SW V1, 4208(V0)
49:                      IEC1bits.U1RXIE=1;
9D017F10  8C431070   LW V1, 4208(V0)
9D017F14  7C834204   INS V1, A0, 8, 1
9D017F18  AC431070   SW V1, 4208(V0)
50:                      U1MODE=(1<<15);
9D017F1C  34038000   ORI V1, ZERO, -32768
9D017F20  3C02BF80   LUI V0, -16512
9D017F24  AC436000   SW V1, 24576(V0)
51:                      return 0;
52:                  } //keyboard_init()
9D017F28  03E00008   JR RA
9D017F2C  00001021   ADDU V0, ZERO, ZERO
53:                  
54:                  
55:                  
56:                  // return translated key code.
57:                  // from kbd_queue.
58:                  unsigned char kbd_get_key(){
59:                      unsigned char key;
60:                      
61:                      if (kbd_head==kbd_tail) return 0;
9D017F30  9383801D   LBU V1, -32739(GP)
9D017F34  306300FF   ANDI V1, V1, 255
9D017F38  9382801C   LBU V0, -32740(GP)
9D017F3C  304200FF   ANDI V0, V0, 255
9D017F40  1062000F   BEQ V1, V0, 0x9D017F80
9D017F44  00000000   NOP
62:                      key=kbd_queue[kbd_head++];
9D017F48  9382801D   LBU V0, -32739(GP)
9D017F4C  304200FF   ANDI V0, V0, 255
9D017F50  24430001   ADDIU V1, V0, 1
9D017F54  306300FF   ANDI V1, V1, 255
9D017F58  A383801D   SB V1, -32739(GP)
9D017F5C  3C03A000   LUI V1, -24576
9D017F60  24634558   ADDIU V1, V1, 17752
9D017F64  00431021   ADDU V0, V0, V1
9D017F68  90420000   LBU V0, 0(V0)
63:                      kbd_head&=KBD_QUEUE_SIZE-1;
9D017F6C  9383801D   LBU V1, -32739(GP)
9D017F70  3063001F   ANDI V1, V1, 31
9D017F74  A383801D   SB V1, -32739(GP)
64:                      return key;
9D017F78  03E00008   JR RA
9D017F7C  00000000   NOP
65:                  } // GetKey()
9D017F80  03E00008   JR RA
9D017F84  00001021   ADDU V0, ZERO, ZERO
66:                  
67:                  unsigned char kbd_wait_key(){ // attend qu'une touche soit enfoncée et retourne sa valeur.
9D017F88  27BDFFE8   ADDIU SP, SP, -24
9D017F8C  AFBF0014   SW RA, 20(SP)
9D017F90  AFB00010   SW S0, 16(SP)
68:                      unsigned char key;
69:                      
70:                      vga_show_cursor(TRUE);
9D017F94  0F403B8F   JAL vga_show_cursor
9D017F98  24040001   ADDIU A0, ZERO, 1
71:                      while (!(key=kbd_get_key())){
9D017F9C  0F405FCC   JAL kbd_get_key
9D017FA0  00000000   NOP
9D017FA4  1040FFFD   BEQ V0, ZERO, 0x9D017F9C
9D017FA8  00408021   ADDU S0, V0, ZERO
72:                      }//while
73:                      vga_show_cursor(FALSE);
9D017FAC  0F403B8F   JAL vga_show_cursor
9D017FB0  00002021   ADDU A0, ZERO, ZERO
74:                      return key;
75:                  }//kbd_wait_key()
9D017FB4  02001021   ADDU V0, S0, ZERO
9D017FB8  8FBF0014   LW RA, 20(SP)
9D017FBC  8FB00010   LW S0, 16(SP)
9D017FC0  03E00008   JR RA
9D017FC4  27BD0018   ADDIU SP, SP, 24
76:                  
77:                   // lit une ligne au clavier, retourne la longueur du texte.
78:                  unsigned char kbd_read_line(unsigned char *ibuff,unsigned char max_char){
9D017FC8  27BDFFD0   ADDIU SP, SP, -48
9D017FCC  AFBF002C   SW RA, 44(SP)
9D017FD0  AFB60028   SW S6, 40(SP)
9D017FD4  AFB50024   SW S5, 36(SP)
9D017FD8  AFB40020   SW S4, 32(SP)
9D017FDC  AFB3001C   SW S3, 28(SP)
9D017FE0  AFB20018   SW S2, 24(SP)
9D017FE4  AFB10014   SW S1, 20(SP)
9D017FE8  AFB00010   SW S0, 16(SP)
9D017FEC  00809821   ADDU S3, A0, ZERO
9D017FF0  00A0A021   ADDU S4, A1, ZERO
79:                      unsigned char c=0, count=0;
9D017FF4  00008021   ADDU S0, ZERO, ZERO
80:                      while ((c!='\r') && (count<=max_char)){
9D01804C  0B406021   J 0x9D018084
9D018050  0290102B   SLTU V0, S4, S0
9D018080  0290102B   SLTU V0, S4, S0
9D018084  1040FFE0   BEQ V0, ZERO, 0x9D018008
9D018088  00000000   NOP
81:                          c=kbd_wait_key();
9D018008  0F405FE2   JAL kbd_wait_key
9D01800C  00000000   NOP
82:                          if (c==CR){
9D017FF8  2411000D   ADDIU S1, ZERO, 13
9D018010  14510005   BNE V0, S1, 0x9D018028
9D018014  00000000   NOP
83:                              vga_put_char('\r');
9D018018  0F403A08   JAL vga_put_char
9D01801C  2404000D   ADDIU A0, ZERO, 13
84:                              break;
9D018020  0B406024   J 0x9D018090
9D018024  A2600000   SB ZERO, 0(S3)
85:                          }else if (c==BS){
9D017FFC  24120008   ADDIU S2, ZERO, 8
9D018028  1452000A   BNE V0, S2, 0x9D018054
9D01802C  2443FFE0   ADDIU V1, V0, -32
86:                              if (count){
9D018030  1200FFF5   BEQ S0, ZERO, 0x9D018008
9D018034  00000000   NOP
87:                                  ibuff--;
9D018038  2673FFFF   ADDIU S3, S3, -1
88:                                  count--;
9D01803C  2610FFFF   ADDIU S0, S0, -1
9D018040  321000FF   ANDI S0, S0, 255
89:                                  vga_print("\b \b");
9D018000  3C159D02   LUI S5, -25342
9D018004  26B5D3AC   ADDIU S5, S5, -11348
9D018044  0F403AA2   JAL vga_print
9D018048  02A02021   ADDU A0, S5, ZERO
90:                              }
91:                          }else if (c >=32 && c<=127){
9D018054  306300FF   ANDI V1, V1, 255
9D018058  2C630060   SLTIU V1, V1, 96
9D01805C  50600009   BEQL V1, ZERO, 0x9D018084
9D018060  0290102B   SLTU V0, S4, S0
92:                              *ibuff++=c;
9D018064  26760001   ADDIU S6, S3, 1
9D018068  A2620000   SB V0, 0(S3)
9D01807C  02C09821   ADDU S3, S6, ZERO
93:                              count++;
9D01806C  26100001   ADDIU S0, S0, 1
9D018070  321000FF   ANDI S0, S0, 255
94:                              vga_put_char(c);
9D018074  0F403A08   JAL vga_put_char
9D018078  7C022420   SEB A0, V0
95:                          }
96:                      }// while
97:                      *ibuff=(char)0;
9D01808C  A2600000   SB ZERO, 0(S3)
98:                      return count;
99:                  } // readline()
9D018090  02001021   ADDU V0, S0, ZERO
9D018094  8FBF002C   LW RA, 44(SP)
9D018098  8FB60028   LW S6, 40(SP)
9D01809C  8FB50024   LW S5, 36(SP)
9D0180A0  8FB40020   LW S4, 32(SP)
9D0180A4  8FB3001C   LW S3, 28(SP)
9D0180A8  8FB20018   LW S2, 24(SP)
9D0180AC  8FB10014   LW S1, 20(SP)
9D0180B0  8FB00010   LW S0, 16(SP)
9D0180B4  03E00008   JR RA
9D0180B8  27BD0030   ADDIU SP, SP, 48
100:                 
101:                 
102:                 #define ERROR_BITS (7<<1)
103:                 
104:                 // keyboard character reception
105:                 void __ISR(_UART_1_VECTOR,IPL3SOFT) kbd_rx_isr(void){
9D0180BC  415DE800   RDPGPR SP, SP
9D0180C0  401A7000   MFC0 K0, EPC
9D0180C4  401B6000   MFC0 K1, Status
9D0180C8  27BDFFE0   ADDIU SP, SP, -32
9D0180CC  AFBA001C   SW K0, 28(SP)
9D0180D0  401A6002   MFC0 K0, SRSCtl
9D0180D4  AFBB0018   SW K1, 24(SP)
9D0180D8  AFBA0014   SW K0, 20(SP)
9D0180DC  7C1B7844   INS K1, ZERO, 1, 15
9D0180E0  377B0C00   ORI K1, K1, 3072
9D0180E4  409B6000   MTC0 K1, Status
9D0180E8  AFA4000C   SW A0, 12(SP)
9D0180EC  AFA30008   SW V1, 8(SP)
9D0180F0  AFA20004   SW V0, 4(SP)
106:                     if (U1STA&ERROR_BITS){
9D0180F4  3C02BF80   LUI V0, -16512
9D0180F8  8C426010   LW V0, 24592(V0)
9D0180FC  3042000E   ANDI V0, V0, 14
9D018100  1040000E   BEQ V0, ZERO, 0x9D01813C
9D018104  3C02BF80   LUI V0, -16512
107:                         U1MODEbits.ON=0;
9D018108  94436000   LHU V1, 24576(V0)
9D01810C  7C037BC4   INS V1, ZERO, 15, 1
9D018110  A4436000   SH V1, 24576(V0)
108:                         U1MODEbits.ON=1;
9D018114  94436000   LHU V1, 24576(V0)
9D018118  24040001   ADDIU A0, ZERO, 1
9D01811C  7C837BC4   INS V1, A0, 15, 1
9D018120  A4436000   SH V1, 24576(V0)
109:                         IFS1bits.U1EIF=0;
9D018124  3C02BF88   LUI V0, -16504
9D018128  8C431040   LW V1, 4160(V0)
9D01812C  7C0339C4   INS V1, ZERO, 7, 1
9D018130  AC431040   SW V1, 4160(V0)
9D018134  0B406061   J 0x9D018184
9D018138  00000000   NOP
110:                     }else{
111:                         kbd_queue[kbd_tail++]=U1RXREG;
9D01813C  9382801C   LBU V0, -32740(GP)
9D018140  304200FF   ANDI V0, V0, 255
9D018144  24430001   ADDIU V1, V0, 1
9D018148  306300FF   ANDI V1, V1, 255
9D01814C  A383801C   SB V1, -32740(GP)
9D018150  3C03BF80   LUI V1, -16512
9D018154  8C636030   LW V1, 24624(V1)
9D018158  3C04A000   LUI A0, -24576
9D01815C  24844558   ADDIU A0, A0, 17752
9D018160  00441021   ADDU V0, V0, A0
9D018164  A0430000   SB V1, 0(V0)
112:                         kbd_tail&=KBD_QUEUE_SIZE-1;
9D018168  9382801C   LBU V0, -32740(GP)
9D01816C  3042001F   ANDI V0, V0, 31
9D018170  A382801C   SB V0, -32740(GP)
113:                         IFS1bits.U1RXIF=0;
9D018174  3C02BF88   LUI V0, -16504
9D018178  8C431040   LW V1, 4160(V0)
9D01817C  7C034204   INS V1, ZERO, 8, 1
9D018180  AC431040   SW V1, 4160(V0)
114:                     }
115:                 } // kbd_rx_isr()
9D018184  8FA4000C   LW A0, 12(SP)
9D018188  8FA30008   LW V1, 8(SP)
9D01818C  8FA20004   LW V0, 4(SP)
9D018190  41606000   DI ZERO
9D018194  000000C0   EHB
9D018198  8FBA001C   LW K0, 28(SP)
9D01819C  8FBB0018   LW K1, 24(SP)
9D0181A0  409A7000   MTC0 K0, EPC
9D0181A4  8FBA0014   LW K0, 20(SP)
9D0181A8  27BD0020   ADDIU SP, SP, 32
9D0181AC  409A6002   MTC0 K0, SRSCtl
9D0181B0  41DDE800   WRPGPR SP, SP
9D0181B4  409B6000   MTC0 K1, Status
9D0181B8  42000018   ERET
116:                 
---  /home/jacques/github/vpc-32vga/hardware/exception.c  -----------------------------------------------
1:                   #include <stdlib.h>
2:                   #include <stdio.h>
3:                   #include <stdint.h>
4:                   #include <setjmp.h>
5:                   #include <p32xxxx.h>
6:                   #include "HardwareProfile.h"
7:                   #include "serial_comm/serial_comm.h"
8:                   
9:                   
10:                  void _general_exception_handler(){
9D019C40  27BDFFA8   ADDIU SP, SP, -88
9D019C44  AFBF0054   SW RA, 84(SP)
9D019C48  AFB00050   SW S0, 80(SP)
11:                  #define _prt(s) ser_print(s);vga_print(s)
12:                  
13:                      unsigned cause,epc;
14:                      char fmt[64];
15:                  
16:                  
17:                      asm volatile("mfc0 %0,$13":"=r"(cause));
9D019C4C  40106800   MFC0 S0, Cause
18:                      cause>>=2;
9D019C50  00108082   SRL S0, S0, 2
19:                      cause&=0x1f;
9D019C8C  3202001F   ANDI V0, S0, 31
20:                      epc= __builtin_mfc0(_CP0_EPC, _CP0_EPC_SELECT);
9D019C54  40067000   MFC0 A2, EPC
21:                      asm volatile("mfc0 $k0, $12");
9D019C58  401A6000   MFC0 K0, Status
22:                      asm volatile("andi $k0,0xfd");
9D019C5C  335A00FD   ANDI K0, K0, 253
23:                      asm volatile("mtc0 $k0,$12");
9D019C60  409A6000   MTC0 K0, Status
24:                      asm volatile("ei");
9D019C64  41606020   EI ZERO
25:                      asm volatile("ehb");
9D019C68  000000C0   EHB
26:                      sprintf(fmt,"Fatal error at address: %0x\n",epc);
9D019C6C  27A40010   ADDIU A0, SP, 16
9D019C70  3C059D02   LUI A1, -25342
9D019C74  0F407973   JAL _sprintf_cdnopsuxX
9D019C78  24A5AAC4   ADDIU A1, A1, -21820
27:                      _prt(fmt);
9D019C7C  0F405504   JAL ser_print
9D019C80  27A40010   ADDIU A0, SP, 16
9D019C84  0F403AA2   JAL vga_print
9D019C88  27A40010   ADDIU A0, SP, 16
28:                      switch (cause){
9D019C90  2C43000E   SLTIU V1, V0, 14
9D019C94  10600062   BEQ V1, ZERO, 0x9D019E20
9D019C98  00021080   SLL V0, V0, 2
9D019C9C  3C039D02   LUI V1, -25342
9D019CA0  24639CB4   ADDIU V1, V1, -25420
9D019CA4  00621021   ADDU V0, V1, V0
9D019CA8  8C420000   LW V0, 0(V0)
9D019CAC  00400008   JR V0
9D019CB0  00000000   NOP
29:                          case SYS:
30:                              _prt("opcode syscall invoked\n");
9D019CEC  3C109D02   LUI S0, -25342
9D019CF0  0F405504   JAL ser_print
9D019CF4  2604AAE4   ADDIU A0, S0, -21788
9D019CF8  0F403AA2   JAL vga_print
9D019CFC  2604AAE4   ADDIU A0, S0, -21788
31:                              break;
9D019D00  0B40678E   J 0x9D019E38
9D019D04  3C109D02   LUI S0, -25342
32:                          case INTR:
33:                              _prt("unmanaged interrupt\n");
9D019D08  3C109D02   LUI S0, -25342
9D019D0C  0F405504   JAL ser_print
9D019D10  2604AAFC   ADDIU A0, S0, -21764
9D019D14  0F403AA2   JAL vga_print
9D019D18  2604AAFC   ADDIU A0, S0, -21764
34:                              break;
9D019D1C  0B40678E   J 0x9D019E38
9D019D20  3C109D02   LUI S0, -25342
35:                          case ADEL:
36:                              _prt("Address error exception (load or instruction fetch)\n");
9D019D24  3C109D02   LUI S0, -25342
9D019D28  0F405504   JAL ser_print
9D019D2C  2604AB14   ADDIU A0, S0, -21740
9D019D30  0F403AA2   JAL vga_print
9D019D34  2604AB14   ADDIU A0, S0, -21740
37:                              break;
9D019D38  0B40678E   J 0x9D019E38
9D019D3C  3C109D02   LUI S0, -25342
38:                          case ADES:
39:                              _prt("Address error exception (store)\n");
9D019D40  3C109D02   LUI S0, -25342
9D019D44  0F405504   JAL ser_print
9D019D48  2604AB4C   ADDIU A0, S0, -21684
9D019D4C  0F403AA2   JAL vga_print
9D019D50  2604AB4C   ADDIU A0, S0, -21684
40:                              break;
9D019D54  0B40678E   J 0x9D019E38
9D019D58  3C109D02   LUI S0, -25342
41:                          case IBE:
42:                              _prt("Bus error exception (instruction fetch)\n");
9D019D5C  3C109D02   LUI S0, -25342
9D019D60  0F405504   JAL ser_print
9D019D64  2604AB70   ADDIU A0, S0, -21648
9D019D68  0F403AA2   JAL vga_print
9D019D6C  2604AB70   ADDIU A0, S0, -21648
43:                              break;
9D019D70  0B40678E   J 0x9D019E38
9D019D74  3C109D02   LUI S0, -25342
44:                          case DBE:
45:                              _prt("Bus error exception (data reference: load or store)\n");
9D019D78  3C109D02   LUI S0, -25342
9D019D7C  0F405504   JAL ser_print
9D019D80  2604AB9C   ADDIU A0, S0, -21604
9D019D84  0F403AA2   JAL vga_print
9D019D88  2604AB9C   ADDIU A0, S0, -21604
46:                              break;
9D019D8C  0B40678E   J 0x9D019E38
9D019D90  3C109D02   LUI S0, -25342
47:                          case BP:
48:                              _prt("Breakpoint exception\n");
9D019D94  3C109D02   LUI S0, -25342
9D019D98  0F405504   JAL ser_print
9D019D9C  2604ABD4   ADDIU A0, S0, -21548
9D019DA0  0F403AA2   JAL vga_print
9D019DA4  2604ABD4   ADDIU A0, S0, -21548
49:                              break;
9D019DA8  0B40678E   J 0x9D019E38
9D019DAC  3C109D02   LUI S0, -25342
50:                          case RI:
51:                              _prt("Reserved instruction exception\n");
9D019DB0  3C109D02   LUI S0, -25342
9D019DB4  0F405504   JAL ser_print
9D019DB8  2604ABEC   ADDIU A0, S0, -21524
9D019DBC  0F403AA2   JAL vga_print
9D019DC0  2604ABEC   ADDIU A0, S0, -21524
52:                              break;
9D019DC4  0B40678E   J 0x9D019E38
9D019DC8  3C109D02   LUI S0, -25342
53:                          case CPU:
54:                              _prt("Coprocessor Unusable exception\n");
9D019DCC  3C109D02   LUI S0, -25342
9D019DD0  0F405504   JAL ser_print
9D019DD4  2604AC0C   ADDIU A0, S0, -21492
9D019DD8  0F403AA2   JAL vga_print
9D019DDC  2604AC0C   ADDIU A0, S0, -21492
55:                              break;
9D019DE0  0B40678E   J 0x9D019E38
9D019DE4  3C109D02   LUI S0, -25342
56:                          case OVF:
57:                              _prt("Arithmetic Overflow exception\n");
9D019DE8  3C109D02   LUI S0, -25342
9D019DEC  0F405504   JAL ser_print
9D019DF0  2604AC2C   ADDIU A0, S0, -21460
9D019DF4  0F403AA2   JAL vga_print
9D019DF8  2604AC2C   ADDIU A0, S0, -21460
58:                              break;
9D019DFC  0B40678E   J 0x9D019E38
9D019E00  3C109D02   LUI S0, -25342
59:                          case TRAP:
60:                              _prt("Trap exception\n");
9D019E04  3C109D02   LUI S0, -25342
9D019E08  0F405504   JAL ser_print
9D019E0C  2604AC4C   ADDIU A0, S0, -21428
9D019E10  0F403AA2   JAL vga_print
9D019E14  2604AC4C   ADDIU A0, S0, -21428
61:                              break;
9D019E18  0B40678E   J 0x9D019E38
9D019E1C  3C109D02   LUI S0, -25342
62:                          default:
63:                              _prt("unknown exception\n");
9D019E20  3C109D02   LUI S0, -25342
9D019E24  0F405504   JAL ser_print
9D019E28  2604AC5C   ADDIU A0, S0, -21412
9D019E2C  0F403AA2   JAL vga_print
9D019E30  2604AC5C   ADDIU A0, S0, -21412
64:                      }//switch
65:                      _prt("<CTRL>-<ALT>-<DEL> to reboot.\n");
9D019E34  3C109D02   LUI S0, -25342
9D019E38  0F405504   JAL ser_print
9D019E3C  2604AC70   ADDIU A0, S0, -21392
9D019E40  0F403AA2   JAL vga_print
9D019E44  2604AC70   ADDIU A0, S0, -21392
66:                      while (1){
67:                          power_led(PLED_OFF);
9D019E48  0F405279   JAL power_led
9D019E4C  00002021   ADDU A0, ZERO, ZERO
68:                          delay_ms(500);
9D019E50  0F4052A0   JAL delay_ms
9D019E54  240401F4   ADDIU A0, ZERO, 500
69:                          power_led(PLED_ON);
9D019E58  0F405279   JAL power_led
9D019E5C  24040001   ADDIU A0, ZERO, 1
70:                          delay_ms(500);
9D019E60  0F4052A0   JAL delay_ms
9D019E64  240401F4   ADDIU A0, ZERO, 500
9D019E68  0B406792   J 0x9D019E48
9D019E6C  00000000   NOP
71:                      }//while
72:                  }
73:                  
74:                  
---  /home/jacques/github/vpc-32vga/hardware/Pinguino/sdmmc.c  ------------------------------------------
1:                   /*
2:                   ** SDMMC.c SD card interface
3:                   **
4:                   ** 7/20/06 v1.4 LDJ
5:                   ** 7/14/07 v2.0 LDJ
6:                   **
7:                   [30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
8:                   ** 07 May 2012	Changes made to allow SD card library to support
9:                   **					PIC32 Pinguino and PIC32 Pinguino Micro that have neither
10:                  **					SD card presence nor WP switch detection switches.
11:                  **					see functions getCD() and getWP() below.
12:                  */
13:                  /*
14:                   *  adapted to VPC-32 project by Jacques Deschênes 2013,2014
15:                   */
16:                  
17:                  #ifndef __SDMMC_C__
18:                  #define __SDMMC_C__
19:                  
20:                  //#include <system.c>
21:                  //#include <digitalw.c>
22:                  //#include <spi.c>        // in order to use default SPI port
23:                  #include <plib.h>
24:                  #include "sdmmc.h"
25:                  //#include "diskio.h"
26:                  //#include "ff.h"
27:                  
28:                  
29:                  void initSD(void)
30:                  {
9D018A94  27BDFFE8   ADDIU SP, SP, -24
9D018A98  AFBF0014   SW RA, 20(SP)
31:                      if (!store_initialized) store_spi_init();
9D018A9C  9382803C   LBU V0, -32708(GP)
9D018AA0  14400004   BNE V0, ZERO, 0x9D018AB4
9D018AA4  8FBF0014   LW RA, 20(SP)
9D018AA8  0F40762E   JAL store_spi_init
9D018AAC  00000000   NOP
32:                  
33:                  //    PORTB |=SDCSEL; //digitalwrite(SDCSEL, HIGH);	// initially keep the SD card disabled
34:                  //	TRISB &=~SDCSEL; //pinmode(SDCSEL, OUTPUT);		// make Card select an output pin
35:                  //
36:                  //	// init the spi module for a slow (safe) clock speed first
37:                  //
38:                  //	SPI2CON = 0x8120;   // ON (0x8000), CKE=1 (0x100), CKP=0, Master mode (0x20)
39:                  //	SPI2BRG = (mGetPeripheralClock() / (2 * 10000000)) - 1; // 10Mbits/sec
40:                  
41:                  }   // initSD
9D018AB0  8FBF0014   LW RA, 20(SP)
9D018AB4  03E00008   JR RA
9D018AB8  27BD0018   ADDIU SP, SP, 24
42:                  
43:                  
44:                  void disableSD(void)
45:                  {
9D018ABC  27BDFFE8   ADDIU SP, SP, -24
9D018AC0  AFBF0014   SW RA, 20(SP)
46:                  
47:                     _sdc_deselect(); 
9D018AC4  24030008   ADDIU V1, ZERO, 8
9D018AC8  3C02BF88   LUI V0, -16504
9D018ACC  AC436128   SW V1, 24872(V0)
48:                     clockSPI();
9D018AD0  0F407642   JAL writeSPI
9D018AD4  240400FF   ADDIU A0, ZERO, 255
49:                  }
9D018AD8  8FBF0014   LW RA, 20(SP)
9D018ADC  03E00008   JR RA
9D018AE0  27BD0018   ADDIU SP, SP, 24
50:                  
51:                  void enableSD(void)
52:                  {
53:                      _sdc_select();
9D018AE4  24030008   ADDIU V1, ZERO, 8
9D018AE8  3C02BF88   LUI V0, -16504
9D018AEC  AC436124   SW V1, 24868(V0)
9D018AF0  03E00008   JR RA
9D018AF4  00000000   NOP
9D018B08  24030008   ADDIU V1, ZERO, 8
9D018B9C  3C02BF88   LUI V0, -16504
9D018BA0  AC436124   SW V1, 24868(V0)
54:                  
55:                  }
56:                  
57:                  // c    command code
58:                  // a    byte address of data block
59:                  int sendSDCmd(unsigned char c, unsigned a)
60:                  {
9D018AF8  27BDFFE8   ADDIU SP, SP, -24
9D018AFC  AFBF0014   SW RA, 20(SP)
9D018B00  AFB00010   SW S0, 16(SP)
9D018B04  00A08021   ADDU S0, A1, ZERO
61:                  	int i, r;
62:                  
63:                  	// enable SD card
64:                  	// CS low
65:                  	enableSD();
66:                  
67:                  	// send a comand packet (6 bytes)
68:                  	writeSPI(c | 0x40);    // send command
9D018B14  0F407642   JAL writeSPI
9D018B18  34840040   ORI A0, A0, 64
69:                  	writeSPI(a>>24);       // msb of the address
9D018B1C  0F407642   JAL writeSPI
9D018B20  00102602   SRL A0, S0, 24
70:                  	writeSPI(a>>16);
9D018B24  0F407642   JAL writeSPI
9D018B28  7E043C00   EXT A0, S0, 16, 8
71:                  	writeSPI(a>>8);
9D018B2C  0F407642   JAL writeSPI
9D018B30  7E043A00   EXT A0, S0, 8, 8
72:                  	writeSPI(a);           // lsb
9D018B34  0F407642   JAL writeSPI
9D018B38  320400FF   ANDI A0, S0, 255
73:                  
74:                  	writeSPI(0x95);        // send CMD0 CRC
9D018B3C  0F407642   JAL writeSPI
9D018B40  24040095   ADDIU A0, ZERO, 149
9D018B44  24100008   ADDIU S0, ZERO, 8
75:                  
76:                  	// now wait for a response, allow for up to 8 bytes delay
77:                  	for(i=0; i<8; i++)
9D018B5C  1600FFFA   BNE S0, ZERO, 0x9D018B48
9D018B60  00000000   NOP
78:                  	{
79:                  		r = readSPI();
9D018B48  0F407642   JAL writeSPI
9D018B4C  240400FF   ADDIU A0, ZERO, 255
80:                  		if (r != 0xFF)
9D018B50  240300FF   ADDIU V1, ZERO, 255
9D018B54  14430003   BNE V0, V1, 0x9D018B64
9D018B58  2610FFFF   ADDIU S0, S0, -1
81:                  			break;
82:                  	}
83:                  	return (r);
84:                  
85:                  	/* return response
86:                  	FF - timeout
87:                  	00 - command accepted
88:                  	01 - command received, card in idle state after RESET
89:                  
90:                  	other codes:
91:                  	bit 0 = Idle state
92:                  	bit 1 = Erase Reset
93:                  	bit 2 = Illegal command
94:                  	bit 3 = Communication CRC error
95:                  	bit 4 = Erase sequence error
96:                  	bit 5 = Address error
97:                  	bit 6 = Parameter error
98:                  	bit 7 = Always 0
99:                  	*/
100:                 	// NOTE CSCD is still low!
101:                 } // sendSDCmd
9D018B64  8FBF0014   LW RA, 20(SP)
9D018B68  8FB00010   LW S0, 16(SP)
9D018B6C  03E00008   JR RA
9D018B70  27BD0018   ADDIU SP, SP, 24
102:                 
103:                 
104:                 // returns 0 if successful
105:                 //          E_COMMAND_ACK   failed to acknowledge reset command
106:                 //          E_INIT_TIMEOUT  failed to initialize
107:                 int initMedia(void)
108:                 {
9D018B74  27BDFFE8   ADDIU SP, SP, -24
9D018B78  AFBF0014   SW RA, 20(SP)
109:                 	int i, r;
110:                 
111:                 	// 1. with the card NOT selected
112:                 	// Set DI and CS high
113:                 	disableSD();
9D018B7C  0F4062AF   JAL disableSD
9D018B80  AFB00010   SW S0, 16(SP)
9D018B84  2410000A   ADDIU S0, ZERO, 10
114:                 
115:                 	// 2. send 74 or more clock cycles to start up
116:                 	// apply 74 or more clock pulses to SCLK.
117:                 	// The card will enter its native operating mode and go ready to accept native commands.
118:                 	for (i=0; i<10; i++)
9D018B94  1600FFFC   BNE S0, ZERO, 0x9D018B88
9D018B98  24030008   ADDIU V1, ZERO, 8
119:                 		clockSPI();
9D018B88  0F407642   JAL writeSPI
9D018B8C  240400FF   ADDIU A0, ZERO, 255
9D018B90  2610FFFF   ADDIU S0, S0, -1
120:                 
121:                 	// 3. now select the card
122:                 	enableSD();
123:                 
124:                 	//card detection is now in disk_initialize()
125:                 
126:                 	return 0;
127:                 } // init media
9D018BA4  00001021   ADDU V0, ZERO, ZERO
9D018BA8  8FBF0014   LW RA, 20(SP)
9D018BAC  8FB00010   LW S0, 16(SP)
9D018BB0  03E00008   JR RA
9D018BB4  27BD0018   ADDIU SP, SP, 24
128:                 
129:                 
130:                 // a        LBA of sector requested
131:                 // p        pointer to sector buffer
132:                 // returns  TRUE if successful
133:                 int readSECTOR(LBA a, char *p)
134:                 {
9D018BB8  27BDFFD8   ADDIU SP, SP, -40
9D018BBC  AFBF0024   SW RA, 36(SP)
9D018BC0  AFB40020   SW S4, 32(SP)
9D018BC4  AFB3001C   SW S3, 28(SP)
9D018BC8  AFB20018   SW S2, 24(SP)
9D018BCC  AFB10014   SW S1, 20(SP)
9D018BD0  AFB00010   SW S0, 16(SP)
9D018BD4  00A08021   ADDU S0, A1, ZERO
135:                 	int r, i;
136:                 
137:                 	#ifdef READ_LED
138:                         _read_off();
139:                 	//digitalwrite(READ_LED, 0);
140:                 	#endif
141:                 
142:                 	// 1. send READ command
143:                 	r = sendSDCmd(READ_SINGLE, (a << 9));
9D018BD8  00042A40   SLL A1, A0, 9
9D018BDC  0F4062BE   JAL sendSDCmd
9D018BE0  24040011   ADDIU A0, ZERO, 17
144:                 	if (r == 0)    // check if command was accepted
9D018BE4  14400019   BNE V0, ZERO, 0x9D018C4C
9D018BE8  00409021   ADDU S2, V0, ZERO
9D018BEC  00008821   ADDU S1, ZERO, ZERO
145:                 	{
146:                 	// 2. wait for a response
147:                 	for(i=0; i<R_TIMEOUT; i++)
9D018BF4  241461A8   ADDIU S4, ZERO, 25000
9D018C08  26310001   ADDIU S1, S1, 1
9D018C0C  1634FFFA   BNE S1, S4, 0x9D018BF8
9D018C10  00000000   NOP
9D018C14  0B406313   J 0x9D018C4C
9D018C18  00000000   NOP
148:                 	{
149:                 	r = readSPI();
9D018BF8  0F407642   JAL writeSPI
9D018BFC  240400FF   ADDIU A0, ZERO, 255
150:                 	if (r == DATA_START)
9D018BF0  241300FE   ADDIU S3, ZERO, 254
9D018C00  10530006   BEQ V0, S3, 0x9D018C1C
9D018C04  00409021   ADDU S2, V0, ZERO
151:                 	break;
152:                 	}
153:                 
154:                 	// 3. if it did not timeout, read 512 byte of data
155:                 	if (i != R_TIMEOUT)
9D018C1C  240261A8   ADDIU V0, ZERO, 25000
9D018C20  1222000A   BEQ S1, V0, 0x9D018C4C
9D018C24  26110200   ADDIU S1, S0, 512
156:                 	{
157:                 		i = 512;
158:                 		do{
159:                 			*p++ = readSPI();
9D018C28  26100001   ADDIU S0, S0, 1
9D018C2C  0F407642   JAL writeSPI
9D018C30  240400FF   ADDIU A0, ZERO, 255
160:                 		} while (--i>0);
9D018C34  1611FFFC   BNE S0, S1, 0x9D018C28
9D018C38  A202FFFF   SB V0, -1(S0)
161:                 
162:                 		// 4. ignore CRC
163:                 		readSPI();
9D018C3C  0F407642   JAL writeSPI
9D018C40  240400FF   ADDIU A0, ZERO, 255
164:                 		readSPI();
9D018C44  0F407642   JAL writeSPI
9D018C48  240400FF   ADDIU A0, ZERO, 255
165:                 
166:                 	} // data arrived
167:                 
168:                 	} // command accepted
169:                 
170:                 	// 5. remember to disable the card
171:                 	disableSD();
9D018C4C  0F4062AF   JAL disableSD
9D018C50  00000000   NOP
172:                 
173:                 	#ifdef READ_LED
174:                         _read_on();
175:                 	//digital(READ_LED, 1);
176:                 	#endif
177:                 
178:                 	return (r == DATA_START);    // return TRUE if successful
9D018C54  3A4200FE   XORI V0, S2, 254
179:                 } // readSECTOR
9D018C58  2C420001   SLTIU V0, V0, 1
9D018C5C  8FBF0024   LW RA, 36(SP)
9D018C60  8FB40020   LW S4, 32(SP)
9D018C64  8FB3001C   LW S3, 28(SP)
9D018C68  8FB20018   LW S2, 24(SP)
9D018C6C  8FB10014   LW S1, 20(SP)
9D018C70  8FB00010   LW S0, 16(SP)
9D018C74  03E00008   JR RA
9D018C78  27BD0028   ADDIU SP, SP, 40
180:                 
181:                 
182:                 // a        LBA of sector requested
183:                 // p        pointer to sector buffer
184:                 // returns  TRUE if successful
185:                 int writeSECTOR(LBA a, char *p)
186:                 {
9D018C7C  27BDFFE0   ADDIU SP, SP, -32
9D018C80  AFBF001C   SW RA, 28(SP)
9D018C84  AFB20018   SW S2, 24(SP)
9D018C88  AFB10014   SW S1, 20(SP)
9D018C8C  AFB00010   SW S0, 16(SP)
9D018C90  00A08021   ADDU S0, A1, ZERO
187:                 	unsigned r, i;
188:                 
189:                 	// 0. check Write Protect
190:                 //	if (getWP())
191:                 //		return FAIL;
192:                 
193:                 	// 1. send WRITE command
194:                 	r = sendSDCmd(WRITE_SINGLE, (a << 9));
9D018C94  00042A40   SLL A1, A0, 9
9D018C98  0F4062BE   JAL sendSDCmd
9D018C9C  24040018   ADDIU A0, ZERO, 24
195:                 	if (r == 0)    // check if command was accepted
9D018CA0  1440001B   BNE V0, ZERO, 0x9D018D10
9D018CA4  00409021   ADDU S2, V0, ZERO
196:                 	{
197:                 		// 2. send data
198:                 		writeSPI(DATA_START);
9D018CA8  0F407642   JAL writeSPI
9D018CAC  240400FE   ADDIU A0, ZERO, 254
9D018CB0  26110200   ADDIU S1, S0, 512
199:                 
200:                 		// send 512 bytes of data
201:                 		for(i=0; i<512; i++)
9D018CC0  1611FFFD   BNE S0, S1, 0x9D018CB8
9D018CC4  26100001   ADDIU S0, S0, 1
202:                 		writeSPI(*p++);
9D018CB4  26100001   ADDIU S0, S0, 1
9D018CB8  0F407642   JAL writeSPI
9D018CBC  9204FFFF   LBU A0, -1(S0)
203:                 
204:                 		// 3. send dummy CRC
205:                 		clockSPI();
9D018CC8  0F407642   JAL writeSPI
9D018CCC  240400FF   ADDIU A0, ZERO, 255
206:                 		clockSPI();
9D018CD0  0F407642   JAL writeSPI
9D018CD4  240400FF   ADDIU A0, ZERO, 255
207:                 
208:                 		// 4. check if data accepted
209:                 		r = readSPI();
9D018CD8  0F407642   JAL writeSPI
9D018CDC  240400FF   ADDIU A0, ZERO, 255
210:                 		if ((r & 0xf) == DATA_ACCEPT)
9D018CE0  3042000F   ANDI V0, V0, 15
9D018CE4  24030005   ADDIU V1, ZERO, 5
9D018CE8  14430009   BNE V0, V1, 0x9D018D10
9D018CEC  3C100003   LUI S0, 3
9D018CF0  3610D090   ORI S0, S0, -12144
211:                 		{
212:                 			#ifdef WRITE_LED
213:                                         _write_off();
214:                 			//digitalwrite(WRITE_LED, 0);
215:                 			#endif
216:                 
217:                 			// 5. wait for write completion
218:                 			for(i=0; i<W_TIMEOUT; i++)
9D018D08  1600FFFA   BNE S0, ZERO, 0x9D018CF4
9D018D0C  00000000   NOP
219:                 			{
220:                 				r = readSPI();
9D018CF4  0F407642   JAL writeSPI
9D018CF8  240400FF   ADDIU A0, ZERO, 255
221:                 				if (r != 0 )
9D018CFC  14400004   BNE V0, ZERO, 0x9D018D10
9D018D00  00409021   ADDU S2, V0, ZERO
9D018D04  2610FFFF   ADDIU S0, S0, -1
222:                 					break;
223:                 			}
224:                 			#ifdef WRITE_LED
225:                                         _write_on();
226:                 			//digitalwrite(WRITE_LED, 1);
227:                 			#endif
228:                 		} // accepted
229:                 		else
230:                 		{
231:                 			r = FAIL;
232:                 		}
233:                 	} // command accepted
234:                 
235:                 	// 6. disable the card
236:                 	disableSD();
9D018D10  0F4062AF   JAL disableSD
9D018D14  00000000   NOP
237:                 
238:                 	return (r);      // return TRUE if successful
239:                 } // writeSECTOR
9D018D18  02401021   ADDU V0, S2, ZERO
9D018D1C  8FBF001C   LW RA, 28(SP)
9D018D20  8FB20018   LW S2, 24(SP)
9D018D24  8FB10014   LW S1, 20(SP)
9D018D28  8FB00010   LW S0, 16(SP)
9D018D2C  03E00008   JR RA
9D018D30  27BD0020   ADDIU SP, SP, 32
240:                 
241:                 
242:                 // SD card connector presence detection switch
243:                 // returns  TRUE card present
244:                 //          FALSE card not present
245:                 int getCD(void)
246:                 {
247:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
248:                 // 2013-09-05 ** added support for VPC_32
249:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined (EMPEROR460)
250:                 	return TRUE;
251:                 #elif defined VPC_32
252:                     return (PORTB&SDC_DET)==0;
9D018D34  3C02BF88   LUI V0, -16504
9D018D38  8C426120   LW V0, 24864(V0)
9D018D3C  38421000   XORI V0, V0, 4096
253:                 #else
254:                 	return (SDCD);
255:                 #endif
256:                 }
9D018D40  03E00008   JR RA
9D018D44  7C420300   EXT V0, V0, 12, 1
257:                 
258:                 // card Write Protect tab detection switch
259:                 // returns  TRUE write protect tab on LOCK
260:                 //          FALSE write protection tab OPEN
261:                 int getWP(void)
262:                 {
263:                 // 07 May 2012 ** Added specific support for PIC32 Pinguino and Micro
264:                 // 2013-09-05 ** added support for VPC_32
265:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG) || defined (PIC32_PINGUINO_MICRO) || defined(EMPEROR460) || defined (VPC_32)
266:                 	return FALSE;
267:                 #else
268:                 	return (SDWP);
269:                 #endif
270:                 }
9D018D48  03E00008   JR RA
271:                 
272:                 #endif /* __SDMMC_C__ */
---  /home/jacques/github/vpc-32vga/hardware/Pinguino/fileio.c  -----------------------------------------
1:                   /*	----------------------------------------------------------------------------
2:                   	FILE:			fileio.c
3:                   	PROJECT:		pinguino32
4:                   	PURPOSE:		SD Card file system functions
5:                   	AUTHORS:		Alfred Broda <alfredbroda@gmail.com>
6:                   					Mark Harper <markfh@f2s.com>
7:                   					Regis Blanchot <rblanchot@gmail.com>
8:                   	FIRST RELEASE:	23 dec. 2011
9:                   	LAST RELEASE:	06 jan. 2012
10:                  	----------------------------------------------------------------------------
11:                  	based on original code by Regis Blanchot and FatFS example for PIC24
12:                  	----------------------------------------------------------------------------
13:                   	[30-03-12][hgmvanbeek@gmail.com][Some cards have no card detect and no write protect]
14:                  	07 May 2012	As part of providing support for PIC32 Pinguino Micro and
15:                  					potentially other cards removed #if defined (PIC32_Pinguino) etc
16:                  					and #endif in function mount() so that SDCS is set via mount 
17:                  					for all cards.
18:                  */
19:                  
20:                  #ifndef __FILEIO_C__
21:                  #define __FILEIO_C__
22:                  
23:                  // standard C libraries used
24:                  #include <stdio.h>
25:                  #include <ctype.h>      		// toupper...
26:                  #include <string.h>     		// memcpy...
27:                  //#include <malloc.h>				// malloc, free?
28:                  #include <GenericTypeDefs.h>
29:                  
30:                  #include "fileio.h"
31:                  #include "sdmmc.h"
32:                  #include "ff.h"					// Fat Filesystem
33:                  #include "diskio.h"				// card access functions
34:                  #include "../serial_comm/serial_comm.h"
35:                  #include "../../console.h"
36:                  
37:                  //#define SD_DEBUG
38:                  
39:                  //#ifdef SD_DEBUG
40:                  //    #include <__cdc.c>          // USB CDC functions
41:                  //#endif
42:                  
43:                  /*	----------------------------------------------------------------------------
44:                   mount
45:                   initializes a MEDIA structure for FILEIO access
46:                   will mount only the first partition on the disk/card
47:                   --------------------------------------------------------------------------*/
48:                  
49:                  BOOL SDCardReady;
50:                  
51:                  static FATFS _Fat;
52:                  
53:                  char mount(unsigned char pin) {
9D016420  27BDFFE0   ADDIU SP, SP, -32
9D016424  AFBF001C   SW RA, 28(SP)
54:                  	int flag, i;
55:                  	FRESULT r;
56:                  
57:                  	SDCS = pin;
58:                  
59:                  	// 0. init the I/Os
60:                  	initSD();
9D016428  0F4062A5   JAL initSD
9D01642C  A38480C8   SB A0, -32568(GP)
61:                  
62:                  
63:                  #ifdef SD_DEBUG
64:                  	DebugPrint("Looking for SD slot... ");
65:                  #endif
66:                  	// 1. check if the card is in the slot
67:                  	if (!getCD()) {
9D016430  0F40634D   JAL getCD
9D016434  00000000   NOP
9D016438  14400004   BNE V0, ZERO, 0x9D01644C
9D01643C  24020002   ADDIU V0, ZERO, 2
68:                  		FError = FE_NOT_PRESENT;
9D016440  A38280BC   SB V0, -32580(GP)
69:                  #ifdef SD_DEBUG
70:                  		DebugPrint( " getCD Failed!\n");
71:                  #endif
72:                  		return FALSE;
9D016444  0B40592F   J 0x9D0164BC
9D016448  00001821   ADDU V1, ZERO, ZERO
73:                  	}
74:                  #ifdef SD_DEBUG
75:                  	DebugPrint("card in slot\n");
76:                  #endif
77:                  
78:                  	// 2. initialize the card
79:                  #ifdef SD_DEBUG
80:                  	DebugPrint("Initializing SD card... ");
81:                  #endif
82:                  	initMedia();
9D01644C  0F4062DD   JAL initMedia
9D016450  00000000   NOP
83:                      if (disk_initialize(0)==STA_NOINIT){
9D016454  0F4040CC   JAL disk_initialize
9D016458  00002021   ADDU A0, ZERO, ZERO
9D01645C  24040001   ADDIU A0, ZERO, 1
9D016460  10440016   BEQ V0, A0, 0x9D0164BC
9D016464  00001821   ADDU V1, ZERO, ZERO
84:                  #ifdef SD_DEBUG
85:                              DebugPrint("disk_initialize() failed!\n");
86:                  #endif
87:                              return 0;
88:                          };
89:                  #ifdef SD_DEBUG
90:                          DebugPrint("disk_initialize() OK\n");
91:                  #endif
92:                  	// We're skipping the old step 3 because there's no need for malloc
93:                  	// This takes 6k off the code size if malloc is not used elsewhere.
94:                  	// Instead, just point it to our _Fat var.
95:                  	// The FATFS struct takes only 560 bytes of mem.
96:                  	Fat = &_Fat;
9D016468  3C05A000   LUI A1, -24576
9D01646C  24A53C24   ADDIU A1, A1, 15396
9D016470  AF8580C0   SW A1, -32576(GP)
97:                  
98:                  	// Mount media
99:                  #ifdef SD_DEBUG
100:                 	DebugPrint("Mounting FAT filesystem... ");
101:                 #endif
102:                 	r = f_mount(0, Fat);
9D016474  0F4018D3   JAL f_mount
9D016478  00002021   ADDU A0, ZERO, ZERO
103:                 	if (r != FR_OK) {
9D01647C  10400003   BEQ V0, ZERO, 0x9D01648C
9D016480  00001821   ADDU V1, ZERO, ZERO
104:                 		FError = r;
105:                 #ifdef SD_DEBUG
106:                 		DebugPrint("Failed!\n");
107:                 #endif
108:                 		//free(Fat);
109:                 		return FALSE;
9D016484  0B40592F   J 0x9D0164BC
9D016488  A38280BC   SB V0, -32580(GP)
110:                 	}
111:                 #ifdef SD_DEBUG
112:                 	DebugPrint( "OK\n");
113:                 #endif
114:                 
115:                 #ifdef SD_DEBUG
116:                 	DebugPrint("Checking FAT filesystem... ");
117:                 #endif
118:                 	const TCHAR * pth = "/";
9D01648C  3C029D02   LUI V0, -25342
9D016490  2442D61C   ADDIU V0, V0, -10724
9D016494  AFA20010   SW V0, 16(SP)
119:                 	r = chk_mounted(&pth, &Fat, 0);
9D016498  27A40010   ADDIU A0, SP, 16
9D01649C  278580C0   ADDIU A1, GP, -32576
9D0164A0  0F401790   JAL chk_mounted
9D0164A4  00003021   ADDU A2, ZERO, ZERO
120:                 	if (r != FR_OK) {
9D0164A8  10400004   BEQ V0, ZERO, 0x9D0164BC
9D0164AC  24030001   ADDIU V1, ZERO, 1
121:                 		FError = r;
122:                 #ifdef SD_DEBUG
123:                 		DebugPrint( "Failed!\n");
124:                                  //put_rc(r);
125:                 #endif
126:                 		unmount();
9D0164B0  0F4058FD   JAL unmount
9D0164B4  A38280BC   SB V0, -32580(GP)
127:                 		return FALSE;
9D0164B8  00001821   ADDU V1, ZERO, ZERO
128:                 	}
129:                 #ifdef SD_DEBUG
130:                 	DebugPrint( "OK\n");
131:                 #endif
132:                 
133:                 	return TRUE;
134:                 } // mount
9D0164BC  00601021   ADDU V0, V1, ZERO
9D0164C0  8FBF001C   LW RA, 28(SP)
9D0164C4  03E00008   JR RA
9D0164C8  27BD0020   ADDIU SP, SP, 32
135:                 
136:                 /*	----------------------------------------------------------------------------
137:                  unmount    initializes a MEDIA structure for FILEIO access
138:                  --------------------------------------------------------------------------*/
139:                 
140:                 void unmount(void) {
9D0163F4  27BDFFE8   ADDIU SP, SP, -24
9D0163F8  AFBF0014   SW RA, 20(SP)
141:                 	f_mount(0, NULL);
9D0163FC  00002021   ADDU A0, ZERO, ZERO
9D016400  0F4018D3   JAL f_mount
9D016404  00002821   ADDU A1, ZERO, ZERO
142:                 	//free(Fat);
143:                 	SPI2CONCLR = 0x8000; // SPI2 OFF
9D016408  34038000   ORI V1, ZERO, -32768
9D01640C  3C02BF80   LUI V0, -16512
9D016410  AC435A04   SW V1, 23044(V0)
144:                 } // unmount
9D016414  8FBF0014   LW RA, 20(SP)
9D016418  03E00008   JR RA
9D01641C  27BD0018   ADDIU SP, SP, 24
145:                 
146:                 /*	----------------------------------------------------------------------------
147:                  present   test if a SD card is present
148:                  --------------------------------------------------------------------------*/
149:                 
150:                 char SD_present(unsigned char pin) {
9D0164CC  27BDFFE8   ADDIU SP, SP, -24
9D0164D0  AFBF0014   SW RA, 20(SP)
151:                 	if (mount(pin)) {
9D0164D4  0F405908   JAL mount
9D0164D8  00000000   NOP
9D0164DC  10400005   BEQ V0, ZERO, 0x9D0164F4
9D0164E0  8FBF0014   LW RA, 20(SP)
152:                 		unmount();
9D0164E4  0F4058FD   JAL unmount
9D0164E8  00000000   NOP
153:                 		return TRUE;
9D0164EC  24020001   ADDIU V0, ZERO, 1
154:                 	} else {
155:                 		return FALSE;
156:                 	}
157:                 }
9D0164F0  8FBF0014   LW RA, 20(SP)
9D0164F4  03E00008   JR RA
9D0164F8  27BD0018   ADDIU SP, SP, 24
158:                 
159:                 /*	----------------------------------------------------------------------------
160:                  Scans the current disk and compiles a list of files with a given extension
161:                  list     array of file names max * 8
162:                  max      number of entries
163:                  ext      file extension we are searching for
164:                  return   number of files found
165:                  --------------------------------------------------------------------------*/
166:                 
167:                 //unsigned listTYPE(char *listname, long *listsize, int max, const char *ext )
168:                 unsigned listTYPE(DIRTABLE *list, int max, const char *ext)
169:                 //unsigned listTYPE(char *list, int max, const char *ext )
170:                 {
171:                 	//TODO: implement
172:                 
173:                 	return 0;
174:                 } // listTYPE
9D0164FC  03E00008   JR RA
9D016500  00001021   ADDU V0, ZERO, ZERO
175:                 
176:                 /* Prints the directory contents */
177:                 unsigned listDir(const char *path) {
9D016504  27BDFF90   ADDIU SP, SP, -112
9D016508  AFBF006C   SW RA, 108(SP)
9D01650C  AFBE0068   SW S8, 104(SP)
9D016510  AFB70064   SW S7, 100(SP)
9D016514  AFB60060   SW S6, 96(SP)
9D016518  AFB5005C   SW S5, 92(SP)
9D01651C  AFB40058   SW S4, 88(SP)
9D016520  AFB30054   SW S3, 84(SP)
9D016524  AFB20050   SW S2, 80(SP)
9D016528  AFB1004C   SW S1, 76(SP)
9D01652C  AFB00048   SW S0, 72(SP)
9D016530  00808821   ADDU S1, A0, ZERO
178:                 	//TODO: remove all CDC references
179:                 	long p1;
180:                 	PF_BYTE res, b;
181:                 	UINT s1, s2;
182:                 	DIR dir; /* Directory object */
183:                         char * fmt;
184:                         dir.fs=Fat;
9D016534  8F8280C0   LW V0, -32576(GP)
9D016538  AFA20020   SW V0, 32(SP)
185:                 	res = f_opendir(&dir, path);
9D01653C  27A40020   ADDIU A0, SP, 32
9D016540  0F401DD9   JAL f_opendir
9D016544  02202821   ADDU A1, S1, ZERO
186:                         if (!res) {
9D016548  304300FF   ANDI V1, V0, 255
9D01654C  1460008E   BNE V1, ZERO, 0x9D016788
9D016550  304200FF   ANDI V0, V0, 255
187:                             p1 = s1 = s2 = 0;
188:                             fmt=malloc(64);
9D016554  0F4064A8   JAL malloc
9D016558  24040040   ADDIU A0, ZERO, 64
189:                             if (!fmt) {
9D01655C  10400084   BEQ V0, ZERO, 0x9D016770
9D016560  00408021   ADDU S0, V0, ZERO
190:                                 res=-1;
9D016780  0B4059C4   J 0x9D016710
9D016784  241200FF   ADDIU S2, ZERO, 255
191:                             }else{
192:                                 sprintf(fmt,"\nreading dirctory: ('%s')\n", path);
9D016564  00402021   ADDU A0, V0, ZERO
9D016568  3C059D02   LUI A1, -25342
9D01656C  24A5D620   ADDIU A1, A1, -10720
9D016570  0F407973   JAL _sprintf_cdnopsuxX
9D016574  02203021   ADDU A2, S1, ZERO
193:                                 print(con,fmt);
9D016578  97848062   LHU A0, -32670(GP)
9D01657C  0F404FCC   JAL print
9D016580  02002821   ADDU A1, S0, ZERO
9D016584  0000A021   ADDU S4, ZERO, ZERO
9D016588  0000A821   ADDU S5, ZERO, ZERO
9D01658C  0000B021   ADDU S6, ZERO, ZERO
194:                             }
195:                         }else{
196:                             return res;
197:                         }
198:                         while (!res) {
199:                 		res = f_readdir(&dir, &Finfo);
9D016590  3C13A000   LUI S3, -24576
9D016594  26713900   ADDIU S1, S3, 14592
9D0165B4  27A40020   ADDIU A0, SP, 32
9D0165B8  0F401E0E   JAL f_readdir
9D0165BC  02202821   ADDU A1, S1, ZERO
9D0165C0  305200FF   ANDI S2, V0, 255
9D016708  0B40596E   J 0x9D0165B8
9D01670C  27A40020   ADDIU A0, SP, 32
200:                 #ifdef SD_DEBUG
201:                 //		put_rc(res);
202:                 #endif
203:                 		if ((res != FR_OK) || !Finfo.fname[0]) {
9D0165C4  16400061   BNE S2, ZERO, 0x9D01674C
9D0165C8  02002021   ADDU A0, S0, ZERO
9D0165CC  82220009   LB V0, 9(S1)
9D0165D0  50400053   BEQL V0, ZERO, 0x9D016720
9D0165D4  AFB60010   SW S6, 16(SP)
204:                 			break;
205:                 		}
206:                 		if (Finfo.fattrib & AM_DIR) {
9D0165D8  92220008   LBU V0, 8(S1)
9D0165DC  30430010   ANDI V1, V0, 16
9D0165E0  306300FF   ANDI V1, V1, 255
9D0165E4  50600004   BEQL V1, ZERO, 0x9D0165F8
9D0165E8  26B50001   ADDIU S5, S5, 1
207:                 			s2++;
9D0165EC  26940001   ADDIU S4, S4, 1
208:                 		} else {
209:                 			s1++;
210:                 			p1 += Finfo.fsize;
9D0165F8  8E633900   LW V1, 14592(S3)
9D0165FC  02C3B021   ADDU S6, S6, V1
211:                 		}
212:                 // what about other outputs ?
213:                 		sprintf(fmt,"%c%c%c%c%c ",
9D016598  3C1E9D02   LUI S8, -25342
9D01659C  27DED63C   ADDIU S8, S8, -10692
9D0165F0  0B405981   J 0x9D016604
9D0165F4  24060044   ADDIU A2, ZERO, 68
9D016600  2406002D   ADDIU A2, ZERO, 45
9D016604  30470001   ANDI A3, V0, 1
9D01660C  308400FF   ANDI A0, A0, 255
9D016610  24030048   ADDIU V1, ZERO, 72
9D016614  2405002D   ADDIU A1, ZERO, 45
9D016618  00A4180A   MOVZ V1, A1, A0
9D01661C  00602021   ADDU A0, V1, ZERO
9D016624  306300FF   ANDI V1, V1, 255
9D016628  24050053   ADDIU A1, ZERO, 83
9D01662C  2408002D   ADDIU T0, ZERO, 45
9D016630  0103280A   MOVZ A1, T0, V1
9D016634  00A01821   ADDU V1, A1, ZERO
9D01663C  304200FF   ANDI V0, V0, 255
9D016640  24050041   ADDIU A1, ZERO, 65
9D016644  0102280A   MOVZ A1, T0, V0
9D016648  AFA40010   SW A0, 16(SP)
9D01664C  AFA30014   SW V1, 20(SP)
9D016650  AFA50018   SW A1, 24(SP)
9D016654  02002021   ADDU A0, S0, ZERO
9D016658  03C02821   ADDU A1, S8, ZERO
9D01665C  24020052   ADDIU V0, ZERO, 82
9D016660  2403002D   ADDIU V1, ZERO, 45
9D016664  0067100A   MOVZ V0, V1, A3
9D016668  0F407973   JAL _sprintf_cdnopsuxX
9D01666C  00403821   ADDU A3, V0, ZERO
214:                                 (Finfo.fattrib & AM_DIR) ? 'D' : '-',
215:                 				(Finfo.fattrib & AM_RDO) ? 'R' : '-',
216:                 				(Finfo.fattrib & AM_HID) ? 'H' : '-',
9D016608  30440002   ANDI A0, V0, 2
217:                 				(Finfo.fattrib & AM_SYS) ? 'S' : '-',
9D016620  30430004   ANDI V1, V0, 4
218:                 				(Finfo.fattrib & AM_ARC) ? 'A' : '-');
9D016638  30420020   ANDI V0, V0, 32
219:                                 print(con, fmt);
9D016670  97848062   LHU A0, -32670(GP)
9D016674  0F404FCC   JAL print
9D016678  02002821   ADDU A1, S0, ZERO
220:                 		sprintf(fmt,"%u/%02u/%02u %02u:%02u ",
9D0165A0  3C179D02   LUI S7, -25342
9D0165A4  26F7D648   ADDIU S7, S7, -10680
9D016688  30E3001F   ANDI V1, A3, 31
9D01668C  AFA30010   SW V1, 16(SP)
9D016690  00021AC2   SRL V1, V0, 11
9D016694  AFA30014   SW V1, 20(SP)
9D016698  7C422940   EXT V0, V0, 5, 6
9D01669C  AFA20018   SW V0, 24(SP)
9D0166A0  02002021   ADDU A0, S0, ZERO
9D0166A4  02E02821   ADDU A1, S7, ZERO
9D0166A8  24C607BC   ADDIU A2, A2, 1980
9D0166AC  0F407973   JAL _sprintf_cdnopsuxX
9D0166B0  7CE71940   EXT A3, A3, 5, 4
221:                                 (Finfo.fdate >> 9) + 1980,
9D01667C  96270004   LHU A3, 4(S1)
9D016684  00073242   SRL A2, A3, 9
222:                 				(Finfo.fdate >> 5) & 15, Finfo.fdate & 31, (Finfo.ftime >> 11),
9D016680  96220006   LHU V0, 6(S1)
223:                 				(Finfo.ftime >> 5) & 63);
224:                                 print(con, fmt);
9D0166B4  97848062   LHU A0, -32670(GP)
9D0166B8  0F404FCC   JAL print
9D0166BC  02002821   ADDU A1, S0, ZERO
225:                                 sprintf(fmt," %9u ", Finfo.fsize);
9D0165A8  3C029D02   LUI V0, -25342
9D0165AC  2442D660   ADDIU V0, V0, -10656
9D0165B0  AFA20040   SW V0, 64(SP)
9D0166C0  02002021   ADDU A0, S0, ZERO
9D0166C4  8FA50040   LW A1, 64(SP)
9D0166C8  0F407973   JAL _sprintf_cdnopsuxX
9D0166CC  8E663900   LW A2, 14592(S3)
226:                                 print(con, fmt);
9D0166D0  97848062   LHU A0, -32670(GP)
9D0166D4  0F404FCC   JAL print
9D0166D8  02002821   ADDU A1, S0, ZERO
227:                 		sprintf(fmt, " %-12s %s\n", Finfo.fname,
9D0166DC  02002021   ADDU A0, S0, ZERO
9D0166E0  3C029D02   LUI V0, -25342
9D0166E4  2445D668   ADDIU A1, V0, -10648
9D0166E8  3C06A000   LUI A2, -24576
9D0166EC  24C63909   ADDIU A2, A2, 14601
9D0166F0  3C079D02   LUI A3, -25342
9D0166F4  0F407973   JAL _sprintf_cdnopsuxX
9D0166F8  24E7D674   ADDIU A3, A3, -10636
228:                 #if _USE_LFN
229:                 				Lfname);
230:                 #else
231:                 				"");
232:                 #endif
233:                                 print(con,fmt);
9D0166FC  97848062   LHU A0, -32670(GP)
9D016700  0F404FCC   JAL print
9D016704  02002821   ADDU A1, S0, ZERO
234:                 	}
235:                         if (!res){
236:                             sprintf(fmt, "\nfile count %d\ndirectory count %d\ntotal size %d\n",s1,s2,p1);
9D016720  02002021   ADDU A0, S0, ZERO
9D016724  3C059D02   LUI A1, -25342
9D016728  24A5D678   ADDIU A1, A1, -10632
9D01672C  02A03021   ADDU A2, S5, ZERO
9D016730  0F407973   JAL _sprintf_cdnopsuxX
9D016734  02803821   ADDU A3, S4, ZERO
237:                             print(con, fmt);
9D016738  97848062   LHU A0, -32670(GP)
9D01673C  0F404FCC   JAL print
9D016740  02002821   ADDU A1, S0, ZERO
9D016744  0B4059C4   J 0x9D016710
9D016748  00000000   NOP
238:                         }else{
239:                             if (fmt){
240:                                     sprintf(fmt,"file i/o error code: %d\n", res);
9D01674C  3C059D02   LUI A1, -25342
9D016750  24A5D6AC   ADDIU A1, A1, -10580
9D016754  0F407973   JAL _sprintf_cdnopsuxX
9D016758  02403021   ADDU A2, S2, ZERO
241:                                     print(con, fmt);
9D01675C  97848062   LHU A0, -32670(GP)
9D016760  0F404FCC   JAL print
9D016764  02002821   ADDU A1, S0, ZERO
9D016768  0B4059C4   J 0x9D016710
9D01676C  00000000   NOP
242:                             }else{
243:                                 print(con,"Memory allocation error.\n");
9D016770  97848062   LHU A0, -32670(GP)
9D016774  3C059D02   LUI A1, -25342
9D016778  0F404FCC   JAL print
9D01677C  24A5D6C8   ADDIU A1, A1, -10552
244:                             }
245:                         }
246:                         free(fmt);
9D016710  0F407BCB   JAL free
9D016714  02002021   ADDU A0, S0, ZERO
247:                 	return res;
9D016718  0B4059E2   J 0x9D016788
9D01671C  02401021   ADDU V0, S2, ZERO
248:                 } // listDir
9D016788  8FBF006C   LW RA, 108(SP)
9D01678C  8FBE0068   LW S8, 104(SP)
9D016790  8FB70064   LW S7, 100(SP)
9D016794  8FB60060   LW S6, 96(SP)
9D016798  8FB5005C   LW S5, 92(SP)
9D01679C  8FB40058   LW S4, 88(SP)
9D0167A0  8FB30054   LW S3, 84(SP)
9D0167A4  8FB20050   LW S2, 80(SP)
9D0167A8  8FB1004C   LW S1, 76(SP)
9D0167AC  8FB00048   LW S0, 72(SP)
9D0167B0  03E00008   JR RA
9D0167B4  27BD0070   ADDIU SP, SP, 112
249:                 
250:                 char isDirectory(FILINFO file) {
9D0167B8  AFA40000   SW A0, 0(SP)
9D0167BC  AFA50004   SW A1, 4(SP)
9D0167C0  AFA60008   SW A2, 8(SP)
9D0167C4  AFA7000C   SW A3, 12(SP)
251:                 	if (file.fattrib & AM_DIR) {
252:                 		return TRUE;
253:                 	} else {
254:                 		return FALSE;
255:                 	}
256:                 }
9D0167C8  03E00008   JR RA
9D0167CC  7CC20100   EXT V0, A2, 4, 1
257:                 
258:                 char isReadOnly(FILINFO file) {
9D0167D0  AFA40000   SW A0, 0(SP)
9D0167D4  AFA50004   SW A1, 4(SP)
9D0167D8  AFA60008   SW A2, 8(SP)
9D0167DC  AFA7000C   SW A3, 12(SP)
259:                 	if (file.fattrib & AM_RDO) {
260:                 		return TRUE;
261:                 	} else {
262:                 		return FALSE;
263:                 	}
264:                 }
9D0167E0  03E00008   JR RA
9D0167E4  30C20001   ANDI V0, A2, 1
265:                 
266:                 char isHidden(FILINFO file) {
9D0167E8  AFA40000   SW A0, 0(SP)
9D0167EC  AFA50004   SW A1, 4(SP)
9D0167F0  AFA60008   SW A2, 8(SP)
9D0167F4  AFA7000C   SW A3, 12(SP)
267:                 	if (file.fattrib & AM_HID) {
268:                 		return TRUE;
269:                 	} else {
270:                 		return FALSE;
271:                 	}
272:                 }
9D0167F8  03E00008   JR RA
9D0167FC  7CC20040   EXT V0, A2, 1, 1
273:                 
274:                 char isSystem(FILINFO file) {
9D016800  AFA40000   SW A0, 0(SP)
9D016804  AFA50004   SW A1, 4(SP)
9D016808  AFA60008   SW A2, 8(SP)
9D01680C  AFA7000C   SW A3, 12(SP)
275:                 	if (file.fattrib & AM_SYS) {
276:                 		return TRUE;
277:                 	} else {
278:                 		return FALSE;
279:                 	}
280:                 }
9D016810  03E00008   JR RA
9D016814  7CC20080   EXT V0, A2, 2, 1
281:                 
282:                 char isArchive(FILINFO file) {
9D016818  AFA40000   SW A0, 0(SP)
9D01681C  AFA50004   SW A1, 4(SP)
9D016820  AFA60008   SW A2, 8(SP)
9D016824  AFA7000C   SW A3, 12(SP)
283:                 	if (file.fattrib & AM_ARC) {
284:                 		return TRUE;
285:                 	} else {
286:                 		return FALSE;
287:                 	}
288:                 }
9D016828  03E00008   JR RA
9D01682C  7CC20140   EXT V0, A2, 5, 1
289:                 #endif /* __FILEIO_C__ */
290:                 
---  /home/jacques/github/vpc-32vga/hardware/Pinguino/ff.c  ---------------------------------------------
1:                   /*----------------------------------------------------------------------------/
2:                    /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
3:                    /-----------------------------------------------------------------------------/
4:                    / FatFs module is a generic FAT file system module for small embedded systems.
5:                    / This is a free software that opened for education, research and commercial
6:                    / developments under license policy of following terms.
7:                    /
8:                    /  Copyright (C) 2011, ChaN, all right reserved.
9:                    /
10:                   / * The FatFs module is a free software and there is NO WARRANTY.
11:                   / * No restriction on use. You can use, modify and redistribute it for
12:                   /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
13:                   / * Redistributions of source code must retain the above copyright notice.
14:                   /
15:                   /-----------------------------------------------------------------------------/
16:                   / Feb 26,'06 R0.00  Prototype.
17:                   /
18:                   / Apr 29,'06 R0.01  First stable version.
19:                   /
20:                   / Jun 01,'06 R0.02  Added FAT12 support.
21:                   /                   Removed unbuffered mode.
22:                   /                   Fixed a problem on small (<32M) partition.
23:                   / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
24:                   /
25:                   / Sep 22,'06 R0.03  Added f_rename().
26:                   /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
27:                   / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
28:                   /                   Fixed f_mkdir() creates incorrect directory on FAT32.
29:                   /
30:                   / Feb 04,'07 R0.04  Supported multiple drive system.
31:                   /                   Changed some interfaces for multiple drive system.
32:                   /                   Changed f_mountdrv() to f_mount().
33:                   /                   Added f_mkfs().
34:                   / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
35:                   /                   Added a capability of extending file size to f_lseek().
36:                   /                   Added minimization level 3.
37:                   /                   Fixed an endian sensitive code in f_mkfs().
38:                   / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
39:                   /                   Added FSInfo support.
40:                   /                   Fixed DBCS name can result FR_INVALID_NAME.
41:                   /                   Fixed short seek (<= csize) collapses the file object.
42:                   /
43:                   / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
44:                   /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
45:                   /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
46:                   / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
47:                   /                   Fixed off by one error at FAT sub-type determination.
48:                   /                   Fixed btr in f_read() can be mistruncated.
49:                   /                   Fixed cached sector is not flushed when create and close without write.
50:                   /
51:                   / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
52:                   /                   Improved performance of f_lseek() on moving to the same or following cluster.
53:                   /
54:                   / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
55:                   /                   Added long file name feature.
56:                   /                   Added multiple code page feature.
57:                   /                   Added re-entrancy for multitask operation.
58:                   /                   Added auto cluster size selection to f_mkfs().
59:                   /                   Added rewind option to f_readdir().
60:                   /                   Changed result code of critical errors.
61:                   /                   Renamed string functions to avoid name collision.
62:                   / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
63:                   /                   Added multiple sector size feature.
64:                   / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
65:                   /                   Fixed wrong cache control in f_lseek().
66:                   /                   Added relative path feature.
67:                   /                   Added f_chdir() and f_chdrive().
68:                   /                   Added proper case conversion to extended char.
69:                   / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
70:                   /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
71:                   /                   Fixed name matching error on the 13 char boundary.
72:                   /                   Added a configuration option, _LFN_UNICODE.
73:                   /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
74:                   /
75:                   / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
76:                   /                   Added file lock feature. (_FS_SHARE)
77:                   /                   Added fast seek feature. (_USE_FASTSEEK)
78:                   /                   Changed some types on the API, XCHAR->TCHAR.
79:                   /                   Changed fname member in the FILINFO structure on Unicode cfg.
80:                   /                   String functions support UTF-8 encoding files on Unicode cfg.
81:                   / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
82:                   /                   Added sector erase feature. (_USE_ERASE)
83:                   /                   Moved file lock semaphore table from fs object to the bss.
84:                   /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
85:                   /                   Fixed f_mkfs() creates wrong FAT32 volume.
86:                   / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
87:                   /                   f_lseek() reports required table size on creating CLMP.
88:                   /                   Extended format syntax of f_printf function.
89:                   /                   Ignores duplicated directory separators in given path names.
90:                   /
91:                   / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
92:                   /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
93:                   /---------------------------------------------------------------------------
94:                   / 2011-12 Alfred Broda <alfredbroda@gmail.com> adapted for Pinguno Project
95:                   / BYTE and WORD were changed to PF_BYTE and PF_WORD because of a conflict.
96:                   ---------------------------------------------------------------------------*/
97:                  
98:                  #include "ff.h"			/* FatFs configurations and declarations */
99:                  #include "diskio.h"		/* Declarations of low level disk I/O functions */
100:                 
101:                 #if defined _DEBUG_
102:                 #include "../serial_comm/serial_comm.h"
103:                 #include"../../console.h"
104:                 #endif
105:                 /*--------------------------------------------------------------------------
106:                 
107:                  Module Private Definitions
108:                 
109:                  ---------------------------------------------------------------------------*/
110:                 
111:                 #if _FATFS != 6502	/* Revision ID */
112:                 #error Wrong include file (ff.h).
113:                 #endif
114:                 
115:                 /* Definitions on sector size */
116:                 #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
117:                 #error Wrong sector size.
118:                 #endif
119:                 #if _MAX_SS != 512
120:                 #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
121:                 #else
122:                 #define	SS(fs)	512U			/* Fixed sector size */
123:                 #endif
124:                 
125:                 /* Reentrancy related */
126:                 #if _FS_REENTRANT
127:                 #if _USE_LFN == 1
128:                 #error Static LFN work area must not be used in re-entrant configuration.
129:                 #endif
130:                 #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
131:                 #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
132:                 #else
133:                 #define	ENTER_FF(fs)
134:                 #define LEAVE_FF(fs, res)	return res
135:                 #endif
136:                 
137:                 #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
138:                 
139:                 /* File shareing feature */
140:                 #if _FS_SHARE
141:                 #if _FS_READONLY
142:                 #error _FS_SHARE must be 0 on read-only cfg.
143:                 #endif
144:                 typedef struct {
145:                 	FATFS *fs; /* File ID 1, volume (NULL:blank entry) */
146:                 	DWORD clu; /* File ID 2, directory */
147:                 	PF_WORD idx; /* File ID 3, directory index */
148:                 	PF_WORD ctr; /* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
149:                 }FILESEM;
150:                 #endif
151:                 
152:                 /* Misc definitions */
153:                 #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
154:                 #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
155:                 
156:                 /* DBCS code ranges and SBCS extend char conversion table */
157:                 
158:                 #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
159:                 #define _DF1S	0x81	/* DBC 1st byte range 1 start */
160:                 #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
161:                 #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
162:                 #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
163:                 #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
164:                 #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
165:                 #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
166:                 #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
167:                 
168:                 #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
169:                 #define _DF1S	0x81
170:                 #define _DF1E	0xFE
171:                 #define _DS1S	0x40
172:                 #define _DS1E	0x7E
173:                 #define _DS2S	0x80
174:                 #define _DS2E	0xFE
175:                 
176:                 #elif _CODE_PAGE == 949	/* Korean */
177:                 #define _DF1S	0x81
178:                 #define _DF1E	0xFE
179:                 #define _DS1S	0x41
180:                 #define _DS1E	0x5A
181:                 #define _DS2S	0x61
182:                 #define _DS2E	0x7A
183:                 #define _DS3S	0x81
184:                 #define _DS3E	0xFE
185:                 
186:                 #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
187:                 #define _DF1S	0x81
188:                 #define _DF1E	0xFE
189:                 #define _DS1S	0x40
190:                 #define _DS1E	0x7E
191:                 #define _DS2S	0xA1
192:                 #define _DS2E	0xFE
193:                 
194:                 #elif _CODE_PAGE == 437	/* U.S. (OEM) */
195:                 #define _DF1S	0
196:                 #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
197:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
198:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
199:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
200:                 
201:                 #elif _CODE_PAGE == 720	/* Arabic (OEM) */
202:                 #define _DF1S	0
203:                 #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
204:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
205:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
206:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
207:                 
208:                 #elif _CODE_PAGE == 737	/* Greek (OEM) */
209:                 #define _DF1S	0
210:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
211:                 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
212:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
213:                 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
214:                 
215:                 #elif _CODE_PAGE == 775	/* Baltic (OEM) */
216:                 #define _DF1S	0
217:                 #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
218:                 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
219:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
220:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
221:                 
222:                 #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
223:                 #define _DF1S	0
224:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
225:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
226:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
227:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
228:                 
229:                 #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
230:                 #define _DF1S	0
231:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
232:                 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
233:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
234:                 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
235:                 
236:                 #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
237:                 #define _DF1S	0
238:                 #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
239:                 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
240:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
241:                 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
242:                 
243:                 #elif _CODE_PAGE == 857	/* Turkish (OEM) */
244:                 #define _DF1S	0
245:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
246:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
247:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
248:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
249:                 
250:                 #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
251:                 #define _DF1S	0
252:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
253:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
254:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
255:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
256:                 
257:                 #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
258:                 #define _DF1S	0
259:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
260:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
261:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
262:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
263:                 
264:                 #elif _CODE_PAGE == 866	/* Russian (OEM) */
265:                 #define _DF1S	0
266:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
267:                 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
268:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
269:                 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
270:                 
271:                 #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
272:                 #define _DF1S	0
273:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
274:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
275:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
276:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
277:                 
278:                 #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
279:                 #define _DF1S	0
280:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
281:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
282:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
283:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
284:                 
285:                 #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
286:                 #define _DF1S	0
287:                 #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
288:                 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
289:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
290:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
291:                 
292:                 #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
293:                 #define _DF1S	0
294:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
295:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
296:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
297:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
298:                 
299:                 #elif _CODE_PAGE == 1253 /* Greek (Windows) */
300:                 #define _DF1S	0
301:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
302:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
303:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
304:                 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
305:                 
306:                 #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
307:                 #define _DF1S	0
308:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
309:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
310:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
311:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
312:                 
313:                 #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
314:                 #define _DF1S	0
315:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
316:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
317:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
318:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
319:                 
320:                 #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
321:                 #define _DF1S	0
322:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
323:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
324:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
325:                 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
326:                 
327:                 #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
328:                 #define _DF1S	0
329:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
330:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
331:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
332:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
333:                 
334:                 #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
335:                 #define _DF1S	0
336:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
337:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
338:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
339:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
340:                 
341:                 #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
342:                 #if _USE_LFN
343:                 #error Cannot use LFN feature without valid code page.
344:                 #endif
345:                 #define _DF1S	0
346:                 
347:                 #else
348:                 #error Unknown code page
349:                 
350:                 #endif
351:                 
352:                 /* Character code support macros */
353:                 #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
354:                 #define IsLower(c)	(((c)>='a')&&((c)<='z'))
355:                 #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
356:                 
357:                 #if _DF1S		/* Code page is DBCS */
358:                 
359:                 #ifdef _DF2S	/* Two 1st byte areas */
360:                 #define IsDBCS1(c)	(((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E) || ((PF_BYTE)(c) >= _DF2S && (PF_BYTE)(c) <= _DF2E))
361:                 #else			/* One 1st byte area */
362:                 #define IsDBCS1(c)	((PF_BYTE)(c) >= _DF1S && (PF_BYTE)(c) <= _DF1E)
363:                 #endif
364:                 
365:                 #ifdef _DS3S	/* Three 2nd byte areas */
366:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E) || ((PF_BYTE)(c) >= _DS3S && (PF_BYTE)(c) <= _DS3E))
367:                 #else			/* Two 2nd byte areas */
368:                 #define IsDBCS2(c)	(((PF_BYTE)(c) >= _DS1S && (PF_BYTE)(c) <= _DS1E) || ((PF_BYTE)(c) >= _DS2S && (PF_BYTE)(c) <= _DS2E))
369:                 #endif
370:                 
371:                 #else			/* Code page is SBCS */
372:                 
373:                 #define IsDBCS1(c)	0
374:                 #define IsDBCS2(c)	0
375:                 
376:                 #endif /* _DF1S */
377:                 
378:                 /* Name status flags */
379:                 #define NS			11		/* Index of name status byte in fn[] */
380:                 #define NS_LOSS		0x01	/* Out of 8.3 format */
381:                 #define NS_LFN		0x02	/* Force to create LFN entry */
382:                 #define NS_LAST		0x04	/* Last segment */
383:                 #define NS_BODY		0x08	/* Lower case flag (body) */
384:                 #define NS_EXT		0x10	/* Lower case flag (ext) */
385:                 #define NS_DOT		0x20	/* Dot entry */
386:                 
387:                 /* FAT sub-type boundaries */
388:                 /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
389:                 #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
390:                 #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
391:                 
392:                 /* FatFs refers the members in the FAT structures as byte array instead of
393:                  / structure member because the structure is not binary compatible between
394:                  / different platforms */
395:                 
396:                 #define BS_jmpBoot			0	/* Jump instruction (3) */
397:                 #define BS_OEMName			3	/* OEM name (8) */
398:                 #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
399:                 #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
400:                 #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
401:                 #define BPB_NumFATs			16	/* Number of FAT copies (1) */
402:                 #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
403:                 #define BPB_TotSec16		19	/* Volume size [sector] (2) */
404:                 #define BPB_Media			21	/* Media descriptor (1) */
405:                 #define BPB_FATSz16			22	/* FAT size [sector] (2) */
406:                 #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
407:                 #define BPB_NumHeads		26	/* Number of heads (2) */
408:                 #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
409:                 #define BPB_TotSec32		32	/* Volume size [sector] (4) */
410:                 #define BS_DrvNum			36	/* Physical drive number (2) */
411:                 #define BS_BootSig			38	/* Extended boot signature (1) */
412:                 #define BS_VolID			39	/* Volume serial number (4) */
413:                 #define BS_VolLab			43	/* Volume label (8) */
414:                 #define BS_FilSysType		54	/* File system type (1) */
415:                 #define BPB_FATSz32			36	/* FAT size [sector] (4) */
416:                 #define BPB_ExtFlags		40	/* Extended flags (2) */
417:                 #define BPB_FSVer			42	/* File system version (2) */
418:                 #define BPB_RootClus		44	/* Root dir first cluster (4) */
419:                 #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
420:                 #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
421:                 #define BS_DrvNum32			64	/* Physical drive number (2) */
422:                 #define BS_BootSig32		66	/* Extended boot signature (1) */
423:                 #define BS_VolID32			67	/* Volume serial number (4) */
424:                 #define BS_VolLab32			71	/* Volume label (8) */
425:                 #define BS_FilSysType32		82	/* File system type (1) */
426:                 #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
427:                 #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
428:                 #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
429:                 #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
430:                 #define MBR_Table			446	/* MBR: Partition table offset (2) */
431:                 #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
432:                 #define BS_55AA				510	/* Boot sector signature (2) */
433:                 
434:                 #define	DIR_Name			0	/* Short file name (11) */
435:                 #define	DIR_Attr			11	/* Attribute (1) */
436:                 #define	DIR_NTres			12	/* NT flag (1) */
437:                 #define	DIR_CrtTime			14	/* Created time (2) */
438:                 #define	DIR_CrtDate			16	/* Created date (2) */
439:                 #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
440:                 #define	DIR_WrtTime			22	/* Modified time (2) */
441:                 #define	DIR_WrtDate			24	/* Modified date (2) */
442:                 #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
443:                 #define	DIR_FileSize		28	/* File size (4) */
444:                 #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
445:                 #define	LDIR_Attr			11	/* LFN attribute (1) */
446:                 #define	LDIR_Type			12	/* LFN type (1) */
447:                 #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
448:                 #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
449:                 #define	SZ_DIR				32		/* Size of a directory entry */
450:                 #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
451:                 #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
452:                 #define	NDDE				0x05	/* Replacement of a character collides with DDE */
453:                 
454:                 /*------------------------------------------------------------*/
455:                 /* Module private work area                                   */
456:                 /*------------------------------------------------------------*/
457:                 /* Note that uninitialized variables with static duration are
458:                  /  zeroed/nulled at start-up. If not, the compiler or start-up
459:                  /  routine is out of ANSI-C standard.
460:                  */
461:                 
462:                 #if _VOLUMES
463:                 static FATFS *FatFs[_VOLUMES]; /* Pointer to the file system objects (logical drives) */
464:                 #else
465:                 #error Number of volumes must not be 0.
466:                 #endif
467:                 
468:                 static PF_WORD Fsid; /* File system mount ID */
469:                 
470:                 #if _FS_RPATH
471:                 static
472:                 PF_BYTE CurrVol; /* Current drive */
473:                 #endif
474:                 
475:                 #if _FS_SHARE
476:                 static
477:                 FILESEM Files[_FS_SHARE]; /* File lock semaphores */
478:                 #endif
479:                 
480:                 #if _USE_LFN == 0			/* No LFN feature */
481:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
482:                 #define INIT_BUF(dobj)		(dobj).fn = sfn
483:                 #define	FREE_BUF()
484:                 
485:                 #elif _USE_LFN == 1			/* LFN feature with static working buffer */
486:                 static WCHAR LfnBuf[_MAX_LFN+1];
487:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]
488:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
489:                 #define	FREE_BUF()
490:                 
491:                 #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
492:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
493:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
494:                 #define	FREE_BUF()
495:                 
496:                 #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
497:                 #define	DEF_NAMEBUF			PF_BYTE sfn[12]; WCHAR *lfn
498:                 #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
499:                 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
500:                 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
501:                 #define	FREE_BUF()			ff_memfree(lfn)
502:                 
503:                 #else
504:                 #error Wrong LFN configuration.
505:                 #endif
506:                 
507:                 /*--------------------------------------------------------------------------
508:                 
509:                  Module Private Functions
510:                 
511:                  ---------------------------------------------------------------------------*/
512:                 
513:                 /*-----------------------------------------------------------------------*/
514:                 /* String functions                                                      */
515:                 /*-----------------------------------------------------------------------*/
516:                 
517:                 /* Copy memory to memory */
518:                 static
519:                 void mem_cpy(void* dst, const void* src, UINT cnt) {
520:                 	PF_BYTE *d = (PF_BYTE*) dst;
521:                 	const PF_BYTE *s = (const PF_BYTE*) src;
522:                 
523:                 #if _WORD_ACCESS == 1
524:                 	while (cnt >= sizeof(int)) {
525:                 		*(int*) d = *(int*) s;
526:                 		d += sizeof(int);
527:                 		s += sizeof(int);
528:                 		cnt -= sizeof(int);
529:                 	}
530:                 #endif
531:                 	while (cnt--)
9D004964  10C00006   BEQ A2, ZERO, 0x9D004980
9D004968  00863021   ADDU A2, A0, A2
9D004978  1486FFFC   BNE A0, A2, 0x9D00496C
9D00497C  A082FFFF   SB V0, -1(A0)
9D004980  03E00008   JR RA
9D004984  00000000   NOP
532:                 		*d++ = *s++;
9D00496C  24840001   ADDIU A0, A0, 1
9D004970  24A50001   ADDIU A1, A1, 1
9D004974  90A2FFFF   LBU V0, -1(A1)
9D004978  1486FFFC   BNE A0, A2, 0x9D00496C
9D00497C  A082FFFF   SB V0, -1(A0)
9D004980  03E00008   JR RA
9D004984  00000000   NOP
533:                 }
534:                 
535:                 /* Fill memory */
536:                 static
537:                 void mem_set(void* dst, int val, UINT cnt) {
538:                 	PF_BYTE *d = (PF_BYTE*) dst;
9D004E64  00A01021   ADDU V0, A1, ZERO
9D005868  00E01021   ADDU V0, A3, ZERO
9D005C68  00801021   ADDU V0, A0, ZERO
9D007F14  02601021   ADDU V0, S3, ZERO
539:                 
540:                 	while (cnt--)
9D004E6C  1443FFFE   BNE V0, V1, 0x9D004E68
9D0056F0  1443FFFE   BNE V0, V1, mem_set
9D005874  1444FFFE   BNE V0, A0, 0x9D005870
9D005C70  1443FFFE   BNE V0, V1, 0x9D005C6C
9D007F1C  1451FFFE   BNE V0, S1, 0x9D007F18
9D007F34  1444FFFE   BNE V0, A0, 0x9D007F30
9D00803C  1622FFFE   BNE S1, V0, f_mkdir::mem_set
541:                 		*d++ = (PF_BYTE) val;
9D004E68  24420001   ADDIU V0, V0, 1
9D0056EC  24420001   ADDIU V0, V0, 1
9D00586C  24030020   ADDIU V1, ZERO, 32
9D005C6C  24420001   ADDIU V0, V0, 1
9D007F18  24420001   ADDIU V0, V0, 1
9D007F2C  24030020   ADDIU V1, ZERO, 32
9D008038  24420001   ADDIU V0, V0, 1
9D00803C  1622FFFE   BNE S1, V0, f_mkdir::mem_set
9D008040  A040FFFF   SB ZERO, -1(V0)
542:                 }
543:                 
544:                 /* Compare memory to memory */
545:                 static
546:                 int mem_cmp(const void* dst, const void* src, UINT cnt) {
547:                 	const PF_BYTE *d = (const PF_BYTE *) dst, *s = (const PF_BYTE *) src;
9D005A4C  01203021   ADDU A2, T1, ZERO
9D005A50  0B401698   J 0x9D005A60
9D005A54  01001821   ADDU V1, T0, ZERO
548:                 	int r = 0;
549:                 
550:                 	while (cnt-- && (r = *d++ - *s++) == 0)
9D005A58  5065004F   BEQL V1, A1, 0x9D005B98
9D005A5C  9123000B   LBU V1, 11(T1)
9D005A60  24630001   ADDIU V1, V1, 1
9D005A64  24C60001   ADDIU A2, A2, 1
9D005A68  9064FFFF   LBU A0, -1(V1)
9D005A6C  90C7FFFF   LBU A3, -1(A2)
9D005A70  1087FFF9   BEQ A0, A3, follow_path::dir_find
9D005A74  00000000   NOP
551:                 		;
552:                 	return r;
553:                 }
554:                 
555:                 /* Check if chr is contained in the string */
556:                 static
557:                 int chk_chr(const char* str, int chr) {
558:                 	while (*str && *str != chr)
9D0058A0  0B401641   J follow_path::create_name
9D0058A4  240C0022   ADDIU T4, ZERO, 34
9D005970  80430000   LB V1, 0(V0)
9D005974  50600073   BEQL V1, ZERO, 0x9D005B44
9D005978  2482FFBF   ADDIU V0, A0, -65
9D00597C  14C3FFFC   BNE A2, V1, follow_path::create_name
9D005980  24420001   ADDIU V0, V0, 1
9D005B34  108C000F   BEQ A0, T4, 0x9D005B74
9D005B38  00803021   ADDU A2, A0, ZERO
9D005B3C  0B40165C   J follow_path::create_name
9D005B40  2682E139   ADDIU V0, S4, -7879
559:                 		str++;
560:                 	return *str;
561:                 }
562:                 
563:                 /*-----------------------------------------------------------------------*/
564:                 /* Request/Release grant to access the volume                            */
565:                 /*-----------------------------------------------------------------------*/
566:                 #if _FS_REENTRANT
567:                 
568:                 static
569:                 int lock_fs (
570:                 		FATFS *fs /* File system object */
571:                 )
572:                 {
573:                 	return ff_req_grant(fs->sobj);
574:                 }
575:                 
576:                 static
577:                 void unlock_fs (
578:                 		FATFS *fs, /* File system object */
579:                 		FRESULT res /* Result code to be returned */
580:                 )
581:                 {
582:                 	if (res != FR_NOT_ENABLED &&
583:                 			res != FR_INVALID_DRIVE &&
584:                 			res != FR_INVALID_OBJECT &&
585:                 			res != FR_TIMEOUT) {
586:                 		ff_rel_grant(fs->sobj);
587:                 	}
588:                 }
589:                 #endif
590:                 
591:                 /*-----------------------------------------------------------------------*/
592:                 /* File shareing control functions                                       */
593:                 /*-----------------------------------------------------------------------*/
594:                 #if _FS_SHARE
595:                 
596:                 static
597:                 FRESULT chk_lock ( /* Check if the file can be accessed */
598:                 		DIR* dj, /* Directory object pointing the file to be checked */
599:                 		int acc /* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
600:                 )
601:                 {
9D004988  3C02A000   LUI V0, -24576
9D00498C  244244D4   ADDIU V0, V0, 17620
602:                 	UINT i, be;
603:                 
604:                 	/* Search file semaphore table */
605:                 	for (i = be = 0; i < _FS_SHARE; i++) {
9D004990  00005021   ADDU T2, ZERO, ZERO
9D004994  00001821   ADDU V1, ZERO, ZERO
9D004998  24080005   ADDIU T0, ZERO, 5
9D0049DC  24630001   ADDIU V1, V1, 1
9D0049E0  1468FFEE   BNE V1, T0, 0x9D00499C
9D0049E4  2442000C   ADDIU V0, V0, 12
9D0049E8  0B40127F   J 0x9D0049FC
9D0049EC  00001021   ADDU V0, ZERO, ZERO
606:                 		if (Files[i].fs) { /* Existing entry */
9D00499C  8C460000   LW A2, 0(V0)
9D0049A0  50C0000E   BEQL A2, ZERO, 0x9D0049DC
9D0049A4  254A0001   ADDIU T2, T2, 1
607:                 			if (Files[i].fs == dj->fs && /* Check if the file matched with an open file */
9D0049A8  8C870000   LW A3, 0(A0)
9D0049AC  54C7000C   BNEL A2, A3, 0x9D0049E0
9D0049B0  24630001   ADDIU V1, V1, 1
9D0049B4  8C470004   LW A3, 4(V0)
9D0049B8  8C860008   LW A2, 8(A0)
9D0049BC  54E60008   BNEL A3, A2, 0x9D0049E0
9D0049C0  24630001   ADDIU V1, V1, 1
608:                 					Files[i].clu == dj->sclust &&
9D0049C4  94470008   LHU A3, 8(V0)
9D0049C8  94860006   LHU A2, 6(A0)
9D0049CC  54E60004   BNEL A3, A2, 0x9D0049E0
9D0049D0  24630001   ADDIU V1, V1, 1
9D0049D4  0B40127C   J 0x9D0049F0
9D0049D8  24020005   ADDIU V0, ZERO, 5
609:                 					Files[i].idx == dj->index) break;
610:                 		} else { /* Blank entry */
611:                 			be++;
612:                 		}
613:                 	}
614:                 	if (i == _FS_SHARE) /* The file is not opened */
9D0049F0  14620007   BNE V1, V0, 0x9D004A10
9D0049F4  00000000   NOP
615:                 	return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES; /* Is there a blank entry for new file? */
9D0049F8  00001021   ADDU V0, ZERO, ZERO
9D0049FC  15400010   BNE T2, ZERO, 0x9D004A40
9D004A00  38A50002   XORI A1, A1, 2
9D004A04  24020012   ADDIU V0, ZERO, 18
9D004A08  03E00008   JR RA
9D004A0C  0005100A   MOVZ V0, ZERO, A1
616:                 
617:                 	/* The file has been opened. Reject any open against writing file and all write mode open */
618:                 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
9D004A10  14A0000B   BNE A1, ZERO, 0x9D004A40
9D004A14  24020010   ADDIU V0, ZERO, 16
9D004A18  00031080   SLL V0, V1, 2
9D004A1C  00031900   SLL V1, V1, 4
9D004A20  00621823   SUBU V1, V1, V0
9D004A24  3C02A000   LUI V0, -24576
9D004A28  244244D4   ADDIU V0, V0, 17620
9D004A2C  00621021   ADDU V0, V1, V0
9D004A30  9443000A   LHU V1, 10(V0)
9D004A34  38630100   XORI V1, V1, 256
9D004A38  24020010   ADDIU V0, ZERO, 16
9D004A3C  0003100B   MOVN V0, ZERO, V1
619:                 }
9D004A40  03E00008   JR RA
9D004A44  00000000   NOP
620:                 
621:                 static
622:                 int enq_lock (void) /* Check if an entry is available for a new file */
623:                 {
624:                 	UINT i;
625:                 
626:                 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
9D006434  3C02A000   LUI V0, -24576
9D006438  8C4244D4   LW V0, 17620(V0)
9D00643C  1040000D   BEQ V0, ZERO, 0x9D006474
9D006440  3C02A000   LUI V0, -24576
9D006444  244244D4   ADDIU V0, V0, 17620
9D006448  24030001   ADDIU V1, ZERO, 1
9D00644C  0B401917   J 0x9D00645C
9D006450  24050005   ADDIU A1, ZERO, 5
9D006454  106500E1   BEQ V1, A1, 0x9D0067DC
9D006458  2442000C   ADDIU V0, V0, 12
9D00645C  8C44000C   LW A0, 12(V0)
9D006460  5480FFFC   BNEL A0, ZERO, enq_lock
9D006464  24630001   ADDIU V1, V1, 1
627:                 	return (i == _FS_SHARE) ? 0 : 1;
628:                 }
629:                 
630:                 static
631:                 UINT inc_lock ( /* Increment file open counter and returns its index (0:int error) */
632:                 		DIR* dj, /* Directory object pointing the file to register or increment */
633:                 		int acc /* Desired access mode (0:Read, !0:Write) */
634:                 )
635:                 {
636:                 	UINT i;
637:                 
638:                 	for (i = 0; i < _FS_SHARE; i++) { /* Find the file */
9D0065F0  00001021   ADDU V0, ZERO, ZERO
9D0065F4  24060005   ADDIU A2, ZERO, 5
9D00661C  24420001   ADDIU V0, V0, 1
9D006620  1446FFF5   BNE V0, A2, 0x9D0065F8
9D006624  2463000C   ADDIU V1, V1, 12
639:                 		if (Files[i].fs == dj->fs &&
9D0065F8  8C650000   LW A1, 0(V1)
9D0065FC  54850008   BNEL A0, A1, 0x9D006620
9D006600  24420001   ADDIU V0, V0, 1
9D006604  8C650004   LW A1, 4(V1)
9D006608  54AA0005   BNEL A1, T2, 0x9D006620
9D00660C  24420001   ADDIU V0, V0, 1
640:                 				Files[i].clu == dj->sclust &&
9D0065DC  8FAA0018   LW T2, 24(SP)
9D006610  94650008   LHU A1, 8(V1)
9D006614  50AB0006   BEQL A1, T3, f_open::inc_lock
9D006618  24030005   ADDIU V1, ZERO, 5
641:                 				Files[i].idx == dj->index) break;
9D0065E0  97AB0016   LHU T3, 22(SP)
9D0065E4  3C08A000   LUI T0, -24576
9D0065E8  250844D4   ADDIU T0, T0, 17620
9D0065EC  01001821   ADDU V1, T0, ZERO
642:                 	}
643:                 
644:                 	if (i == _FS_SHARE) { /* Not opened. Register it as new. */
9D006630  1443001F   BNE V0, V1, 0x9D0066B0
9D006634  00000000   NOP
645:                 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++);
9D006628  0B40198F   J 0x9D00663C
9D00662C  3C02A000   LUI V0, -24576
9D006638  3C02A000   LUI V0, -24576
9D00663C  8C4244D4   LW V0, 17620(V0)
9D006640  1040000E   BEQ V0, ZERO, f_open::inc_lock
9D006644  01001821   ADDU V1, T0, ZERO
9D006648  24020001   ADDIU V0, ZERO, 1
9D00664C  0B401997   J 0x9D00665C
9D006650  24060005   ADDIU A2, ZERO, 5
9D006654  1046003F   BEQ V0, A2, 0x9D006754
9D006658  2463000C   ADDIU V1, V1, 12
9D00665C  8C65000C   LW A1, 12(V1)
9D006660  54A0FFFC   BNEL A1, ZERO, f_open::inc_lock
9D006664  24420001   ADDIU V0, V0, 1
9D00667C  00001021   ADDU V0, ZERO, ZERO
646:                 		if (i == _FS_SHARE) return 0; /* No space to register (int err) */
9D006668  24030005   ADDIU V1, ZERO, 5
9D00666C  14430005   BNE V0, V1, 0x9D006684
9D006670  00022880   SLL A1, V0, 2
647:                 		Files[i].fs = dj->fs;
9D006680  00022880   SLL A1, V0, 2
9D006684  00023100   SLL A2, V0, 4
9D006688  00C52823   SUBU A1, A2, A1
9D00668C  3C03A000   LUI V1, -24576
9D006690  246344D4   ADDIU V1, V1, 17620
9D006694  00A31821   ADDU V1, A1, V1
9D006698  AC640000   SW A0, 0(V1)
648:                 		Files[i].clu = dj->sclust;
9D00669C  8FA40018   LW A0, 24(SP)
9D0066A0  AC640004   SW A0, 4(V1)
649:                 		Files[i].idx = dj->index;
9D0066A4  97A40016   LHU A0, 22(SP)
9D0066A8  A4640008   SH A0, 8(V1)
650:                 		Files[i].ctr = 0;
9D0066AC  A460000A   SH ZERO, 10(V1)
651:                 	}
652:                 
653:                 	if (acc && Files[i].ctr) return 0; /* Access violation (int err) */
9D0066B0  1120000B   BEQ T1, ZERO, f_open::inc_lock
9D0066B4  00021880   SLL V1, V0, 2
9D0066B8  00022100   SLL A0, V0, 4
9D0066BC  00831823   SUBU V1, A0, V1
9D0066C0  3C04A000   LUI A0, -24576
9D0066C4  248444D4   ADDIU A0, A0, 17620
9D0066C8  00641821   ADDU V1, V1, A0
9D0066CC  9463000A   LHU V1, 10(V1)
9D0066D0  1060000B   BEQ V1, ZERO, 0x9D006700
9D0066D4  24050100   ADDIU A1, ZERO, 256
654:                 
655:                 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1; /* Set semaphore value */
9D0066E0  00022100   SLL A0, V0, 4
9D0066E4  00831823   SUBU V1, A0, V1
9D0066E8  3C04A000   LUI A0, -24576
9D0066EC  248444D4   ADDIU A0, A0, 17620
9D0066F0  00641821   ADDU V1, V1, A0
9D0066F4  9465000A   LHU A1, 10(V1)
9D0066F8  24A50001   ADDIU A1, A1, 1
9D0066FC  30A5FFFF   ANDI A1, A1, -1
9D006700  00021880   SLL V1, V0, 2
9D006704  00022100   SLL A0, V0, 4
9D006708  00831823   SUBU V1, A0, V1
9D00670C  3C04A000   LUI A0, -24576
9D006710  248444D4   ADDIU A0, A0, 17620
9D006714  00641821   ADDU V1, V1, A0
9D006718  A465000A   SH A1, 10(V1)
656:                 
657:                 	return i + 1;
9D00671C  24430001   ADDIU V1, V0, 1
658:                 }
659:                 
660:                 static
661:                 FRESULT dec_lock ( /* Decrement file open counter */
662:                 		UINT i /* Semaphore index */
663:                 )
664:                 {
665:                 	PF_WORD n;
666:                 	FRESULT res;
667:                 
668:                 	if (--i < _FS_SHARE) {
9D006F34  8E030028   LW V1, 40(S0)
9D006F38  2463FFFF   ADDIU V1, V1, -1
9D006F3C  2C640005   SLTIU A0, V1, 5
9D006F40  50800028   BEQL A0, ZERO, 0x9D006FE4
9D006F44  24020002   ADDIU V0, ZERO, 2
669:                 		n = Files[i].ctr;
9D006F48  00032080   SLL A0, V1, 2
9D006F4C  00032900   SLL A1, V1, 4
9D006F50  00A42023   SUBU A0, A1, A0
9D006F54  3C05A000   LUI A1, -24576
9D006F58  24A544D4   ADDIU A1, A1, 17620
9D006F5C  00852021   ADDU A0, A0, A1
9D006F60  9484000A   LHU A0, 10(A0)
670:                 		if (n == 0x100) n = 0;
9D006F64  24050100   ADDIU A1, ZERO, 256
9D006F68  50850014   BEQL A0, A1, f_close::dec_lock
9D006F6C  00002021   ADDU A0, ZERO, ZERO
671:                 		if (n) n--;
9D006F70  10800012   BEQ A0, ZERO, f_close::dec_lock
9D006F74  00033080   SLL A2, V1, 2
9D006F78  2484FFFF   ADDIU A0, A0, -1
9D006F7C  3084FFFF   ANDI A0, A0, -1
672:                 		Files[i].ctr = n;
9D006F80  00033900   SLL A3, V1, 4
9D006F84  00E63023   SUBU A2, A3, A2
9D006F88  3C05A000   LUI A1, -24576
9D006F8C  24A544D4   ADDIU A1, A1, 17620
9D006F90  00C52821   ADDU A1, A2, A1
9D006FBC  00033080   SLL A2, V1, 2
9D006FC0  00033900   SLL A3, V1, 4
9D006FC4  00E63023   SUBU A2, A3, A2
9D006FC8  3C05A000   LUI A1, -24576
9D006FCC  24A544D4   ADDIU A1, A1, 17620
9D006FD0  00C52821   ADDU A1, A2, A1
9D006FD4  0B401BE7   J 0x9D006F9C
9D006FD8  A4A4000A   SH A0, 10(A1)
673:                 		if (!n) Files[i].fs = 0;
9D006F94  14800011   BNE A0, ZERO, 0x9D006FDC
9D006F98  A4A4000A   SH A0, 10(A1)
9D006F9C  00032080   SLL A0, V1, 2
9D006FA0  00031900   SLL V1, V1, 4
9D006FA4  00641823   SUBU V1, V1, A0
9D006FA8  3C04A000   LUI A0, -24576
9D006FAC  248444D4   ADDIU A0, A0, 17620
9D006FB0  00641821   ADDU V1, V1, A0
9D006FB4  0B401BF7   J 0x9D006FDC
9D006FB8  AC600000   SW ZERO, 0(V1)
674:                 		res = FR_OK;
675:                 	} else {
676:                 		res = FR_INT_ERR;
677:                 	}
678:                 	return res;
679:                 }
680:                 
681:                 static
682:                 void clear_lock ( /* Clear lock entries of the volume */
683:                 		FATFS *fs
684:                 )
685:                 {
686:                 	UINT i;
687:                 
688:                 	for (i = 0; i < _FS_SHARE; i++) {
9D0062F8  5443FFFC   BNEL V0, V1, 0x9D0062EC
9D006378  5446FFFC   BNEL V0, A2, 0x9D00636C
689:                 		if (Files[i].fs == fs) Files[i].fs = 0;
9D0062E8  8C440000   LW A0, 0(V0)
9D006368  8C430000   LW V1, 0(V0)
9D00636C  50830001   BEQL A0, V1, 0x9D006374
9D006370  AC400000   SW ZERO, 0(V0)
9D006374  2442000C   ADDIU V0, V0, 12
9D006378  5446FFFC   BNEL V0, A2, 0x9D00636C
9D00637C  8C430000   LW V1, 0(V0)
690:                 	}
691:                 }
692:                 #endif
693:                 
694:                 /*-----------------------------------------------------------------------*/
695:                 /* Change window offset                                                  */
696:                 /*-----------------------------------------------------------------------*/
697:                 
698:                 static FRESULT move_window(FATFS *fs, /* File system object */
699:                 DWORD sector /* Sector number to make appearance in the fs->win[] */
700:                 ) /* Move to zero only writes back dirty window */
701:                 {
9D004BE0  27BDFFD8   ADDIU SP, SP, -40
9D004BE4  AFBF0024   SW RA, 36(SP)
9D004BE8  AFB40020   SW S4, 32(SP)
9D004BEC  AFB3001C   SW S3, 28(SP)
9D004BF0  AFB20018   SW S2, 24(SP)
9D004BF4  AFB10014   SW S1, 20(SP)
9D004BF8  AFB00010   SW S0, 16(SP)
9D004BFC  00808021   ADDU S0, A0, ZERO
702:                 	DWORD wsect;
703:                 
704:                 	wsect = fs->winsect;
9D004C00  8C910030   LW S1, 48(A0)
705:                 	if (wsect != sector) { /* Changed current window */
9D004C04  1225002E   BEQ S1, A1, 0x9D004CC0
9D004C08  00A09021   ADDU S2, A1, ZERO
706:                 #if !_FS_READONLY
707:                 		if (fs->wflag) { /* Write back dirty window if needed */
9D004C0C  90820004   LBU V0, 4(A0)
9D004C10  1040001F   BEQ V0, ZERO, 0x9D004C90
9D004C14  02203021   ADDU A2, S1, ZERO
708:                 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
9D004C18  24940034   ADDIU S4, A0, 52
9D004C1C  90840001   LBU A0, 1(A0)
9D004C20  02802821   ADDU A1, S4, ZERO
9D004C24  0F404196   JAL disk_write
9D004C28  24070001   ADDIU A3, ZERO, 1
9D004C2C  14400025   BNE V0, ZERO, 0x9D004CC4
9D004C30  24030001   ADDIU V1, ZERO, 1
709:                 				return FR_DISK_ERR;
710:                 			fs->wflag = 0;
9D004C34  A2000004   SB ZERO, 4(S0)
711:                 			if (wsect < (fs->fatbase + fs->fsize)) { /* In FAT area */
9D004C38  8E030020   LW V1, 32(S0)
9D004C3C  8E020024   LW V0, 36(S0)
9D004C40  00621021   ADDU V0, V1, V0
9D004C44  0222102B   SLTU V0, S1, V0
9D004C48  10400011   BEQ V0, ZERO, 0x9D004C90
9D004C4C  00000000   NOP
712:                 				PF_BYTE nf;
713:                 				for (nf = fs->n_fats; nf > 1; nf--) { /* Reflect the change to all FAT copies */
9D004C50  92130003   LBU S3, 3(S0)
9D004C54  2E620002   SLTIU V0, S3, 2
9D004C58  1440000D   BNE V0, ZERO, 0x9D004C90
9D004C5C  00000000   NOP
9D004C7C  2673FFFF   ADDIU S3, S3, -1
9D004C80  327300FF   ANDI S3, S3, 255
9D004C84  24020001   ADDIU V0, ZERO, 1
9D004C88  5662FFF6   BNEL S3, V0, 0x9D004C64
9D004C8C  8E020020   LW V0, 32(S0)
714:                 					wsect += fs->fsize;
9D004C60  8E020020   LW V0, 32(S0)
9D004C64  02228821   ADDU S1, S1, V0
715:                 					disk_write(fs->drv, fs->win, wsect, 1);
9D004C68  92040001   LBU A0, 1(S0)
9D004C6C  02802821   ADDU A1, S4, ZERO
9D004C70  02203021   ADDU A2, S1, ZERO
9D004C74  0F404196   JAL disk_write
9D004C78  24070001   ADDIU A3, ZERO, 1
716:                 				}
717:                 			}
718:                 		}
719:                 #endif
720:                 		if (sector) {
9D004C90  1240000C   BEQ S2, ZERO, 0x9D004CC4
9D004C94  00001821   ADDU V1, ZERO, ZERO
721:                 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
9D004C98  92040001   LBU A0, 1(S0)
9D004C9C  26050034   ADDIU A1, S0, 52
9D004CA0  02403021   ADDU A2, S2, ZERO
9D004CA4  0F40415F   JAL disk_read
9D004CA8  24070001   ADDIU A3, ZERO, 1
9D004CAC  14400005   BNE V0, ZERO, 0x9D004CC4
9D004CB0  24030001   ADDIU V1, ZERO, 1
722:                 				return FR_DISK_ERR;
723:                 			fs->winsect = sector;
9D004CB4  AE120030   SW S2, 48(S0)
724:                 		}
725:                 	}
726:                 
727:                 	return FR_OK;
9D004CB8  0B401331   J 0x9D004CC4
9D004CBC  00001821   ADDU V1, ZERO, ZERO
9D004CC0  00001821   ADDU V1, ZERO, ZERO
728:                 }
9D004CC4  00601021   ADDU V0, V1, ZERO
9D004CC8  8FBF0024   LW RA, 36(SP)
9D004CCC  8FB40020   LW S4, 32(SP)
9D004CD0  8FB3001C   LW S3, 28(SP)
9D004CD4  8FB20018   LW S2, 24(SP)
9D004CD8  8FB10014   LW S1, 20(SP)
9D004CDC  8FB00010   LW S0, 16(SP)
9D004CE0  03E00008   JR RA
9D004CE4  27BD0028   ADDIU SP, SP, 40
729:                 
730:                 /*-----------------------------------------------------------------------*/
731:                 /* Clean-up cached data                                                  */
732:                 /*-----------------------------------------------------------------------*/
733:                 #if !_FS_READONLY
734:                 static FRESULT sync( /* FR_OK: successful, FR_DISK_ERR: failed */
735:                 FATFS *fs /* File system object */
736:                 ) {
9D004E1C  27BDFFE8   ADDIU SP, SP, -24
9D004E20  AFBF0014   SW RA, 20(SP)
9D004E24  AFB00010   SW S0, 16(SP)
9D004E28  00808021   ADDU S0, A0, ZERO
737:                 	FRESULT res;
738:                 
739:                 	res = move_window(fs, 0);
9D004E2C  0F4012F8   JAL move_window
9D004E30  00002821   ADDU A1, ZERO, ZERO
740:                 	if (res == FR_OK) {
9D004E34  1440003A   BNE V0, ZERO, 0x9D004F20
9D004E38  8FBF0014   LW RA, 20(SP)
741:                 		/* Update FSInfo sector if needed */
742:                 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
9D004E3C  92030000   LBU V1, 0(S0)
9D004E40  24020003   ADDIU V0, ZERO, 3
9D004E44  54620031   BNEL V1, V0, 0x9D004F0C
9D004E48  92040001   LBU A0, 1(S0)
9D004E4C  92020005   LBU V0, 5(S0)
9D004E50  5040002E   BEQL V0, ZERO, 0x9D004F0C
9D004E54  92040001   LBU A0, 1(S0)
743:                 			fs->winsect = 0;
9D004E58  AE000030   SW ZERO, 48(S0)
744:                 			/* Create FSInfo structure */
745:                 			mem_set(fs->win, 0, 512);
9D004E5C  26050034   ADDIU A1, S0, 52
9D004E60  26030234   ADDIU V1, S0, 564
746:                 			ST_WORD(fs->win+BS_55AA, 0xAA55);
9D004E74  24020055   ADDIU V0, ZERO, 85
9D004E78  A2020232   SB V0, 562(S0)
9D004E7C  2402FFAA   ADDIU V0, ZERO, -86
9D004E80  A2020233   SB V0, 563(S0)
747:                 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
9D004E84  24020052   ADDIU V0, ZERO, 82
9D004E88  A2020034   SB V0, 52(S0)
9D004E8C  A2020035   SB V0, 53(S0)
9D004E90  24020061   ADDIU V0, ZERO, 97
9D004E94  A2020036   SB V0, 54(S0)
9D004E98  24030041   ADDIU V1, ZERO, 65
9D004E9C  A2030037   SB V1, 55(S0)
748:                 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
9D004EA0  24040072   ADDIU A0, ZERO, 114
9D004EA4  A2040218   SB A0, 536(S0)
9D004EA8  A2040219   SB A0, 537(S0)
9D004EAC  A203021A   SB V1, 538(S0)
9D004EB0  A202021B   SB V0, 539(S0)
749:                 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
9D004EB4  8E020010   LW V0, 16(S0)
9D004EB8  A202021C   SB V0, 540(S0)
9D004EBC  7C433A00   EXT V1, V0, 8, 8
9D004EC0  A203021D   SB V1, 541(S0)
9D004EC4  00021C02   SRL V1, V0, 16
9D004EC8  A203021E   SB V1, 542(S0)
9D004ECC  00021602   SRL V0, V0, 24
9D004ED0  A202021F   SB V0, 543(S0)
750:                 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
9D004ED4  8E02000C   LW V0, 12(S0)
9D004ED8  A2020220   SB V0, 544(S0)
9D004EDC  7C433A00   EXT V1, V0, 8, 8
9D004EE0  A2030221   SB V1, 545(S0)
9D004EE4  00021C02   SRL V1, V0, 16
9D004EE8  A2030222   SB V1, 546(S0)
9D004EEC  00021602   SRL V0, V0, 24
9D004EF0  A2020223   SB V0, 547(S0)
751:                 			/* Write it into the FSInfo sector */
752:                 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
9D004EF4  92040001   LBU A0, 1(S0)
9D004EF8  8E060014   LW A2, 20(S0)
9D004EFC  0F404196   JAL disk_write
9D004F00  24070001   ADDIU A3, ZERO, 1
753:                 			fs->fsi_flag = 0;
9D004F04  A2000005   SB ZERO, 5(S0)
754:                 		}
755:                 		/* Make sure that no pending write process in the physical drive */
756:                 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
9D004F08  92040001   LBU A0, 1(S0)
9D004F0C  00002821   ADDU A1, ZERO, ZERO
9D004F10  0F4041DD   JAL disk_ioctl
9D004F14  00003021   ADDU A2, ZERO, ZERO
9D004F18  0002102B   SLTU V0, ZERO, V0
757:                 			res = FR_DISK_ERR;
758:                 	}
759:                 
760:                 	return res;
761:                 }
9D004F1C  8FBF0014   LW RA, 20(SP)
9D004F20  8FB00010   LW S0, 16(SP)
9D004F24  03E00008   JR RA
9D004F28  27BD0018   ADDIU SP, SP, 24
762:                 #endif
763:                 
764:                 /*-----------------------------------------------------------------------*/
765:                 /* Get sector# from cluster#                                             */
766:                 /*-----------------------------------------------------------------------*/
767:                 
768:                 DWORD clust2sect( /* !=0: Sector number, 0: Failed - invalid cluster# */
769:                 FATFS *fs, /* File system object */
770:                 DWORD clst /* Cluster# to be converted */
771:                 ) {
772:                 	clst -= 2;
9D004F2C  24A5FFFE   ADDIU A1, A1, -2
773:                 	if (clst >= (fs->n_fatent - 2))
9D004F30  8C83001C   LW V1, 28(A0)
9D004F34  2463FFFE   ADDIU V1, V1, -2
9D004F38  00A3182B   SLTU V1, A1, V1
9D004F3C  10600005   BEQ V1, ZERO, 0x9D004F54
9D004F40  00001021   ADDU V0, ZERO, ZERO
774:                 		return 0; /* Invalid cluster# */
775:                 	return clst * fs->csize + fs->database;
9D004F44  90830002   LBU V1, 2(A0)
9D004F48  8C82002C   LW V0, 44(A0)
9D004F4C  70A32002   MUL A0, A1, V1
9D004F50  00821021   ADDU V0, A0, V0
776:                 }
9D004F54  03E00008   JR RA
9D004F58  00000000   NOP
777:                 
778:                 /*-----------------------------------------------------------------------*/
779:                 /* FAT access - Read value of a FAT entry                                */
780:                 /*-----------------------------------------------------------------------*/
781:                 
782:                 DWORD get_fat( /* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
783:                 FATFS *fs, /* File system object */
784:                 DWORD clst /* Cluster# to get the link information */
785:                 ) {
9D004F5C  27BDFFD8   ADDIU SP, SP, -40
9D004F60  AFBF0024   SW RA, 36(SP)
9D004F64  AFB30020   SW S3, 32(SP)
9D004F68  AFB2001C   SW S2, 28(SP)
9D004F6C  AFB10018   SW S1, 24(SP)
9D004F70  AFB00014   SW S0, 20(SP)
786:                 	UINT wc, bc;
787:                 	PF_BYTE *p;
788:                 
789:                 	if (clst < 2 || clst >= fs->n_fatent) /* Chack range */
9D004F74  2CA20002   SLTIU V0, A1, 2
9D004F78  14400051   BNE V0, ZERO, 0x9D0050C0
9D004F7C  00A08021   ADDU S0, A1, ZERO
9D004F80  00808821   ADDU S1, A0, ZERO
9D004F84  8C82001C   LW V0, 28(A0)
9D004F88  00A2102B   SLTU V0, A1, V0
9D004F8C  1040004D   BEQ V0, ZERO, 0x9D0050C4
9D004F90  24030001   ADDIU V1, ZERO, 1
790:                 		return 1;
791:                 
792:                 	switch (fs->fs_type) {
9D004F94  90820000   LBU V0, 0(A0)
9D004F98  24030002   ADDIU V1, ZERO, 2
9D004F9C  50430025   BEQL V0, V1, 0x9D005034
9D004FA0  00052A02   SRL A1, A1, 8
9D004FA4  24030003   ADDIU V1, ZERO, 3
9D004FA8  5043002F   BEQL V0, V1, 0x9D005068
9D004FAC  000529C2   SRL A1, A1, 7
9D004FB0  24030001   ADDIU V1, ZERO, 1
9D004FB4  54430043   BNEL V0, V1, 0x9D0050C4
9D004FB8  2403FFFF   ADDIU V1, ZERO, -1
793:                 	case FS_FAT12:
794:                 		bc = (UINT) clst;
795:                 		bc += bc / 2;
9D004FBC  00059042   SRL S2, A1, 1
9D004FC0  02459021   ADDU S2, S2, A1
796:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D004FC4  00122A42   SRL A1, S2, 9
9D004FC8  8C820024   LW V0, 36(A0)
9D004FCC  0F4012F8   JAL move_window
9D004FD0  00A22821   ADDU A1, A1, V0
9D004FD4  1440003B   BNE V0, ZERO, 0x9D0050C4
9D004FD8  2403FFFF   ADDIU V1, ZERO, -1
797:                 			break;
798:                 		wc = fs->win[bc % SS(fs)];
9D004FDC  324201FF   ANDI V0, S2, 511
9D004FE0  02221021   ADDU V0, S1, V0
9D004FE4  90530034   LBU S3, 52(V0)
799:                 		bc++;
9D004FE8  26520001   ADDIU S2, S2, 1
800:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs))))
9D004FEC  00122A42   SRL A1, S2, 9
9D004FF0  8E220024   LW V0, 36(S1)
9D004FF4  02202021   ADDU A0, S1, ZERO
9D004FF8  0F4012F8   JAL move_window
9D004FFC  00A22821   ADDU A1, A1, V0
9D005000  14400030   BNE V0, ZERO, 0x9D0050C4
9D005004  2403FFFF   ADDIU V1, ZERO, -1
801:                 			break;
802:                 		wc |= fs->win[bc % SS(fs)] << 8;
9D005008  325201FF   ANDI S2, S2, 511
9D00500C  02328821   ADDU S1, S1, S2
9D005010  92220034   LBU V0, 52(S1)
9D005014  00021200   SLL V0, V0, 8
9D005018  00539825   OR S3, V0, S3
803:                 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
9D00501C  32030001   ANDI V1, S0, 1
9D005020  00131102   SRL V0, S3, 4
9D005024  32730FFF   ANDI S3, S3, 4095
9D005028  0263100A   MOVZ V0, S3, V1
9D00502C  0B401431   J 0x9D0050C4
9D005030  00401821   ADDU V1, V0, ZERO
804:                 
805:                 	case FS_FAT16:
806:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))))
9D005034  8C820024   LW V0, 36(A0)
9D005038  0F4012F8   JAL move_window
9D00503C  00A22821   ADDU A1, A1, V0
9D005040  14400020   BNE V0, ZERO, 0x9D0050C4
9D005044  2403FFFF   ADDIU V1, ZERO, -1
807:                 			break;
808:                 		p = &fs->win[clst * 2 % SS(fs)];
9D005048  00108040   SLL S0, S0, 1
9D00504C  321001FE   ANDI S0, S0, 510
809:                 		return LD_WORD(p);
9D005050  02301021   ADDU V0, S1, S0
9D005054  90430035   LBU V1, 53(V0)
9D005058  00031A00   SLL V1, V1, 8
9D00505C  90420034   LBU V0, 52(V0)
9D005060  0B401431   J 0x9D0050C4
9D005064  00621825   OR V1, V1, V0
810:                 
811:                 	case FS_FAT32:
812:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))))
9D005068  8C820024   LW V0, 36(A0)
9D00506C  0F4012F8   JAL move_window
9D005070  00A22821   ADDU A1, A1, V0
9D005074  14400013   BNE V0, ZERO, 0x9D0050C4
9D005078  2403FFFF   ADDIU V1, ZERO, -1
813:                 			break;
814:                 		p = &fs->win[clst * 4 % SS(fs)];
9D00507C  00108080   SLL S0, S0, 2
9D005080  321001FC   ANDI S0, S0, 508
9D005084  02301021   ADDU V0, S1, S0
9D005094  24420034   ADDIU V0, V0, 52
815:                 		return LD_DWORD(p) & 0x0FFFFFFF;
9D005088  90440036   LBU A0, 54(V0)
9D00508C  00042400   SLL A0, A0, 16
9D005090  90430037   LBU V1, 55(V0)
9D005098  00031E00   SLL V1, V1, 24
9D00509C  00831825   OR V1, A0, V1
9D0050A0  90420001   LBU V0, 1(V0)
9D0050A4  00021200   SLL V0, V0, 8
9D0050A8  00621825   OR V1, V1, V0
9D0050AC  02308021   ADDU S0, S1, S0
9D0050B0  92020034   LBU V0, 52(S0)
9D0050B4  00621825   OR V1, V1, V0
9D0050B8  0B401431   J 0x9D0050C4
9D0050BC  7C63D800   EXT V1, V1, 0, 28
9D0050C0  24030001   ADDIU V1, ZERO, 1
816:                 	}
817:                 
818:                 	return 0xFFFFFFFF; /* An error occurred at the disk I/O layer */
819:                 }
9D0050C4  00601021   ADDU V0, V1, ZERO
9D0050C8  8FBF0024   LW RA, 36(SP)
9D0050CC  8FB30020   LW S3, 32(SP)
9D0050D0  8FB2001C   LW S2, 28(SP)
9D0050D4  8FB10018   LW S1, 24(SP)
9D0050D8  8FB00014   LW S0, 20(SP)
9D0050DC  03E00008   JR RA
9D0050E0  27BD0028   ADDIU SP, SP, 40
820:                 
821:                 /*-----------------------------------------------------------------------*/
822:                 /* FAT access - Change value of a FAT entry                              */
823:                 /*-----------------------------------------------------------------------*/
824:                 #if !_FS_READONLY
825:                 
826:                 FRESULT put_fat(FATFS *fs, /* File system object */
827:                 DWORD clst, /* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
828:                 DWORD val /* New value to mark the cluster */
829:                 ) {
9D005280  27BDFFD8   ADDIU SP, SP, -40
9D005284  AFBF0024   SW RA, 36(SP)
9D005288  AFB30020   SW S3, 32(SP)
9D00528C  AFB2001C   SW S2, 28(SP)
9D005290  AFB10018   SW S1, 24(SP)
9D005294  AFB00014   SW S0, 20(SP)
9D005298  00A08021   ADDU S0, A1, ZERO
830:                 	UINT bc;
831:                 	PF_BYTE *p;
832:                 	FRESULT res;
833:                 
834:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D00529C  2CA30002   SLTIU V1, A1, 2
9D0052A0  1460005D   BNE V1, ZERO, 0x9D005418
9D0052A4  24020002   ADDIU V0, ZERO, 2
9D0052A8  8C83001C   LW V1, 28(A0)
9D0052AC  00A3182B   SLTU V1, A1, V1
9D0052B0  10600059   BEQ V1, ZERO, 0x9D005418
9D0052B4  00808821   ADDU S1, A0, ZERO
835:                 		res = FR_INT_ERR;
836:                 
837:                 	} else {
838:                 		switch (fs->fs_type) {
9D0052B8  90820000   LBU V0, 0(A0)
9D0052BC  24030002   ADDIU V1, ZERO, 2
9D0052C0  10430031   BEQ V0, V1, 0x9D005388
9D0052C4  00C09021   ADDU S2, A2, ZERO
9D0052C8  24030003   ADDIU V1, ZERO, 3
9D0052CC  1043003B   BEQ V0, V1, 0x9D0053BC
9D0052D0  24030001   ADDIU V1, ZERO, 1
9D0052D4  1443004E   BNE V0, V1, 0x9D005410
9D0052D8  24020002   ADDIU V0, ZERO, 2
839:                 		case FS_FAT12:
840:                 			bc = clst;
841:                 			bc += bc / 2;
9D0052DC  00059842   SRL S3, A1, 1
9D0052E0  02659821   ADDU S3, S3, A1
842:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D0052E4  00132A42   SRL A1, S3, 9
9D0052E8  8C820024   LW V0, 36(A0)
9D0052EC  0F4012F8   JAL move_window
9D0052F0  00A22821   ADDU A1, A1, V0
843:                 			if (res != FR_OK)
9D0052F4  14400047   BNE V0, ZERO, 0x9D005414
9D0052F8  24030001   ADDIU V1, ZERO, 1
844:                 				break;
845:                 			p = &fs->win[bc % SS(fs)];
9D0052FC  326301FF   ANDI V1, S3, 511
846:                 			*p = (clst & 1) ? ((*p & 0x0F) | ((PF_BYTE) val << 4))
9D005300  32100001   ANDI S0, S0, 1
9D005304  12000008   BEQ S0, ZERO, 0x9D005328
9D005308  324200FF   ANDI V0, S2, 255
9D00530C  02231021   ADDU V0, S1, V1
9D005310  90440034   LBU A0, 52(V0)
9D005314  3084000F   ANDI A0, A0, 15
9D005318  324200FF   ANDI V0, S2, 255
9D00531C  00021100   SLL V0, V0, 4
9D005320  00821025   OR V0, A0, V0
9D005324  304200FF   ANDI V0, V0, 255
9D005328  02231821   ADDU V1, S1, V1
9D00532C  A0620034   SB V0, 52(V1)
847:                 					: (PF_BYTE) val;
848:                 			bc++;
9D005330  26730001   ADDIU S3, S3, 1
849:                 			fs->wflag = 1;
9D005334  24020001   ADDIU V0, ZERO, 1
9D005338  A2220004   SB V0, 4(S1)
850:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D00533C  00132A42   SRL A1, S3, 9
9D005340  8E220024   LW V0, 36(S1)
9D005344  02202021   ADDU A0, S1, ZERO
9D005348  0F4012F8   JAL move_window
9D00534C  00A22821   ADDU A1, A1, V0
851:                 			if (res != FR_OK)
9D005350  14400030   BNE V0, ZERO, 0x9D005414
9D005354  24030001   ADDIU V1, ZERO, 1
852:                 				break;
853:                 			p = &fs->win[bc % SS(fs)];
854:                 			*p = (clst & 1) ? (PF_BYTE) (val >> 4) : ((*p & 0xF0)
9D005358  12000003   BEQ S0, ZERO, 0x9D005368
9D00535C  327301FF   ANDI S3, S3, 511
9D005360  0B4014DF   J 0x9D00537C
9D005364  7E523900   EXT S2, S2, 4, 8
9D005368  02331821   ADDU V1, S1, S3
9D00536C  90630034   LBU V1, 52(V1)
9D005370  7E521A00   EXT S2, S2, 8, 4
9D005374  306300F0   ANDI V1, V1, 240
9D005378  00729025   OR S2, V1, S2
9D00537C  02339821   ADDU S3, S1, S3
855:                 					| ((PF_BYTE) (val >> 8) & 0x0F));
856:                 			break;
9D005380  0B401504   J 0x9D005410
9D005384  A2720034   SB S2, 52(S3)
857:                 
858:                 		case FS_FAT16:
859:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
9D005388  00052A02   SRL A1, A1, 8
9D00538C  8C820024   LW V0, 36(A0)
9D005390  0F4012F8   JAL move_window
9D005394  00A22821   ADDU A1, A1, V0
860:                 			if (res != FR_OK)
9D005398  1440001E   BNE V0, ZERO, 0x9D005414
9D00539C  24030001   ADDIU V1, ZERO, 1
861:                 				break;
862:                 			p = &fs->win[clst * 2 % SS(fs)];
9D0053A0  00108040   SLL S0, S0, 1
9D0053A4  321001FE   ANDI S0, S0, 510
863:                 			ST_WORD(p, (PF_WORD)val)
9D0053A8  02301821   ADDU V1, S1, S0
9D0053AC  A0720034   SB S2, 52(V1)
9D0053B0  7E523A00   EXT S2, S2, 8, 8
864:                 			;
865:                 			break;
9D0053B4  0B401504   J 0x9D005410
9D0053B8  A0720035   SB S2, 53(V1)
866:                 
867:                 		case FS_FAT32:
868:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
9D0053BC  000529C2   SRL A1, A1, 7
9D0053C0  8C820024   LW V0, 36(A0)
9D0053C4  0F4012F8   JAL move_window
9D0053C8  00A22821   ADDU A1, A1, V0
869:                 			if (res != FR_OK)
9D0053CC  14400011   BNE V0, ZERO, 0x9D005414
9D0053D0  24030001   ADDIU V1, ZERO, 1
870:                 				break;
871:                 			p = &fs->win[clst * 4 % SS(fs)];
9D0053D4  00108080   SLL S0, S0, 2
9D0053D8  321001FC   ANDI S0, S0, 508
9D0053DC  02301821   ADDU V1, S1, S0
872:                 			val |= LD_DWORD(p) & 0xF0000000;
9D0053E0  90640037   LBU A0, 55(V1)
9D0053E4  00042600   SLL A0, A0, 24
9D0053E8  02308021   ADDU S0, S1, S0
9D0053EC  7C04D804   INS A0, ZERO, 0, 28
9D0053F0  00929025   OR S2, A0, S2
873:                 			ST_DWORD(p, val)
9D0053F4  A2120034   SB S2, 52(S0)
9D0053F8  7E443A00   EXT A0, S2, 8, 8
9D0053FC  A0640035   SB A0, 53(V1)
9D005400  00122402   SRL A0, S2, 16
9D005404  A0640036   SB A0, 54(V1)
9D005408  00129602   SRL S2, S2, 24
9D00540C  A0720037   SB S2, 55(V1)
874:                 			;
875:                 			break;
876:                 
877:                 		default:
878:                 			res = FR_INT_ERR;
879:                 		}
880:                 		fs->wflag = 1;
9D005410  24030001   ADDIU V1, ZERO, 1
9D005414  A2230004   SB V1, 4(S1)
881:                 	}
882:                 
883:                 	return res;
884:                 }
9D005418  8FBF0024   LW RA, 36(SP)
9D00541C  8FB30020   LW S3, 32(SP)
9D005420  8FB2001C   LW S2, 28(SP)
9D005424  8FB10018   LW S1, 24(SP)
9D005428  8FB00014   LW S0, 20(SP)
9D00542C  03E00008   JR RA
9D005430  27BD0028   ADDIU SP, SP, 40
885:                 #endif /* !_FS_READONLY */
886:                 
887:                 /*-----------------------------------------------------------------------*/
888:                 /* FAT handling - Remove a cluster chain                                 */
889:                 /*-----------------------------------------------------------------------*/
890:                 #if !_FS_READONLY
891:                 static FRESULT remove_chain(FATFS *fs, /* File system object */
892:                 DWORD clst /* Cluster# to remove a chain from */
893:                 ) {
9D005D60  27BDFFD0   ADDIU SP, SP, -48
9D005D64  AFBF002C   SW RA, 44(SP)
9D005D68  AFB50028   SW S5, 40(SP)
9D005D6C  AFB40024   SW S4, 36(SP)
9D005D70  AFB30020   SW S3, 32(SP)
9D005D74  AFB2001C   SW S2, 28(SP)
9D005D78  AFB10018   SW S1, 24(SP)
9D005D7C  AFB00014   SW S0, 20(SP)
9D005D80  00A09021   ADDU S2, A1, ZERO
894:                 	FRESULT res;
895:                 	DWORD nxt;
896:                 #if _USE_ERASE
897:                 	DWORD scl = clst, ecl = clst, resion[2];
898:                 #endif
899:                 
900:                 	if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
9D005D84  2CA30002   SLTIU V1, A1, 2
9D005D88  14600024   BNE V1, ZERO, 0x9D005E1C
9D005D8C  24020002   ADDIU V0, ZERO, 2
9D005D90  8C83001C   LW V1, 28(A0)
9D005D94  00A3182B   SLTU V1, A1, V1
9D005D98  10600020   BEQ V1, ZERO, 0x9D005E1C
9D005D9C  00808021   ADDU S0, A0, ZERO
901:                 		res = FR_INT_ERR;
902:                 
903:                 	} else {
904:                 		res = FR_OK;
905:                 		while (clst < fs->n_fatent) { /* Not a last link? */
9D005DF8  8E03001C   LW V1, 28(S0)
9D005DFC  0223182B   SLTU V1, S1, V1
9D005E00  10600006   BEQ V1, ZERO, 0x9D005E1C
9D005E04  02209021   ADDU S2, S1, ZERO
906:                 			nxt = get_fat(fs, clst); /* Get cluster status */
9D005DAC  02002021   ADDU A0, S0, ZERO
9D005DB0  0F4013D7   JAL get_fat
9D005DB4  02402821   ADDU A1, S2, ZERO
9D005E08  0B40176C   J 0x9D005DB0
9D005E0C  02002021   ADDU A0, S0, ZERO
9D005E10  0B401787   J 0x9D005E1C
9D005E14  00001021   ADDU V0, ZERO, ZERO
907:                 			if (nxt == 0)
9D005DB8  10400015   BEQ V0, ZERO, 0x9D005E10
9D005DBC  00408821   ADDU S1, V0, ZERO
908:                 				break; /* Empty cluster? */
909:                 			if (nxt == 1) {
9D005DA0  24140001   ADDIU S4, ZERO, 1
9D005DC0  50540016   BEQL V0, S4, 0x9D005E1C
9D005DC4  24020002   ADDIU V0, ZERO, 2
910:                 				res = FR_INT_ERR;
911:                 				break;
912:                 			} /* Internal error? */
913:                 			if (nxt == 0xFFFFFFFF) {
9D005DA4  2413FFFF   ADDIU S3, ZERO, -1
9D005DC8  10530013   BEQ V0, S3, 0x9D005E18
9D005DCC  02002021   ADDU A0, S0, ZERO
914:                 				res = FR_DISK_ERR;
9D005E18  24020001   ADDIU V0, ZERO, 1
915:                 				break;
916:                 			} /* Disk error? */
917:                 			res = put_fat(fs, clst, 0); /* Mark the cluster "empty" */
9D005DD0  02402821   ADDU A1, S2, ZERO
9D005DD4  0F4014A0   JAL put_fat
9D005DD8  00003021   ADDU A2, ZERO, ZERO
918:                 			if (res != FR_OK)
9D005DDC  14400010   BNE V0, ZERO, 0x9D005E20
9D005DE0  8FBF002C   LW RA, 44(SP)
919:                 				break;
920:                 			if (fs->free_clust != 0xFFFFFFFF) { /* Update FSInfo */
9D005DE4  8E030010   LW V1, 16(S0)
9D005DE8  10730003   BEQ V1, S3, 0x9D005DF8
9D005DEC  24630001   ADDIU V1, V1, 1
921:                 				fs->free_clust++;
9D005DF0  AE030010   SW V1, 16(S0)
922:                 				fs->fsi_flag = 1;
9D005DA8  24150001   ADDIU S5, ZERO, 1
9D005DF4  A2150005   SB S5, 5(S0)
923:                 			}
924:                 #if _USE_ERASE
925:                 			if (ecl + 1 == nxt) { /* Next cluster is contiguous */
926:                 				ecl = nxt;
927:                 			} else { /* End of contiguous clusters */
928:                 				resion[0] = clust2sect(fs, scl); /* Start sector */
929:                 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1; /* End sector */
930:                 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion); /* Erase the block */
931:                 				scl = ecl = nxt;
932:                 			}
933:                 #endif
934:                 			clst = nxt; /* Next cluster */
935:                 		}
936:                 	}
937:                 
938:                 	return res;
939:                 }
9D005E1C  8FBF002C   LW RA, 44(SP)
9D005E20  8FB50028   LW S5, 40(SP)
9D005E24  8FB40024   LW S4, 36(SP)
9D005E28  8FB30020   LW S3, 32(SP)
9D005E2C  8FB2001C   LW S2, 28(SP)
9D005E30  8FB10018   LW S1, 24(SP)
9D005E34  8FB00014   LW S0, 20(SP)
9D005E38  03E00008   JR RA
9D005E3C  27BD0030   ADDIU SP, SP, 48
940:                 #endif
941:                 
942:                 /*-----------------------------------------------------------------------*/
943:                 /* FAT handling - Stretch or Create a cluster chain                      */
944:                 /*-----------------------------------------------------------------------*/
945:                 #if !_FS_READONLY
946:                 static DWORD create_chain( /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
947:                 FATFS *fs, /* File system object */
948:                 DWORD clst /* Cluster# to stretch. 0 means create a new chain. */
949:                 ) {
9D005434  27BDFFD0   ADDIU SP, SP, -48
9D005438  AFBF002C   SW RA, 44(SP)
9D00543C  AFB60028   SW S6, 40(SP)
9D005440  AFB50024   SW S5, 36(SP)
9D005444  AFB40020   SW S4, 32(SP)
9D005448  AFB3001C   SW S3, 28(SP)
9D00544C  AFB20018   SW S2, 24(SP)
9D005450  AFB10014   SW S1, 20(SP)
9D005454  AFB00010   SW S0, 16(SP)
9D005458  00808821   ADDU S1, A0, ZERO
950:                 	DWORD cs, ncl, scl;
951:                 	FRESULT res;
952:                 
953:                 	if (clst == 0) { /* Create a new chain */
9D00545C  14A00009   BNE A1, ZERO, 0x9D005484
9D005460  00A0B021   ADDU S6, A1, ZERO
954:                 		scl = fs->last_clust; /* Get suggested start point */
9D005464  8C92000C   LW S2, 12(A0)
955:                 		if (!scl || scl >= fs->n_fatent)
9D005468  52400011   BEQL S2, ZERO, 0x9D0054B0
9D00546C  24120001   ADDIU S2, ZERO, 1
9D005470  8C83001C   LW V1, 28(A0)
9D005474  0243182B   SLTU V1, S2, V1
956:                 			scl = 1;
9D005478  24020001   ADDIU V0, ZERO, 1
9D00547C  0B40152C   J 0x9D0054B0
9D005480  0043900A   MOVZ S2, V0, V1
957:                 	} else { /* Stretch the current chain */
958:                 		cs = get_fat(fs, clst); /* Check the cluster status */
9D005484  0F4013D7   JAL get_fat
9D005488  00000000   NOP
959:                 		if (cs < 2)
9D00548C  2C430002   SLTIU V1, V0, 2
9D005490  54600042   BNEL V1, ZERO, 0x9D00559C
9D005494  24020001   ADDIU V0, ZERO, 1
960:                 			return 1; /* It is an invalid cluster */
961:                 		if (cs < fs->n_fatent)
9D005498  8E23001C   LW V1, 28(S1)
9D00549C  0043182B   SLTU V1, V0, V1
9D0054A0  10600003   BEQ V1, ZERO, 0x9D0054B0
9D0054A4  02C09021   ADDU S2, S6, ZERO
962:                 			return cs; /* It is already followed by next cluster */
963:                 		scl = clst;
964:                 	}
965:                 
966:                 	ncl = scl; /* Start cluster */
9D0054B0  02408021   ADDU S0, S2, ZERO
967:                 	for (;;) {
968:                 		ncl++; /* Next cluster */
9D0054C0  26100001   ADDIU S0, S0, 1
969:                 		if (ncl >= fs->n_fatent) { /* Wrap around */
9D0054C4  8E22001C   LW V0, 28(S1)
9D0054C8  0202102B   SLTU V0, S0, V0
9D0054CC  14400004   BNE V0, ZERO, 0x9D0054E0
9D0054D0  02202021   ADDU A0, S1, ZERO
970:                 			ncl = 2;
971:                 			if (ncl > scl)
9D0054B4  2E550002   SLTIU S5, S2, 2
9D0054D4  16A0002C   BNE S5, ZERO, 0x9D005588
9D0054D8  24100002   ADDIU S0, ZERO, 2
972:                 				return 0; /* No free cluster */
9D005588  0B401567   J 0x9D00559C
9D00558C  00001021   ADDU V0, ZERO, ZERO
973:                 		}
974:                 		cs = get_fat(fs, ncl); /* Get the cluster status */
9D0054DC  02202021   ADDU A0, S1, ZERO
9D0054E0  0F4013D7   JAL get_fat
9D0054E4  02002821   ADDU A1, S0, ZERO
975:                 		if (cs == 0)
9D0054E8  50400009   BEQL V0, ZERO, 0x9D005510
9D0054EC  02009021   ADDU S2, S0, ZERO
976:                 			break; /* Found a free cluster */
977:                 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
9D0054B8  2413FFFF   ADDIU S3, ZERO, -1
9D0054BC  24140001   ADDIU S4, ZERO, 1
9D0054F0  1053002B   BEQ V0, S3, 0x9D0055A0
9D0054F4  8FBF002C   LW RA, 44(SP)
9D0054F8  5054002A   BEQL V0, S4, 0x9D0055A4
9D0054FC  8FB60028   LW S6, 40(SP)
978:                 			return cs;
979:                 		if (ncl == scl)
9D005500  1612FFF0   BNE S0, S2, 0x9D0054C4
9D005504  26100001   ADDIU S0, S0, 1
9D005508  0B401564   J 0x9D005590
9D00550C  00001021   ADDU V0, ZERO, ZERO
980:                 			return 0; /* No free cluster */
981:                 	}
982:                 
983:                 	res = put_fat(fs, ncl, 0x0FFFFFFF); /* Mark the new cluster "last link" */
9D005510  02202021   ADDU A0, S1, ZERO
9D005514  02002821   ADDU A1, S0, ZERO
9D005518  3C060FFF   LUI A2, 4095
9D00551C  0F4014A0   JAL put_fat
9D005520  34C6FFFF   ORI A2, A2, -1
984:                 	if (res == FR_OK && clst != 0) {
9D005524  14400013   BNE V0, ZERO, 0x9D005574
9D005528  38420001   XORI V0, V0, 1
9D00552C  52C00008   BEQL S6, ZERO, 0x9D005550
9D005530  AE32000C   SW S2, 12(S1)
985:                 		res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
9D005534  02202021   ADDU A0, S1, ZERO
9D005538  02C02821   ADDU A1, S6, ZERO
9D00553C  0F4014A0   JAL put_fat
9D005540  02003021   ADDU A2, S0, ZERO
986:                 	}
987:                 	if (res == FR_OK) {
9D005544  1440000B   BNE V0, ZERO, 0x9D005574
9D005548  38420001   XORI V0, V0, 1
988:                 		fs->last_clust = ncl; /* Update FSINFO */
9D00554C  AE32000C   SW S2, 12(S1)
989:                 		if (fs->free_clust != 0xFFFFFFFF) {
9D005550  8E220010   LW V0, 16(S1)
9D005554  2403FFFF   ADDIU V1, ZERO, -1
9D005558  1043000F   BEQ V0, V1, 0x9D005598
9D00555C  2442FFFF   ADDIU V0, V0, -1
990:                 			fs->free_clust--;
9D005560  AE220010   SW V0, 16(S1)
991:                 			fs->fsi_flag = 1;
9D005564  24020001   ADDIU V0, ZERO, 1
9D005568  A2220005   SB V0, 5(S1)
9D00556C  0B401567   J 0x9D00559C
9D005570  02001021   ADDU V0, S0, ZERO
992:                 		}
993:                 	} else {
994:                 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
9D005574  2403FFFF   ADDIU V1, ZERO, -1
9D005578  24040001   ADDIU A0, ZERO, 1
9D00557C  0082180B   MOVN V1, A0, V0
9D005580  0B401567   J 0x9D00559C
9D005584  00601021   ADDU V0, V1, ZERO
995:                 	}
996:                 
997:                 	return ncl; /* Return new cluster number or error code */
998:                 }
9D0054A8  0B401568   J 0x9D0055A0
9D0054AC  8FBF002C   LW RA, 44(SP)
9D005590  0B401568   J 0x9D0055A0
9D005594  8FBF002C   LW RA, 44(SP)
9D005598  02001021   ADDU V0, S0, ZERO
9D00559C  8FBF002C   LW RA, 44(SP)
9D0055A0  8FB60028   LW S6, 40(SP)
9D0055A4  8FB50024   LW S5, 36(SP)
9D0055A8  8FB40020   LW S4, 32(SP)
9D0055AC  8FB3001C   LW S3, 28(SP)
9D0055B0  8FB20018   LW S2, 24(SP)
9D0055B4  8FB10014   LW S1, 20(SP)
9D0055B8  8FB00010   LW S0, 16(SP)
9D0055BC  03E00008   JR RA
9D0055C0  27BD0030   ADDIU SP, SP, 48
999:                 #endif /* !_FS_READONLY */
1000:                
1001:                /*-----------------------------------------------------------------------*/
1002:                /* FAT handling - Convert offset into cluster with link map table        */
1003:                /*-----------------------------------------------------------------------*/
1004:                
1005:                #if _USE_FASTSEEK
1006:                static DWORD clmt_clust( /* <2:Error, >=2:Cluster number */
1007:                FIL* fp, /* Pointer to the file object */
1008:                DWORD ofs /* File offset to be converted to cluster# */
1009:                ) {
1010:                	DWORD cl, ncl, *tbl;
1011:                
1012:                	tbl = fp->cltbl + 1; /* Top of CLMT */
9D004A48  8C830024   LW V1, 36(A0)
9D004A4C  24660004   ADDIU A2, V1, 4
1013:                	cl = ofs / SS(fp->fs) / fp->fs->csize; /* Cluster order from top of the file */
9D004A50  00052A42   SRL A1, A1, 9
9D004A54  8C820000   LW V0, 0(A0)
9D004A58  90420002   LBU V0, 2(V0)
9D004A5C  00A2001B   DIVU A1, V0
9D004A60  004001F4   TEQ V0, ZERO
9D004A64  00002812   MFLO A1
1014:                	for (;;) {
1015:                		ncl = *tbl++; /* Number of cluters in the fragment */
9D004A68  8C630004   LW V1, 4(V1)
9D004A98  8CC30000   LW V1, 0(A2)
1016:                		if (!ncl)
9D004A6C  10600011   BEQ V1, ZERO, 0x9D004AB4
9D004A70  00001012   MFLO V0
9D004A9C  1460FFFA   BNE V1, ZERO, 0x9D004A88
9D004AA0  0043202B   SLTU A0, V0, V1
9D004AA4  03E00008   JR RA
9D004AA8  00001021   ADDU V0, ZERO, ZERO
1017:                			return 0; /* End of table? (error) */
9D004AB4  03E00008   JR RA
9D004AB8  00001021   ADDU V0, ZERO, ZERO
1018:                		if (cl < ncl)
9D004A74  00A3282B   SLTU A1, A1, V1
9D004A78  50A00006   BEQL A1, ZERO, 0x9D004A94
9D004A7C  00431023   SUBU V0, V0, V1
9D004A88  54800008   BNEL A0, ZERO, 0x9D004AAC
9D004A8C  8CC30004   LW V1, 4(A2)
1019:                			break; /* In this fragment? */
1020:                		cl -= ncl;
9D004A90  00431023   SUBU V0, V0, V1
9D004A94  24C60008   ADDIU A2, A2, 8
1021:                		tbl++; /* Next fragment */
1022:                	}
1023:                	return cl + *tbl; /* Return the cluster number */
9D004A80  0B4012AB   J 0x9D004AAC
9D004A84  8CC30004   LW V1, 4(A2)
9D004AAC  03E00008   JR RA
9D004AB0  00431021   ADDU V0, V0, V1
9D004AB4  03E00008   JR RA
9D004AB8  00001021   ADDU V0, ZERO, ZERO
1024:                }
1025:                #endif	/* _USE_FASTSEEK */
1026:                
1027:                /*-----------------------------------------------------------------------*/
1028:                /* Directory handling - Set directory index                              */
1029:                /*-----------------------------------------------------------------------*/
1030:                
1031:                static FRESULT dir_sdi(DIR *dj, /* Pointer to directory object */
1032:                PF_WORD idx /* Directory index number */
1033:                ) {
9D0050E4  27BDFFD8   ADDIU SP, SP, -40
9D0050E8  AFBF0024   SW RA, 36(SP)
9D0050EC  AFB30020   SW S3, 32(SP)
9D0050F0  AFB2001C   SW S2, 28(SP)
9D0050F4  AFB10018   SW S1, 24(SP)
9D0050F8  AFB00014   SW S0, 20(SP)
9D0050FC  00808021   ADDU S0, A0, ZERO
9D005100  00A08821   ADDU S1, A1, ZERO
1034:                	DWORD clst;
1035:                	PF_WORD ic;
1036:                
1037:                	dj->index = idx;
9D005104  A6050006   SH A1, 6(S0)
1038:                	clst = dj->sclust;
9D005108  8C850008   LW A1, 8(A0)
1039:                	if (clst == 1 || clst >= dj->fs->n_fatent) /* Check start cluster range */
9D00510C  24030001   ADDIU V1, ZERO, 1
9D005110  10A3003E   BEQ A1, V1, 0x9D00520C
9D005114  24020002   ADDIU V0, ZERO, 2
9D005118  8C830000   LW V1, 0(A0)
9D00511C  8C64001C   LW A0, 28(V1)
9D005120  00A4202B   SLTU A0, A1, A0
9D005124  5080003A   BEQL A0, ZERO, 0x9D005210
9D005128  8FBF0024   LW RA, 36(SP)
1040:                		return FR_INT_ERR;
1041:                	if (!clst && dj->fs->fs_type == FS_FAT32) /* Replace cluster# 0 with root cluster# if in FAT32 */
9D00512C  54A00012   BNEL A1, ZERO, 0x9D005178
9D005130  90720002   LBU S2, 2(V1)
9D005134  90640000   LBU A0, 0(V1)
9D005138  24020003   ADDIU V0, ZERO, 3
9D00513C  54820005   BNEL A0, V0, 0x9D005154
9D005140  AE00000C   SW ZERO, 12(S0)
1042:                		clst = dj->fs->dirbase;
9D005144  8C650028   LW A1, 40(V1)
1043:                
1044:                	if (clst == 0) { /* Static table (root-dir in FAT12/16) */
9D005148  54A0000B   BNEL A1, ZERO, 0x9D005178
9D00514C  90720002   LBU S2, 2(V1)
1045:                		dj->clust = clst;
9D005150  AE00000C   SW ZERO, 12(S0)
1046:                		if (idx >= dj->fs->n_rootdir) /* Index is out of range */
9D005154  94640008   LHU A0, 8(V1)
9D005158  0224202B   SLTU A0, S1, A0
9D00515C  1080002B   BEQ A0, ZERO, 0x9D00520C
9D005160  24020002   ADDIU V0, ZERO, 2
1047:                			return FR_INT_ERR;
1048:                		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D005164  00111102   SRL V0, S1, 4
9D005168  8C630028   LW V1, 40(V1)
9D00516C  00431021   ADDU V0, V0, V1
9D005170  0B401478   J 0x9D0051E0
9D005174  AE020010   SW V0, 16(S0)
1049:                	} else { /* Dynamic table (sub-dirs or root-dir in FAT32) */
1050:                		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize; /* Entries per cluster */
9D005178  00129100   SLL S2, S2, 4
1051:                		while (idx >= ic) { /* Follow cluster chain */
9D00517C  0232102B   SLTU V0, S1, S2
9D005180  14400011   BNE V0, ZERO, 0x9D0051C8
9D005184  2413FFFF   ADDIU S3, ZERO, -1
9D0051BC  0232102B   SLTU V0, S1, S2
9D0051C0  1040FFF1   BEQ V0, ZERO, 0x9D005188
9D0051C4  00000000   NOP
1052:                			clst = get_fat(dj->fs, clst); /* Get next cluster */
9D005188  0F4013D7   JAL get_fat
9D00518C  8E040000   LW A0, 0(S0)
1053:                			if (clst == 0xFFFFFFFF)
9D005190  1053001B   BEQ V0, S3, 0x9D005200
9D005194  00402821   ADDU A1, V0, ZERO
1054:                				return FR_DISK_ERR; /* Disk error */
9D005200  0B401483   J 0x9D00520C
9D005204  24020001   ADDIU V0, ZERO, 1
1055:                			if (clst < 2 || clst >= dj->fs->n_fatent) /* Reached to end of table or int error */
9D005198  2C420002   SLTIU V0, V0, 2
9D00519C  1440001B   BNE V0, ZERO, 0x9D00520C
9D0051A0  24020002   ADDIU V0, ZERO, 2
9D0051A4  8E020000   LW V0, 0(S0)
9D0051A8  8C42001C   LW V0, 28(V0)
9D0051AC  00A2102B   SLTU V0, A1, V0
9D0051B0  10400015   BEQ V0, ZERO, 0x9D005208
9D0051B4  02328823   SUBU S1, S1, S2
1056:                				return FR_INT_ERR;
9D005208  24020002   ADDIU V0, ZERO, 2
1057:                			idx -= ic;
9D0051B8  3231FFFF   ANDI S1, S1, -1
1058:                		}
1059:                		dj->clust = clst;
9D0051C8  AE05000C   SW A1, 12(S0)
1060:                		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
9D0051CC  0F4013CB   JAL clust2sect
9D0051D0  8E040000   LW A0, 0(S0)
9D0051D4  00111902   SRL V1, S1, 4
9D0051D8  00621021   ADDU V0, V1, V0
9D0051DC  AE020010   SW V0, 16(S0)
1061:                	}
1062:                
1063:                	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR; /* Ptr to the entry in the sector */
9D0051E0  3231000F   ANDI S1, S1, 15
9D0051E4  00118940   SLL S1, S1, 5
9D0051E8  8E020000   LW V0, 0(S0)
9D0051EC  00511021   ADDU V0, V0, S1
9D0051F0  24420034   ADDIU V0, V0, 52
9D0051F4  AE020014   SW V0, 20(S0)
1064:                
1065:                	return FR_OK; /* Seek succeeded */
9D0051F8  0B401483   J 0x9D00520C
9D0051FC  00001021   ADDU V0, ZERO, ZERO
1066:                }
9D00520C  8FBF0024   LW RA, 36(SP)
9D005210  8FB30020   LW S3, 32(SP)
9D005214  8FB2001C   LW S2, 28(SP)
9D005218  8FB10018   LW S1, 24(SP)
9D00521C  8FB00014   LW S0, 20(SP)
9D005220  03E00008   JR RA
9D005224  27BD0028   ADDIU SP, SP, 40
1067:                
1068:                /*-----------------------------------------------------------------------*/
1069:                /* Directory handling - Move directory index next                        */
1070:                /*-----------------------------------------------------------------------*/
1071:                
1072:                static FRESULT dir_next( /* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
1073:                DIR *dj, /* Pointer to directory object */
1074:                int stretch /* 0: Do not stretch table, 1: Stretch table if needed */
1075:                ) {
9D0055C4  27BDFFD0   ADDIU SP, SP, -48
9D0055C8  AFBF002C   SW RA, 44(SP)
9D0055CC  AFB50028   SW S5, 40(SP)
9D0055D0  AFB40024   SW S4, 36(SP)
9D0055D4  AFB30020   SW S3, 32(SP)
9D0055D8  AFB2001C   SW S2, 28(SP)
9D0055DC  AFB10018   SW S1, 24(SP)
9D0055E0  AFB00014   SW S0, 20(SP)
9D0055E4  00808021   ADDU S0, A0, ZERO
1076:                	DWORD clst;
1077:                	PF_WORD i;
1078:                
1079:                	stretch = stretch; /* To suppress warning on read-only cfg. */
1080:                	i = dj->index + 1;
9D0055E8  94910006   LHU S1, 6(A0)
9D0055EC  26310001   ADDIU S1, S1, 1
9D0055F0  3231FFFF   ANDI S1, S1, -1
1081:                	if (!i || !dj->sect) /* Report EOT when index has reached 65535 */
9D0055F4  12200068   BEQ S1, ZERO, 0x9D005798
9D0055F8  24030004   ADDIU V1, ZERO, 4
9D0055FC  8C820010   LW V0, 16(A0)
9D005600  50400066   BEQL V0, ZERO, 0x9D00579C
9D005604  00601021   ADDU V0, V1, ZERO
1082:                		return FR_NO_FILE;
1083:                
1084:                	if (!(i % (SS(dj->fs) / SZ_DIR))) { /* Sector changed? */
9D005608  3233000F   ANDI S3, S1, 15
9D00560C  5660005A   BNEL S3, ZERO, 0x9D005778
9D005610  A6110006   SH S1, 6(S0)
9D005614  00A09021   ADDU S2, A1, ZERO
1085:                		dj->sect++; /* Next sector */
9D005618  24420001   ADDIU V0, V0, 1
9D00561C  AC820010   SW V0, 16(A0)
1086:                
1087:                		if (dj->clust == 0) { /* Static table */
9D005620  8C85000C   LW A1, 12(A0)
9D005624  54A00008   BNEL A1, ZERO, 0x9D005648
9D005628  8C840000   LW A0, 0(A0)
1088:                			if (i >= dj->fs->n_rootdir) /* Report EOT when end of table */
9D00562C  8C820000   LW V0, 0(A0)
9D005630  94420008   LHU V0, 8(V0)
9D005634  0222102B   SLTU V0, S1, V0
9D005638  10400058   BEQ V0, ZERO, 0x9D00579C
9D00563C  00601021   ADDU V0, V1, ZERO
9D005640  0B4015DE   J 0x9D005778
9D005644  A6110006   SH S1, 6(S0)
1089:                				return FR_NO_FILE;
1090:                		} else { /* Dynamic table */
1091:                			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) { /* Cluster changed? */
9D005648  90830002   LBU V1, 2(A0)
9D00564C  2463FFFF   ADDIU V1, V1, -1
9D005650  00111102   SRL V0, S1, 4
9D005654  00621024   AND V0, V1, V0
9D005658  54400047   BNEL V0, ZERO, 0x9D005778
9D00565C  A6110006   SH S1, 6(S0)
1092:                				clst = get_fat(dj->fs, dj->clust); /* Get next cluster */
9D005660  0F4013D7   JAL get_fat
9D005664  00000000   NOP
9D005668  0040A021   ADDU S4, V0, ZERO
1093:                				if (clst <= 1)
9D00566C  2C420002   SLTIU V0, V0, 2
9D005670  14400049   BNE V0, ZERO, 0x9D005798
9D005674  24030002   ADDIU V1, ZERO, 2
1094:                					return FR_INT_ERR;
1095:                				if (clst == 0xFFFFFFFF)
9D005678  2402FFFF   ADDIU V0, ZERO, -1
9D00567C  52820046   BEQL S4, V0, 0x9D005798
9D005680  24030001   ADDIU V1, ZERO, 1
1096:                					return FR_DISK_ERR;
1097:                				if (clst >= dj->fs->n_fatent) { /* When it reached end of dynamic table */
9D005684  8E040000   LW A0, 0(S0)
9D005688  8C82001C   LW V0, 28(A0)
9D00568C  0282102B   SLTU V0, S4, V0
9D005690  54400034   BNEL V0, ZERO, 0x9D005764
9D005694  AE14000C   SW S4, 12(S0)
1098:                #if !_FS_READONLY
1099:                					PF_BYTE c;
1100:                					if (!stretch)
9D005698  1240003F   BEQ S2, ZERO, 0x9D005798
9D00569C  24030004   ADDIU V1, ZERO, 4
1101:                						return FR_NO_FILE; /* When do not stretch, report EOT */
1102:                					clst = create_chain(dj->fs, dj->clust); /* Stretch cluster chain */
9D0056A0  0F40150D   JAL create_chain
9D0056A4  8E05000C   LW A1, 12(S0)
9D0056A8  0040A021   ADDU S4, V0, ZERO
1103:                					if (clst == 0)
9D0056AC  1040003A   BEQ V0, ZERO, 0x9D005798
9D0056B0  24030007   ADDIU V1, ZERO, 7
1104:                						return FR_DENIED; /* No free cluster */
1105:                					if (clst == 1)
9D0056B4  24020001   ADDIU V0, ZERO, 1
9D0056B8  12820037   BEQ S4, V0, 0x9D005798
9D0056BC  24030002   ADDIU V1, ZERO, 2
1106:                						return FR_INT_ERR;
1107:                					if (clst == 0xFFFFFFFF)
9D0056C0  2402FFFF   ADDIU V0, ZERO, -1
9D0056C4  12820034   BEQ S4, V0, 0x9D005798
9D0056C8  24030001   ADDIU V1, ZERO, 1
1108:                						return FR_DISK_ERR;
1109:                					/* Clean-up stretched table */
1110:                					if (move_window(dj->fs, 0))
9D0056CC  8E040000   LW A0, 0(S0)
9D0056D0  0F4012F8   JAL move_window
9D0056D4  00002821   ADDU A1, ZERO, ZERO
9D0056D8  1440002F   BNE V0, ZERO, 0x9D005798
9D0056DC  24030001   ADDIU V1, ZERO, 1
1111:                						return FR_DISK_ERR; /* Flush active window */
1112:                					mem_set(dj->fs->win, 0, SS(dj->fs)); /* Clear window buffer */
9D0056E0  8E030000   LW V1, 0(S0)
9D0056E4  24620034   ADDIU V0, V1, 52
9D0056E8  24630234   ADDIU V1, V1, 564
1113:                					dj->fs->winsect = clust2sect(dj->fs, clst); /* Cluster start sector */
9D0056F8  8E120000   LW S2, 0(S0)
9D0056FC  02402021   ADDU A0, S2, ZERO
9D005700  0F4013CB   JAL clust2sect
9D005704  02802821   ADDU A1, S4, ZERO
9D005708  AE420030   SW V0, 48(S2)
1114:                					for (c = 0; c < dj->fs->csize; c++) { /* Fill the new cluster with 0 */
9D00570C  00009021   ADDU S2, ZERO, ZERO
9D005710  0B4015D0   J 0x9D005740
9D005714  24150001   ADDIU S5, ZERO, 1
9D00573C  325200FF   ANDI S2, S2, 255
9D005740  8E020000   LW V0, 0(S0)
9D005744  90430002   LBU V1, 2(V0)
9D005748  0243182B   SLTU V1, S2, V1
9D00574C  5460FFF2   BNEL V1, ZERO, 0x9D005718
9D005750  A0550004   SB S5, 4(V0)
1115:                						dj->fs->wflag = 1;
1116:                						if (move_window(dj->fs, 0))
9D005718  8E040000   LW A0, 0(S0)
9D00571C  0F4012F8   JAL move_window
9D005720  00002821   ADDU A1, ZERO, ZERO
9D005724  1440001B   BNE V0, ZERO, 0x9D005794
9D005728  26520001   ADDIU S2, S2, 1
1117:                							return FR_DISK_ERR;
9D005794  24030001   ADDIU V1, ZERO, 1
1118:                						dj->fs->winsect++;
9D00572C  8E020000   LW V0, 0(S0)
9D005730  8C430030   LW V1, 48(V0)
9D005734  24630001   ADDIU V1, V1, 1
9D005738  AC430030   SW V1, 48(V0)
1119:                					}
1120:                					dj->fs->winsect -= c; /* Rewind window address */
9D005754  8C430030   LW V1, 48(V0)
9D005758  00729023   SUBU S2, V1, S2
9D00575C  AC520030   SW S2, 48(V0)
1121:                #else
1122:                					return FR_NO_FILE; /* Report EOT */
1123:                #endif
1124:                				}
1125:                				dj->clust = clst; /* Initialize data for new cluster */
9D005760  AE14000C   SW S4, 12(S0)
1126:                				dj->sect = clust2sect(dj->fs, clst);
9D005764  8E040000   LW A0, 0(S0)
9D005768  0F4013CB   JAL clust2sect
9D00576C  02802821   ADDU A1, S4, ZERO
9D005770  AE020010   SW V0, 16(S0)
1127:                			}
1128:                		}
1129:                	}
1130:                
1131:                	dj->index = i;
9D005774  A6110006   SH S1, 6(S0)
1132:                	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
9D005778  00139940   SLL S3, S3, 5
9D00577C  8E020000   LW V0, 0(S0)
9D005780  00539821   ADDU S3, V0, S3
9D005784  26730034   ADDIU S3, S3, 52
9D005788  AE130014   SW S3, 20(S0)
1133:                
1134:                	return FR_OK;
9D00578C  0B4015E6   J 0x9D005798
9D005790  00001821   ADDU V1, ZERO, ZERO
1135:                }
9D005798  00601021   ADDU V0, V1, ZERO
9D00579C  8FBF002C   LW RA, 44(SP)
9D0057A0  8FB50028   LW S5, 40(SP)
9D0057A4  8FB40024   LW S4, 36(SP)
9D0057A8  8FB30020   LW S3, 32(SP)
9D0057AC  8FB2001C   LW S2, 28(SP)
9D0057B0  8FB10018   LW S1, 24(SP)
9D0057B4  8FB00014   LW S0, 20(SP)
9D0057B8  03E00008   JR RA
9D0057BC  27BD0030   ADDIU SP, SP, 48
1136:                
1137:                /*-----------------------------------------------------------------------*/
1138:                /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1139:                /*-----------------------------------------------------------------------*/
1140:                #if _USE_LFN
1141:                static
1142:                const PF_BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30}; /* Offset of LFN chars in the directory entry */
1143:                
1144:                static
1145:                int cmp_lfn ( /* 1:Matched, 0:Not matched */
1146:                		WCHAR *lfnbuf, /* Pointer to the LFN to be compared */
1147:                		PF_BYTE *dir /* Pointer to the directory entry containing a part of LFN */
1148:                )
1149:                {
1150:                	UINT i, s;
1151:                	WCHAR wc, uc;
1152:                
1153:                	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13; /* Get offset in the LFN buffer */
1154:                	s = 0; wc = 1;
1155:                	do {
1156:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1157:                		if (wc) { /* Last char has not been processed */
1158:                			wc = ff_wtoupper(uc); /* Convert it to upper case */
1159:                			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++])) /* Compare it */
1160:                			return 0; /* Not matched */
1161:                		} else {
1162:                			if (uc != 0xFFFF) return 0; /* Check filler */
1163:                		}
1164:                	}while (++s < 13); /* Repeat until all chars in the entry are checked */
1165:                
1166:                	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i]) /* Last segment matched but different length */
1167:                	return 0;
1168:                
1169:                	return 1; /* The part of LFN matched */
1170:                }
1171:                
1172:                static
1173:                int pick_lfn ( /* 1:Succeeded, 0:Buffer overflow */
1174:                		WCHAR *lfnbuf, /* Pointer to the Unicode-LFN buffer */
1175:                		PF_BYTE *dir /* Pointer to the directory entry */
1176:                )
1177:                {
1178:                	UINT i, s;
1179:                	WCHAR wc, uc;
1180:                
1181:                	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13; /* Offset in the LFN buffer */
1182:                
1183:                	s = 0; wc = 1;
1184:                	do {
1185:                		uc = LD_WORD(dir+LfnOfs[s]); /* Pick an LFN character from the entry */
1186:                		if (wc) { /* Last char has not been processed */
1187:                			if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1188:                			lfnbuf[i++] = wc = uc; /* Store it */
1189:                		} else {
1190:                			if (uc != 0xFFFF) return 0; /* Check filler */
1191:                		}
1192:                	}while (++s < 13); /* Read all character in the entry */
1193:                
1194:                	if (dir[LDIR_Ord] & LLE) { /* Put terminator if it is the last LFN part */
1195:                		if (i >= _MAX_LFN) return 0; /* Buffer overflow? */
1196:                		lfnbuf[i] = 0;
1197:                	}
1198:                
1199:                	return 1;
1200:                }
1201:                
1202:                #if !_FS_READONLY
1203:                static
1204:                void fit_lfn (
1205:                		const WCHAR *lfnbuf, /* Pointer to the LFN buffer */
1206:                		PF_BYTE *dir, /* Pointer to the directory entry */
1207:                		PF_BYTE ord, /* LFN order (1-20) */
1208:                		PF_BYTE sum /* SFN sum */
1209:                )
1210:                {
1211:                	UINT i, s;
1212:                	WCHAR wc;
1213:                
1214:                	dir[LDIR_Chksum] = sum; /* Set check sum */
1215:                	dir[LDIR_Attr] = AM_LFN; /* Set attribute. LFN entry */
1216:                	dir[LDIR_Type] = 0;
1217:                	ST_WORD(dir+LDIR_FstClusLO, 0);
1218:                
1219:                	i = (ord - 1) * 13; /* Get offset in the LFN buffer */
1220:                	s = wc = 0;
1221:                	do {
1222:                		if (wc != 0xFFFF) wc = lfnbuf[i++]; /* Get an effective char */
1223:                		ST_WORD(dir+LfnOfs[s], wc); /* Put it */
1224:                		if (!wc) wc = 0xFFFF; /* Padding chars following last char */
1225:                	}while (++s < 13);
1226:                	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE; /* Bottom LFN part is the start of LFN sequence */
1227:                	dir[LDIR_Ord] = ord; /* Set the LFN order */
1228:                }
1229:                
1230:                #endif
1231:                #endif
1232:                
1233:                /*-----------------------------------------------------------------------*/
1234:                /* Create numbered name                                                  */
1235:                /*-----------------------------------------------------------------------*/
1236:                #if _USE_LFN
1237:                void gen_numname (
1238:                		PF_BYTE *dst, /* Pointer to generated SFN */
1239:                		const PF_BYTE *src, /* Pointer to source SFN to be modified */
1240:                		const WCHAR *lfn, /* Pointer to LFN */
1241:                		PF_WORD seq /* Sequence number */
1242:                )
1243:                {
1244:                	PF_BYTE ns[8], c;
1245:                	UINT i, j;
1246:                
1247:                	mem_cpy(dst, src, 11);
1248:                
1249:                	if (seq > 5) { /* On many collisions, generate a hash number instead of sequential number */
1250:                		do seq = (seq >> 1) + (seq << 15) + (PF_WORD)*lfn++; while (*lfn);
1251:                	}
1252:                
1253:                	/* itoa (hexdecimal) */
1254:                	i = 7;
1255:                	do {
1256:                		c = (seq % 16) + '0';
1257:                		if (c > '9') c += 7;
1258:                		ns[i--] = c;
1259:                		seq /= 16;
1260:                	}while (seq);
1261:                	ns[i] = '~';
1262:                
1263:                	/* Append the number */
1264:                	for (j = 0; j < i && dst[j] != ' '; j++) {
1265:                		if (IsDBCS1(dst[j])) {
1266:                			if (j == i - 1) break;
1267:                			j++;
1268:                		}
1269:                	}
1270:                	do {
1271:                		dst[j++] = (i < 8) ? ns[i++] : ' ';
1272:                	}while (j < 8);
1273:                }
1274:                #endif
1275:                
1276:                /*-----------------------------------------------------------------------*/
1277:                /* Calculate sum of an SFN                                               */
1278:                /*-----------------------------------------------------------------------*/
1279:                #if _USE_LFN
1280:                static
1281:                PF_BYTE sum_sfn (
1282:                		const PF_BYTE *dir /* Ptr to directory entry */
1283:                )
1284:                {
1285:                	PF_BYTE sum = 0;
1286:                	UINT n = 11;
1287:                
1288:                	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
1289:                	return sum;
1290:                }
1291:                #endif
1292:                
1293:                /*-----------------------------------------------------------------------*/
1294:                /* Directory handling - Find an object in the directory                  */
1295:                /*-----------------------------------------------------------------------*/
1296:                
1297:                static FRESULT dir_find(DIR *dj /* Pointer to the directory object linked to the file name */
1298:                ) {
1299:                	FRESULT res;
1300:                	PF_BYTE c, *dir;
1301:                #if _USE_LFN
1302:                	PF_BYTE a, ord, sum;
1303:                #endif
1304:                
1305:                	res = dir_sdi(dj, 0); /* Rewind directory object */
9D005B7C  02202021   ADDU A0, S1, ZERO
9D005B80  0F401439   JAL dir_sdi
9D005B84  00002821   ADDU A1, ZERO, ZERO
1306:                	if (res != FR_OK)
9D005B88  5040FFA2   BEQL V0, ZERO, follow_path::dir_find
9D005B8C  8E240000   LW A0, 0(S1)
1307:                		return res;
1308:                
1309:                #if _USE_LFN
1310:                	ord = sum = 0xFF;
1311:                #endif
1312:                	do {
1313:                		res = move_window(dj->fs, dj->sect);
9D005A14  0F4012F8   JAL move_window
9D005A18  8E250010   LW A1, 16(S1)
1314:                		if (res != FR_OK)
9D005A1C  54400064   BNEL V0, ZERO, 0x9D005BB0
9D005A20  8E230018   LW V1, 24(S1)
1315:                			break;
1316:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D005A24  8E280014   LW T0, 20(S1)
1317:                		c = dir[DIR_Name];
1318:                		if (c == 0) {
9D005A28  91030000   LBU V1, 0(T0)
9D005A2C  50600065   BEQL V1, ZERO, 0x9D005BC4
9D005A30  8E220018   LW V0, 24(S1)
1319:                			res = FR_NO_FILE;
1320:                			break;
1321:                		} /* Reached to end of table */
1322:                #if _USE_LFN	/* LFN configuration */
1323:                		a = dir[DIR_Attr] & AM_MASK;
1324:                		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1325:                			ord = 0xFF;
1326:                		} else {
1327:                			if (a == AM_LFN) { /* An LFN entry is found */
1328:                				if (dj->lfn) {
1329:                					if (c & LLE) { /* Is it start of LFN sequence? */
1330:                						sum = dir[LDIR_Chksum];
1331:                						c &= ~LLE; ord = c; /* LFN start order */
1332:                						dj->lfn_idx = dj->index;
1333:                					}
1334:                					/* Check validity of the LFN entry and compare it with given name */
1335:                					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1336:                				}
1337:                			} else { /* An SFN entry is found */
1338:                				if (!ord && sum == sum_sfn(dir)) break; /* LFN matched? */
1339:                				ord = 0xFF; dj->lfn_idx = 0xFFFF; /* Reset LFN sequence */
1340:                				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break; /* SFN matched? */
1341:                			}
1342:                		}
1343:                #else		/* Non LFN configuration */
1344:                		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
9D005A34  9103000B   LBU V1, 11(T0)
9D005A38  30630008   ANDI V1, V1, 8
9D005A3C  306300FF   ANDI V1, V1, 255
9D005A40  1460000D   BNE V1, ZERO, 0x9D005A78
9D005A44  2505000B   ADDIU A1, T0, 11
9D005A48  8E290018   LW T1, 24(S1)
1345:                			break;
1346:                #endif
1347:                		res = dir_next(dj, 0); /* Next entry */
9D005A78  02202021   ADDU A0, S1, ZERO
9D005A7C  0F401571   JAL dir_next
9D005A80  00002821   ADDU A1, ZERO, ZERO
1348:                	} while (res == FR_OK);
9D005A84  5040FFE3   BEQL V0, ZERO, follow_path::dir_find
9D005A88  8E240000   LW A0, 0(S1)
1349:                
1350:                	return res;
1351:                }
1352:                
1353:                /*-----------------------------------------------------------------------*/
1354:                /* Read an object from the directory                                     */
1355:                /*-----------------------------------------------------------------------*/
1356:                #if _FS_MINIMIZE <= 1
1357:                static FRESULT dir_read(DIR *dj /* Pointer to the directory object that pointing the entry to be read */
1358:                ) {
9D005CC4  27BDFFE0   ADDIU SP, SP, -32
9D005CC8  AFBF001C   SW RA, 28(SP)
9D005CCC  AFB10018   SW S1, 24(SP)
9D005CD0  AFB00014   SW S0, 20(SP)
9D005CD4  00808021   ADDU S0, A0, ZERO
1359:                	FRESULT res;
1360:                	PF_BYTE c, *dir;
1361:                #if _USE_LFN
1362:                	PF_BYTE a, ord = 0xFF, sum = 0xFF;
1363:                #endif
1364:                
1365:                	res = FR_NO_FILE;
9D005CD8  24020004   ADDIU V0, ZERO, 4
1366:                	while (dj->sect) {
9D005CDC  0B40174C   J 0x9D005D30
9D005CE0  241100E5   ADDIU S1, ZERO, 229
9D005D30  8E050010   LW A1, 16(S0)
9D005D34  14A0FFEB   BNE A1, ZERO, 0x9D005CE4
9D005D38  00000000   NOP
1367:                		res = move_window(dj->fs, dj->sect);
9D005CE4  0F4012F8   JAL move_window
9D005CE8  8E040000   LW A0, 0(S0)
1368:                		if (res != FR_OK)
9D005CEC  54400017   BNEL V0, ZERO, 0x9D005D4C
9D005CF0  AE000010   SW ZERO, 16(S0)
1369:                			break;
1370:                		dir = dj->dir; /* Ptr to the directory entry of current index */
9D005CF4  8E040014   LW A0, 20(S0)
1371:                		c = dir[DIR_Name];
9D005CF8  90830000   LBU V1, 0(A0)
1372:                		if (c == 0) {
9D005CFC  50600011   BEQL V1, ZERO, 0x9D005D44
9D005D00  24020004   ADDIU V0, ZERO, 4
1373:                			res = FR_NO_FILE;
1374:                			break;
1375:                		} /* Reached to end of table */
1376:                #if _USE_LFN	/* LFN configuration */
1377:                		a = dir[DIR_Attr] & AM_MASK;
1378:                		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) { /* An entry without valid data */
1379:                			ord = 0xFF;
1380:                		} else {
1381:                			if (a == AM_LFN) { /* An LFN entry is found */
1382:                				if (c & LLE) { /* Is it start of LFN sequence? */
1383:                					sum = dir[LDIR_Chksum];
1384:                					c &= ~LLE; ord = c;
1385:                					dj->lfn_idx = dj->index;
1386:                				}
1387:                				/* Check LFN validity and capture it */
1388:                				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
1389:                			} else { /* An SFN entry is found */
1390:                				if (ord || sum != sum_sfn(dir)) /* Is there a valid LFN? */
1391:                				dj->lfn_idx = 0xFFFF; /* It has no LFN. */
1392:                				break;
1393:                			}
1394:                		}
1395:                #else		/* Non LFN configuration */
1396:                		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL)) /* Is it a valid entry? */
9D005D04  50710006   BEQL V1, S1, 0x9D005D20
9D005D08  02002021   ADDU A0, S0, ZERO
9D005D0C  9083000B   LBU V1, 11(A0)
9D005D10  30630008   ANDI V1, V1, 8
9D005D14  306300FF   ANDI V1, V1, 255
9D005D18  1060000C   BEQ V1, ZERO, 0x9D005D4C
9D005D1C  02002021   ADDU A0, S0, ZERO
1397:                			break;
1398:                #endif
1399:                		res = dir_next(dj, 0); /* Next entry */
9D005D20  0F401571   JAL dir_next
9D005D24  00002821   ADDU A1, ZERO, ZERO
1400:                		if (res != FR_OK)
9D005D28  54400008   BNEL V0, ZERO, 0x9D005D4C
9D005D2C  AE000010   SW ZERO, 16(S0)
1401:                			break;
1402:                	}
1403:                
1404:                	if (res != FR_OK)
9D005D3C  10400004   BEQ V0, ZERO, 0x9D005D50
9D005D40  8FBF001C   LW RA, 28(SP)
1405:                		dj->sect = 0;
9D005D44  0B401753   J 0x9D005D4C
9D005D48  AE000010   SW ZERO, 16(S0)
1406:                
1407:                	return res;
1408:                }
9D005D4C  8FBF001C   LW RA, 28(SP)
9D005D50  8FB10018   LW S1, 24(SP)
9D005D54  8FB00014   LW S0, 20(SP)
9D005D58  03E00008   JR RA
9D005D5C  27BD0020   ADDIU SP, SP, 32
1409:                #endif
1410:                
1411:                /*-----------------------------------------------------------------------*/
1412:                /* Register an object to the directory                                   */
1413:                /*-----------------------------------------------------------------------*/
1414:                #if !_FS_READONLY
1415:                static FRESULT dir_register( /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
1416:                DIR *dj /* Target directory with object name to be created */
1417:                ) {
9D005BF0  27BDFFE0   ADDIU SP, SP, -32
9D005BF4  AFBF001C   SW RA, 28(SP)
9D005BF8  AFB20018   SW S2, 24(SP)
9D005BFC  AFB10014   SW S1, 20(SP)
9D005C00  AFB00010   SW S0, 16(SP)
9D005C04  00808821   ADDU S1, A0, ZERO
1418:                	FRESULT res;
1419:                	PF_BYTE c, *dir;
1420:                #if _USE_LFN	/* LFN configuration */
1421:                	PF_WORD n, ne, is;
1422:                	PF_BYTE sn[12], *fn, sum;
1423:                	WCHAR *lfn;
1424:                
1425:                	fn = dj->fn; lfn = dj->lfn;
1426:                	mem_cpy(sn, fn, 12);
1427:                
1428:                	if (_FS_RPATH && (sn[NS] & NS_DOT)) /* Cannot create dot entry */
1429:                	return FR_INVALID_NAME;
1430:                
1431:                	if (sn[NS] & NS_LOSS) { /* When LFN is out of 8.3 format, generate a numbered name */
1432:                		fn[NS] = 0; dj->lfn = 0; /* Find only SFN */
1433:                		for (n = 1; n < 100; n++) {
1434:                			gen_numname(fn, sn, lfn, n); /* Generate a numbered name */
1435:                			res = dir_find(dj); /* Check if the name collides with existing SFN */
1436:                			if (res != FR_OK) break;
1437:                		}
1438:                		if (n == 100) return FR_DENIED; /* Abort if too many collisions */
1439:                		if (res != FR_NO_FILE) return res; /* Abort if the result is other than 'not collided' */
1440:                		fn[NS] = sn[NS]; dj->lfn = lfn;
1441:                	}
1442:                
1443:                	if (sn[NS] & NS_LFN) { /* When LFN is to be created, reserve an SFN + LFN entries. */
1444:                		for (ne = 0; lfn[ne]; ne++);
1445:                		ne = (ne + 25) / 13;
1446:                	} else { /* Otherwise reserve only an SFN entry. */
1447:                		ne = 1;
1448:                	}
1449:                
1450:                	/* Reserve contiguous entries */
1451:                	res = dir_sdi(dj, 0);
1452:                	if (res != FR_OK) return res;
1453:                	n = is = 0;
1454:                	do {
1455:                		res = move_window(dj->fs, dj->sect);
1456:                		if (res != FR_OK) break;
1457:                		c = *dj->dir; /* Check the entry status */
1458:                		if (c == DDE || c == 0) { /* Is it a blank entry? */
1459:                			if (n == 0) is = dj->index; /* First index of the contiguous entry */
1460:                			if (++n == ne) break; /* A contiguous entry that required count is found */
1461:                		} else {
1462:                			n = 0; /* Not a blank entry. Restart to search */
1463:                		}
1464:                		res = dir_next(dj, 1); /* Next entry with table stretch */
1465:                	}while (res == FR_OK);
1466:                
1467:                	if (res == FR_OK && ne > 1) { /* Initialize LFN entry if needed */
1468:                		res = dir_sdi(dj, is);
1469:                		if (res == FR_OK) {
1470:                			sum = sum_sfn(dj->fn); /* Sum of the SFN tied to the LFN */
1471:                			ne--;
1472:                			do { /* Store LFN entries in bottom first */
1473:                				res = move_window(dj->fs, dj->sect);
1474:                				if (res != FR_OK) break;
1475:                				fit_lfn(dj->lfn, dj->dir, (PF_BYTE)ne, sum);
1476:                				dj->fs->wflag = 1;
1477:                				res = dir_next(dj, 0); /* Next entry */
1478:                			}while (res == FR_OK && --ne);
1479:                		}
1480:                	}
1481:                
1482:                #else	/* Non LFN configuration */
1483:                	res = dir_sdi(dj, 0);
9D005C08  0F401439   JAL dir_sdi
9D005C0C  00002821   ADDU A1, ZERO, ZERO
1484:                	if (res == FR_OK) {
9D005C10  14400025   BNE V0, ZERO, 0x9D005CA8
9D005C14  00408021   ADDU S0, V0, ZERO
1485:                		do { /* Find a blank entry for the SFN */
1486:                			res = move_window(dj->fs, dj->sect);
9D005C1C  8E240000   LW A0, 0(S1)
9D005C20  0F4012F8   JAL move_window
9D005C24  8E250010   LW A1, 16(S1)
1487:                			if (res != FR_OK)
9D005C28  1440001F   BNE V0, ZERO, 0x9D005CA8
9D005C2C  00408021   ADDU S0, V0, ZERO
1488:                				break;
1489:                			c = *dj->dir;
9D005C30  8E220014   LW V0, 20(S1)
9D005C34  90420000   LBU V0, 0(V0)
1490:                			if (c == DDE || c == 0)
9D005C18  241200E5   ADDIU S2, ZERO, 229
9D005C38  50520017   BEQL V0, S2, 0x9D005C98
9D005C3C  8E240000   LW A0, 0(S1)
9D005C40  10400014   BEQ V0, ZERO, 0x9D005C94
9D005C44  02202021   ADDU A0, S1, ZERO
1491:                				break; /* Is it a blank entry? */
1492:                			res = dir_next(dj, 1); /* Next entry with table stretch */
9D005C48  0F401571   JAL dir_next
9D005C4C  24050001   ADDIU A1, ZERO, 1
1493:                		} while (res == FR_OK);
9D005C50  1040FFF2   BEQ V0, ZERO, 0x9D005C1C
9D005C54  00408021   ADDU S0, V0, ZERO
9D005C58  0B40172B   J 0x9D005CAC
9D005C5C  02001021   ADDU V0, S0, ZERO
1494:                	}
1495:                #endif
1496:                
1497:                	if (res == FR_OK) { /* Initialize the SFN entry */
1498:                		res = move_window(dj->fs, dj->sect);
9D005C94  8E240000   LW A0, 0(S1)
9D005C98  0F4012F8   JAL move_window
9D005C9C  8E250010   LW A1, 16(S1)
1499:                		if (res == FR_OK) {
9D005CA0  1040FFEF   BEQ V0, ZERO, 0x9D005C60
9D005CA4  00408021   ADDU S0, V0, ZERO
1500:                			dir = dj->dir;
9D005C60  8E240014   LW A0, 20(S1)
9D005C64  24830020   ADDIU V1, A0, 32
1501:                			mem_set(dir, 0, SZ_DIR); /* Clean the entry */
1502:                			mem_cpy(dir, dj->fn, 11); /* Put SFN */
9D005C78  8E250018   LW A1, 24(S1)
9D005C7C  0F401259   JAL mem_cpy
9D005C80  2406000B   ADDIU A2, ZERO, 11
1503:                #if _USE_LFN
1504:                			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT); /* Put NT flag */
1505:                #endif
1506:                			dj->fs->wflag = 1;
9D005C84  8E220000   LW V0, 0(S1)
9D005C88  24030001   ADDIU V1, ZERO, 1
9D005C8C  0B40172A   J 0x9D005CA8
9D005C90  A0430004   SB V1, 4(V0)
1507:                		}
1508:                	}
1509:                
1510:                	return res;
1511:                }
9D005CA8  02001021   ADDU V0, S0, ZERO
9D005CAC  8FBF001C   LW RA, 28(SP)
9D005CB0  8FB20018   LW S2, 24(SP)
9D005CB4  8FB10014   LW S1, 20(SP)
9D005CB8  8FB00010   LW S0, 16(SP)
9D005CBC  03E00008   JR RA
9D005CC0  27BD0020   ADDIU SP, SP, 32
1512:                #endif /* !_FS_READONLY */
1513:                
1514:                /*-----------------------------------------------------------------------*/
1515:                /* Remove an object from the directory                                   */
1516:                /*-----------------------------------------------------------------------*/
1517:                #if !_FS_READONLY && !_FS_MINIMIZE
1518:                static FRESULT dir_remove( /* FR_OK: Successful, FR_DISK_ERR: A disk error */
1519:                DIR *dj /* Directory object pointing the entry to be removed */
1520:                ) {
9D005228  27BDFFE8   ADDIU SP, SP, -24
9D00522C  AFBF0014   SW RA, 20(SP)
9D005230  AFB00010   SW S0, 16(SP)
9D005234  00808021   ADDU S0, A0, ZERO
1521:                	FRESULT res;
1522:                #if _USE_LFN	/* LFN configuration */
1523:                	PF_WORD i;
1524:                
1525:                	i = dj->index; /* SFN index */
1526:                	res = dir_sdi(dj, (PF_WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx)); /* Goto the SFN or top of the LFN entries */
1527:                	if (res == FR_OK) {
1528:                		do {
1529:                			res = move_window(dj->fs, dj->sect);
1530:                			if (res != FR_OK) break;
1531:                			*dj->dir = DDE; /* Mark the entry "deleted" */
1532:                			dj->fs->wflag = 1;
1533:                			if (dj->index >= i) break; /* When reached SFN, all entries of the object has been deleted. */
1534:                			res = dir_next(dj, 0); /* Next entry */
1535:                		}while (res == FR_OK);
1536:                		if (res == FR_NO_FILE) res = FR_INT_ERR;
1537:                	}
1538:                
1539:                #else			/* Non LFN configuration */
1540:                	res = dir_sdi(dj, dj->index);
9D005238  0F401439   JAL dir_sdi
9D00523C  94850006   LHU A1, 6(A0)
1541:                	if (res == FR_OK) {
9D005240  1440000C   BNE V0, ZERO, 0x9D005274
9D005244  8FBF0014   LW RA, 20(SP)
1542:                		res = move_window(dj->fs, dj->sect);
9D005248  8E040000   LW A0, 0(S0)
9D00524C  0F4012F8   JAL move_window
9D005250  8E050010   LW A1, 16(S0)
1543:                		if (res == FR_OK) {
9D005254  14400006   BNE V0, ZERO, 0x9D005270
9D005258  2404FFE5   ADDIU A0, ZERO, -27
1544:                			*dj->dir = DDE; /* Mark the entry "deleted" */
9D00525C  8E030014   LW V1, 20(S0)
9D005260  A0640000   SB A0, 0(V1)
1545:                			dj->fs->wflag = 1;
9D005264  8E030000   LW V1, 0(S0)
9D005268  24040001   ADDIU A0, ZERO, 1
9D00526C  A0640004   SB A0, 4(V1)
1546:                		}
1547:                	}
1548:                #endif
1549:                
1550:                	return res;
1551:                }
9D005270  8FBF0014   LW RA, 20(SP)
9D005274  8FB00010   LW S0, 16(SP)
9D005278  03E00008   JR RA
9D00527C  27BD0018   ADDIU SP, SP, 24
1552:                #endif /* !_FS_READONLY */
1553:                
1554:                /*-----------------------------------------------------------------------*/
1555:                /* Pick a segment and create the object name in directory form           */
1556:                /*-----------------------------------------------------------------------*/
1557:                
1558:                static FRESULT create_name(DIR *dj, /* Pointer to the directory object */
1559:                const TCHAR **path /* Pointer to pointer to the segment in the path string */
1560:                ) {
1561:                #ifdef _EXCVT
1562:                	static const PF_BYTE excvt[] = _EXCVT; /* Upper conversion table for extended chars */
1563:                #endif
1564:                
1565:                #if _USE_LFN	/* LFN configuration */
1566:                	PF_BYTE b, cf;
1567:                	WCHAR w, *lfn;
1568:                	UINT i, ni, si, di;
1569:                	const TCHAR *p;
1570:                
1571:                	/* Create LFN in Unicode */
1572:                	for (p = *path; *p == '/' || *p == '\\'; p++); /* Strip duplicated separator */
1573:                	lfn = dj->lfn;
1574:                	si = di = 0;
1575:                	for (;;) {
1576:                		w = p[si++]; /* Get a character */
1577:                		if (w < ' ' || w == '/' || w == '\\') break; /* Break on end of segment */
1578:                		if (di >= _MAX_LFN) /* Reject too long name */
1579:                		return FR_INVALID_NAME;
1580:                #if !_LFN_UNICODE
1581:                		w &= 0xFF;
1582:                		if (IsDBCS1(w)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1583:                			b = (PF_BYTE)p[si++]; /* Get 2nd byte */
1584:                			if (!IsDBCS2(b))
1585:                			return FR_INVALID_NAME; /* Reject invalid sequence */
1586:                			w = (w << 8) + b; /* Create a DBC */
1587:                		}
1588:                		w = ff_convert(w, 1); /* Convert ANSI/OEM to Unicode */
1589:                		if (!w) return FR_INVALID_NAME; /* Reject invalid code */
1590:                #endif
1591:                		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
1592:                		return FR_INVALID_NAME;
1593:                		lfn[di++] = w; /* Store the Unicode char */
1594:                	}
1595:                	*path = &p[si]; /* Return pointer to the next segment */
1596:                	cf = (w < ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
1597:                #if _FS_RPATH
1598:                	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
1599:                			(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
1600:                		lfn[di] = 0;
1601:                		for (i = 0; i < 11; i++)
1602:                		dj->fn[i] = (i < di) ? '.' : ' ';
1603:                		dj->fn[i] = cf | NS_DOT; /* This is a dot entry */
1604:                		return FR_OK;
1605:                	}
1606:                #endif
1607:                	while (di) { /* Strip trailing spaces and dots */
1608:                		w = lfn[di-1];
1609:                		if (w != ' ' && w != '.') break;
1610:                		di--;
1611:                	}
1612:                	if (!di) return FR_INVALID_NAME; /* Reject nul string */
1613:                
1614:                	lfn[di] = 0; /* LFN is created */
1615:                
1616:                	/* Create SFN in directory form */
1617:                	mem_set(dj->fn, ' ', 11);
1618:                	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++); /* Strip leading spaces and dots */
1619:                	if (si) cf |= NS_LOSS | NS_LFN;
1620:                	while (di && lfn[di - 1] != '.') di--; /* Find extension (di<=si: no extension) */
1621:                
1622:                	b = i = 0; ni = 8;
1623:                	for (;;) {
1624:                		w = lfn[si++]; /* Get an LFN char */
1625:                		if (!w) break; /* Break on end of the LFN */
1626:                		if (w == ' ' || (w == '.' && si != di)) { /* Remove spaces and dots */
1627:                			cf |= NS_LOSS | NS_LFN; continue;
1628:                		}
1629:                
1630:                		if (i >= ni || si == di) { /* Extension or end of SFN */
1631:                			if (ni == 11) { /* Long extension */
1632:                				cf |= NS_LOSS | NS_LFN; break;
1633:                			}
1634:                			if (si != di) cf |= NS_LOSS | NS_LFN; /* Out of 8.3 format */
1635:                			if (si > di) break; /* No extension */
1636:                			si = di; i = 8; ni = 11; /* Enter extension section */
1637:                			b <<= 2; continue;
1638:                		}
1639:                
1640:                		if (w >= 0x80) { /* Non ASCII char */
1641:                #ifdef _EXCVT
1642:                			w = ff_convert(w, 0); /* Unicode -> OEM code */
1643:                			if (w) w = excvt[w - 0x80]; /* Convert extended char to upper (SBCS) */
1644:                #else
1645:                			w = ff_convert(ff_wtoupper(w), 0); /* Upper converted Unicode -> OEM code */
1646:                #endif
1647:                			cf |= NS_LFN; /* Force create LFN entry */
1648:                		}
1649:                
1650:                		if (_DF1S && w >= 0x100) { /* Double byte char (always false on SBCS cfg) */
1651:                			if (i >= ni - 1) {
1652:                				cf |= NS_LOSS | NS_LFN; i = ni; continue;
1653:                			}
1654:                			dj->fn[i++] = (PF_BYTE)(w >> 8);
1655:                		} else { /* Single byte char */
1656:                			if (!w || chk_chr("+,;=[]", w)) { /* Replace illegal chars for SFN */
1657:                				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
1658:                			} else {
1659:                				if (IsUpper(w)) { /* ASCII large capital */
1660:                					b |= 2;
1661:                				} else {
1662:                					if (IsLower(w)) { /* ASCII small capital */
1663:                						b |= 1; w -= 0x20;
1664:                					}
1665:                				}
1666:                			}
1667:                		}
1668:                		dj->fn[i++] = (PF_BYTE)w;
1669:                	}
1670:                
1671:                	if (dj->fn[0] == DDE) dj->fn[0] = NDDE; /* If the first char collides with deleted mark, replace it with 0x05 */
1672:                
1673:                	if (ni == 8) b <<= 2;
1674:                	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) /* Create LFN entry when there are composite capitals */
1675:                	cf |= NS_LFN;
1676:                	if (!(cf & NS_LFN)) { /* When LFN is in 8.3 format without extended char, NT flags are created */
1677:                		if ((b & 0x03) == 0x01) cf |= NS_EXT; /* NT flag (Extension has only small capital) */
1678:                		if ((b & 0x0C) == 0x04) cf |= NS_BODY; /* NT flag (Filename has only small capital) */
1679:                	}
1680:                
1681:                	dj->fn[NS] = cf; /* SFN is created */
1682:                
1683:                	return FR_OK;
1684:                
1685:                #else	/* Non-LFN configuration */
1686:                	PF_BYTE b, c, d, *sfn;
1687:                	UINT ni, si, i;
1688:                	const char *p;
1689:                
1690:                	/* Create file name in directory form */
1691:                	for (p = *path; *p == '/' || *p == '\\'; p++)
9D005824  2413005C   ADDIU S3, ZERO, 92
9D005828  3C149D02   LUI S4, -25342
9D00584C  82020000   LB V0, 0(S0)
9D005850  5052FFFE   BEQL V0, S2, follow_path::create_name
9D005854  26100001   ADDIU S0, S0, 1
9D005858  5053FFFC   BEQL V0, S3, follow_path::create_name
9D00585C  26100001   ADDIU S0, S0, 1
1692:                		; /* Strip duplicated separator */
1693:                	sfn = dj->fn;
9D005860  8E270018   LW A3, 24(S1)
9D005864  24E4000B   ADDIU A0, A3, 11
1694:                	mem_set(sfn, ' ', 11);
1695:                	si = i = b = 0;
1696:                	ni = 8;
1697:                #if _FS_RPATH
1698:                	if (p[si] == '.') { /* Is this a dot entry? */
9D00587C  82030000   LB V1, 0(S0)
9D005880  2402002E   ADDIU V0, ZERO, 46
9D005884  10620008   BEQ V1, V0, follow_path::create_name
9D005888  00004021   ADDU T0, ZERO, ZERO
9D00588C  00002821   ADDU A1, ZERO, ZERO
9D005890  240B0008   ADDIU T3, ZERO, 8
9D005894  00004821   ADDU T1, ZERO, ZERO
1699:                		for (;;) {
1700:                			c = (PF_BYTE)p[si++];
9D0058B0  92020001   LBU V0, 1(S0)
9D0058C8  92020002   LBU V0, 2(S0)
1701:                			if (c != '.' || si >= 3) break;
9D0058B4  2403002E   ADDIU V1, ZERO, 46
9D0058B8  54430007   BNEL V0, V1, 0x9D0058D8
9D0058BC  24030002   ADDIU V1, ZERO, 2
9D0058CC  504300BF   BEQL V0, V1, 0x9D005BCC
9D0058D0  24020006   ADDIU V0, ZERO, 6
9D0058D4  24030003   ADDIU V1, ZERO, 3
1702:                			sfn[i++] = c;
9D0058A8  2402002E   ADDIU V0, ZERO, 46
9D0058AC  A0E20000   SB V0, 0(A3)
9D0058C0  2402002E   ADDIU V0, ZERO, 46
9D0058C4  A0E20001   SB V0, 1(A3)
1703:                		}
1704:                		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
9D0058D8  5052008E   BEQL V0, S2, 0x9D005B14
9D0058DC  02038021   ADDU S0, S0, V1
9D0058E0  5053008C   BEQL V0, S3, 0x9D005B14
9D0058E4  02038021   ADDU S0, S0, V1
9D0058E8  2C420021   SLTIU V0, V0, 33
9D0058EC  504000B7   BEQL V0, ZERO, 0x9D005BCC
9D0058F0  24020006   ADDIU V0, ZERO, 6
1705:                		*path = &p[si]; /* Return pointer to the next segment */
9D0058F4  0B4016C7   J 0x9D005B1C
9D0058F8  02038021   ADDU S0, S0, V1
1706:                		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
9D0058FC  0B4016DF   J follow_path::dir_find
9D005900  A0E2000B   SB V0, 11(A3)
9D005B14  0B40163F   J 0x9D0058FC
9D005B18  24020020   ADDIU V0, ZERO, 32
9D005B1C  0B40163F   J 0x9D0058FC
9D005B20  24020024   ADDIU V0, ZERO, 36
1707:                		return FR_OK;
1708:                	}
1709:                #endif
1710:                	for (;;) {
1711:                		c = (PF_BYTE) p[si++];
9D005904  24A50001   ADDIU A1, A1, 1
9D005908  02051021   ADDU V0, S0, A1
9D00590C  8042FFFF   LB V0, -1(V0)
9D005910  304400FF   ANDI A0, V0, 255
1712:                		if (c <= ' ' || c == '/' || c == '\\')
9D005914  2C830021   SLTIU V1, A0, 33
9D005918  54600093   BNEL V1, ZERO, follow_path::create_name
9D00591C  02058021   ADDU S0, S0, A1
9D005920  5092008E   BEQL A0, S2, follow_path::create_name
9D005924  02058021   ADDU S0, S0, A1
9D005928  5093008C   BEQL A0, S3, follow_path::create_name
9D00592C  02058021   ADDU S0, S0, A1
1713:                			break; /* Break on end of segment */
1714:                		if (c == '.' || i >= ni) {
9D005898  240A002E   ADDIU T2, ZERO, 46
9D005930  108A007C   BEQ A0, T2, follow_path::create_name
9D005934  010B182B   SLTU V1, T0, T3
9D005938  506000A4   BEQL V1, ZERO, 0x9D005BCC
9D00593C  24020006   ADDIU V0, ZERO, 6
9D005940  0B401656   J follow_path::create_name
9D005944  00000000   NOP
1715:                			if (ni != 8 || c != '.')
9D00589C  240D0008   ADDIU T5, ZERO, 8
9D005B24  516DFF88   BEQL T3, T5, 0x9D005948
9D005B28  00094880   SLL T1, T1, 2
9D005B2C  0B4016F3   J 0x9D005BCC
9D005B30  24020006   ADDIU V0, ZERO, 6
1716:                				return FR_INVALID_NAME;
1717:                			i = 8;
9D00594C  01A04021   ADDU T0, T5, ZERO
1718:                			ni = 11;
9D005950  0B401641   J follow_path::create_name
9D005954  240B000B   ADDIU T3, ZERO, 11
1719:                			b <<= 2;
9D005948  312900FF   ANDI T1, T1, 255
1720:                			continue;
1721:                		}
1722:                		if (c >= 0x80) { /* Extended char? */
9D005958  04410076   BGEZ V0, chk_chr
9D00595C  00000000   NOP
1723:                			b |= 3; /* Eliminate NT flag */
9D005960  35290003   ORI T1, T1, 3
1724:                #ifdef _EXCVT
1725:                			c = excvt[c-0x80]; /* Upper conversion (SBCS) */
9D00582C  3C159D02   LUI S5, -25342
9D005830  0B401613   J follow_path::create_name
9D005834  26B5E148   ADDIU S5, S5, -7864
9D005964  02A42021   ADDU A0, S5, A0
9D005968  0B4016CD   J chk_chr
9D00596C  9084FF80   LBU A0, -128(A0)
1726:                #else
1727:                #if !_DF1S	/* ASCII only cfg */
1728:                			return FR_INVALID_NAME;
1729:                #endif
1730:                #endif
1731:                		}
1732:                		if (IsDBCS1(c)) { /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1733:                			d = (PF_BYTE) p[si++]; /* Get 2nd byte */
1734:                			if (!IsDBCS2(d) || i >= ni - 1) /* Reject invalid DBC */
1735:                				return FR_INVALID_NAME;
1736:                			sfn[i++] = c;
1737:                			sfn[i++] = d;
1738:                		} else { /* Single byte code */
1739:                			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) /* Reject illegal chrs for SFN */
1740:                				return FR_INVALID_NAME;
1741:                			if (IsUpper(c)) { /* ASCII large capital? */
9D005B44  304200FF   ANDI V0, V0, 255
9D005B48  2C42001A   SLTIU V0, V0, 26
9D005B4C  5440FF96   BNEL V0, ZERO, 0x9D0059A8
9D005B50  35290002   ORI T1, T1, 2
1742:                				b |= 2;
1743:                			} else {
1744:                				if (IsLower(c)) { /* ASCII small capital? */
9D00598C  304200FF   ANDI V0, V0, 255
9D005990  2C42001A   SLTIU V0, V0, 26
9D005994  10400005   BEQ V0, ZERO, 0x9D0059AC
9D005998  00E81021   ADDU V0, A3, T0
9D005B54  0B401663   J follow_path::create_name
9D005B58  2482FF9F   ADDIU V0, A0, -97
1745:                					b |= 1;
9D00599C  35290001   ORI T1, T1, 1
1746:                					c -= 0x20;
9D0059A0  2484FFE0   ADDIU A0, A0, -32
9D0059A4  308400FF   ANDI A0, A0, 255
1747:                				}
1748:                			}
1749:                			sfn[i++] = c;
9D0059A8  00E81021   ADDU V0, A3, T0
9D0059AC  A0440000   SB A0, 0(V0)
9D0059B0  0B401641   J follow_path::create_name
9D0059B4  25080001   ADDIU T0, T0, 1
1750:                		}
1751:                	}
1752:                	*path = &p[si]; /* Return pointer to the next segment */
9D005B5C  01201821   ADDU V1, T1, ZERO
9D005B68  01201821   ADDU V1, T1, ZERO
1753:                	c = (c <= ' ') ? NS_LAST : 0; /* Set last segment flag if end of path */
9D005B60  0B40166E   J follow_path::create_name
9D005B64  00001021   ADDU V0, ZERO, ZERO
9D005B6C  0B40166E   J follow_path::create_name
9D005B70  24020004   ADDIU V0, ZERO, 4
1754:                
1755:                	if (!i)
9D0059B8  51000084   BEQL T0, ZERO, 0x9D005BCC
9D0059BC  24020006   ADDIU V0, ZERO, 6
1756:                		return FR_INVALID_NAME; /* Reject nul string */
1757:                	if (sfn[0] == DDE)
9D0059C0  90E50000   LBU A1, 0(A3)
9D0059C4  240400E5   ADDIU A0, ZERO, 229
9D0059C8  14A40004   BNE A1, A0, 0x9D0059DC
9D0059CC  24040008   ADDIU A0, ZERO, 8
1758:                		sfn[0] = NDDE; /* When first char collides with DDE, replace it with 0x05 */
9D0059D0  24040005   ADDIU A0, ZERO, 5
9D0059D4  A0E40000   SB A0, 0(A3)
1759:                
1760:                	if (ni == 8)
9D0059D8  24040008   ADDIU A0, ZERO, 8
9D0059DC  15640004   BNE T3, A0, 0x9D0059F0
9D0059E0  31240003   ANDI A0, T1, 3
1761:                		b <<= 2;
9D0059E4  00031880   SLL V1, V1, 2
9D0059E8  306900FF   ANDI T1, V1, 255
1762:                	if ((b & 0x03) == 0x01)
9D0059EC  31240003   ANDI A0, T1, 3
1763:                		c |= NS_EXT; /* NT flag (Name extension has only small capital) */
9D0059F0  34430010   ORI V1, V0, 16
9D0059F4  38840001   XORI A0, A0, 1
9D0059F8  0064100A   MOVZ V0, V1, A0
1764:                	if ((b & 0x0C) == 0x04)
9D0059FC  3124000C   ANDI A0, T1, 12
1765:                		c |= NS_BODY; /* NT flag (Name body has only small capital) */
9D005A00  34430008   ORI V1, V0, 8
9D005A04  38840004   XORI A0, A0, 4
9D005A08  0064100A   MOVZ V0, V1, A0
1766:                
1767:                	sfn[NS] = c; /* Store NT flag, File name is created */
9D005A0C  0B4016DF   J follow_path::dir_find
9D005A10  A0E2000B   SB V0, 11(A3)
1768:                
1769:                	return FR_OK;
1770:                #endif
1771:                }
1772:                
1773:                /*-----------------------------------------------------------------------*/
1774:                /* Get file information from directory entry                             */
1775:                /*-----------------------------------------------------------------------*/
1776:                #if _FS_MINIMIZE <= 1
1777:                static
1778:                void get_fileinfo( /* No return code */
1779:                DIR *dj, /* Pointer to the directory object */
1780:                FILINFO *fno /* Pointer to the file information to be filled */
1781:                ) {
1782:                	UINT i;
1783:                	PF_BYTE nt, *dir;
1784:                	TCHAR *p, c;
1785:                
1786:                	p = fno->fname;
1787:                	if (dj->sect) {
9D004ABC  8C820010   LW V0, 16(A0)
9D004AC0  1040003B   BEQ V0, ZERO, 0x9D004BB0
9D004AC4  24A30009   ADDIU V1, A1, 9
1788:                		dir = dj->dir;
9D004AC8  8C860014   LW A2, 20(A0)
1789:                		nt = dir[DIR_NTres]; /* NT flag */
1790:                		for (i = 0; i < 8; i++) { /* Copy name body */
9D004AE4  24080008   ADDIU T0, ZERO, 8
9D004B0C  24840001   ADDIU A0, A0, 1
9D004B10  1488FFF7   BNE A0, T0, 0x9D004AF0
9D004B14  A062FFFF   SB V0, -1(V1)
1791:                			c = dir[i];
9D004ACC  80C20000   LB V0, 0(A2)
9D004AF4  80420000   LB V0, 0(V0)
1792:                			if (c == ' ')
9D004AD0  24040020   ADDIU A0, ZERO, 32
9D004AD4  10440010   BEQ V0, A0, 0x9D004B18
9D004AD8  00002021   ADDU A0, ZERO, ZERO
9D004AE8  0B4012C0   J 0x9D004B00
9D004AEC  240B0020   ADDIU T3, ZERO, 32
9D004AF0  00C41021   ADDU V0, A2, A0
9D004AF8  504B0008   BEQL V0, T3, 0x9D004B1C
9D004AFC  90C40008   LBU A0, 8(A2)
1793:                				break;
1794:                			if (c == NDDE)
9D004ADC  240A0005   ADDIU T2, ZERO, 5
1795:                				c = (TCHAR) DDE;
9D004AE0  2409FFE5   ADDIU T1, ZERO, -27
9D004B00  004A3826   XOR A3, V0, T2
9D004B04  0127100A   MOVZ V0, T1, A3
9D004B44  0B4012D5   J 0x9D004B54
9D004B48  00E01821   ADDU V1, A3, ZERO
1796:                			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c))
1797:                				c += 0x20;
1798:                #if _LFN_UNICODE
1799:                			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
1800:                			c = (c << 8) | dir[++i];
1801:                			c = ff_convert(c, 1);
1802:                			if (!c) c = '?';
1803:                #endif
1804:                			*p++ = c;
9D004B08  24630001   ADDIU V1, V1, 1
1805:                		}
1806:                		if (dir[8] != ' ') { /* Copy name extension */
9D004B18  90C40008   LBU A0, 8(A2)
9D004B1C  24020020   ADDIU V0, ZERO, 32
9D004B20  1082000C   BEQ A0, V0, 0x9D004B54
9D004B24  2402002E   ADDIU V0, ZERO, 46
1807:                			*p++ = '.';
9D004B28  A0620000   SB V0, 0(V1)
9D004B3C  0B4012D5   J 0x9D004B54
9D004B40  24630001   ADDIU V1, V1, 1
1808:                			for (i = 8; i < 11; i++) {
1809:                				c = dir[i];
9D004B2C  80C20008   LB V0, 8(A2)
9D004BB8  80C20009   LB V0, 9(A2)
9D004BCC  80C2000A   LB V0, 10(A2)
1810:                				if (c == ' ')
9D004B30  24040020   ADDIU A0, ZERO, 32
9D004B34  54440020   BNEL V0, A0, 0x9D004BB8
9D004B38  A0620001   SB V0, 1(V1)
9D004BBC  24040020   ADDIU A0, ZERO, 32
9D004BC0  1044FFE0   BEQ V0, A0, 0x9D004B44
9D004BC4  24670002   ADDIU A3, V1, 2
9D004BD0  1444FFDE   BNE V0, A0, 0x9D004B4C
9D004BD4  24670003   ADDIU A3, V1, 3
9D004BD8  0B4012D5   J 0x9D004B54
9D004BDC  00E01821   ADDU V1, A3, ZERO
1811:                					break;
1812:                				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c))
1813:                					c += 0x20;
1814:                #if _LFN_UNICODE
1815:                				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
1816:                				c = (c << 8) | dir[++i];
1817:                				c = ff_convert(c, 1);
1818:                				if (!c) c = '?';
1819:                #endif
1820:                				*p++ = c;
9D004B4C  A0620003   SB V0, 3(V1)
9D004B50  24630004   ADDIU V1, V1, 4
9D004BC8  A0620002   SB V0, 2(V1)
1821:                			}
1822:                		}
1823:                		fno->fattrib = dir[DIR_Attr]; /* Attribute */
9D004B54  90C2000B   LBU V0, 11(A2)
9D004B58  A0A20008   SB V0, 8(A1)
1824:                		fno->fsize = LD_DWORD(dir+DIR_FileSize); /* Size */
9D004B5C  90C4001F   LBU A0, 31(A2)
9D004B60  00042600   SLL A0, A0, 24
9D004B64  90C2001E   LBU V0, 30(A2)
9D004B68  00021400   SLL V0, V0, 16
9D004B6C  00821025   OR V0, A0, V0
9D004B70  90C4001C   LBU A0, 28(A2)
9D004B74  00441025   OR V0, V0, A0
9D004B78  90C4001D   LBU A0, 29(A2)
9D004B7C  00042200   SLL A0, A0, 8
9D004B80  00441025   OR V0, V0, A0
9D004B84  ACA20000   SW V0, 0(A1)
1825:                		fno->fdate = LD_WORD(dir+DIR_WrtDate); /* Date */
9D004B88  90C20019   LBU V0, 25(A2)
9D004B8C  00021200   SLL V0, V0, 8
9D004B90  90C40018   LBU A0, 24(A2)
9D004B94  00441025   OR V0, V0, A0
9D004B98  A4A20004   SH V0, 4(A1)
1826:                		fno->ftime = LD_WORD(dir+DIR_WrtTime); /* Time */
9D004B9C  90C20017   LBU V0, 23(A2)
9D004BA0  00021200   SLL V0, V0, 8
9D004BA4  90C40016   LBU A0, 22(A2)
9D004BA8  00441025   OR V0, V0, A0
9D004BAC  A4A20006   SH V0, 6(A1)
1827:                	}
1828:                	*p = 0; /* Terminate SFN str by a \0 */
9D004BB0  03E00008   JR RA
9D004BB4  A0600000   SB ZERO, 0(V1)
9D004BB8  80C20009   LB V0, 9(A2)
9D004BBC  24040020   ADDIU A0, ZERO, 32
9D004BC0  1044FFE0   BEQ V0, A0, 0x9D004B44
9D004BC4  24670002   ADDIU A3, V1, 2
9D004BC8  A0620002   SB V0, 2(V1)
9D004BCC  80C2000A   LB V0, 10(A2)
9D004BD0  1444FFDE   BNE V0, A0, 0x9D004B4C
9D004BD4  24670003   ADDIU A3, V1, 3
9D004BD8  0B4012D5   J 0x9D004B54
9D004BDC  00E01821   ADDU V1, A3, ZERO
1829:                
1830:                #if _USE_LFN
1831:                	if (fno->lfname && fno->lfsize) {
1832:                		TCHAR *tp = fno->lfname;
1833:                		WCHAR w, *lfn;
1834:                
1835:                		i = 0;
1836:                		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
1837:                			lfn = dj->lfn;
1838:                			while ((w = *lfn++) != 0) { /* Get an LFN char */
1839:                #if !_LFN_UNICODE
1840:                				w = ff_convert(w, 0); /* Unicode -> OEM conversion */
1841:                				if (!w) {i = 0; break;} /* Could not convert, no LFN */
1842:                				if (_DF1S && w >= 0x100) /* Put 1st byte if it is a DBC (always false on SBCS cfg) */
1843:                				tp[i++] = (TCHAR)(w >> 8);
1844:                #endif
1845:                				if (i >= fno->lfsize - 1) {i = 0; break;} /* Buffer overflow, no LFN */
1846:                				tp[i++] = (TCHAR)w;
1847:                			}
1848:                		}
1849:                		tp[i] = 0; /* Terminate the LFN str by a \0 */
1850:                	}
1851:                #endif
1852:                }
1853:                #endif /* _FS_MINIMIZE <= 1 */
1854:                
1855:                /*-----------------------------------------------------------------------*/
1856:                /* Follow a file path                                                    */
1857:                /*-----------------------------------------------------------------------*/
1858:                
1859:                static FRESULT follow_path( /* FR_OK(0): successful, !=0: error code */
1860:                DIR *dj, /* Directory object to return last directory and found object */
1861:                const TCHAR *path /* Full-path string to find a file or directory */
1862:                ) {
9D0057C0  27BDFFD0   ADDIU SP, SP, -48
9D0057C4  AFBF002C   SW RA, 44(SP)
9D0057C8  AFB50028   SW S5, 40(SP)
9D0057CC  AFB40024   SW S4, 36(SP)
9D0057D0  AFB30020   SW S3, 32(SP)
9D0057D4  AFB2001C   SW S2, 28(SP)
9D0057D8  AFB10018   SW S1, 24(SP)
9D0057DC  AFB00014   SW S0, 20(SP)
9D0057E0  00808821   ADDU S1, A0, ZERO
1863:                	FRESULT res;
1864:                	PF_BYTE *dir, ns;
1865:                
1866:                #if _FS_RPATH
1867:                	if (*path == '/' || *path == '\\') { /* There is a heading separator */
9D0057E4  80A20000   LB V0, 0(A1)
9D0057E8  2403002F   ADDIU V1, ZERO, 47
9D0057EC  10430004   BEQ V0, V1, 0x9D005800
9D0057F0  00A08021   ADDU S0, A1, ZERO
9D0057F4  2403005C   ADDIU V1, ZERO, 92
9D0057F8  54430004   BNEL V0, V1, 0x9D00580C
9D0057FC  8C820000   LW V0, 0(A0)
1868:                		path++; dj->sclust = 0; /* Strip it and start from the root dir */
9D005800  26100001   ADDIU S0, S0, 1
9D005804  0B401605   J 0x9D005814
9D005808  AE200008   SW ZERO, 8(S1)
1869:                	} else { /* No heading separator */
1870:                		dj->sclust = dj->fs->cdir; /* Start from the current dir */
9D00580C  8C420018   LW V0, 24(V0)
9D005810  AC820008   SW V0, 8(A0)
1871:                	}
1872:                #else
1873:                	if (*path == '/' || *path == '\\') /* Strip heading separator if exist */
1874:                		path++;
1875:                	dj->sclust = 0; /* Start from the root dir */
1876:                #endif
1877:                
1878:                	if ((UINT) *path < ' ') { /* Nul path means the start directory itself */
9D005814  92020000   LBU V0, 0(S0)
9D005818  2C420020   SLTIU V0, V0, 32
9D00581C  14400006   BNE V0, ZERO, 0x9D005838
9D005820  2412002F   ADDIU S2, ZERO, 47
1879:                		res = dir_sdi(dj, 0);
9D005838  02202021   ADDU A0, S1, ZERO
9D00583C  0F401439   JAL dir_sdi
9D005840  00002821   ADDU A1, ZERO, ZERO
9D005844  0B4016F3   J 0x9D005BCC
9D005848  AE200014   SW ZERO, 20(S1)
1880:                		dj->dir = 0;
1881:                
1882:                	} else { /* Follow path */
1883:                		for (;;) {
1884:                			res = create_name(dj, &path); /* Get a segment */
1885:                			if (res != FR_OK)
1886:                				break;
1887:                			res = dir_find(dj); /* Find it */
9D005AC4  24030004   ADDIU V1, ZERO, 4
9D005AC8  24020005   ADDIU V0, ZERO, 5
9D005ACC  0B4016F3   J 0x9D005BCC
9D005AD0  0064100B   MOVN V0, V1, A0
1888:                			ns = *(dj->fn + NS);
9D005A8C  0B4016EC   J 0x9D005BB0
9D005A90  8E230018   LW V1, 24(S1)
9D005B90  0B4016EC   J 0x9D005BB0
9D005B94  8E230018   LW V1, 24(S1)
9D005BC4  0B4016A5   J 0x9D005A94
9D005BC8  9043000B   LBU V1, 11(V0)
1889:                			if (res != FR_OK) { /* Failed to find the object */
1890:                				if (res != FR_NO_FILE)
9D005BB0  24040004   ADDIU A0, ZERO, 4
9D005BB4  1044FFB7   BEQ V0, A0, 0x9D005A94
9D005BB8  9063000B   LBU V1, 11(V1)
9D005BBC  0B4016F4   J 0x9D005BD0
9D005BC0  8FBF002C   LW RA, 44(SP)
1891:                					break; /* Abort if any hard error occured */
1892:                				/* Object not found */
1893:                				if (_FS_RPATH && (ns & NS_DOT)) { /* If dot entry is not exit */
9D005A94  30620020   ANDI V0, V1, 32
9D005A98  304200FF   ANDI V0, V0, 255
9D005A9C  50400008   BEQL V0, ZERO, 0x9D005AC0
9D005AA0  30630004   ANDI V1, V1, 4
1894:                					dj->sclust = 0;
9D005AA4  AE200008   SW ZERO, 8(S1)
1895:                					dj->dir = 0; /* It is the root dir */
1896:                					res = FR_OK;
9D005AB8  0B4016F3   J 0x9D005BCC
9D005ABC  00001021   ADDU V0, ZERO, ZERO
1897:                					if (!(ns & NS_LAST))
9D005AA8  30620004   ANDI V0, V1, 4
9D005AAC  304200FF   ANDI V0, V0, 255
9D005AB0  1040FF66   BEQ V0, ZERO, follow_path::create_name
9D005AB4  AE200014   SW ZERO, 20(S1)
1898:                						continue;
1899:                				} else { /* Could not find the object */
1900:                					if (!(ns & NS_LAST))
9D005AC0  306400FF   ANDI A0, V1, 255
1901:                						res = FR_NO_PATH;
9D005984  0B4016F3   J 0x9D005BCC
9D005988  24020006   ADDIU V0, ZERO, 6
9D005B74  0B4016F3   J 0x9D005BCC
9D005B78  24020006   ADDIU V0, ZERO, 6
1902:                				}
1903:                				break;
1904:                			}
1905:                			if (ns & NS_LAST)
9D005B98  30630004   ANDI V1, V1, 4
9D005B9C  306300FF   ANDI V1, V1, 255
9D005BA0  5060FFCC   BEQL V1, ZERO, 0x9D005AD4
9D005BA4  9102000B   LBU V0, 11(T0)
9D005BA8  0B4016F4   J 0x9D005BD0
9D005BAC  8FBF002C   LW RA, 44(SP)
1906:                				break; /* Last segment match. Function completed. */
1907:                			dir = dj->dir; /* There is next segment. Follow the sub directory */
1908:                			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
9D005AD4  30420010   ANDI V0, V0, 16
9D005AD8  304200FF   ANDI V0, V0, 255
9D005ADC  1040003B   BEQ V0, ZERO, 0x9D005BCC
9D005AE0  24020005   ADDIU V0, ZERO, 5
1909:                				res = FR_NO_PATH;
1910:                				break;
1911:                			}
1912:                			dj->sclust = LD_CLUST(dir);
9D005AE4  91030015   LBU V1, 21(T0)
9D005AE8  00031A00   SLL V1, V1, 8
9D005AEC  91020014   LBU V0, 20(T0)
9D005AF0  00621825   OR V1, V1, V0
9D005AF4  00031C00   SLL V1, V1, 16
9D005AF8  9104001B   LBU A0, 27(T0)
9D005AFC  00042200   SLL A0, A0, 8
9D005B00  9102001A   LBU V0, 26(T0)
9D005B04  00821025   OR V0, A0, V0
9D005B08  00621025   OR V0, V1, V0
9D005B0C  0B401613   J follow_path::create_name
9D005B10  AE220008   SW V0, 8(S1)
1913:                		}
1914:                	}
1915:                
1916:                	return res;
1917:                }
9D005BCC  8FBF002C   LW RA, 44(SP)
9D005BD0  8FB50028   LW S5, 40(SP)
9D005BD4  8FB40024   LW S4, 36(SP)
9D005BD8  8FB30020   LW S3, 32(SP)
9D005BDC  8FB2001C   LW S2, 28(SP)
9D005BE0  8FB10018   LW S1, 24(SP)
9D005BE4  8FB00014   LW S0, 20(SP)
9D005BE8  03E00008   JR RA
9D005BEC  27BD0030   ADDIU SP, SP, 48
1918:                
1919:                /*-----------------------------------------------------------------------*/
1920:                /* Load a sector and check if it is an FAT Volume Boot Record            */
1921:                /*-----------------------------------------------------------------------*/
1922:                
1923:                static PF_BYTE check_fs( /* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
1924:                FATFS *fs, /* File system object */
1925:                DWORD sect /* Sector# (lba) to check if it is an FAT boot record or not */
1926:                ) {
9D004CE8  27BDFFE8   ADDIU SP, SP, -24
9D004CEC  AFBF0014   SW RA, 20(SP)
9D004CF0  AFB00010   SW S0, 16(SP)
9D004CF4  00808021   ADDU S0, A0, ZERO
9D004CF8  00A03021   ADDU A2, A1, ZERO
1927:                	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK) /* Load boot record */
9D004CFC  90840001   LBU A0, 1(A0)
9D004D00  26050034   ADDIU A1, S0, 52
9D004D04  0F40415F   JAL disk_read
9D004D08  24070001   ADDIU A3, ZERO, 1
9D004D0C  14400027   BNE V0, ZERO, 0x9D004DAC
9D004D10  24030003   ADDIU V1, ZERO, 3
1928:                		return 3;
1929:                	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55) /* Check record signature (always placed at offset 510 even if the sector size is >512) */
9D004D14  92040233   LBU A0, 563(S0)
9D004D18  00042200   SLL A0, A0, 8
9D004D1C  92020232   LBU V0, 562(S0)
9D004D20  00822025   OR A0, A0, V0
9D004D24  7C042620   SEH A0, A0
9D004D28  2402AA55   ADDIU V0, ZERO, -21931
9D004D2C  1482001F   BNE A0, V0, 0x9D004DAC
9D004D30  24030002   ADDIU V1, ZERO, 2
1930:                		return 2;
1931:                
1932:                	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
9D004D34  9203006D   LBU V1, 109(S0)
9D004D38  00031E00   SLL V1, V1, 24
9D004D3C  9202006C   LBU V0, 108(S0)
9D004D40  00021400   SLL V0, V0, 16
9D004D44  00621825   OR V1, V1, V0
9D004D48  9202006A   LBU V0, 106(S0)
9D004D4C  00621825   OR V1, V1, V0
9D004D50  9202006B   LBU V0, 107(S0)
9D004D54  00021200   SLL V0, V0, 8
9D004D58  00621825   OR V1, V1, V0
9D004D5C  7C63B800   EXT V1, V1, 0, 24
9D004D60  3C020054   LUI V0, 84
9D004D64  24424146   ADDIU V0, V0, 16710
9D004D68  50620010   BEQL V1, V0, 0x9D004DAC
9D004D6C  00001821   ADDU V1, ZERO, ZERO
1933:                		return 0;
1934:                	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
9D004D70  92030089   LBU V1, 137(S0)
9D004D74  00031E00   SLL V1, V1, 24
9D004D78  92020088   LBU V0, 136(S0)
9D004D7C  00021400   SLL V0, V0, 16
9D004D80  00621825   OR V1, V1, V0
9D004D84  92020086   LBU V0, 134(S0)
9D004D88  00621825   OR V1, V1, V0
9D004D8C  92020087   LBU V0, 135(S0)
9D004D90  00021200   SLL V0, V0, 8
9D004D94  00621825   OR V1, V1, V0
9D004D98  7C63B800   EXT V1, V1, 0, 24
9D004D9C  3C02FFAB   LUI V0, -85
9D004DA0  3442BEBA   ORI V0, V0, -16710
9D004DA4  00621821   ADDU V1, V1, V0
9D004DA8  0003182B   SLTU V1, ZERO, V1
1935:                		return 0;
1936:                
1937:                	return 1;
1938:                }
9D004DAC  00601021   ADDU V0, V1, ZERO
9D004DB0  8FBF0014   LW RA, 20(SP)
9D004DB4  8FB00010   LW S0, 16(SP)
9D004DB8  03E00008   JR RA
9D004DBC  27BD0018   ADDIU SP, SP, 24
1939:                
1940:                /*-----------------------------------------------------------------------*/
1941:                /* Check if the file system object is valid or not                       */
1942:                /*-----------------------------------------------------------------------*/
1943:                
1944:                FRESULT chk_mounted( /* FR_OK(0): successful, !=0: any error occurred */
1945:                                            const TCHAR **path, /* Pointer to pointer to the path name (drive number) */
1946:                                            FATFS **rfs, /* Pointer to pointer to the found file system object */
1947:                                            PF_BYTE chk_wp /* !=0: Check media write protection for write access */
1948:                                            ) {
9D005E40  27BDFFE0   ADDIU SP, SP, -32
9D005E44  AFBF001C   SW RA, 28(SP)
9D005E48  AFB20018   SW S2, 24(SP)
9D005E4C  AFB10014   SW S1, 20(SP)
9D005E50  AFB00010   SW S0, 16(SP)
1949:                	PF_BYTE fmt, b, pi, *tbl;
1950:                	UINT vol;
1951:                	DSTATUS stat;
1952:                	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
1953:                	PF_WORD nrsv;
1954:                	const TCHAR *p = *path;
9D005E54  8C820000   LW V0, 0(A0)
1955:                	FATFS *fs;
1956:                
1957:                	/* Get logical drive number from the path name */
1958:                	vol = p[0] - '0'; /* Is there a drive number? */
9D005E58  80430000   LB V1, 0(V0)
9D005E5C  2463FFD0   ADDIU V1, V1, -48
1959:                	if (vol <= 9 && p[1] == ':') { /* Found a drive number, get and strip it */
9D005E60  2C67000A   SLTIU A3, V1, 10
9D005E64  10E00008   BEQ A3, ZERO, 0x9D005E88
9D005E68  00C08821   ADDU S1, A2, ZERO
9D005E6C  80470001   LB A3, 1(V0)
9D005E70  2406003A   ADDIU A2, ZERO, 58
9D005E74  54E60005   BNEL A3, A2, 0x9D005E8C
9D005E78  93838058   LBU V1, -32680(GP)
1960:                		p += 2;
9D005E7C  24420002   ADDIU V0, V0, 2
1961:                		*path = p; /* Return pointer to the path name */
9D005E80  0B4017A3   J 0x9D005E8C
9D005E84  AC820000   SW V0, 0(A0)
1962:                	} else { /* No drive number is given */
1963:                #if _FS_RPATH
1964:                		vol = CurrVol; /* Use current drive */
9D005E88  93838058   LBU V1, -32680(GP)
1965:                #else
1966:                		vol = 0; /* Use drive 0 */
1967:                #endif
1968:                	}
1969:                
1970:                	/* Check if the file system object is valid or not */
1971:                	if (vol >= _VOLUMES) /* Is the drive number valid? */
9D005E8C  14600129   BNE V1, ZERO, 0x9D006334
9D005E90  2402000B   ADDIU V0, ZERO, 11
1972:                		return FR_INVALID_DRIVE;
1973:                	*rfs = fs = FatFs[vol]; /* Return pointer to the corresponding file system object */
9D005E94  8F90805C   LW S0, -32676(GP)
1974:                	if (!fs)
9D005E98  1200011B   BEQ S0, ZERO, 0x9D006308
9D005E9C  ACB00000   SW S0, 0(A1)
1975:                		return FR_NOT_ENABLED; /* Is the file system object available? */
9D006308  0B4018CD   J 0x9D006334
9D00630C  2402000C   ADDIU V0, ZERO, 12
1976:                
1977:                	ENTER_FF(fs); /* Lock file system */
1978:                
1979:                	if (fs->fs_type) { /* If the logical drive has been mounted */
9D005EA0  92020000   LBU V0, 0(S0)
9D005EA4  5040000D   BEQL V0, ZERO, 0x9D005EDC
9D005EA8  A2000000   SB ZERO, 0(S0)
1980:                		stat = disk_status(fs->drv);
9D005EAC  0F404159   JAL disk_status
9D005EB0  92040001   LBU A0, 1(S0)
9D005EB4  00401821   ADDU V1, V0, ZERO
1981:                		if (!(stat & STA_NOINIT)) { /* and the physical drive is kept initialized (has not been changed), */
9D005EB8  30420001   ANDI V0, V0, 1
9D005EBC  54400007   BNEL V0, ZERO, 0x9D005EDC
9D005EC0  A2000000   SB ZERO, 0(S0)
1982:                			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check write protection if needed */
9D005EC4  1220011B   BEQ S1, ZERO, 0x9D006334
9D005EC8  30630004   ANDI V1, V1, 4
9D005ECC  306300FF   ANDI V1, V1, 255
1983:                				return FR_WRITE_PROTECTED;
1984:                			return FR_OK; /* The file system object is valid */
9D005ED0  2402000A   ADDIU V0, ZERO, 10
9D005ED4  0B4018CD   J 0x9D006334
9D005ED8  0003100A   MOVZ V0, ZERO, V1
1985:                		}
1986:                	}
1987:                
1988:                	/* The file system object is not valid. */
1989:                	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
1990:                
1991:                	fs->fs_type = 0; /* Clear the file system object */
1992:                	fs->drv = LD2PD(vol); /* Bind the logical drive and a physical drive */
9D005EDC  A2000001   SB ZERO, 1(S0)
1993:                	stat = disk_initialize(fs->drv); /* Initialize low level disk I/O layer */
9D005EE0  0F4040CC   JAL disk_initialize
9D005EE4  00002021   ADDU A0, ZERO, ZERO
9D005EE8  00401821   ADDU V1, V0, ZERO
1994:                	if (stat & STA_NOINIT) /* Check if the initialization succeeded */
9D005EEC  30440001   ANDI A0, V0, 1
9D005EF0  14800110   BNE A0, ZERO, 0x9D006334
9D005EF4  24020003   ADDIU V0, ZERO, 3
1995:                		return FR_NOT_READY; /* Failed to initialize due to no media or hard error */
1996:                	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT)) /* Check disk write protection if needed */
9D005EF8  12200004   BEQ S1, ZERO, 0x9D005F0C
9D005EFC  30630004   ANDI V1, V1, 4
9D005F00  306300FF   ANDI V1, V1, 255
9D005F04  1460010B   BNE V1, ZERO, 0x9D006334
9D005F08  2402000A   ADDIU V0, ZERO, 10
1997:                		return FR_WRITE_PROTECTED;
1998:                #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
1999:                	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
2000:                	return FR_DISK_ERR;
2001:                #endif
2002:                	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
2003:                	fmt = check_fs(fs, bsect = 0); /* Load sector 0 and check if it is an FAT-VBR (in SFD) */
9D005F0C  02002021   ADDU A0, S0, ZERO
9D005F10  0F40133A   JAL check_fs
9D005F14  00002821   ADDU A1, ZERO, ZERO
9D005F18  00401821   ADDU V1, V0, ZERO
2004:                	if (LD2PT(vol) && !fmt)
2005:                		fmt = 1; /* Force non-SFD if the volume is forced partition */
2006:                	if (fmt == 1) { /* Not an FAT-VBR, the physical drive can be partitioned */
9D005F1C  24020001   ADDIU V0, ZERO, 1
9D005F20  14620012   BNE V1, V0, 0x9D005F6C
9D005F24  00008821   ADDU S1, ZERO, ZERO
2007:                		/* Check the partition listed in the partition table */
2008:                		pi = LD2PT(vol);
2009:                		if (pi)
2010:                			pi--;
2011:                		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
2012:                		if (tbl[4]) { /* Is the partition existing? */
9D005F28  920301F6   LBU V1, 502(S0)
9D005F2C  10600101   BEQ V1, ZERO, 0x9D006334
9D005F30  2402000D   ADDIU V0, ZERO, 13
2013:                			bsect = LD_DWORD(&tbl[8]); /* Partition offset in LBA */
9D005F34  921101FD   LBU S1, 509(S0)
9D005F38  00118E00   SLL S1, S1, 24
9D005F3C  920201FC   LBU V0, 508(S0)
9D005F40  00021400   SLL V0, V0, 16
9D005F44  02228825   OR S1, S1, V0
9D005F48  920201FA   LBU V0, 506(S0)
9D005F4C  02228825   OR S1, S1, V0
9D005F50  920201FB   LBU V0, 507(S0)
9D005F54  00021200   SLL V0, V0, 8
9D005F58  02228825   OR S1, S1, V0
2014:                			fmt = check_fs(fs, bsect); /* Check the partition */
9D005F5C  02002021   ADDU A0, S0, ZERO
9D005F60  0F40133A   JAL check_fs
9D005F64  02202821   ADDU A1, S1, ZERO
9D005F68  00401821   ADDU V1, V0, ZERO
2015:                		}
2016:                	}
2017:                	if (fmt == 3)
9D005F6C  24020003   ADDIU V0, ZERO, 3
9D005F70  506200F0   BEQL V1, V0, 0x9D006334
9D005F74  24020001   ADDIU V0, ZERO, 1
2018:                		return FR_DISK_ERR;
2019:                	if (fmt)
9D005F78  146000EE   BNE V1, ZERO, 0x9D006334
9D005F7C  2402000D   ADDIU V0, ZERO, 13
2020:                		return FR_NO_FILESYSTEM; /* No FAT volume is found */
2021:                
2022:                	/* An FAT volume is found. Following code initializes the file system object */
2023:                
2024:                	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs)) /* (BPB_BytsPerSec must be equal to the physical sector size) */
9D005F80  92040040   LBU A0, 64(S0)
9D005F84  00042200   SLL A0, A0, 8
9D005F88  9202003F   LBU V0, 63(S0)
9D005F8C  00822025   OR A0, A0, V0
9D005F90  7C042620   SEH A0, A0
9D005F94  24030200   ADDIU V1, ZERO, 512
9D005F98  148300E6   BNE A0, V1, 0x9D006334
9D005F9C  2402000D   ADDIU V0, ZERO, 13
2025:                		return FR_NO_FILESYSTEM;
2026:                
2027:                	fasize = LD_WORD(fs->win+BPB_FATSz16); /* Number of sectors per FAT */
9D005FA0  9204004B   LBU A0, 75(S0)
9D005FA4  00042200   SLL A0, A0, 8
9D005FA8  9202004A   LBU V0, 74(S0)
9D005FAC  00822025   OR A0, A0, V0
2028:                	if (!fasize)
9D005FB0  5480000C   BNEL A0, ZERO, 0x9D005FE4
9D005FB4  AE040020   SW A0, 32(S0)
2029:                		fasize = LD_DWORD(fs->win+BPB_FATSz32);
9D005FB8  9204005B   LBU A0, 91(S0)
9D005FBC  00042600   SLL A0, A0, 24
9D005FC0  9202005A   LBU V0, 90(S0)
9D005FC4  00021400   SLL V0, V0, 16
9D005FC8  00822025   OR A0, A0, V0
9D005FCC  92020058   LBU V0, 88(S0)
9D005FD0  00822025   OR A0, A0, V0
9D005FD4  92020059   LBU V0, 89(S0)
9D005FD8  00021200   SLL V0, V0, 8
9D005FDC  00822025   OR A0, A0, V0
2030:                	fs->fsize = fasize;
9D005FE0  AE040020   SW A0, 32(S0)
2031:                
2032:                	fs->n_fats = b = fs->win[BPB_NumFATs]; /* Number of FAT copies */
9D005FE4  92070044   LBU A3, 68(S0)
9D005FE8  A2070003   SB A3, 3(S0)
2033:                	if (b != 1 && b != 2)
9D005FEC  24E3FFFF   ADDIU V1, A3, -1
9D005FF0  306300FF   ANDI V1, V1, 255
9D005FF4  2C630002   SLTIU V1, V1, 2
9D005FF8  106000CE   BEQ V1, ZERO, 0x9D006334
9D005FFC  2402000D   ADDIU V0, ZERO, 13
2034:                		return FR_NO_FILESYSTEM; /* (Must be 1 or 2) */
2035:                	fasize *= b; /* Number of sectors for FAT area */
9D006090  70874802   MUL T1, A0, A3
2036:                
2037:                	fs->csize = b = fs->win[BPB_SecPerClus]; /* Number of sectors per cluster */
9D006000  92030041   LBU V1, 65(S0)
2038:                	if (!b || (b & (b - 1)))
9D006004  106000CB   BEQ V1, ZERO, 0x9D006334
9D006008  A2030002   SB V1, 2(S0)
9D00600C  2465FFFF   ADDIU A1, V1, -1
9D006010  00A32824   AND A1, A1, V1
9D006014  14A000C8   BNE A1, ZERO, 0x9D006338
9D006018  8FBF001C   LW RA, 28(SP)
2039:                		return FR_NO_FILESYSTEM; /* (Must be power of 2) */
2040:                
2041:                	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt); /* Number of root directory entries */
9D00601C  92050046   LBU A1, 70(S0)
9D006020  00052A00   SLL A1, A1, 8
9D006024  92020045   LBU V0, 69(S0)
9D006028  00A22825   OR A1, A1, V0
9D00602C  A6050008   SH A1, 8(S0)
2042:                	if (fs->n_rootdir % (SS(fs) / SZ_DIR))
9D006030  30A6000F   ANDI A2, A1, 15
9D006034  14C000BF   BNE A2, ZERO, 0x9D006334
9D006038  2402000D   ADDIU V0, ZERO, 13
2043:                		return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be sector aligned) */
2044:                
2045:                	tsect = LD_WORD(fs->win+BPB_TotSec16); /* Number of sectors on the volume */
9D00603C  92080048   LBU T0, 72(S0)
9D006040  00084200   SLL T0, T0, 8
9D006044  92020047   LBU V0, 71(S0)
9D006048  01024025   OR T0, T0, V0
2046:                	if (!tsect)
9D00604C  1500000B   BNE T0, ZERO, 0x9D00607C
9D006050  92060043   LBU A2, 67(S0)
2047:                		tsect = LD_DWORD(fs->win+BPB_TotSec32);
9D006054  92080057   LBU T0, 87(S0)
9D006058  00084600   SLL T0, T0, 24
9D00605C  92020056   LBU V0, 86(S0)
9D006060  00021400   SLL V0, V0, 16
9D006064  01024025   OR T0, T0, V0
9D006068  92020054   LBU V0, 84(S0)
9D00606C  01024025   OR T0, T0, V0
9D006070  92020055   LBU V0, 85(S0)
9D006074  00021200   SLL V0, V0, 8
9D006078  01024025   OR T0, T0, V0
2048:                
2049:                	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt); /* Number of reserved sectors */
9D00607C  00063200   SLL A2, A2, 8
9D006080  92020042   LBU V0, 66(S0)
9D006084  00C23025   OR A2, A2, V0
2050:                	if (!nrsv)
9D006088  10C000AA   BEQ A2, ZERO, 0x9D006334
9D00608C  2402000D   ADDIU V0, ZERO, 13
2051:                		return FR_NO_FILESYSTEM; /* (BPB_RsvdSecCnt must not be 0) */
2052:                
2053:                	/* Determine the FAT sub type */
2054:                	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR); /* RSV+FAT+DIR */
9D006094  00053902   SRL A3, A1, 4
9D006098  00E63821   ADDU A3, A3, A2
9D00609C  00E93821   ADDU A3, A3, T1
2055:                	if (tsect < sysect)
9D0060A0  0107502B   SLTU T2, T0, A3
9D0060A4  154000A4   BNE T2, ZERO, 0x9D006338
9D0060A8  8FBF001C   LW RA, 28(SP)
2056:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2057:                	nclst = (tsect - sysect) / fs->csize; /* Number of clusters */
9D0060AC  01074023   SUBU T0, T0, A3
9D0060B0  0103001B   DIVU T0, V1
9D0060B4  006001F4   TEQ V1, ZERO
9D0060B8  00001812   MFLO V1
2058:                	if (!nclst)
9D0060BC  1060009F   BEQ V1, ZERO, 0x9D00633C
9D0060C0  8FB20018   LW S2, 24(SP)
2059:                		return FR_NO_FILESYSTEM; /* (Invalid volume size) */
2060:                	fmt = FS_FAT12;
9D0060C8  24020001   ADDIU V0, ZERO, 1
9D0060CC  24080002   ADDIU T0, ZERO, 2
9D0060D0  0112100A   MOVZ V0, T0, S2
9D0060D4  00409021   ADDU S2, V0, ZERO
2061:                	if (nclst >= MIN_FAT16)
9D0060C4  2C720FF6   SLTIU S2, V1, 4086
2062:                		fmt = FS_FAT16;
2063:                	if (nclst >= MIN_FAT32)
9D0060D8  3402FFF6   ORI V0, ZERO, -10
9D0060DC  0062102B   SLTU V0, V1, V0
9D0060E0  1040008D   BEQ V0, ZERO, 0x9D006318
9D0060E4  24630002   ADDIU V1, V1, 2
2064:                		fmt = FS_FAT32;
9D00632C  0B401841   J 0x9D006104
9D006330  24120003   ADDIU S2, ZERO, 3
2065:                
2066:                	/* Boundaries and Limits */
2067:                	fs->n_fatent = nclst + 2; /* Number of FAT entries */
9D0060E8  AE03001C   SW V1, 28(S0)
9D006318  AE03001C   SW V1, 28(S0)
2068:                	fs->database = bsect + sysect; /* Data start sector */
9D0060EC  00F13821   ADDU A3, A3, S1
9D0060F0  AE07002C   SW A3, 44(S0)
9D00631C  00F13821   ADDU A3, A3, S1
9D006320  AE07002C   SW A3, 44(S0)
2069:                	fs->fatbase = bsect + nrsv; /* FAT start sector */
9D0060F4  02263021   ADDU A2, S1, A2
9D006324  02263021   ADDU A2, S1, A2
9D006328  AE060024   SW A2, 36(S0)
2070:                	if (fmt == FS_FAT32) {
9D0060F8  24020003   ADDIU V0, ZERO, 3
9D0060FC  16420010   BNE S2, V0, 0x9D006140
9D006100  AE060024   SW A2, 36(S0)
2071:                		if (fs->n_rootdir)
9D006104  14A0008B   BNE A1, ZERO, 0x9D006334
9D006108  2402000D   ADDIU V0, ZERO, 13
2072:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be 0) */
2073:                		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
9D00610C  92050063   LBU A1, 99(S0)
9D006110  00052E00   SLL A1, A1, 24
9D006114  92020062   LBU V0, 98(S0)
9D006118  00021400   SLL V0, V0, 16
9D00611C  00A22825   OR A1, A1, V0
9D006120  92020060   LBU V0, 96(S0)
9D006124  00A22825   OR A1, A1, V0
9D006128  92020061   LBU V0, 97(S0)
9D00612C  00021200   SLL V0, V0, 8
9D006130  00A21025   OR V0, A1, V0
9D006134  AE020028   SW V0, 40(S0)
9D006138  0B40185D   J 0x9D006174
9D00613C  00031880   SLL V1, V1, 2
2074:                		szbfat = fs->n_fatent * 4; /* (Required FAT size) */
2075:                	} else {
2076:                		if (!fs->n_rootdir)
9D006140  10A0007C   BEQ A1, ZERO, 0x9D006334
9D006144  2402000D   ADDIU V0, ZERO, 13
2077:                			return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must not be 0) */
2078:                		fs->dirbase = fs->fatbase + fasize; /* Root directory start sector */
9D006148  01263021   ADDU A2, T1, A2
2079:                		szbfat = (fmt == FS_FAT16) ? /* (Required FAT size) */
2080:                		fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
9D00614C  24020002   ADDIU V0, ZERO, 2
9D006150  16420003   BNE S2, V0, 0x9D006160
9D006154  AE060028   SW A2, 40(S0)
9D006158  0B40185D   J 0x9D006174
9D00615C  00031840   SLL V1, V1, 1
9D006160  24020003   ADDIU V0, ZERO, 3
9D006164  70621002   MUL V0, V1, V0
9D006168  00021042   SRL V0, V0, 1
9D00616C  30630001   ANDI V1, V1, 1
9D006170  00431821   ADDU V1, V0, V1
2081:                	}
2082:                	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) /* (BPB_FATSz must not be less than required) */
9D006174  246201FF   ADDIU V0, V1, 511
9D006178  00021242   SRL V0, V0, 9
9D00617C  0082202B   SLTU A0, A0, V0
9D006180  1480006C   BNE A0, ZERO, 0x9D006334
9D006184  2402000D   ADDIU V0, ZERO, 13
2083:                		return FR_NO_FILESYSTEM;
2084:                
2085:                #if !_FS_READONLY
2086:                	/* Initialize cluster allocation information */
2087:                	fs->free_clust = 0xFFFFFFFF;
9D006188  2402FFFF   ADDIU V0, ZERO, -1
9D00618C  AE020010   SW V0, 16(S0)
2088:                	fs->last_clust = 0;
2089:                
2090:                	/* Get fsinfo if available */
2091:                	if (fmt == FS_FAT32) {
9D006190  24020003   ADDIU V0, ZERO, 3
9D006194  16420048   BNE S2, V0, 0x9D0062B8
9D006198  AE00000C   SW ZERO, 12(S0)
2092:                		fs->fsi_flag = 0;
9D00619C  A2000005   SB ZERO, 5(S0)
2093:                		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
9D0061A0  92060065   LBU A2, 101(S0)
9D0061A4  00063200   SLL A2, A2, 8
9D0061A8  92020064   LBU V0, 100(S0)
9D0061AC  00C23025   OR A2, A2, V0
9D0061B0  02263021   ADDU A2, S1, A2
9D0061B4  AE060014   SW A2, 20(S0)
2094:                		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK
9D0061B8  92040001   LBU A0, 1(S0)
9D0061BC  26050034   ADDIU A1, S0, 52
9D0061C0  0F40415F   JAL disk_read
9D0061C4  24070001   ADDIU A3, ZERO, 1
9D0061C8  5440003C   BNEL V0, ZERO, 0x9D0062BC
9D0061CC  A2120000   SB S2, 0(S0)
2095:                				&& LD_WORD(fs->win+BS_55AA) == 0xAA55
9D0061D0  92030233   LBU V1, 563(S0)
9D0061D4  00031A00   SLL V1, V1, 8
9D0061D8  92020232   LBU V0, 562(S0)
9D0061DC  00621825   OR V1, V1, V0
9D0061E0  7C031E20   SEH V1, V1
9D0061E4  2402AA55   ADDIU V0, ZERO, -21931
9D0061E8  54620034   BNEL V1, V0, 0x9D0062BC
9D0061EC  A2120000   SB S2, 0(S0)
2096:                				&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
9D0061F0  92030037   LBU V1, 55(S0)
9D0061F4  00031E00   SLL V1, V1, 24
9D0061F8  92020036   LBU V0, 54(S0)
9D0061FC  00021400   SLL V0, V0, 16
9D006200  00621825   OR V1, V1, V0
9D006204  92020034   LBU V0, 52(S0)
9D006208  00621825   OR V1, V1, V0
9D00620C  92020035   LBU V0, 53(S0)
9D006210  00021200   SLL V0, V0, 8
9D006214  00621825   OR V1, V1, V0
9D006218  3C024161   LUI V0, 16737
9D00621C  24425252   ADDIU V0, V0, 21074
9D006220  54620026   BNEL V1, V0, 0x9D0062BC
9D006224  A2120000   SB S2, 0(S0)
2097:                				&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
9D006228  9203021B   LBU V1, 539(S0)
9D00622C  00031E00   SLL V1, V1, 24
9D006230  9202021A   LBU V0, 538(S0)
9D006234  00021400   SLL V0, V0, 16
9D006238  00621825   OR V1, V1, V0
9D00623C  92020218   LBU V0, 536(S0)
9D006240  00621825   OR V1, V1, V0
9D006244  92020219   LBU V0, 537(S0)
9D006248  00021200   SLL V0, V0, 8
9D00624C  00621825   OR V1, V1, V0
9D006250  3C026141   LUI V0, 24897
9D006254  24427272   ADDIU V0, V0, 29298
9D006258  54620018   BNEL V1, V0, 0x9D0062BC
9D00625C  A2120000   SB S2, 0(S0)
2098:                			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
9D006260  92030223   LBU V1, 547(S0)
9D006264  00031E00   SLL V1, V1, 24
9D006268  92020222   LBU V0, 546(S0)
9D00626C  00021400   SLL V0, V0, 16
9D006270  00621825   OR V1, V1, V0
9D006274  92020220   LBU V0, 544(S0)
9D006278  00621825   OR V1, V1, V0
9D00627C  92020221   LBU V0, 545(S0)
9D006280  00021200   SLL V0, V0, 8
9D006284  00621025   OR V0, V1, V0
9D006288  AE02000C   SW V0, 12(S0)
2099:                			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
9D00628C  9203021F   LBU V1, 543(S0)
9D006290  00031E00   SLL V1, V1, 24
9D006294  9202021E   LBU V0, 542(S0)
9D006298  00021400   SLL V0, V0, 16
9D00629C  00621825   OR V1, V1, V0
9D0062A0  9202021C   LBU V0, 540(S0)
9D0062A4  00621825   OR V1, V1, V0
9D0062A8  9202021D   LBU V0, 541(S0)
9D0062AC  00021200   SLL V0, V0, 8
9D0062B0  00621025   OR V0, V1, V0
9D0062B4  AE020010   SW V0, 16(S0)
2100:                		}
2101:                	}
2102:                #endif
2103:                	fs->fs_type = fmt; /* FAT sub-type */
9D0062B8  A2120000   SB S2, 0(S0)
2104:                	fs->id = ++Fsid; /* File system mount ID */
9D0062BC  9782805A   LHU V0, -32678(GP)
9D0062C0  24420001   ADDIU V0, V0, 1
9D0062C4  3042FFFF   ANDI V0, V0, -1
9D0062C8  A782805A   SH V0, -32678(GP)
9D0062CC  A6020006   SH V0, 6(S0)
2105:                	fs->winsect = 0; /* Invalidate sector cache */
9D0062D0  AE000030   SW ZERO, 48(S0)
2106:                	fs->wflag = 0;
9D0062D4  A2000004   SB ZERO, 4(S0)
2107:                #if _FS_RPATH
2108:                	fs->cdir = 0; /* Current directory (root dir) */
9D0062D8  AE000018   SW ZERO, 24(S0)
9D0062DC  3C02A000   LUI V0, -24576
9D0062E0  244244D4   ADDIU V0, V0, 17620
9D0062E4  2443003C   ADDIU V1, V0, 60
2109:                #endif
2110:                #if _FS_SHARE				/* Clear file lock semaphores */
2111:                	clear_lock(fs);
2112:                #endif
2113:                
2114:                	return FR_OK;
9D006300  0B4018C4   J 0x9D006310
9D006304  00001021   ADDU V0, ZERO, ZERO
2115:                }
9D006310  0B4018CE   J 0x9D006338
9D006314  8FBF001C   LW RA, 28(SP)
9D006334  8FBF001C   LW RA, 28(SP)
9D006338  8FB20018   LW S2, 24(SP)
9D00633C  8FB10014   LW S1, 20(SP)
9D006340  8FB00010   LW S0, 16(SP)
9D006344  03E00008   JR RA
9D006348  27BD0020   ADDIU SP, SP, 32
2116:                
2117:                /*-----------------------------------------------------------------------*/
2118:                /* Check if the file/dir object is valid or not                          */
2119:                /*-----------------------------------------------------------------------*/
2120:                
2121:                static FRESULT validate( /* FR_OK(0): The object is valid, !=0: Invalid */
2122:                FATFS *fs, /* Pointer to the file system object */
2123:                PF_WORD id /* Member id of the target object to be checked */
2124:                ) {
9D004DE0  27BDFFE8   ADDIU SP, SP, -24
9D004DE4  AFBF0014   SW RA, 20(SP)
2125:                	if (!fs || !fs->fs_type || fs->id != id)
9D004DC0  10800010   BEQ A0, ZERO, 0x9D004E04
9D004DC4  00000000   NOP
9D004DC8  90830000   LBU V1, 0(A0)
9D004DCC  10600011   BEQ V1, ZERO, 0x9D004E14
9D004DD0  24020009   ADDIU V0, ZERO, 9
9D004DD4  94830006   LHU V1, 6(A0)
9D004DD8  1465000E   BNE V1, A1, 0x9D004E14
9D004DDC  00000000   NOP
2126:                		return FR_INVALID_OBJECT;
9D004E04  03E00008   JR RA
9D004E08  24020009   ADDIU V0, ZERO, 9
2127:                
2128:                	ENTER_FF(fs); /* Lock file system */
2129:                
2130:                	if (disk_status(fs->drv) & STA_NOINIT)
9D004DE8  0F404159   JAL disk_status
9D004DEC  90840001   LBU A0, 1(A0)
9D004DF0  30420001   ANDI V0, V0, 1
2131:                		return FR_NOT_READY;
9D004DF4  24030003   ADDIU V1, ZERO, 3
9D004DF8  0002180A   MOVZ V1, ZERO, V0
9D004DFC  0B401383   J 0x9D004E0C
9D004E00  00601021   ADDU V0, V1, ZERO
2132:                
2133:                	return FR_OK;
2134:                }
9D004E0C  8FBF0014   LW RA, 20(SP)
9D004E10  27BD0018   ADDIU SP, SP, 24
9D004E14  03E00008   JR RA
9D004E18  00000000   NOP
2135:                
2136:                /*--------------------------------------------------------------------------
2137:                
2138:                 Public Functions
2139:                
2140:                 --------------------------------------------------------------------------*/
2141:                
2142:                /*-----------------------------------------------------------------------*/
2143:                /* Mount/Unmount a Logical Drive                                         */
2144:                /*-----------------------------------------------------------------------*/
2145:                
2146:                FRESULT f_mount(PF_BYTE vol, /* Logical drive number to be mounted/unmounted */
2147:                                FATFS *fs /* Pointer to new file system object (NULL for unmount)*/
2148:                                ) {
2149:                	FATFS *rfs;
2150:                
2151:                	if (vol >= _VOLUMES) {/* Check if the drive number is valid */
9D00634C  14800011   BNE A0, ZERO, 0x9D006394
9D006350  2402000B   ADDIU V0, ZERO, 11
2152:                		return FR_INVALID_DRIVE;
2153:                	}
2154:                	rfs = FatFs[vol]; /* Get current fs object */
9D006354  8F84805C   LW A0, -32676(GP)
2155:                
2156:                	if (rfs) {
9D006358  1080000A   BEQ A0, ZERO, 0x9D006384
9D00635C  3C02A000   LUI V0, -24576
9D006360  244244D4   ADDIU V0, V0, 17620
9D006364  2446003C   ADDIU A2, V0, 60
2157:                #if _FS_SHARE
2158:                		clear_lock(rfs);
2159:                #endif
2160:                #if _FS_REENTRANT				/* Discard sync object of the current volume */
2161:                		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2162:                #endif
2163:                		rfs->fs_type = 0; /* Clear old fs object */
9D006380  A0800000   SB ZERO, 0(A0)
2164:                	}
2165:                
2166:                	if (fs) {
9D006384  54A00001   BNEL A1, ZERO, 0x9D00638C
9D006388  A0A00000   SB ZERO, 0(A1)
2167:                		fs->fs_type = 0; /* Clear new fs object */
2168:                #if _FS_REENTRANT				/* Create sync object for the new volume */
2169:                		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2170:                #endif
2171:                	}
2172:                	FatFs[vol] = fs; /* Register new fs object */
9D00638C  AF85805C   SW A1, -32676(GP)
2173:                
2174:                	return FR_OK;
9D006390  00001021   ADDU V0, ZERO, ZERO
2175:                }
9D006394  03E00008   JR RA
9D006398  00000000   NOP
2176:                
2177:                /*-----------------------------------------------------------------------*/
2178:                /* Open or Create a File                                                 */
2179:                /*-----------------------------------------------------------------------*/
2180:                
2181:                FRESULT f_open(FIL *fp, /* Pointer to the blank file object */
2182:                                const TCHAR *path, /* Pointer to the file name */
2183:                                PF_BYTE mode /* Access mode and file open mode flags */
2184:                                ) {
9D00639C  27BDFFB0   ADDIU SP, SP, -80
9D0063A0  AFBF004C   SW RA, 76(SP)
9D0063A4  AFB40048   SW S4, 72(SP)
9D0063A8  AFB30044   SW S3, 68(SP)
9D0063AC  AFB20040   SW S2, 64(SP)
9D0063B0  AFB1003C   SW S1, 60(SP)
9D0063B4  AFB00038   SW S0, 56(SP)
9D0063B8  00808821   ADDU S1, A0, ZERO
9D0063BC  AFA50054   SW A1, 84(SP)
9D0063C0  00C09821   ADDU S3, A2, ZERO
2185:                	FRESULT res;
2186:                	DIR dj;
2187:                	PF_BYTE *dir;
2188:                	DEF_NAMEBUF;
2189:                
2190:                	fp->fs = 0; /* Clear file object */
9D0063C4  AC800000   SW ZERO, 0(A0)
2191:                
2192:                #if !_FS_READONLY
2193:                	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS
9D0063C8  30D2001F   ANDI S2, A2, 31
2194:                			| FA_CREATE_NEW;
2195:                	res = chk_mounted(&path, &dj.fs, (PF_BYTE) (mode & ~FA_READ));
9D0063CC  27A40054   ADDIU A0, SP, 84
9D0063D0  27A50010   ADDIU A1, SP, 16
9D0063D4  0F401790   JAL chk_mounted
9D0063D8  30C6001E   ANDI A2, A2, 30
2196:                #else
2197:                	mode &= FA_READ;
2198:                	res = chk_mounted(&path, &dj.fs, 0);
2199:                #endif
2200:                	INIT_BUF(dj);
9D0063DC  27A3002C   ADDIU V1, SP, 44
2201:                	if (res == FR_OK)
9D0063E0  144000D4   BNE V0, ZERO, 0x9D006734
9D0063E4  AFA30028   SW V1, 40(SP)
2202:                		res = follow_path(&dj, path); /* Follow the file path */
9D0063E8  27A40010   ADDIU A0, SP, 16
9D0063EC  0F4015F0   JAL follow_path
9D0063F0  8FA50054   LW A1, 84(SP)
2203:                	dir = dj.dir;
9D006734  0B4019D0   J 0x9D006740
9D006738  8FB00024   LW S0, 36(SP)
2204:                
2205:                #if !_FS_READONLY	/* R/W configuration */
2206:                	if (res == FR_OK) {
9D0063F4  144000D2   BNE V0, ZERO, 0x9D006740
9D0063F8  8FB00024   LW S0, 36(SP)
2207:                		if (!dir) /* Current dir itself */
9D0063FC  120000CF   BEQ S0, ZERO, 0x9D00673C
9D006400  27A40010   ADDIU A0, SP, 16
2208:                			res = FR_INVALID_NAME;
9D00673C  24020006   ADDIU V0, ZERO, 6
2209:                #if _FS_SHARE
2210:                		else
2211:                		res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
9D006404  2402FFFE   ADDIU V0, ZERO, -2
9D006408  02422824   AND A1, S2, V0
9D00640C  0F401262   JAL chk_lock
9D006410  0005282B   SLTU A1, ZERO, A1
2212:                #endif
2213:                	}
2214:                	/* Create or Open a file */
2215:                	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
9D006414  3263001C   ANDI V1, S3, 28
9D006418  10600054   BEQ V1, ZERO, 0x9D00656C
9D00641C  00000000   NOP
9D006740  3263001C   ANDI V1, S3, 28
9D006744  1460FF36   BNE V1, ZERO, 0x9D006420
9D006748  00000000   NOP
9D00674C  0B40196B   J 0x9D0065AC
9D006750  00000000   NOP
2216:                		DWORD dw, cl;
2217:                
2218:                		if (res != FR_OK) { /* No file, create new */
9D006420  5040001B   BEQL V0, ZERO, 0x9D006490
9D006424  9203000B   LBU V1, 11(S0)
2219:                			if (res == FR_NO_FILE) /* There is no file to open, create a new entry */
9D006428  24030004   ADDIU V1, ZERO, 4
9D00642C  144300ED   BNE V0, V1, 0x9D0067E4
9D006430  8FBF004C   LW RA, 76(SP)
2220:                #if _FS_SHARE
2221:                				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
9D006468  24040005   ADDIU A0, ZERO, 5
9D00646C  106400DC   BEQ V1, A0, 0x9D0067E0
9D006470  24020012   ADDIU V0, ZERO, 18
9D006474  0F4016FC   JAL dir_register
9D006478  27A40010   ADDIU A0, SP, 16
9D0067DC  24020012   ADDIU V0, ZERO, 18
2222:                #else
2223:                				res = dir_register(&dj);
2224:                #endif
2225:                			mode |= FA_CREATE_ALWAYS; /* File is created */
9D00647C  36520008   ORI S2, S2, 8
2226:                			dir = dj.dir; /* New entry */
2227:                		} else { /* Any object is already existing */
2228:                			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) { /* Cannot overwrite it (R/O or DIR) */
9D006490  30630011   ANDI V1, V1, 17
9D006494  146000D2   BNE V1, ZERO, 0x9D0067E0
9D006498  24020007   ADDIU V0, ZERO, 7
2229:                				res = FR_DENIED;
2230:                			} else {
2231:                				if (mode & FA_CREATE_NEW) /* Cannot create as new file */
9D00649C  32730004   ANDI S3, S3, 4
9D0064A0  327300FF   ANDI S3, S3, 255
9D0064A4  166000CE   BNE S3, ZERO, 0x9D0067E0
9D0064A8  24020008   ADDIU V0, ZERO, 8
2232:                					res = FR_EXIST;
2233:                			}
2234:                		}
2235:                		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) { /* Truncate it if overwrite mode */
9D006480  1040000A   BEQ V0, ZERO, 0x9D0064AC
9D006484  8FB00024   LW S0, 36(SP)
9D006488  0B4019F9   J 0x9D0067E4
9D00648C  8FBF004C   LW RA, 76(SP)
9D0064AC  32420008   ANDI V0, S2, 8
9D0064B0  304200FF   ANDI V0, V0, 255
9D0064B4  10400040   BEQ V0, ZERO, 0x9D0065B8
9D0064B8  32430008   ANDI V1, S2, 8
2236:                			dw = get_fattime(); /* Created time */
9D0064BC  0F4042BB   JAL get_fattime
9D0064C0  00000000   NOP
2237:                			ST_DWORD(dir+DIR_CrtTime, dw);
9D0064C4  A202000E   SB V0, 14(S0)
9D0064C8  7C433A00   EXT V1, V0, 8, 8
9D0064CC  A203000F   SB V1, 15(S0)
9D0064D0  00021C02   SRL V1, V0, 16
9D0064D4  A2030010   SB V1, 16(S0)
9D0064D8  00021602   SRL V0, V0, 24
9D0064DC  A2020011   SB V0, 17(S0)
2238:                			dir[DIR_Attr] = 0; /* Reset attribute */
9D0064E0  A200000B   SB ZERO, 11(S0)
2239:                			ST_DWORD(dir+DIR_FileSize, 0); /* size = 0 */
9D0064E4  A200001C   SB ZERO, 28(S0)
9D0064E8  A200001D   SB ZERO, 29(S0)
9D0064EC  A200001E   SB ZERO, 30(S0)
9D0064F0  A200001F   SB ZERO, 31(S0)
2240:                			cl = LD_CLUST(dir); /* Get start cluster */
9D0064F4  92130015   LBU S3, 21(S0)
9D0064F8  00139A00   SLL S3, S3, 8
9D0064FC  92020014   LBU V0, 20(S0)
9D006500  02629825   OR S3, S3, V0
9D006504  00139C00   SLL S3, S3, 16
9D006508  9203001B   LBU V1, 27(S0)
9D00650C  00031A00   SLL V1, V1, 8
9D006510  9202001A   LBU V0, 26(S0)
9D006514  00621025   OR V0, V1, V0
9D006518  02629825   OR S3, S3, V0
2241:                			ST_CLUST(dir, 0); /* cluster = 0 */
9D00651C  A200001A   SB ZERO, 26(S0)
9D006520  A200001B   SB ZERO, 27(S0)
9D006524  A2000014   SB ZERO, 20(S0)
9D006528  A2000015   SB ZERO, 21(S0)
2242:                			dj.fs->wflag = 1;
9D00652C  8FA40010   LW A0, 16(SP)
9D006530  24020001   ADDIU V0, ZERO, 1
2243:                			if (cl) { /* Remove the cluster chain if exist */
9D006534  1260001F   BEQ S3, ZERO, 0x9D0065B4
9D006538  A0820004   SB V0, 4(A0)
2244:                				dw = dj.fs->winsect;
9D00653C  8C940030   LW S4, 48(A0)
2245:                				res = remove_chain(dj.fs, cl);
9D006540  0F401758   JAL remove_chain
9D006544  02602821   ADDU A1, S3, ZERO
2246:                				if (res == FR_OK) {
9D006548  144000A6   BNE V0, ZERO, 0x9D0067E4
9D00654C  8FBF004C   LW RA, 76(SP)
2247:                					dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
9D006550  8FA40010   LW A0, 16(SP)
9D006554  2673FFFF   ADDIU S3, S3, -1
9D006558  AC93000C   SW S3, 12(A0)
2248:                					res = move_window(dj.fs, dw);
9D00655C  0F4012F8   JAL move_window
9D006560  02802821   ADDU A1, S4, ZERO
9D006564  0B40196B   J 0x9D0065AC
9D006568  00000000   NOP
2249:                				}
2250:                			}
2251:                		}
2252:                	} else { /* Open an existing file */
2253:                		if (res == FR_OK) { /* Follow succeeded */
9D00656C  1440009D   BNE V0, ZERO, 0x9D0067E4
9D006570  8FBF004C   LW RA, 76(SP)
2254:                			if (dir[DIR_Attr] & AM_DIR) { /* It is a directory */
9D006574  9203000B   LBU V1, 11(S0)
9D006578  30640010   ANDI A0, V1, 16
9D00657C  308400FF   ANDI A0, A0, 255
9D006580  14800097   BNE A0, ZERO, 0x9D0067E0
9D006584  24020004   ADDIU V0, ZERO, 4
2255:                				res = FR_NO_FILE;
2256:                			} else {
2257:                				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
9D006588  32730002   ANDI S3, S3, 2
9D00658C  327300FF   ANDI S3, S3, 255
9D006590  52600009   BEQL S3, ZERO, 0x9D0065B8
9D006594  32430008   ANDI V1, S2, 8
9D006598  30630001   ANDI V1, V1, 1
9D00659C  14600090   BNE V1, ZERO, 0x9D0067E0
9D0065A0  24020007   ADDIU V0, ZERO, 7
9D0065A4  0B40196E   J 0x9D0065B8
9D0065A8  32430008   ANDI V1, S2, 8
2258:                					res = FR_DENIED;
2259:                			}
2260:                		}
2261:                	}
2262:                	if (res == FR_OK) {
9D0065AC  1440008D   BNE V0, ZERO, 0x9D0067E4
9D0065B0  8FBF004C   LW RA, 76(SP)
2263:                		if (mode & FA_CREATE_ALWAYS) /* Set file change flag if created or overwritten */
9D0065B4  32430008   ANDI V1, S2, 8
9D0065B8  306300FF   ANDI V1, V1, 255
2264:                			mode |= FA__WRITTEN;
9D0065BC  36420020   ORI V0, S2, 32
9D0065C0  0043900B   MOVN S2, V0, V1
2265:                		fp->dir_sect = dj.fs->winsect; /* Pointer to the directory entry */
9D0065C4  8FA40010   LW A0, 16(SP)
9D0065C8  8C820030   LW V0, 48(A0)
9D0065CC  AE22001C   SW V0, 28(S1)
2266:                		fp->dir_ptr = dir;
9D0065D0  AE300020   SW S0, 32(S1)
2267:                #if _FS_SHARE
2268:                		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
9D0065D4  2402FFFE   ADDIU V0, ZERO, -2
9D0065D8  02424824   AND T1, S2, V0
9D006674  0B4019D6   J 0x9D006758
9D006678  AE200028   SW ZERO, 40(S1)
9D0066D8  0B4019D6   J 0x9D006758
9D0066DC  AE200028   SW ZERO, 40(S1)
9D006720  AE230028   SW V1, 40(S1)
9D006754  AE200028   SW ZERO, 40(S1)
2269:                		if (!fp->lockid) res = FR_INT_ERR;
9D006724  1060002E   BEQ V1, ZERO, 0x9D0067E0
9D006728  24020002   ADDIU V0, ZERO, 2
9D00672C  0B4019D8   J 0x9D006760
9D006730  A2320006   SB S2, 6(S1)
9D006758  0B4019F8   J 0x9D0067E0
9D00675C  24020002   ADDIU V0, ZERO, 2
2270:                #endif
2271:                	}
2272:                
2273:                #else				/* R/O configuration */
2274:                	if (res == FR_OK) { /* Follow succeeded */
2275:                		if (!dir) { /* Current dir itself */
2276:                			res = FR_INVALID_NAME;
2277:                		} else {
2278:                			if (dir[DIR_Attr] & AM_DIR) /* It is a directory */
2279:                			res = FR_NO_FILE;
2280:                		}
2281:                	}
2282:                #endif
2283:                	FREE_BUF();
2284:                
2285:                	if (res == FR_OK) {
2286:                		fp->flag = mode; /* File access mode */
2287:                		fp->sclust = LD_CLUST(dir); /* File start cluster */
9D006760  92030015   LBU V1, 21(S0)
9D006764  00031A00   SLL V1, V1, 8
9D006768  92020014   LBU V0, 20(S0)
9D00676C  00621825   OR V1, V1, V0
9D006770  00031C00   SLL V1, V1, 16
9D006774  9204001B   LBU A0, 27(S0)
9D006778  00042200   SLL A0, A0, 8
9D00677C  9202001A   LBU V0, 26(S0)
9D006780  00821025   OR V0, A0, V0
9D006784  00621025   OR V0, V1, V0
9D006788  AE220010   SW V0, 16(S1)
2288:                		fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
9D00678C  9203001F   LBU V1, 31(S0)
9D006790  00031E00   SLL V1, V1, 24
9D006794  9202001E   LBU V0, 30(S0)
9D006798  00021400   SLL V0, V0, 16
9D00679C  00621825   OR V1, V1, V0
9D0067A0  9202001C   LBU V0, 28(S0)
9D0067A4  00621825   OR V1, V1, V0
9D0067A8  9202001D   LBU V0, 29(S0)
9D0067AC  00021200   SLL V0, V0, 8
9D0067B0  00621025   OR V0, V1, V0
9D0067B4  AE22000C   SW V0, 12(S1)
2289:                		fp->fptr = 0; /* File pointer */
9D0067B8  AE200008   SW ZERO, 8(S1)
2290:                		fp->dsect = 0;
9D0067BC  AE200018   SW ZERO, 24(S1)
2291:                #if _USE_FASTSEEK
2292:                		fp->cltbl = 0; /* Normal seek mode */
9D0067C0  AE200024   SW ZERO, 36(S1)
2293:                #endif
2294:                		fp->fs = dj.fs;
9D0067C4  8FA20010   LW V0, 16(SP)
9D0067C8  AE220000   SW V0, 0(S1)
2295:                		fp->id = dj.fs->id; /* Validate file object */
9D0067CC  94420006   LHU V0, 6(V0)
9D0067D0  A6220004   SH V0, 4(S1)
9D0067D4  0B4019F8   J 0x9D0067E0
9D0067D8  00001021   ADDU V0, ZERO, ZERO
2296:                	}
2297:                
2298:                	LEAVE_FF(dj.fs, res);
2299:                }
9D0067E0  8FBF004C   LW RA, 76(SP)
9D0067E4  8FB40048   LW S4, 72(SP)
9D0067E8  8FB30044   LW S3, 68(SP)
9D0067EC  8FB20040   LW S2, 64(SP)
9D0067F0  8FB1003C   LW S1, 60(SP)
9D0067F4  8FB00038   LW S0, 56(SP)
9D0067F8  03E00008   JR RA
9D0067FC  27BD0050   ADDIU SP, SP, 80
2300:                
2301:                /*-----------------------------------------------------------------------*/
2302:                /* Read File                                                             */
2303:                /*-----------------------------------------------------------------------*/
2304:                
2305:                FRESULT f_read(FIL *fp, /* Pointer to the file object */
2306:                                void *buff, /* Pointer to data buffer */
2307:                                UINT btr, /* Number of bytes to read */
2308:                                UINT *br /* Pointer to number of bytes read */
2309:                                ) {
9D006800  27BDFFC8   ADDIU SP, SP, -56
9D006804  AFBF0034   SW RA, 52(SP)
9D006808  AFBE0030   SW S8, 48(SP)
9D00680C  AFB7002C   SW S7, 44(SP)
9D006810  AFB60028   SW S6, 40(SP)
9D006814  AFB50024   SW S5, 36(SP)
9D006818  AFB40020   SW S4, 32(SP)
9D00681C  AFB3001C   SW S3, 28(SP)
9D006820  AFB20018   SW S2, 24(SP)
9D006824  AFB10014   SW S1, 20(SP)
9D006828  AFB00010   SW S0, 16(SP)
9D00682C  00808021   ADDU S0, A0, ZERO
9D006830  00A09821   ADDU S3, A1, ZERO
9D006834  00C0A021   ADDU S4, A2, ZERO
9D006838  00E09021   ADDU S2, A3, ZERO
2310:                	FRESULT res;
2311:                	DWORD clst, sect, remain;
2312:                	UINT rcnt, cc;
2313:                	PF_BYTE csect, *rbuff = buff;
2314:                
2315:                	*br = 0; /* Initialize byte counter */
9D00683C  ACE00000   SW ZERO, 0(A3)
2316:                
2317:                	res = validate(fp->fs, fp->id); /* Check validity */
9D006840  8C840000   LW A0, 0(A0)
9D006844  0F401370   JAL validate
9D006848  96050004   LHU A1, 4(S0)
9D00684C  00401821   ADDU V1, V0, ZERO
2318:                	if (res != FR_OK)
9D006850  1460008C   BNE V1, ZERO, 0x9D006A84
9D006854  8FBF0034   LW RA, 52(SP)
2319:                		LEAVE_FF(fp->fs, res);
2320:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D006858  92030006   LBU V1, 6(S0)
9D00685C  7C032420   SEB A0, V1
9D006860  04800087   BLTZ A0, 0x9D006A80
9D006864  24020002   ADDIU V0, ZERO, 2
2321:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2322:                	if (!(fp->flag & FA_READ)) /* Check access mode */
9D006868  30630001   ANDI V1, V1, 1
9D00686C  10600084   BEQ V1, ZERO, 0x9D006A80
9D006870  24020007   ADDIU V0, ZERO, 7
2323:                		LEAVE_FF(fp->fs, FR_DENIED);
2324:                	remain = fp->fsize - fp->fptr;
9D006874  8E11000C   LW S1, 12(S0)
9D006878  8E020008   LW V0, 8(S0)
9D00687C  02228823   SUBU S1, S1, V0
9D006880  0234102B   SLTU V0, S1, S4
9D006884  0282880A   MOVZ S1, S4, V0
2325:                	if (btr > remain)
2326:                		btr = (UINT) remain; /* Truncate btr by remaining bytes */
2327:                
2328:                	for (;btr; /* Repeat until all data read */
9D006888  1220007C   BEQ S1, ZERO, 0x9D006A7C
9D00688C  241E0200   ADDIU S8, ZERO, 512
9D006A6C  1620FF88   BNE S1, ZERO, 0x9D006890
9D006A70  AE420000   SW V0, 0(S2)
9D006A74  0B401AA0   J 0x9D006A80
9D006A78  00001021   ADDU V0, ZERO, ZERO
9D006A7C  00001021   ADDU V0, ZERO, ZERO
2329:                	rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
9D006A50  02749821   ADDU S3, S3, S4
9D006A54  8E020008   LW V0, 8(S0)
9D006A58  00541021   ADDU V0, V0, S4
9D006A5C  AE020008   SW V0, 8(S0)
9D006A60  8E420000   LW V0, 0(S2)
9D006A64  00541021   ADDU V0, V0, S4
9D006A68  02348823   SUBU S1, S1, S4
2330:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D006890  8E050008   LW A1, 8(S0)
9D006894  30A201FF   ANDI V0, A1, 511
9D006898  54400057   BNEL V0, ZERO, 0x9D0069F8
9D00689C  8E140008   LW S4, 8(S0)
2331:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D0068A0  8E040000   LW A0, 0(S0)
9D0068A4  0005AA42   SRL S5, A1, 9
9D0068A8  90820002   LBU V0, 2(A0)
9D0068AC  2442FFFF   ADDIU V0, V0, -1
9D0068B0  02A2A824   AND S5, S5, V0
9D0068B4  32B500FF   ANDI S5, S5, 255
2332:                			if (!csect) { /* On the cluster boundary? */
9D0068B8  56A0001F   BNEL S5, ZERO, 0x9D006938
9D0068BC  8E160000   LW S6, 0(S0)
2333:                				if (fp->fptr == 0) { /* On the top of the file? */
9D0068C0  54A00003   BNEL A1, ZERO, 0x9D0068D0
9D0068C4  8E020024   LW V0, 36(S0)
9D0068C8  0B401A3C   J 0x9D0068F0
9D0068CC  8E020010   LW V0, 16(S0)
2334:                					clst = fp->sclust; /* Follow from the origin */
2335:                				} else { /* Middle or end of the file */
2336:                #if _USE_FASTSEEK
2337:                					if (fp->cltbl)
9D0068D0  10400005   BEQ V0, ZERO, 0x9D0068E8
9D0068D4  00000000   NOP
2338:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D0068D8  0F401292   JAL clmt_clust
9D0068DC  02002021   ADDU A0, S0, ZERO
9D0068E0  0B401A3D   J 0x9D0068F4
9D0068E4  2C430002   SLTIU V1, V0, 2
2339:                					else
2340:                #endif
2341:                						clst = get_fat(fp->fs, fp->clust); /* Follow cluster chain on the FAT */
9D0068E8  0F4013D7   JAL get_fat
9D0068EC  8E050014   LW A1, 20(S0)
2342:                				}
2343:                				if (clst < 2)
9D0068F0  2C430002   SLTIU V1, V0, 2
9D0068F4  10600007   BEQ V1, ZERO, 0x9D006914
9D0068F8  2403FFFF   ADDIU V1, ZERO, -1
2344:                					ABORT(fp->fs, FR_INT_ERR);
9D0068FC  92030006   LBU V1, 6(S0)
9D006900  2402FF80   ADDIU V0, ZERO, -128
9D006904  00621025   OR V0, V1, V0
9D006908  A2020006   SB V0, 6(S0)
9D00690C  0B401AA0   J 0x9D006A80
9D006910  24020002   ADDIU V0, ZERO, 2
2345:                				if (clst == 0xFFFFFFFF)
9D006914  54430007   BNEL V0, V1, 0x9D006934
9D006918  AE020014   SW V0, 20(S0)
2346:                					ABORT(fp->fs, FR_DISK_ERR);
9D00691C  92030006   LBU V1, 6(S0)
9D006920  2402FF80   ADDIU V0, ZERO, -128
9D006924  00621025   OR V0, V1, V0
9D006928  A2020006   SB V0, 6(S0)
9D00692C  0B401AA0   J 0x9D006A80
9D006930  24020001   ADDIU V0, ZERO, 1
2347:                				fp->clust = clst; /* Update current cluster */
2348:                			}
2349:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D006934  8E160000   LW S6, 0(S0)
9D006938  02C02021   ADDU A0, S6, ZERO
9D00693C  0F4013CB   JAL clust2sect
9D006940  8E050014   LW A1, 20(S0)
2350:                			if (!sect)
9D006944  14400007   BNE V0, ZERO, 0x9D006964
9D006948  0011A242   SRL S4, S1, 9
2351:                				ABORT(fp->fs, FR_INT_ERR);
9D00694C  92030006   LBU V1, 6(S0)
9D006950  2402FF80   ADDIU V0, ZERO, -128
9D006954  00621025   OR V0, V1, V0
9D006958  A2020006   SB V0, 6(S0)
9D00695C  0B401AA0   J 0x9D006A80
9D006960  24020002   ADDIU V0, ZERO, 2
2352:                			sect += csect;
2353:                			cc = btr / SS(fp->fs); /* When remaining bytes >= sector size, */
2354:                			if (cc) { /* Read maximum contiguous sectors directly */
9D006964  12800022   BEQ S4, ZERO, 0x9D0069F0
9D006968  0055B821   ADDU S7, V0, S5
2355:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D00696C  92C20002   LBU V0, 2(S6)
9D006970  02951821   ADDU V1, S4, S5
9D006974  0043182B   SLTU V1, V0, V1
2356:                					cc = fp->fs->csize - csect;
9D006978  0055A823   SUBU S5, V0, S5
9D00697C  02A3A00B   MOVN S4, S5, V1
2357:                				if (disk_read(fp->fs->drv, rbuff, sect, (PF_BYTE) cc) != RES_OK)
9D006980  92C40001   LBU A0, 1(S6)
9D006984  02602821   ADDU A1, S3, ZERO
9D006988  02E03021   ADDU A2, S7, ZERO
9D00698C  0F40415F   JAL disk_read
9D006990  328700FF   ANDI A3, S4, 255
9D006994  50400007   BEQL V0, ZERO, 0x9D0069B4
9D006998  8E050000   LW A1, 0(S0)
2358:                					ABORT(fp->fs, FR_DISK_ERR);
9D00699C  92030006   LBU V1, 6(S0)
9D0069A0  2402FF80   ADDIU V0, ZERO, -128
9D0069A4  00621025   OR V0, V1, V0
9D0069A8  A2020006   SB V0, 6(S0)
9D0069AC  0B401AA0   J 0x9D006A80
9D0069B0  24020001   ADDIU V0, ZERO, 1
2359:                #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
2360:                #if _FS_TINY
2361:                				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
9D0069B4  90A20004   LBU V0, 4(A1)
9D0069B8  50400025   BEQL V0, ZERO, 0x9D006A50
9D0069BC  0014A240   SLL S4, S4, 9
9D0069C0  8CA20030   LW V0, 48(A1)
9D0069C4  0057B823   SUBU S7, V0, S7
9D0069C8  02F4102B   SLTU V0, S7, S4
9D0069CC  50400020   BEQL V0, ZERO, 0x9D006A50
9D0069D0  0014A240   SLL S4, S4, 9
2362:                				mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
9D0069D4  00172240   SLL A0, S7, 9
9D0069D8  02642021   ADDU A0, S3, A0
9D0069DC  24A50034   ADDIU A1, A1, 52
9D0069E0  0F401259   JAL mem_cpy
9D0069E4  03C03021   ADDU A2, S8, ZERO
2363:                #else
2364:                				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
2365:                					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf,
2366:                							SS(fp->fs));
2367:                #endif
2368:                #endif
2369:                				rcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2370:                				continue;
9D0069E8  0B401A94   J 0x9D006A50
9D0069EC  0014A240   SLL S4, S4, 9
2371:                			}
2372:                #if !_FS_TINY
2373:                			if (fp->dsect != sect) { /* Load data sector if not in cache */
2374:                #if !_FS_READONLY
2375:                				if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2376:                					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2377:                							!= RES_OK)
2378:                						ABORT(fp->fs, FR_DISK_ERR);
2379:                					fp->flag &= ~FA__DIRTY;
2380:                				}
2381:                #endif
2382:                				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK) /* Fill sector cache */
2383:                					ABORT(fp->fs, FR_DISK_ERR);
2384:                			}
2385:                #endif
2386:                			fp->dsect = sect;
9D0069F0  AE170018   SW S7, 24(S0)
2387:                		}
2388:                		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs)); /* Get partial sector data from sector buffer */
9D0069F4  8E140008   LW S4, 8(S0)
9D0069F8  329401FF   ANDI S4, S4, 511
9D0069FC  03D4A023   SUBU S4, S8, S4
9D006A00  0291102B   SLTU V0, S4, S1
9D006A04  0222A00A   MOVZ S4, S1, V0
2389:                		if (rcnt > btr)
2390:                			rcnt = btr;
2391:                #if _FS_TINY
2392:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D006A08  8E040000   LW A0, 0(S0)
9D006A0C  0F4012F8   JAL move_window
9D006A10  8E050018   LW A1, 24(S0)
9D006A14  50400007   BEQL V0, ZERO, 0x9D006A34
9D006A18  8E050008   LW A1, 8(S0)
2393:                		ABORT(fp->fs, FR_DISK_ERR);
9D006A1C  92030006   LBU V1, 6(S0)
9D006A20  2402FF80   ADDIU V0, ZERO, -128
9D006A24  00621025   OR V0, V1, V0
9D006A28  A2020006   SB V0, 6(S0)
9D006A2C  0B401AA0   J 0x9D006A80
9D006A30  24020001   ADDIU V0, ZERO, 1
2394:                		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
9D006A34  30A501FF   ANDI A1, A1, 511
9D006A38  8E020000   LW V0, 0(S0)
9D006A3C  00452821   ADDU A1, V0, A1
9D006A40  02602021   ADDU A0, S3, ZERO
9D006A44  24A50034   ADDIU A1, A1, 52
9D006A48  0F401259   JAL mem_cpy
9D006A4C  02803021   ADDU A2, S4, ZERO
2395:                #else
2396:                		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt); /* Pick partial sector */
2397:                #endif
2398:                	}
2399:                
2400:                	LEAVE_FF(fp->fs, FR_OK);
2401:                }
9D006A80  8FBF0034   LW RA, 52(SP)
9D006A84  8FBE0030   LW S8, 48(SP)
9D006A88  8FB7002C   LW S7, 44(SP)
9D006A8C  8FB60028   LW S6, 40(SP)
9D006A90  8FB50024   LW S5, 36(SP)
9D006A94  8FB40020   LW S4, 32(SP)
9D006A98  8FB3001C   LW S3, 28(SP)
9D006A9C  8FB20018   LW S2, 24(SP)
9D006AA0  8FB10014   LW S1, 20(SP)
9D006AA4  8FB00010   LW S0, 16(SP)
9D006AA8  03E00008   JR RA
9D006AAC  27BD0038   ADDIU SP, SP, 56
2402:                
2403:                #if !_FS_READONLY
2404:                /*-----------------------------------------------------------------------*/
2405:                /* Write File                                                            */
2406:                /*-----------------------------------------------------------------------*/
2407:                
2408:                FRESULT f_write(FIL *fp, /* Pointer to the file object */
2409:                                const void *buff, /* Pointer to the data to be written */
2410:                                UINT btw, /* Number of bytes to write */
2411:                                UINT *bw /* Pointer to number of bytes written */
2412:                                ) {
9D006AB0  27BDFFC8   ADDIU SP, SP, -56
9D006AB4  AFBF0034   SW RA, 52(SP)
9D006AB8  AFBE0030   SW S8, 48(SP)
9D006ABC  AFB7002C   SW S7, 44(SP)
9D006AC0  AFB60028   SW S6, 40(SP)
9D006AC4  AFB50024   SW S5, 36(SP)
9D006AC8  AFB40020   SW S4, 32(SP)
9D006ACC  AFB3001C   SW S3, 28(SP)
9D006AD0  AFB20018   SW S2, 24(SP)
9D006AD4  AFB10014   SW S1, 20(SP)
9D006AD8  AFB00010   SW S0, 16(SP)
9D006ADC  00808021   ADDU S0, A0, ZERO
9D006AE0  00A09821   ADDU S3, A1, ZERO
9D006AE4  00C08821   ADDU S1, A2, ZERO
9D006AE8  00E09021   ADDU S2, A3, ZERO
2413:                	FRESULT res;
2414:                	DWORD clst, sect;
2415:                	UINT wcnt, cc;
2416:                	const PF_BYTE *wbuff = buff;
2417:                	PF_BYTE csect;
2418:                
2419:                	*bw = 0; /* Initialize byte counter */
9D006AEC  ACE00000   SW ZERO, 0(A3)
2420:                
2421:                	res = validate(fp->fs, fp->id); /* Check validity */
9D006AF0  8C840000   LW A0, 0(A0)
9D006AF4  0F401370   JAL validate
9D006AF8  96050004   LHU A1, 4(S0)
9D006AFC  00401821   ADDU V1, V0, ZERO
2422:                	if (res != FR_OK)
9D006B00  146000BA   BNE V1, ZERO, 0x9D006DEC
9D006B04  8FBF0034   LW RA, 52(SP)
2423:                		LEAVE_FF(fp->fs, res);
2424:                	if (fp->flag & FA__ERROR) /* Aborted file? */
9D006B08  92030006   LBU V1, 6(S0)
9D006B0C  7C032420   SEB A0, V1
9D006B10  048000B5   BLTZ A0, 0x9D006DE8
9D006B14  24020002   ADDIU V0, ZERO, 2
2425:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2426:                	if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D006B18  30630002   ANDI V1, V1, 2
9D006B1C  306300FF   ANDI V1, V1, 255
9D006B20  106000B1   BEQ V1, ZERO, 0x9D006DE8
9D006B24  24020007   ADDIU V0, ZERO, 7
2427:                		LEAVE_FF(fp->fs, FR_DENIED);
2428:                	if ((DWORD) (fp->fsize + btw) < fp->fsize)
9D006B28  8E02000C   LW V0, 12(S0)
9D006B2C  02221821   ADDU V1, S1, V0
9D006B30  0062102B   SLTU V0, V1, V0
9D006B34  544000A4   BNEL V0, ZERO, 0x9D006DC8
9D006B38  8E020008   LW V0, 8(S0)
2429:                		btw = 0; /* File size cannot reach 4GB */
2430:                
2431:                	for (; btw; /* Repeat until all data written */
9D006B3C  122000A1   BEQ S1, ZERO, 0x9D006DC4
9D006B40  241E0200   ADDIU S8, ZERO, 512
9D006DBC  1620FF61   BNE S1, ZERO, 0x9D006B44
9D006DC0  AE420000   SW V0, 0(S2)
2432:                	wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
9D006DA0  02749821   ADDU S3, S3, S4
9D006DA4  8E020008   LW V0, 8(S0)
9D006DA8  00541021   ADDU V0, V0, S4
9D006DAC  AE020008   SW V0, 8(S0)
9D006DB0  8E420000   LW V0, 0(S2)
9D006DB4  00541021   ADDU V0, V0, S4
9D006DB8  02348823   SUBU S1, S1, S4
2433:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
9D006B44  8E050008   LW A1, 8(S0)
9D006B48  30A201FF   ANDI V0, A1, 511
9D006B4C  5440007B   BNEL V0, ZERO, 0x9D006D3C
9D006B50  8E140008   LW S4, 8(S0)
2434:                			csect = (PF_BYTE) (fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
9D006B54  8E040000   LW A0, 0(S0)
9D006B58  0005AA42   SRL S5, A1, 9
9D006B5C  90820002   LBU V0, 2(A0)
9D006B60  2442FFFF   ADDIU V0, V0, -1
9D006B64  02A2A824   AND S5, S5, V0
9D006B68  32B500FF   ANDI S5, S5, 255
2435:                			if (!csect) { /* On the cluster boundary? */
9D006B6C  56A00026   BNEL S5, ZERO, 0x9D006C08
9D006B70  8C830030   LW V1, 48(A0)
2436:                				if (fp->fptr == 0) { /* On the top of the file? */
9D006B74  54A00008   BNEL A1, ZERO, 0x9D006B98
9D006B78  8E020024   LW V0, 36(S0)
2437:                					clst = fp->sclust; /* Follow from the origin */
9D006B7C  8E020010   LW V0, 16(S0)
2438:                					if (clst == 0) /* When no cluster is allocated, */
9D006B80  1440000F   BNE V0, ZERO, 0x9D006BC0
9D006B84  24030001   ADDIU V1, ZERO, 1
2439:                						fp->sclust = clst = create_chain(fp->fs, 0); /* Create a new cluster chain */
9D006B88  0F40150D   JAL create_chain
9D006B8C  00000000   NOP
9D006B90  0B401AEE   J 0x9D006BB8
9D006B94  AE020010   SW V0, 16(S0)
2440:                				} else { /* Middle or end of the file */
2441:                #if _USE_FASTSEEK
2442:                					if (fp->cltbl)
9D006B98  10400005   BEQ V0, ZERO, 0x9D006BB0
9D006B9C  00000000   NOP
2443:                						clst = clmt_clust(fp, fp->fptr); /* Get cluster# from the CLMT */
9D006BA0  0F401292   JAL clmt_clust
9D006BA4  02002021   ADDU A0, S0, ZERO
9D006BA8  0B401AEE   J 0x9D006BB8
9D006BAC  00000000   NOP
2444:                					else
2445:                #endif
2446:                						clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
9D006BB0  0F40150D   JAL create_chain
9D006BB4  8E050014   LW A1, 20(S0)
2447:                				}
2448:                				if (clst == 0)
9D006BB8  10400082   BEQ V0, ZERO, 0x9D006DC4
9D006BBC  24030001   ADDIU V1, ZERO, 1
2449:                					break; /* Could not allocate a new cluster (disk full) */
2450:                				if (clst == 1)
9D006BC0  14430007   BNE V0, V1, 0x9D006BE0
9D006BC4  2403FFFF   ADDIU V1, ZERO, -1
2451:                					ABORT(fp->fs, FR_INT_ERR);
9D006BC8  92030006   LBU V1, 6(S0)
9D006BCC  2402FF80   ADDIU V0, ZERO, -128
9D006BD0  00621025   OR V0, V1, V0
9D006BD4  A2020006   SB V0, 6(S0)
9D006BD8  0B401B7A   J 0x9D006DE8
9D006BDC  24020002   ADDIU V0, ZERO, 2
2452:                				if (clst == 0xFFFFFFFF)
9D006BE0  54430007   BNEL V0, V1, 0x9D006C00
9D006BE4  AE020014   SW V0, 20(S0)
2453:                					ABORT(fp->fs, FR_DISK_ERR);
9D006BE8  92030006   LBU V1, 6(S0)
9D006BEC  2402FF80   ADDIU V0, ZERO, -128
9D006BF0  00621025   OR V0, V1, V0
9D006BF4  A2020006   SB V0, 6(S0)
9D006BF8  0B401B7A   J 0x9D006DE8
9D006BFC  24020001   ADDIU V0, ZERO, 1
2454:                				fp->clust = clst; /* Update current cluster */
2455:                			}
2456:                #if _FS_TINY
2457:                			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0)) /* Write-back sector cache */
9D006C00  8E040000   LW A0, 0(S0)
9D006C04  8C830030   LW V1, 48(A0)
9D006C08  8E020018   LW V0, 24(S0)
9D006C0C  5462000B   BNEL V1, V0, 0x9D006C3C
9D006C10  8E160000   LW S6, 0(S0)
9D006C14  0F4012F8   JAL move_window
9D006C18  00002821   ADDU A1, ZERO, ZERO
9D006C1C  50400007   BEQL V0, ZERO, 0x9D006C3C
9D006C20  8E160000   LW S6, 0(S0)
2458:                			ABORT(fp->fs, FR_DISK_ERR);
9D006C24  92030006   LBU V1, 6(S0)
9D006C28  2402FF80   ADDIU V0, ZERO, -128
9D006C2C  00621025   OR V0, V1, V0
9D006C30  A2020006   SB V0, 6(S0)
9D006C34  0B401B7A   J 0x9D006DE8
9D006C38  24020001   ADDIU V0, ZERO, 1
2459:                #else
2460:                			if (fp->flag & FA__DIRTY) { /* Write-back sector cache */
2461:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2462:                					ABORT(fp->fs, FR_DISK_ERR);
2463:                				fp->flag &= ~FA__DIRTY;
2464:                			}
2465:                #endif
2466:                			sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
9D006C3C  02C02021   ADDU A0, S6, ZERO
9D006C40  0F4013CB   JAL clust2sect
9D006C44  8E050014   LW A1, 20(S0)
2467:                			if (!sect)
9D006C48  14400007   BNE V0, ZERO, 0x9D006C68
9D006C4C  0011A242   SRL S4, S1, 9
2468:                				ABORT(fp->fs, FR_INT_ERR);
9D006C50  92030006   LBU V1, 6(S0)
9D006C54  2402FF80   ADDIU V0, ZERO, -128
9D006C58  00621025   OR V0, V1, V0
9D006C5C  A2020006   SB V0, 6(S0)
9D006C60  0B401B7A   J 0x9D006DE8
9D006C64  24020002   ADDIU V0, ZERO, 2
2469:                			sect += csect;
2470:                			cc = btw / SS(fp->fs); /* When remaining bytes >= sector size, */
2471:                			if (cc) { /* Write maximum contiguous sectors directly */
9D006C68  12800021   BEQ S4, ZERO, 0x9D006CF0
9D006C6C  0055B821   ADDU S7, V0, S5
2472:                				if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
9D006C70  92C20002   LBU V0, 2(S6)
9D006C74  02951821   ADDU V1, S4, S5
9D006C78  0043182B   SLTU V1, V0, V1
2473:                					cc = fp->fs->csize - csect;
9D006C7C  0055A823   SUBU S5, V0, S5
9D006C80  02A3A00B   MOVN S4, S5, V1
2474:                				if (disk_write(fp->fs->drv, wbuff, sect, (PF_BYTE) cc)
9D006C84  92C40001   LBU A0, 1(S6)
9D006C88  02602821   ADDU A1, S3, ZERO
9D006C8C  02E03021   ADDU A2, S7, ZERO
9D006C90  0F404196   JAL disk_write
9D006C94  328700FF   ANDI A3, S4, 255
9D006C98  50400007   BEQL V0, ZERO, 0x9D006CB8
9D006C9C  8E040000   LW A0, 0(S0)
2475:                						!= RES_OK)
2476:                					ABORT(fp->fs, FR_DISK_ERR);
9D006CA0  92030006   LBU V1, 6(S0)
9D006CA4  2402FF80   ADDIU V0, ZERO, -128
9D006CA8  00621025   OR V0, V1, V0
9D006CAC  A2020006   SB V0, 6(S0)
9D006CB0  0B401B7A   J 0x9D006DE8
9D006CB4  24020001   ADDIU V0, ZERO, 1
2477:                #if _FS_TINY
2478:                				if (fp->fs->winsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
9D006CB8  8C820030   LW V0, 48(A0)
9D006CBC  0057B823   SUBU S7, V0, S7
9D006CC0  02F4102B   SLTU V0, S7, S4
9D006CC4  50400036   BEQL V0, ZERO, 0x9D006DA0
9D006CC8  0014A240   SLL S4, S4, 9
2479:                					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
9D006CCC  00172A40   SLL A1, S7, 9
9D006CD0  24840034   ADDIU A0, A0, 52
9D006CD4  02652821   ADDU A1, S3, A1
9D006CD8  0F401259   JAL mem_cpy
9D006CDC  03C03021   ADDU A2, S8, ZERO
2480:                					fp->fs->wflag = 0;
9D006CE0  8E020000   LW V0, 0(S0)
9D006CE4  A0400004   SB ZERO, 4(V0)
2481:                				}
2482:                #else
2483:                				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
2484:                					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)),
2485:                							SS(fp->fs));
2486:                					fp->flag &= ~FA__DIRTY;
2487:                				}
2488:                #endif
2489:                				wcnt = SS(fp->fs) * cc; /* Number of bytes transferred */
2490:                				continue;
9D006CE8  0B401B68   J 0x9D006DA0
9D006CEC  0014A240   SLL S4, S4, 9
2491:                			}
2492:                #if _FS_TINY
2493:                			if (fp->fptr >= fp->fsize) { /* Avoid silly cache filling at growing edge */
9D006CF0  8E030008   LW V1, 8(S0)
9D006CF4  8E02000C   LW V0, 12(S0)
9D006CF8  0062102B   SLTU V0, V1, V0
9D006CFC  5440000E   BNEL V0, ZERO, 0x9D006D38
9D006D00  AE170018   SW S7, 24(S0)
2494:                				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
9D006D04  02C02021   ADDU A0, S6, ZERO
9D006D08  0F4012F8   JAL move_window
9D006D0C  00002821   ADDU A1, ZERO, ZERO
9D006D10  50400007   BEQL V0, ZERO, 0x9D006D30
9D006D14  8E020000   LW V0, 0(S0)
9D006D18  92030006   LBU V1, 6(S0)
9D006D1C  2402FF80   ADDIU V0, ZERO, -128
9D006D20  00621025   OR V0, V1, V0
9D006D24  A2020006   SB V0, 6(S0)
9D006D28  0B401B7A   J 0x9D006DE8
9D006D2C  24020001   ADDIU V0, ZERO, 1
2495:                				fp->fs->winsect = sect;
9D006D30  AC570030   SW S7, 48(V0)
2496:                			}
2497:                #else
2498:                			if (fp->dsect != sect) { /* Fill sector cache with file data */
2499:                				if (fp->fptr < fp->fsize && disk_read(fp->fs->drv, fp->buf,
2500:                						sect, 1) != RES_OK)
2501:                					ABORT(fp->fs, FR_DISK_ERR);
2502:                			}
2503:                #endif
2504:                			fp->dsect = sect;
9D006D34  AE170018   SW S7, 24(S0)
2505:                		}
2506:                		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
9D006D38  8E140008   LW S4, 8(S0)
9D006D3C  329401FF   ANDI S4, S4, 511
9D006D40  03D4A023   SUBU S4, S8, S4
9D006D44  0291102B   SLTU V0, S4, S1
9D006D48  0222A00A   MOVZ S4, S1, V0
2507:                		if (wcnt > btw)
2508:                			wcnt = btw;
2509:                #if _FS_TINY
2510:                		if (move_window(fp->fs, fp->dsect)) /* Move sector window */
9D006D4C  8E040000   LW A0, 0(S0)
9D006D50  0F4012F8   JAL move_window
9D006D54  8E050018   LW A1, 24(S0)
9D006D58  50400007   BEQL V0, ZERO, 0x9D006D78
9D006D5C  8E040008   LW A0, 8(S0)
2511:                		ABORT(fp->fs, FR_DISK_ERR);
9D006D60  92030006   LBU V1, 6(S0)
9D006D64  2402FF80   ADDIU V0, ZERO, -128
9D006D68  00621025   OR V0, V1, V0
9D006D6C  A2020006   SB V0, 6(S0)
9D006D70  0B401B7A   J 0x9D006DE8
9D006D74  24020001   ADDIU V0, ZERO, 1
2512:                		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
9D006D78  308401FF   ANDI A0, A0, 511
9D006D7C  8E020000   LW V0, 0(S0)
9D006D80  00442021   ADDU A0, V0, A0
9D006D84  24840034   ADDIU A0, A0, 52
9D006D88  02602821   ADDU A1, S3, ZERO
9D006D8C  0F401259   JAL mem_cpy
9D006D90  02803021   ADDU A2, S4, ZERO
2513:                		fp->fs->wflag = 1;
9D006D94  8E020000   LW V0, 0(S0)
9D006D98  24030001   ADDIU V1, ZERO, 1
9D006D9C  A0430004   SB V1, 4(V0)
2514:                #else
2515:                		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt); /* Fit partial sector */
2516:                		fp->flag |= FA__DIRTY;
2517:                #endif
2518:                	}
2519:                
2520:                	if (fp->fptr > fp->fsize)
9D006DC4  8E020008   LW V0, 8(S0)
9D006DC8  8E03000C   LW V1, 12(S0)
9D006DCC  0062182B   SLTU V1, V1, V0
9D006DD0  54600001   BNEL V1, ZERO, 0x9D006DD8
9D006DD4  AE02000C   SW V0, 12(S0)
2521:                		fp->fsize = fp->fptr; /* Update file size if needed */
2522:                	fp->flag |= FA__WRITTEN; /* Set file change flag */
9D006DD8  92020006   LBU V0, 6(S0)
9D006DDC  34420020   ORI V0, V0, 32
9D006DE0  A2020006   SB V0, 6(S0)
2523:                
2524:                	LEAVE_FF(fp->fs, FR_OK);
9D006DE4  00001021   ADDU V0, ZERO, ZERO
2525:                }
9D006DE8  8FBF0034   LW RA, 52(SP)
9D006DEC  8FBE0030   LW S8, 48(SP)
9D006DF0  8FB7002C   LW S7, 44(SP)
9D006DF4  8FB60028   LW S6, 40(SP)
9D006DF8  8FB50024   LW S5, 36(SP)
9D006DFC  8FB40020   LW S4, 32(SP)
9D006E00  8FB3001C   LW S3, 28(SP)
9D006E04  8FB20018   LW S2, 24(SP)
9D006E08  8FB10014   LW S1, 20(SP)
9D006E0C  8FB00010   LW S0, 16(SP)
9D006E10  03E00008   JR RA
9D006E14  27BD0038   ADDIU SP, SP, 56
2526:                
2527:                /*-----------------------------------------------------------------------*/
2528:                /* Synchronize the File Object                                           */
2529:                /*-----------------------------------------------------------------------*/
2530:                
2531:                FRESULT f_sync(FIL *fp /* Pointer to the file object */
2532:                ) {
9D006E18  27BDFFE0   ADDIU SP, SP, -32
9D006E1C  AFBF001C   SW RA, 28(SP)
9D006E20  AFB10018   SW S1, 24(SP)
9D006E24  AFB00014   SW S0, 20(SP)
9D006E28  00808021   ADDU S0, A0, ZERO
2533:                	FRESULT res;
2534:                	DWORD tim;
2535:                	PF_BYTE *dir;
2536:                
2537:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D006E2C  8C840000   LW A0, 0(A0)
9D006E30  0F401370   JAL validate
9D006E34  96050004   LHU A1, 4(S0)
2538:                	if (res == FR_OK) {
9D006E38  14400033   BNE V0, ZERO, 0x9D006F08
9D006E3C  8FBF001C   LW RA, 28(SP)
2539:                		if (fp->flag & FA__WRITTEN) { /* Has the file been written? */
9D006E40  92030006   LBU V1, 6(S0)
9D006E44  30630020   ANDI V1, V1, 32
9D006E48  306300FF   ANDI V1, V1, 255
9D006E4C  1060002F   BEQ V1, ZERO, 0x9D006F0C
9D006E50  8FB10018   LW S1, 24(SP)
2540:                #if !_FS_TINY	/* Write-back dirty buffer */
2541:                			if (fp->flag & FA__DIRTY) {
2542:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2543:                					LEAVE_FF(fp->fs, FR_DISK_ERR);
2544:                				fp->flag &= ~FA__DIRTY;
2545:                			}
2546:                #endif
2547:                			/* Update the directory entry */
2548:                			res = move_window(fp->fs, fp->dir_sect);
9D006E54  8E040000   LW A0, 0(S0)
9D006E58  0F4012F8   JAL move_window
9D006E5C  8E05001C   LW A1, 28(S0)
2549:                			if (res == FR_OK) {
9D006E60  14400029   BNE V0, ZERO, 0x9D006F08
9D006E64  8FBF001C   LW RA, 28(SP)
2550:                				dir = fp->dir_ptr;
9D006E68  8E110020   LW S1, 32(S0)
2551:                				dir[DIR_Attr] |= AM_ARC; /* Set archive bit */
9D006E6C  9222000B   LBU V0, 11(S1)
9D006E70  34420020   ORI V0, V0, 32
9D006E74  A222000B   SB V0, 11(S1)
2552:                				ST_DWORD(dir+DIR_FileSize, fp->fsize); /* Update file size */
9D006E78  8E02000C   LW V0, 12(S0)
9D006E7C  A222001C   SB V0, 28(S1)
9D006E80  9602000C   LHU V0, 12(S0)
9D006E84  00021202   SRL V0, V0, 8
9D006E88  A222001D   SB V0, 29(S1)
9D006E8C  9602000E   LHU V0, 14(S0)
9D006E90  A222001E   SB V0, 30(S1)
9D006E94  9202000F   LBU V0, 15(S0)
9D006E98  A222001F   SB V0, 31(S1)
2553:                				ST_CLUST(dir, fp->sclust); /* Update start cluster */
9D006E9C  8E020010   LW V0, 16(S0)
9D006EA0  A222001A   SB V0, 26(S1)
9D006EA4  96020010   LHU V0, 16(S0)
9D006EA8  00021202   SRL V0, V0, 8
9D006EAC  A222001B   SB V0, 27(S1)
9D006EB0  96020012   LHU V0, 18(S0)
9D006EB4  A2220014   SB V0, 20(S1)
9D006EB8  96020012   LHU V0, 18(S0)
9D006EBC  00021202   SRL V0, V0, 8
2554:                				tim = get_fattime(); /* Update updated time */
9D006EC0  0F4042BB   JAL get_fattime
9D006EC4  A2220015   SB V0, 21(S1)
2555:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D006EC8  A2220016   SB V0, 22(S1)
9D006ECC  7C433A00   EXT V1, V0, 8, 8
9D006ED0  A2230017   SB V1, 23(S1)
9D006ED4  00021C02   SRL V1, V0, 16
9D006ED8  A2230018   SB V1, 24(S1)
9D006EDC  00021602   SRL V0, V0, 24
9D006EE0  A2220019   SB V0, 25(S1)
2556:                				fp->flag &= ~FA__WRITTEN;
9D006EE4  92020006   LBU V0, 6(S0)
9D006EE8  7C022944   INS V0, ZERO, 5, 1
9D006EEC  A2020006   SB V0, 6(S0)
2557:                				fp->fs->wflag = 1;
9D006EF0  8E020000   LW V0, 0(S0)
9D006EF4  24030001   ADDIU V1, ZERO, 1
9D006EF8  A0430004   SB V1, 4(V0)
2558:                				res = sync(fp->fs);
9D006EFC  0F401387   JAL sync
9D006F00  8E040000   LW A0, 0(S0)
2559:                			}
2560:                		}
2561:                	}
2562:                
2563:                	LEAVE_FF(fp->fs, res);
2564:                }
9D006F04  8FBF001C   LW RA, 28(SP)
9D006F08  8FB10018   LW S1, 24(SP)
9D006F0C  8FB00014   LW S0, 20(SP)
9D006F10  03E00008   JR RA
9D006F14  27BD0020   ADDIU SP, SP, 32
2565:                
2566:                #endif /* !_FS_READONLY */
2567:                
2568:                /*-----------------------------------------------------------------------*/
2569:                /* Close File                                                            */
2570:                /*-----------------------------------------------------------------------*/
2571:                
2572:                FRESULT f_close(FIL *fp /* Pointer to the file object to be closed */
2573:                ) {
9D006F18  27BDFFE8   ADDIU SP, SP, -24
9D006F1C  AFBF0014   SW RA, 20(SP)
9D006F20  AFB00010   SW S0, 16(SP)
2574:                	FRESULT res;
2575:                
2576:                #if _FS_READONLY
2577:                	FATFS *fs = fp->fs;
2578:                	res = validate(fs, fp->id);
2579:                	if (res == FR_OK) fp->fs = 0; /* Discard file object */
2580:                	LEAVE_FF(fs, res);
2581:                
2582:                #else
2583:                	res = f_sync(fp); /* Flush cached data */
9D006F24  0F401B86   JAL f_sync
9D006F28  00808021   ADDU S0, A0, ZERO
2584:                #if _FS_SHARE
2585:                	if (res == FR_OK) { /* Decrement open counter */
9D006F2C  1440002D   BNE V0, ZERO, 0x9D006FE4
9D006F30  8FBF0014   LW RA, 20(SP)
2586:                #if _FS_REENTRANT
2587:                		res = validate(fp->fs, fp->id);
2588:                		if (res == FR_OK) {
2589:                			res = dec_lock(fp->lockid);
2590:                			unlock_fs(fp->fs, FR_OK);
2591:                		}
2592:                #else
2593:                		res = dec_lock(fp->lockid);
2594:                #endif
2595:                	}
2596:                #endif
2597:                	if (res == FR_OK)
2598:                		fp->fs = 0; /* Discard file object */
9D006FDC  AE000000   SW ZERO, 0(S0)
2599:                	return res;
2600:                #endif
2601:                }
9D006FE0  8FBF0014   LW RA, 20(SP)
9D006FE4  8FB00010   LW S0, 16(SP)
9D006FE8  03E00008   JR RA
9D006FEC  27BD0018   ADDIU SP, SP, 24
2602:                
2603:                /*-----------------------------------------------------------------------*/
2604:                /* Current Drive/Directory Handlings                                     */
2605:                /*-----------------------------------------------------------------------*/
2606:                
2607:                #if _FS_RPATH >= 1
2608:                
2609:                FRESULT f_chdrive (
2610:                		PF_BYTE drv /* Drive number */
2611:                )
2612:                {
2613:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
9D006FF0  14800003   BNE A0, ZERO, 0x9D007000
9D006FF4  2402000B   ADDIU V0, ZERO, 11
2614:                
2615:                	CurrVol = drv;
9D006FF8  A3808058   SB ZERO, -32680(GP)
2616:                
2617:                	return FR_OK;
9D006FFC  00001021   ADDU V0, ZERO, ZERO
2618:                }
9D007000  03E00008   JR RA
9D007004  00000000   NOP
2619:                
2620:                FRESULT f_chdir (
2621:                		const TCHAR *path /* Pointer to the directory path */
2622:                )
2623:                {
9D007008  27BDFFC0   ADDIU SP, SP, -64
9D00700C  AFBF003C   SW RA, 60(SP)
9D007010  AFA40040   SW A0, 64(SP)
2624:                	FRESULT res;
2625:                	DIR dj;
2626:                	DEF_NAMEBUF;
2627:                
2628:                	res = chk_mounted(&path, &dj.fs, 0);
9D007014  27A40040   ADDIU A0, SP, 64
9D007018  27A50010   ADDIU A1, SP, 16
9D00701C  0F401790   JAL chk_mounted
9D007020  00003021   ADDU A2, ZERO, ZERO
2629:                	if (res == FR_OK) {
9D007024  14400023   BNE V0, ZERO, 0x9D0070B4
9D007028  8FBF003C   LW RA, 60(SP)
2630:                		INIT_BUF(dj);
9D00702C  27A2002C   ADDIU V0, SP, 44
9D007030  AFA20028   SW V0, 40(SP)
2631:                		res = follow_path(&dj, path); /* Follow the path */
9D007034  27A40010   ADDIU A0, SP, 16
9D007038  0F4015F0   JAL follow_path
9D00703C  8FA50040   LW A1, 64(SP)
2632:                		FREE_BUF();
2633:                		if (res == FR_OK) { /* Follow completed */
9D007040  14400019   BNE V0, ZERO, 0x9D0070A8
9D007044  38440004   XORI A0, V0, 4
2634:                			if (!dj.dir) {
9D007048  8FA30024   LW V1, 36(SP)
9D00704C  54600005   BNEL V1, ZERO, 0x9D007064
9D007050  9064000B   LBU A0, 11(V1)
2635:                				dj.fs->cdir = dj.sclust; /* Start directory itself */
9D007054  8FA40018   LW A0, 24(SP)
9D007058  8FA30010   LW V1, 16(SP)
9D00705C  0B401C2C   J 0x9D0070B0
9D007060  AC640018   SW A0, 24(V1)
2636:                			} else {
2637:                				if (dj.dir[DIR_Attr] & AM_DIR) /* Reached to the directory */
9D007064  30840010   ANDI A0, A0, 16
9D007068  308400FF   ANDI A0, A0, 255
9D00706C  50800010   BEQL A0, ZERO, 0x9D0070B0
9D007070  24020005   ADDIU V0, ZERO, 5
2638:                				dj.fs->cdir = LD_CLUST(dj.dir);
9D007074  90650015   LBU A1, 21(V1)
9D007078  00052A00   SLL A1, A1, 8
9D00707C  90640014   LBU A0, 20(V1)
9D007080  00A42825   OR A1, A1, A0
9D007084  00052C00   SLL A1, A1, 16
9D007088  9064001B   LBU A0, 27(V1)
9D00708C  00042200   SLL A0, A0, 8
9D007090  9063001A   LBU V1, 26(V1)
9D007094  00832025   OR A0, A0, V1
9D007098  00A42025   OR A0, A1, A0
9D00709C  8FA30010   LW V1, 16(SP)
9D0070A0  0B401C2C   J 0x9D0070B0
9D0070A4  AC640018   SW A0, 24(V1)
2639:                				else
2640:                				res = FR_NO_PATH; /* Reached but a file */
2641:                			}
2642:                		}
2643:                		if (res == FR_NO_FILE) res = FR_NO_PATH;
9D0070A8  24030005   ADDIU V1, ZERO, 5
9D0070AC  0064100A   MOVZ V0, V1, A0
2644:                	}
2645:                
2646:                	LEAVE_FF(dj.fs, res);
2647:                }
9D0070B0  8FBF003C   LW RA, 60(SP)
9D0070B4  03E00008   JR RA
9D0070B8  27BD0040   ADDIU SP, SP, 64
2648:                
2649:                #if _FS_RPATH >= 2
2650:                FRESULT f_getcwd (
2651:                		TCHAR *path, /* Pointer to the directory path */
2652:                		UINT sz_path /* Size of path */
2653:                )
2654:                {
9D0070BC  27BDFF90   ADDIU SP, SP, -112
9D0070C0  AFBF006C   SW RA, 108(SP)
9D0070C4  AFB60068   SW S6, 104(SP)
9D0070C8  AFB50064   SW S5, 100(SP)
9D0070CC  AFB40060   SW S4, 96(SP)
9D0070D0  AFB3005C   SW S3, 92(SP)
9D0070D4  AFB20058   SW S2, 88(SP)
9D0070D8  AFB10054   SW S1, 84(SP)
9D0070DC  AFB00050   SW S0, 80(SP)
9D0070E0  AFA40070   SW A0, 112(SP)
9D0070E4  00A0A021   ADDU S4, A1, ZERO
2655:                	FRESULT res;
2656:                	DIR dj;
2657:                	UINT i, n;
2658:                	DWORD ccl;
2659:                	TCHAR *tp;
2660:                	FILINFO fno;
2661:                	DEF_NAMEBUF;
2662:                
2663:                	*path = 0;
9D0070E8  A0800000   SB ZERO, 0(A0)
2664:                	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0); /* Get current volume */
9D0070EC  27A40070   ADDIU A0, SP, 112
9D0070F0  27A50010   ADDIU A1, SP, 16
9D0070F4  0F401790   JAL chk_mounted
9D0070F8  00003021   ADDU A2, ZERO, ZERO
2665:                	if (res == FR_OK) {
9D0070FC  14400089   BNE V0, ZERO, 0x9D007324
9D007100  00409021   ADDU S2, V0, ZERO
2666:                		INIT_BUF(dj);
9D007104  27A20044   ADDIU V0, SP, 68
9D007108  AFA20028   SW V0, 40(SP)
2667:                		i = sz_path; /* Bottom of buffer (dir stack base) */
9D00711C  02808021   ADDU S0, S4, ZERO
2668:                		dj.sclust = dj.fs->cdir; /* Start to follow upper dir from current dir */
9D00710C  8FA20010   LW V0, 16(SP)
9D007110  8C560018   LW S6, 24(V0)
2669:                		while ((ccl = dj.sclust) != 0) { /* Repeat while current dir is a sub-dir */
9D007114  12C0007C   BEQ S6, ZERO, 0x9D007308
9D007118  AFB60018   SW S6, 24(SP)
9D007274  8FB60018   LW S6, 24(SP)
9D007278  16C0FFAC   BNE S6, ZERO, 0x9D00712C
9D00727C  27A40010   ADDIU A0, SP, 16
9D007280  0B401CB2   J 0x9D0072C8
9D007284  8FA30070   LW V1, 112(SP)
2670:                			res = dir_sdi(&dj, 1); /* Get parent dir */
9D007128  27A40010   ADDIU A0, SP, 16
9D00712C  0F401439   JAL dir_sdi
9D007130  24050001   ADDIU A1, ZERO, 1
2671:                			if (res != FR_OK) break;
9D007134  5440006D   BNEL V0, ZERO, 0x9D0072EC
9D007138  00409021   ADDU S2, V0, ZERO
2672:                			res = dir_read(&dj);
9D00713C  0F401731   JAL dir_read
9D007140  27A40010   ADDIU A0, SP, 16
2673:                			if (res != FR_OK) break;
9D007144  54400069   BNEL V0, ZERO, 0x9D0072EC
9D007148  00409021   ADDU S2, V0, ZERO
2674:                			dj.sclust = LD_CLUST(dj.dir); /* Goto parent dir */
9D00714C  8FA20024   LW V0, 36(SP)
9D007150  90430015   LBU V1, 21(V0)
9D007154  00031A00   SLL V1, V1, 8
9D007158  90440014   LBU A0, 20(V0)
9D00715C  00641825   OR V1, V1, A0
9D007160  00031C00   SLL V1, V1, 16
9D007164  9045001B   LBU A1, 27(V0)
9D007168  00052A00   SLL A1, A1, 8
9D00716C  9044001A   LBU A0, 26(V0)
9D007170  00A41025   OR V0, A1, A0
9D007174  00621025   OR V0, V1, V0
9D007178  AFA20018   SW V0, 24(SP)
2675:                			res = dir_sdi(&dj, 0);
9D00717C  27A40010   ADDIU A0, SP, 16
9D007180  0F401439   JAL dir_sdi
9D007184  00002821   ADDU A1, ZERO, ZERO
2676:                			if (res != FR_OK) break;
9D007188  14400057   BNE V0, ZERO, 0x9D0072E8
9D00718C  00408821   ADDU S1, V0, ZERO
2677:                			do { /* Find the entry links to the child dir */
2678:                				res = dir_read(&dj);
9D007190  0F401731   JAL dir_read
9D007194  27A40010   ADDIU A0, SP, 16
2679:                				if (res != FR_OK) break;
9D007198  14400011   BNE V0, ZERO, 0x9D0071E0
9D00719C  8FA30024   LW V1, 36(SP)
2680:                				if (ccl == LD_CLUST(dj.dir)) break; /* Found the entry */
9D0071A0  90640015   LBU A0, 21(V1)
9D0071A4  00042200   SLL A0, A0, 8
9D0071A8  90620014   LBU V0, 20(V1)
9D0071AC  00822025   OR A0, A0, V0
9D0071B0  00042400   SLL A0, A0, 16
9D0071B4  9062001B   LBU V0, 27(V1)
9D0071B8  00021200   SLL V0, V0, 8
9D0071BC  9063001A   LBU V1, 26(V1)
9D0071C0  00431025   OR V0, V0, V1
9D0071C4  00821025   OR V0, A0, V0
9D0071C8  10560009   BEQ V0, S6, 0x9D0071F0
9D0071CC  27A40010   ADDIU A0, SP, 16
2681:                				res = dir_next(&dj, 0);
9D0071D0  0F401571   JAL dir_next
9D0071D4  00002821   ADDU A1, ZERO, ZERO
2682:                			}while (res == FR_OK);
9D0071D8  1040FFED   BEQ V0, ZERO, 0x9D007190
9D0071DC  00000000   NOP
2683:                			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
9D007120  24150004   ADDIU S5, ZERO, 4
9D0071E0  50550042   BEQL V0, S5, 0x9D0072EC
9D0071E4  24120002   ADDIU S2, ZERO, 2
2684:                			if (res != FR_OK) break;
9D0071E8  54400040   BNEL V0, ZERO, 0x9D0072EC
9D0071EC  00409021   ADDU S2, V0, ZERO
2685:                #if _USE_LFN
2686:                			fno.lfname = path;
2687:                			fno.lfsize = i;
2688:                #endif
2689:                			get_fileinfo(&dj, &fno); /* Get the dir name and push it to the buffer */
9D0071F0  27A40010   ADDIU A0, SP, 16
9D0071F4  0F4012AF   JAL get_fileinfo
9D0071F8  27A5002C   ADDIU A1, SP, 44
2690:                			tp = fno.fname;
2691:                			if (_USE_LFN && *path) tp = path;
2692:                			for (n = 0; tp[n]; n++);
9D0071FC  83A20035   LB V0, 53(SP)
9D007200  1040003C   BEQ V0, ZERO, 0x9D0072F4
9D007204  00001021   ADDU V0, ZERO, ZERO
9D007208  24420001   ADDIU V0, V0, 1
9D00720C  27A4002C   ADDIU A0, SP, 44
9D007210  00821821   ADDU V1, A0, V0
9D007214  80630009   LB V1, 9(V1)
9D007218  5460FFFD   BNEL V1, ZERO, 0x9D007210
9D00721C  24420001   ADDIU V0, V0, 1
2693:                			if (i < n + 3) {
9D007220  24430003   ADDIU V1, V0, 3
9D007224  0203182B   SLTU V1, S0, V1
9D007228  54600030   BNEL V1, ZERO, 0x9D0072EC
9D00722C  24120011   ADDIU S2, ZERO, 17
9D0072F4  2E020003   SLTIU V0, S0, 3
9D0072F8  1040FFDB   BEQ V0, ZERO, 0x9D007268
9D0072FC  2610FFFF   ADDIU S0, S0, -1
2694:                				res = FR_NOT_ENOUGH_CORE; break;
9D007300  0B401CBB   J 0x9D0072EC
9D007304  24120011   ADDIU S2, ZERO, 17
2695:                			}
2696:                			while (n) path[--i] = tp[--n];
9D007230  1040000C   BEQ V0, ZERO, 0x9D007264
9D007234  00401821   ADDU V1, V0, ZERO
9D007238  02002021   ADDU A0, S0, ZERO
9D00723C  2484FFFF   ADDIU A0, A0, -1
9D007240  2463FFFF   ADDIU V1, V1, -1
9D007244  27A60010   ADDIU A2, SP, 16
9D007248  00C32821   ADDU A1, A2, V1
9D00724C  80A60025   LB A2, 37(A1)
9D007250  8FA50070   LW A1, 112(SP)
9D007254  00A42821   ADDU A1, A1, A0
9D007258  1460FFF8   BNE V1, ZERO, 0x9D00723C
9D00725C  A0A60000   SB A2, 0(A1)
9D007260  02028023   SUBU S0, S0, V0
2697:                			path[--i] = '/';
9D007124  2413002F   ADDIU S3, ZERO, 47
9D007264  2610FFFF   ADDIU S0, S0, -1
9D007268  8FA20070   LW V0, 112(SP)
9D00726C  00501021   ADDU V0, V0, S0
9D007270  A0530000   SB S3, 0(V0)
2698:                		}
2699:                		tp = path;
9D0072EC  0B401CB0   J 0x9D0072C0
9D0072F0  8FA20070   LW V0, 112(SP)
9D007308  8FA30070   LW V1, 112(SP)
2700:                		if (res == FR_OK) {
2701:                			*tp++ = '0' + CurrVol; /* Put drive number */
9D0072C8  93828058   LBU V0, -32680(GP)
9D0072CC  24420030   ADDIU V0, V0, 48
9D0072D0  A0620000   SB V0, 0(V1)
9D00730C  93828058   LBU V0, -32680(GP)
9D007310  24420030   ADDIU V0, V0, 48
9D007314  A0620000   SB V0, 0(V1)
2702:                			*tp++ = ':';
9D0072D4  2402003A   ADDIU V0, ZERO, 58
9D0072E0  0B401CA6   J 0x9D007298
9D0072E4  24620002   ADDIU V0, V1, 2
9D0072E8  00409021   ADDU S2, V0, ZERO
9D007318  2402003A   ADDIU V0, ZERO, 58
9D00731C  0B401CA2   J 0x9D007288
9D007320  A0620001   SB V0, 1(V1)
2703:                			if (i == sz_path) { /* Root-dir */
9D0072D8  1214FFEB   BEQ S0, S4, 0x9D007288
9D0072DC  A0620001   SB V0, 1(V1)
2704:                				*tp++ = '/';
9D007288  24620003   ADDIU V0, V1, 3
9D00728C  2404002F   ADDIU A0, ZERO, 47
9D007290  0B401CB0   J 0x9D0072C0
9D007294  A0640002   SB A0, 2(V1)
2705:                			} else { /* Sub-dir */
2706:                				do /* Add stacked path str */
2707:                				*tp++ = path[i++];
9D007298  24420001   ADDIU V0, V0, 1
9D00729C  26030001   ADDIU V1, S0, 1
9D0072A0  8FA40070   LW A0, 112(SP)
9D0072A4  00908021   ADDU S0, A0, S0
9D0072A8  82040000   LB A0, 0(S0)
9D0072AC  A044FFFF   SB A0, -1(V0)
2708:                				while (i < sz_path);
9D0072B0  0074202B   SLTU A0, V1, S4
9D0072B4  1480FFF8   BNE A0, ZERO, 0x9D007298
9D0072B8  00608021   ADDU S0, V1, ZERO
9D0072BC  02209021   ADDU S2, S1, ZERO
2709:                			}
2710:                		}
2711:                		*tp = 0;
9D0072C0  0B401CC9   J 0x9D007324
9D0072C4  A0400000   SB ZERO, 0(V0)
2712:                		FREE_BUF();
2713:                	}
2714:                
2715:                	LEAVE_FF(dj.fs, res);
2716:                }
9D007324  02401021   ADDU V0, S2, ZERO
9D007328  8FBF006C   LW RA, 108(SP)
9D00732C  8FB60068   LW S6, 104(SP)
9D007330  8FB50064   LW S5, 100(SP)
9D007334  8FB40060   LW S4, 96(SP)
9D007338  8FB3005C   LW S3, 92(SP)
9D00733C  8FB20058   LW S2, 88(SP)
9D007340  8FB10054   LW S1, 84(SP)
9D007344  8FB00050   LW S0, 80(SP)
9D007348  03E00008   JR RA
9D00734C  27BD0070   ADDIU SP, SP, 112
2717:                #endif /* _FS_RPATH >= 2 */
2718:                #endif /* _FS_RPATH >= 1 */
2719:                
2720:                #if _FS_MINIMIZE <= 2
2721:                /*-----------------------------------------------------------------------*/
2722:                /* Seek File R/W Pointer                                                 */
2723:                /*-----------------------------------------------------------------------*/
2724:                
2725:                FRESULT f_lseek(FIL *fp, /* Pointer to the file object */
2726:                                DWORD ofs /* File pointer from top of file */
2727:                                ) {
9D007350  27BDFFC8   ADDIU SP, SP, -56
9D007354  AFBF0034   SW RA, 52(SP)
9D007358  AFB70030   SW S7, 48(SP)
9D00735C  AFB6002C   SW S6, 44(SP)
9D007360  AFB50028   SW S5, 40(SP)
9D007364  AFB40024   SW S4, 36(SP)
9D007368  AFB30020   SW S3, 32(SP)
9D00736C  AFB2001C   SW S2, 28(SP)
9D007370  AFB10018   SW S1, 24(SP)
9D007374  AFB00014   SW S0, 20(SP)
9D007378  00808021   ADDU S0, A0, ZERO
9D00737C  00A08821   ADDU S1, A1, ZERO
2728:                	FRESULT res;
2729:                
2730:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D007380  8C840000   LW A0, 0(A0)
9D007384  0F401370   JAL validate
9D007388  96050004   LHU A1, 4(S0)
2731:                	if (res != FR_OK)
9D00738C  144000E9   BNE V0, ZERO, 0x9D007734
9D007390  00401821   ADDU V1, V0, ZERO
2732:                		LEAVE_FF(fp->fs, res);
2733:                	if (fp->flag & FA__ERROR) /* Check abort flag */
9D007394  92120006   LBU S2, 6(S0)
9D007398  7C121420   SEB V0, S2
9D00739C  044000E5   BLTZ V0, 0x9D007734
9D0073A0  24030002   ADDIU V1, ZERO, 2
2734:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2735:                
2736:                #if _USE_FASTSEEK
2737:                	if (fp->cltbl) { /* Fast seek */
9D0073A4  8E020024   LW V0, 36(S0)
9D0073A8  1040005A   BEQ V0, ZERO, 0x9D007514
9D0073AC  2403FFFF   ADDIU V1, ZERO, -1
2738:                		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
2739:                
2740:                		if (ofs == CREATE_LINKMAP) { /* Create CLMT */
9D0073B0  56230037   BNEL S1, V1, 0x9D007490
9D0073B4  8E02000C   LW V0, 12(S0)
2741:                			tbl = fp->cltbl;
2742:                			tlen = *tbl++;
9D0073B8  24560004   ADDIU S6, V0, 4
2743:                			ulen = 2; /* Given table size and required table size */
9D00746C  24150002   ADDIU S5, ZERO, 2
2744:                			cl = fp->sclust; /* Top of the chain */
9D0073BC  8E140010   LW S4, 16(S0)
2745:                			if (cl) {
9D0073C0  1280002A   BEQ S4, ZERO, 0x9D00746C
9D0073C4  8C570000   LW S7, 0(V0)
9D0073C8  24150002   ADDIU S5, ZERO, 2
2746:                				do {
2747:                					/* Get a fragment */
2748:                					tcl = cl;
2749:                					ncl = 0;
9D0073D4  00009021   ADDU S2, ZERO, ZERO
2750:                					ulen += 2; /* Top, length and used items */
9D007434  26B50002   ADDIU S5, S5, 2
2751:                					do {
2752:                						pcl = cl;
2753:                						ncl++;
9D0073D8  26520001   ADDIU S2, S2, 1
2754:                						cl = get_fat(fp->fs, cl);
9D0073D0  02808821   ADDU S1, S4, ZERO
9D0073DC  8E040000   LW A0, 0(S0)
9D0073E0  0F4013D7   JAL get_fat
9D0073E4  02202821   ADDU A1, S1, ZERO
9D007464  0B401CF5   J 0x9D0073D4
9D007468  02808821   ADDU S1, S4, ZERO
2755:                						if (cl <= 1)
9D0073E8  2C430002   SLTIU V1, V0, 2
9D0073EC  10600007   BEQ V1, ZERO, 0x9D00740C
9D0073F0  00000000   NOP
2756:                							ABORT(fp->fs, FR_INT_ERR);
9D0073F4  92030006   LBU V1, 6(S0)
9D0073F8  2402FF80   ADDIU V0, ZERO, -128
9D0073FC  00621025   OR V0, V1, V0
9D007400  A2020006   SB V0, 6(S0)
9D007404  0B401DCD   J 0x9D007734
9D007408  24030002   ADDIU V1, ZERO, 2
2757:                						if (cl == 0xFFFFFFFF)
9D0073CC  2413FFFF   ADDIU S3, ZERO, -1
9D00740C  14530007   BNE V0, S3, 0x9D00742C
9D007410  26310001   ADDIU S1, S1, 1
2758:                							ABORT(fp->fs, FR_DISK_ERR);
9D007414  92030006   LBU V1, 6(S0)
9D007418  2402FF80   ADDIU V0, ZERO, -128
9D00741C  00621025   OR V0, V1, V0
9D007420  A2020006   SB V0, 6(S0)
9D007424  0B401DCD   J 0x9D007734
9D007428  24030001   ADDIU V1, ZERO, 1
2759:                					} while (cl == pcl + 1);
9D00742C  5222FFEB   BEQL S1, V0, 0x9D0073DC
9D007430  26520001   ADDIU S2, S2, 1
2760:                					if (ulen <= tlen) { /* Store the length and top of the fragment */
9D007438  02F5182B   SLTU V1, S7, S5
9D00743C  54600005   BNEL V1, ZERO, 0x9D007454
9D007440  8E030000   LW V1, 0(S0)
2761:                						*tbl++ = ncl;
9D007444  AED20000   SW S2, 0(S6)
2762:                						*tbl++ = tcl;
9D007448  AED40004   SW S4, 4(S6)
9D00744C  26D60008   ADDIU S6, S6, 8
2763:                					}
2764:                				} while (cl < fp->fs->n_fatent); /* Repeat until end of chain */
9D007450  8E030000   LW V1, 0(S0)
9D007454  8C63001C   LW V1, 28(V1)
9D007458  0043182B   SLTU V1, V0, V1
9D00745C  10600004   BEQ V1, ZERO, 0x9D007470
9D007460  0040A021   ADDU S4, V0, ZERO
2765:                			}
2766:                			*fp->cltbl = ulen; /* Number of items used */
9D007470  8E020024   LW V0, 36(S0)
9D007474  AC550000   SW S5, 0(V0)
2767:                			if (ulen <= tlen)
9D007478  02F5A82B   SLTU S5, S7, S5
9D00747C  16A000AD   BNE S5, ZERO, 0x9D007734
9D007480  24030011   ADDIU V1, ZERO, 17
2768:                				*tbl = 0; /* Terminate table */
9D007484  AEC00000   SW ZERO, 0(S6)
9D007488  0B401DCD   J 0x9D007734
9D00748C  00001821   ADDU V1, ZERO, ZERO
9D007490  0051182B   SLTU V1, V0, S1
9D007494  0043880B   MOVN S1, V0, V1
2769:                			else
2770:                				res = FR_NOT_ENOUGH_CORE; /* Given table size is smaller than required */
2771:                
2772:                		} else { /* Fast seek */
2773:                			if (ofs > fp->fsize) /* Clip offset at the file size */
2774:                				ofs = fp->fsize;
2775:                			fp->fptr = ofs; /* Set file pointer */
9D007498  AE110008   SW S1, 8(S0)
2776:                			if (ofs) {
9D00749C  122000A5   BEQ S1, ZERO, 0x9D007734
9D0074A0  00001821   ADDU V1, ZERO, ZERO
2777:                				fp->clust = clmt_clust(fp, ofs - 1);
9D0074A4  2634FFFF   ADDIU S4, S1, -1
9D0074A8  02002021   ADDU A0, S0, ZERO
9D0074AC  0F401292   JAL clmt_clust
9D0074B0  02802821   ADDU A1, S4, ZERO
9D0074B4  AE020014   SW V0, 20(S0)
2778:                				dsc = clust2sect(fp->fs, fp->clust);
9D0074B8  8E130000   LW S3, 0(S0)
9D0074BC  02602021   ADDU A0, S3, ZERO
9D0074C0  0F4013CB   JAL clust2sect
9D0074C4  00402821   ADDU A1, V0, ZERO
2779:                				if (!dsc)
9D0074C8  54400006   BNEL V0, ZERO, 0x9D0074E4
9D0074CC  92640002   LBU A0, 2(S3)
2780:                					ABORT(fp->fs, FR_INT_ERR);
9D0074D0  2402FF80   ADDIU V0, ZERO, -128
9D0074D4  02429025   OR S2, S2, V0
9D0074D8  A2120006   SB S2, 6(S0)
9D0074DC  0B401DCD   J 0x9D007734
9D0074E0  24030002   ADDIU V1, ZERO, 2
2781:                				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
9D0074F0  00141A42   SRL V1, S4, 9
9D0074F4  2484FFFF   ADDIU A0, A0, -1
9D0074F8  00641824   AND V1, V1, A0
9D0074FC  00431021   ADDU V0, V0, V1
2782:                				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) { /* Refill sector cache if needed */
9D0074E4  323101FF   ANDI S1, S1, 511
9D0074E8  12200092   BEQ S1, ZERO, 0x9D007734
9D0074EC  00001821   ADDU V1, ZERO, ZERO
9D007500  8E030018   LW V1, 24(S0)
9D007504  1062008B   BEQ V1, V0, 0x9D007734
9D007508  00001821   ADDU V1, ZERO, ZERO
2783:                #if !_FS_TINY
2784:                #if !_FS_READONLY
2785:                					if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2786:                						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1)
2787:                								!= RES_OK)
2788:                							ABORT(fp->fs, FR_DISK_ERR);
2789:                						fp->flag &= ~FA__DIRTY;
2790:                					}
2791:                #endif
2792:                					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK) /* Load current sector */
2793:                						ABORT(fp->fs, FR_DISK_ERR);
2794:                #endif
2795:                					fp->dsect = dsc;
9D00750C  0B401DCD   J 0x9D007734
9D007510  AE020018   SW V0, 24(S0)
2796:                				}
2797:                			}
2798:                		}
2799:                	} else
2800:                #endif
2801:                
2802:                	/* Normal Seek */
2803:                	{
2804:                		DWORD clst, bcs, nsect, ifptr;
2805:                
2806:                		if (ofs > fp->fsize /* In read-only mode, clip offset with the file size */
9D007514  8E02000C   LW V0, 12(S0)
9D007518  0051182B   SLTU V1, V0, S1
9D00751C  50600005   BEQL V1, ZERO, 0x9D007534
9D007520  8E020008   LW V0, 8(S0)
2807:                #if !_FS_READONLY
2808:                				&& !(fp->flag & FA_WRITE)
9D007524  32520002   ANDI S2, S2, 2
9D007528  325200FF   ANDI S2, S2, 255
2809:                #endif
2810:                		)
2811:                			ofs = fp->fsize;
9D00752C  0052880A   MOVZ S1, V0, S2
2812:                
2813:                		ifptr = fp->fptr;
9D007530  8E020008   LW V0, 8(S0)
2814:                		fp->fptr = nsect = 0;
9D007534  AE000008   SW ZERO, 8(S0)
2815:                		if (ofs) {
9D007538  1220007E   BEQ S1, ZERO, 0x9D007734
9D00753C  00001821   ADDU V1, ZERO, ZERO
2816:                			bcs = (DWORD) fp->fs->csize * SS(fp->fs); /* Cluster size (byte) */
9D007540  8E040000   LW A0, 0(S0)
9D007544  90920002   LBU S2, 2(A0)
2817:                			if (ifptr > 0 && (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
9D007548  10400012   BEQ V0, ZERO, 0x9D007594
9D00754C  00129240   SLL S2, S2, 9
9D007550  2442FFFF   ADDIU V0, V0, -1
9D007554  2623FFFF   ADDIU V1, S1, -1
9D007558  0072001B   DIVU V1, S2
9D00755C  024001F4   TEQ S2, ZERO
9D007560  00001812   MFLO V1
9D007564  0052001B   DIVU V0, S2
9D007568  024001F4   TEQ S2, ZERO
9D00756C  00002812   MFLO A1
9D007570  0065182B   SLTU V1, V1, A1
9D007574  54600008   BNEL V1, ZERO, 0x9D007598
9D007578  8E020010   LW V0, 16(S0)
2818:                				fp->fptr = (ifptr - 1) & ~(bcs - 1); /* start from the current cluster */
9D00757C  00121823   SUBU V1, ZERO, S2
9D007580  00621024   AND V0, V1, V0
9D007584  AE020008   SW V0, 8(S0)
2819:                				ofs -= fp->fptr;
9D007588  02228823   SUBU S1, S1, V0
2820:                				clst = fp->clust;
9D00758C  0B401D7C   J 0x9D0075F0
9D007590  8E020014   LW V0, 20(S0)
2821:                			} else { /* When seek to back cluster, */
2822:                				clst = fp->sclust; /* start from the first cluster */
9D007594  8E020010   LW V0, 16(S0)
2823:                #if !_FS_READONLY
2824:                				if (clst == 0) { /* If no cluster chain, create a new chain */
9D007598  54400015   BNEL V0, ZERO, 0x9D0075F0
9D00759C  AE020014   SW V0, 20(S0)
2825:                					clst = create_chain(fp->fs, 0);
9D0075A0  0F40150D   JAL create_chain
9D0075A4  00002821   ADDU A1, ZERO, ZERO
2826:                					if (clst == 1)
9D0075A8  24030001   ADDIU V1, ZERO, 1
9D0075AC  54430007   BNEL V0, V1, 0x9D0075CC
9D0075B0  2403FFFF   ADDIU V1, ZERO, -1
2827:                						ABORT(fp->fs, FR_INT_ERR);
9D0075B4  92030006   LBU V1, 6(S0)
9D0075B8  2402FF80   ADDIU V0, ZERO, -128
9D0075BC  00621025   OR V0, V1, V0
9D0075C0  A2020006   SB V0, 6(S0)
9D0075C4  0B401DCD   J 0x9D007734
9D0075C8  24030002   ADDIU V1, ZERO, 2
2828:                					if (clst == 0xFFFFFFFF)
9D0075CC  54430007   BNEL V0, V1, 0x9D0075EC
9D0075D0  AE020010   SW V0, 16(S0)
2829:                						ABORT(fp->fs, FR_DISK_ERR);
9D0075D4  92030006   LBU V1, 6(S0)
9D0075D8  2402FF80   ADDIU V0, ZERO, -128
9D0075DC  00621025   OR V0, V1, V0
9D0075E0  A2020006   SB V0, 6(S0)
9D0075E4  0B401DCD   J 0x9D007734
9D0075E8  24030001   ADDIU V1, ZERO, 1
2830:                					fp->sclust = clst;
2831:                				}
2832:                #endif
2833:                				fp->clust = clst;
9D0075EC  AE020014   SW V0, 20(S0)
2834:                			}
2835:                			if (clst != 0) {
9D0075F0  10400041   BEQ V0, ZERO, 0x9D0076F8
9D0075F4  00001821   ADDU V1, ZERO, ZERO
2836:                				while (ofs > bcs) { /* Cluster following loop */
9D0075F8  0251182B   SLTU V1, S2, S1
9D0075FC  1060002C   BEQ V1, ZERO, 0x9D0076B0
9D007600  2413FFFF   ADDIU S3, ZERO, -1
9D00769C  0251182B   SLTU V1, S2, S1
9D0076A0  5460FFD9   BNEL V1, ZERO, 0x9D007608
9D0076A4  92030006   LBU V1, 6(S0)
9D0076A8  0B401DAD   J 0x9D0076B4
9D0076AC  8E030008   LW V1, 8(S0)
2837:                #if !_FS_READONLY
2838:                					if (fp->flag & FA_WRITE) { /* Check if in write mode or not */
9D007604  92030006   LBU V1, 6(S0)
9D007608  30630002   ANDI V1, V1, 2
9D00760C  306300FF   ANDI V1, V1, 255
9D007610  10600007   BEQ V1, ZERO, 0x9D007630
9D007614  8E040000   LW A0, 0(S0)
2839:                						clst = create_chain(fp->fs, clst); /* Force stretch if in write mode */
9D007618  0F40150D   JAL create_chain
9D00761C  00402821   ADDU A1, V0, ZERO
2840:                						if (clst == 0) { /* When disk gets full, clip file size */
9D007620  14400005   BNE V0, ZERO, 0x9D007638
9D007624  00000000   NOP
9D007628  0B401DAC   J 0x9D0076B0
9D00762C  02408821   ADDU S1, S2, ZERO
2841:                							ofs = bcs;
2842:                							break;
2843:                						}
2844:                					} else
2845:                #endif
2846:                						clst = get_fat(fp->fs, clst); /* Follow cluster chain if not in write mode */
9D007630  0F4013D7   JAL get_fat
9D007634  00402821   ADDU A1, V0, ZERO
2847:                					if (clst == 0xFFFFFFFF)
9D007638  54530007   BNEL V0, S3, 0x9D007658
9D00763C  2C430002   SLTIU V1, V0, 2
2848:                						ABORT(fp->fs, FR_DISK_ERR);
9D007640  92030006   LBU V1, 6(S0)
9D007644  2402FF80   ADDIU V0, ZERO, -128
9D007648  00621025   OR V0, V1, V0
9D00764C  A2020006   SB V0, 6(S0)
9D007650  0B401DCD   J 0x9D007734
9D007654  24030001   ADDIU V1, ZERO, 1
2849:                					if (clst <= 1 || clst >= fp->fs->n_fatent)
9D007658  54600007   BNEL V1, ZERO, 0x9D007678
9D00765C  92030006   LBU V1, 6(S0)
9D007660  8E030000   LW V1, 0(S0)
9D007664  8C63001C   LW V1, 28(V1)
9D007668  0043182B   SLTU V1, V0, V1
9D00766C  54600007   BNEL V1, ZERO, 0x9D00768C
9D007670  AE020014   SW V0, 20(S0)
2850:                						ABORT(fp->fs, FR_INT_ERR);
9D007674  92030006   LBU V1, 6(S0)
9D007678  2402FF80   ADDIU V0, ZERO, -128
9D00767C  00621025   OR V0, V1, V0
9D007680  A2020006   SB V0, 6(S0)
9D007684  0B401DCD   J 0x9D007734
9D007688  24030002   ADDIU V1, ZERO, 2
2851:                					fp->clust = clst;
2852:                					fp->fptr += bcs;
9D00768C  8E030008   LW V1, 8(S0)
9D007690  00721821   ADDU V1, V1, S2
9D007694  AE030008   SW V1, 8(S0)
2853:                					ofs -= bcs;
9D007698  02328823   SUBU S1, S1, S2
2854:                				}
2855:                				fp->fptr += ofs;
9D0076B0  8E030008   LW V1, 8(S0)
9D0076B4  00711821   ADDU V1, V1, S1
9D0076B8  AE030008   SW V1, 8(S0)
2856:                				if (ofs % SS(fp->fs)) {
9D0076BC  322301FF   ANDI V1, S1, 511
9D0076C0  1060000D   BEQ V1, ZERO, 0x9D0076F8
9D0076C4  00001821   ADDU V1, ZERO, ZERO
2857:                					nsect = clust2sect(fp->fs, clst); /* Current sector */
9D0076C8  8E040000   LW A0, 0(S0)
9D0076CC  0F4013CB   JAL clust2sect
9D0076D0  00402821   ADDU A1, V0, ZERO
2858:                					if (!nsect)
9D0076D4  54400007   BNEL V0, ZERO, 0x9D0076F4
9D0076D8  00111A42   SRL V1, S1, 9
2859:                						ABORT(fp->fs, FR_INT_ERR);
9D0076DC  92030006   LBU V1, 6(S0)
9D0076E0  2402FF80   ADDIU V0, ZERO, -128
9D0076E4  00621025   OR V0, V1, V0
9D0076E8  A2020006   SB V0, 6(S0)
9D0076EC  0B401DCD   J 0x9D007734
9D0076F0  24030002   ADDIU V1, ZERO, 2
9D0076F4  00431821   ADDU V1, V0, V1
2860:                					nsect += ofs / SS(fp->fs);
2861:                				}
2862:                			}
2863:                		}
2864:                		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) { /* Fill sector cache if needed */
9D0076F8  8E020008   LW V0, 8(S0)
9D0076FC  304401FF   ANDI A0, V0, 511
9D007700  50800005   BEQL A0, ZERO, 0x9D007718
9D007704  8E04000C   LW A0, 12(S0)
9D007708  8E040018   LW A0, 24(S0)
9D00770C  54830001   BNEL A0, V1, 0x9D007714
9D007710  AE030018   SW V1, 24(S0)
2865:                #if !_FS_TINY
2866:                #if !_FS_READONLY
2867:                			if (fp->flag & FA__DIRTY) { /* Write-back dirty sector cache */
2868:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
2869:                					ABORT(fp->fs, FR_DISK_ERR);
2870:                				fp->flag &= ~FA__DIRTY;
2871:                			}
2872:                #endif
2873:                			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK) /* Fill sector cache */
2874:                				ABORT(fp->fs, FR_DISK_ERR);
2875:                #endif
2876:                			fp->dsect = nsect;
2877:                		}
2878:                #if !_FS_READONLY
2879:                		if (fp->fptr > fp->fsize) { /* Set file change flag if the file size is extended */
9D007714  8E04000C   LW A0, 12(S0)
9D007718  0082202B   SLTU A0, A0, V0
9D00771C  10800005   BEQ A0, ZERO, 0x9D007734
9D007720  00001821   ADDU V1, ZERO, ZERO
2880:                			fp->fsize = fp->fptr;
9D007724  AE02000C   SW V0, 12(S0)
2881:                			fp->flag |= FA__WRITTEN;
9D007728  92020006   LBU V0, 6(S0)
9D00772C  34420020   ORI V0, V0, 32
9D007730  A2020006   SB V0, 6(S0)
2882:                		}
2883:                #endif
2884:                	}
2885:                
2886:                	LEAVE_FF(fp->fs, res);
2887:                }
9D007734  00601021   ADDU V0, V1, ZERO
9D007738  8FBF0034   LW RA, 52(SP)
9D00773C  8FB70030   LW S7, 48(SP)
9D007740  8FB6002C   LW S6, 44(SP)
9D007744  8FB50028   LW S5, 40(SP)
9D007748  8FB40024   LW S4, 36(SP)
9D00774C  8FB30020   LW S3, 32(SP)
9D007750  8FB2001C   LW S2, 28(SP)
9D007754  8FB10018   LW S1, 24(SP)
9D007758  8FB00014   LW S0, 20(SP)
9D00775C  03E00008   JR RA
9D007760  27BD0038   ADDIU SP, SP, 56
2888:                
2889:                #if _FS_MINIMIZE <= 1
2890:                /*-----------------------------------------------------------------------*/
2891:                /* Create a Directroy Object                                             */
2892:                /*-----------------------------------------------------------------------*/
2893:                
2894:                FRESULT f_opendir(DIR *dj, /* Pointer to directory object to create */
2895:                const TCHAR *path /* Pointer to the directory path */
2896:                ) {
9D007764  27BDFFD8   ADDIU SP, SP, -40
9D007768  AFBF0024   SW RA, 36(SP)
9D00776C  AFB00020   SW S0, 32(SP)
9D007770  00808021   ADDU S0, A0, ZERO
9D007774  AFA5002C   SW A1, 44(SP)
2897:                	FRESULT res;
2898:                	DEF_NAMEBUF;
2899:                
2900:                	res = chk_mounted(&path, &dj->fs, 0);
9D007778  27A4002C   ADDIU A0, SP, 44
9D00777C  02002821   ADDU A1, S0, ZERO
9D007780  0F401790   JAL chk_mounted
9D007784  00003021   ADDU A2, ZERO, ZERO
2901:                	if (res == FR_OK) {
9D007788  14400028   BNE V0, ZERO, 0x9D00782C
9D00778C  8FBF0024   LW RA, 36(SP)
2902:                		INIT_BUF(*dj);
9D007790  27A20010   ADDIU V0, SP, 16
9D007794  AE020018   SW V0, 24(S0)
2903:                		res = follow_path(dj, path); /* Follow the path to the directory */
9D007798  02002021   ADDU A0, S0, ZERO
9D00779C  0F4015F0   JAL follow_path
9D0077A0  8FA5002C   LW A1, 44(SP)
2904:                		FREE_BUF();
2905:                		if (res == FR_OK) { /* Follow completed */
9D0077A4  14400015   BNE V0, ZERO, 0x9D0077FC
9D0077A8  38440004   XORI A0, V0, 4
2906:                			if (dj->dir) { /* It is not the root dir */
9D0077AC  8E030014   LW V1, 20(S0)
9D0077B0  50600016   BEQL V1, ZERO, 0x9D00780C
9D0077B4  8E020000   LW V0, 0(S0)
2907:                				if (dj->dir[DIR_Attr] & AM_DIR) { /* The object is a directory */
9D0077B8  9064000B   LBU A0, 11(V1)
9D0077BC  30840010   ANDI A0, A0, 16
9D0077C0  308400FF   ANDI A0, A0, 255
9D0077C4  10800018   BEQ A0, ZERO, 0x9D007828
9D0077C8  24020005   ADDIU V0, ZERO, 5
2908:                					dj->sclust = LD_CLUST(dj->dir);
9D0077CC  90640015   LBU A0, 21(V1)
9D0077D0  00042200   SLL A0, A0, 8
9D0077D4  90620014   LBU V0, 20(V1)
9D0077D8  00822025   OR A0, A0, V0
9D0077DC  00042400   SLL A0, A0, 16
9D0077E0  9062001B   LBU V0, 27(V1)
9D0077E4  00021200   SLL V0, V0, 8
9D0077E8  9063001A   LBU V1, 26(V1)
9D0077EC  00431025   OR V0, V0, V1
9D0077F0  00821025   OR V0, A0, V0
9D0077F4  0B401E02   J 0x9D007808
9D0077F8  AE020008   SW V0, 8(S0)
2909:                				} else { /* The object is not a directory */
2910:                					res = FR_NO_PATH;
2911:                				}
2912:                			}
2913:                			if (res == FR_OK) {
2914:                				dj->id = dj->fs->id;
9D007808  8E020000   LW V0, 0(S0)
9D00780C  94420006   LHU V0, 6(V0)
9D007810  A6020004   SH V0, 4(S0)
2915:                				res = dir_sdi(dj, 0); /* Rewind dir */
9D007814  02002021   ADDU A0, S0, ZERO
9D007818  0F401439   JAL dir_sdi
9D00781C  00002821   ADDU A1, ZERO, ZERO
2916:                			}
2917:                		}
2918:                		if (res == FR_NO_FILE){
2919:                			res = FR_NO_PATH;
9D0077FC  24030005   ADDIU V1, ZERO, 5
9D007800  0B401E0A   J 0x9D007828
9D007804  0064100A   MOVZ V0, V1, A0
9D007820  0B401DFF   J 0x9D0077FC
9D007824  38440004   XORI A0, V0, 4
2920:                                }
2921:                	}
2922:                	LEAVE_FF(dj->fs, res);
2923:                }
9D007828  8FBF0024   LW RA, 36(SP)
9D00782C  8FB00020   LW S0, 32(SP)
9D007830  03E00008   JR RA
9D007834  27BD0028   ADDIU SP, SP, 40
2924:                
2925:                /*-----------------------------------------------------------------------*/
2926:                /* Read Directory Entry in Sequense                                      */
2927:                /*-----------------------------------------------------------------------*/
2928:                
2929:                FRESULT f_readdir(DIR *dj, /* Pointer to the open directory object */
2930:                FILINFO *fno /* Pointer to file information to return */
2931:                ) {
9D007838  27BDFFD0   ADDIU SP, SP, -48
9D00783C  AFBF002C   SW RA, 44(SP)
9D007840  AFB20028   SW S2, 40(SP)
9D007844  AFB10024   SW S1, 36(SP)
9D007848  AFB00020   SW S0, 32(SP)
9D00784C  00808021   ADDU S0, A0, ZERO
9D007850  00A09021   ADDU S2, A1, ZERO
2932:                	FRESULT res;
2933:                	DEF_NAMEBUF;
2934:                
2935:                	res = validate(dj->fs, dj->id); /* Check validity of the object */
9D007854  8C840000   LW A0, 0(A0)
9D007858  0F401370   JAL validate
9D00785C  96050004   LHU A1, 4(S0)
2936:                	if (res == FR_OK) {
9D007860  1440001C   BNE V0, ZERO, 0x9D0078D4
9D007864  00408821   ADDU S1, V0, ZERO
2937:                		if (!fno) {
9D007868  16400006   BNE S2, ZERO, 0x9D007884
9D00786C  27A20010   ADDIU V0, SP, 16
2938:                			res = dir_sdi(dj, 0); /* Rewind the directory object */
9D007870  02002021   ADDU A0, S0, ZERO
9D007874  0F401439   JAL dir_sdi
9D007878  00002821   ADDU A1, ZERO, ZERO
9D00787C  0B401E35   J 0x9D0078D4
9D007880  00408821   ADDU S1, V0, ZERO
2939:                		} else {
2940:                			INIT_BUF(*dj);
9D007884  AE020018   SW V0, 24(S0)
2941:                			res = dir_read(dj); /* Read an directory item */
9D007888  0F401731   JAL dir_read
9D00788C  02002021   ADDU A0, S0, ZERO
2942:                			if (res == FR_NO_FILE) { /* Reached end of dir */
9D007890  24030004   ADDIU V1, ZERO, 4
9D007894  14430003   BNE V0, V1, 0x9D0078A4
9D007898  00000000   NOP
2943:                				dj->sect = 0;
9D00789C  0B401E2B   J 0x9D0078AC
9D0078A0  AE000010   SW ZERO, 16(S0)
2944:                				res = FR_OK;
2945:                			}
2946:                			if (res == FR_OK) { /* A valid entry is found */
9D0078A4  5440000B   BNEL V0, ZERO, 0x9D0078D4
9D0078A8  00408821   ADDU S1, V0, ZERO
2947:                				get_fileinfo(dj, fno); /* Get the object information */
9D0078AC  02002021   ADDU A0, S0, ZERO
9D0078B0  0F4012AF   JAL get_fileinfo
9D0078B4  02402821   ADDU A1, S2, ZERO
2948:                				res = dir_next(dj, 0); /* Increment index for next */
9D0078B8  02002021   ADDU A0, S0, ZERO
9D0078BC  0F401571   JAL dir_next
9D0078C0  00002821   ADDU A1, ZERO, ZERO
2949:                				if (res == FR_NO_FILE) {
9D0078C4  24030004   ADDIU V1, ZERO, 4
9D0078C8  54430002   BNEL V0, V1, 0x9D0078D4
9D0078CC  00408821   ADDU S1, V0, ZERO
9D0078D0  AE000010   SW ZERO, 16(S0)
2950:                					dj->sect = 0;
2951:                					res = FR_OK;
2952:                				}
2953:                			} FREE_BUF();
2954:                		}
2955:                	}
2956:                
2957:                	LEAVE_FF(dj->fs, res);
2958:                }
9D0078D4  02201021   ADDU V0, S1, ZERO
9D0078D8  8FBF002C   LW RA, 44(SP)
9D0078DC  8FB20028   LW S2, 40(SP)
9D0078E0  8FB10024   LW S1, 36(SP)
9D0078E4  8FB00020   LW S0, 32(SP)
9D0078E8  03E00008   JR RA
9D0078EC  27BD0030   ADDIU SP, SP, 48
2959:                
2960:                #if _FS_MINIMIZE == 0
2961:                /*-----------------------------------------------------------------------*/
2962:                /* Get File Status                                                       */
2963:                /*-----------------------------------------------------------------------*/
2964:                
2965:                FRESULT f_stat(const TCHAR *path, /* Pointer to the file path */
2966:                                FILINFO *fno /* Pointer to file information to return */
2967:                                ) {
9D0078F0  27BDFFB8   ADDIU SP, SP, -72
9D0078F4  AFBF0044   SW RA, 68(SP)
9D0078F8  AFB10040   SW S1, 64(SP)
9D0078FC  AFB0003C   SW S0, 60(SP)
9D007900  AFA40048   SW A0, 72(SP)
9D007904  00A08821   ADDU S1, A1, ZERO
2968:                	FRESULT res;
2969:                	DIR dj;
2970:                	DEF_NAMEBUF;
2971:                
2972:                	res = chk_mounted(&path, &dj.fs, 0);
9D007908  27A40048   ADDIU A0, SP, 72
9D00790C  27A50010   ADDIU A1, SP, 16
9D007910  0F401790   JAL chk_mounted
9D007914  00003021   ADDU A2, ZERO, ZERO
2973:                	if (res == FR_OK) {
9D007918  14400010   BNE V0, ZERO, 0x9D00795C
9D00791C  00408021   ADDU S0, V0, ZERO
2974:                		INIT_BUF(dj);
9D007920  27A2002C   ADDIU V0, SP, 44
9D007924  AFA20028   SW V0, 40(SP)
2975:                		res = follow_path(&dj, path); /* Follow the file path */
9D007928  27A40010   ADDIU A0, SP, 16
9D00792C  0F4015F0   JAL follow_path
9D007930  8FA50048   LW A1, 72(SP)
2976:                		if (res == FR_OK) { /* Follow completed */
9D007934  14400009   BNE V0, ZERO, 0x9D00795C
9D007938  00408021   ADDU S0, V0, ZERO
2977:                			if (dj.dir) /* Found an object */
9D00793C  8FA20024   LW V0, 36(SP)
9D007940  10400005   BEQ V0, ZERO, 0x9D007958
9D007944  27A40010   ADDIU A0, SP, 16
2978:                				get_fileinfo(&dj, fno);
9D007948  0F4012AF   JAL get_fileinfo
9D00794C  02202821   ADDU A1, S1, ZERO
9D007950  0B401E58   J 0x9D007960
9D007954  02001021   ADDU V0, S0, ZERO
2979:                			else
2980:                				/* It is root dir */
2981:                				res = FR_INVALID_NAME;
9D007958  24100006   ADDIU S0, ZERO, 6
2982:                		}FREE_BUF();
2983:                	}
2984:                
2985:                	LEAVE_FF(dj.fs, res);
2986:                }
9D00795C  02001021   ADDU V0, S0, ZERO
9D007960  8FBF0044   LW RA, 68(SP)
9D007964  8FB10040   LW S1, 64(SP)
9D007968  8FB0003C   LW S0, 60(SP)
9D00796C  03E00008   JR RA
9D007970  27BD0048   ADDIU SP, SP, 72
2987:                
2988:                #if !_FS_READONLY
2989:                /*-----------------------------------------------------------------------*/
2990:                /* Get Number of Free Clusters                                           */
2991:                /*-----------------------------------------------------------------------*/
2992:                
2993:                FRESULT f_getfree(const TCHAR *path, /* Pointer to the logical drive number (root dir) */
2994:                DWORD *nclst, /* Pointer to the variable to return number of free clusters */
2995:                FATFS **fatfs /* Pointer to pointer to corresponding file system object to return */
2996:                ) {
9D007974  27BDFFC8   ADDIU SP, SP, -56
9D007978  AFBF0034   SW RA, 52(SP)
9D00797C  AFB70030   SW S7, 48(SP)
9D007980  AFB6002C   SW S6, 44(SP)
9D007984  AFB50028   SW S5, 40(SP)
9D007988  AFB40024   SW S4, 36(SP)
9D00798C  AFB30020   SW S3, 32(SP)
9D007990  AFB2001C   SW S2, 28(SP)
9D007994  AFB10018   SW S1, 24(SP)
9D007998  AFB00014   SW S0, 20(SP)
9D00799C  AFA40038   SW A0, 56(SP)
9D0079A0  00A0B021   ADDU S6, A1, ZERO
9D0079A4  00C09021   ADDU S2, A2, ZERO
2997:                	FRESULT res;
2998:                	DWORD n, clst, sect, stat;
2999:                	UINT i;
3000:                	PF_BYTE fat, *p;
3001:                
3002:                	/* Get drive number */
3003:                	res = chk_mounted(&path, fatfs, 0);
9D0079A8  27A40038   ADDIU A0, SP, 56
9D0079AC  00C02821   ADDU A1, A2, ZERO
9D0079B0  0F401790   JAL chk_mounted
9D0079B4  00003021   ADDU A2, ZERO, ZERO
3004:                	if (res == FR_OK) {
9D0079B8  1440005C   BNE V0, ZERO, 0x9D007B2C
9D0079BC  0040A821   ADDU S5, V0, ZERO
3005:                		/* If free_clust is valid, return it without full cluster scan */
3006:                		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
9D0079C0  8E420000   LW V0, 0(S2)
9D0079C4  8C430010   LW V1, 16(V0)
9D0079C8  8C50001C   LW S0, 28(V0)
9D0079CC  2604FFFE   ADDIU A0, S0, -2
9D0079D0  0083202B   SLTU A0, A0, V1
9D0079D4  54800003   BNEL A0, ZERO, 0x9D0079E4
9D0079D8  90530000   LBU S3, 0(V0)
9D0079DC  0B401ECB   J 0x9D007B2C
9D0079E0  AEC30000   SW V1, 0(S6)
3007:                			*nclst = (*fatfs)->free_clust;
3008:                		} else {
3009:                			/* Get number of free clusters */
3010:                			fat = (*fatfs)->fs_type;
3011:                			n = 0;
9D007A48  00008821   ADDU S1, ZERO, ZERO
3012:                			if (fat == FS_FAT12) {
9D0079E4  24030001   ADDIU V1, ZERO, 1
9D0079E8  56630015   BNEL S3, V1, 0x9D007A40
9D0079EC  8C450024   LW A1, 36(V0)
9D0079F0  24100002   ADDIU S0, ZERO, 2
9D0079F4  00008821   ADDU S1, ZERO, ZERO
3013:                				clst = 2;
3014:                				do {
3015:                					stat = get_fat(*fatfs, clst);
9D007A00  8E440000   LW A0, 0(S2)
9D007A04  0F4013D7   JAL get_fat
9D007A08  02002821   ADDU A1, S0, ZERO
3016:                					if (stat == 0xFFFFFFFF) {
9D0079F8  2413FFFF   ADDIU S3, ZERO, -1
9D007A0C  50530044   BEQL V0, S3, 0x9D007B20
9D007A10  24150001   ADDIU S5, ZERO, 1
3017:                						res = FR_DISK_ERR;
3018:                						break;
3019:                					}
3020:                					if (stat == 1) {
9D0079FC  24140001   ADDIU S4, ZERO, 1
9D007A14  10540041   BEQ V0, S4, 0x9D007B1C
9D007A18  2C420001   SLTIU V0, V0, 1
3021:                						res = FR_INT_ERR;
9D007B1C  24150002   ADDIU S5, ZERO, 2
3022:                						break;
3023:                					}
3024:                					if (stat == 0)
3025:                						n++;
9D007A1C  02228821   ADDU S1, S1, V0
3026:                				} while (++clst < (*fatfs)->n_fatent);
9D007A20  26100001   ADDIU S0, S0, 1
9D007A24  8E420000   LW V0, 0(S2)
9D007A28  8C42001C   LW V0, 28(V0)
9D007A2C  0202102B   SLTU V0, S0, V0
9D007A30  5440FFF4   BNEL V0, ZERO, 0x9D007A04
9D007A34  8E440000   LW A0, 0(S2)
9D007A38  0B401EC9   J 0x9D007B24
9D007A3C  8E420000   LW V0, 0(S2)
3027:                			} else {
3028:                				clst = (*fatfs)->n_fatent;
3029:                				sect = (*fatfs)->fatbase;
3030:                				i = 0;
9D007A44  00002021   ADDU A0, ZERO, ZERO
3031:                				p = 0;
9D007A40  00001821   ADDU V1, ZERO, ZERO
3032:                				do {
3033:                					if (!i) {
9D007A50  14800008   BNE A0, ZERO, 0x9D007A74
9D007A54  24B70001   ADDIU S7, A1, 1
3034:                						res = move_window(*fatfs, sect++);
9D007A58  0F4012F8   JAL move_window
9D007A5C  8E440000   LW A0, 0(S2)
9D007AF0  0040A821   ADDU S5, V0, ZERO
3035:                						if (res != FR_OK)
9D007A60  14400023   BNE V0, ZERO, 0x9D007AF0
9D007A64  02E02821   ADDU A1, S7, ZERO
3036:                							break;
3037:                						p = (*fatfs)->win;
9D007A68  8E430000   LW V1, 0(S2)
9D007A6C  24630034   ADDIU V1, V1, 52
3038:                						i = SS(*fatfs);
9D007A70  24040200   ADDIU A0, ZERO, 512
3039:                					}
3040:                					if (fat == FS_FAT16) {
9D007A4C  24140002   ADDIU S4, ZERO, 2
9D007A74  5674000B   BNEL S3, S4, 0x9D007AA4
9D007A78  90660003   LBU A2, 3(V1)
3041:                						if (LD_WORD(p) == 0)
9D007A7C  90620001   LBU V0, 1(V1)
9D007A80  00021200   SLL V0, V0, 8
9D007A84  90660000   LBU A2, 0(V1)
9D007A88  00461025   OR V0, V0, A2
9D007A8C  7C021620   SEH V0, V0
3042:                							n++;
9D007A90  2C420001   SLTIU V0, V0, 1
9D007A94  02228821   ADDU S1, S1, V0
3043:                						p += 2;
9D007A98  24630002   ADDIU V1, V1, 2
9D007A9C  0B401EB7   J 0x9D007ADC
9D007AA0  2484FFFE   ADDIU A0, A0, -2
3044:                						i -= 2;
3045:                					} else {
3046:                						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0)
9D007AA4  00063600   SLL A2, A2, 24
9D007AA8  90620002   LBU V0, 2(V1)
9D007AAC  00021400   SLL V0, V0, 16
9D007AB0  00C21025   OR V0, A2, V0
9D007AB4  90660000   LBU A2, 0(V1)
9D007AB8  00461025   OR V0, V0, A2
9D007ABC  90660001   LBU A2, 1(V1)
9D007AC0  00063200   SLL A2, A2, 8
9D007AC4  00461025   OR V0, V0, A2
9D007AC8  7C42D800   EXT V0, V0, 0, 28
3047:                							n++;
9D007ACC  2C420001   SLTIU V0, V0, 1
9D007AD0  02228821   ADDU S1, S1, V0
3048:                						p += 4;
9D007AD4  24630004   ADDIU V1, V1, 4
3049:                						i -= 4;
9D007AD8  2484FFFC   ADDIU A0, A0, -4
3050:                					}
3051:                				} while (--clst);
9D007ADC  2610FFFF   ADDIU S0, S0, -1
9D007AE0  1600FFDB   BNE S0, ZERO, 0x9D007A50
9D007AE4  00000000   NOP
9D007AE8  0B401EBE   J 0x9D007AF8
9D007AEC  8E420000   LW V0, 0(S2)
3052:                			}
3053:                			(*fatfs)->free_clust = n;
9D007AF4  8E420000   LW V0, 0(S2)
9D007AF8  AC510010   SW S1, 16(V0)
9D007B20  8E420000   LW V0, 0(S2)
9D007B24  0B401EC5   J 0x9D007B14
9D007B28  AC510010   SW S1, 16(V0)
3054:                			if (fat == FS_FAT32)
9D007AFC  24020003   ADDIU V0, ZERO, 3
9D007B00  5662000A   BNEL S3, V0, 0x9D007B2C
9D007B04  AED10000   SW S1, 0(S6)
3055:                				(*fatfs)->fsi_flag = 1;
9D007B08  8E420000   LW V0, 0(S2)
9D007B0C  24030001   ADDIU V1, ZERO, 1
9D007B10  A0430005   SB V1, 5(V0)
3056:                			*nclst = n;
9D007B14  0B401ECB   J 0x9D007B2C
9D007B18  AED10000   SW S1, 0(S6)
3057:                		}
3058:                	}
3059:                	LEAVE_FF(*fatfs, res);
3060:                }
9D007B2C  02A01021   ADDU V0, S5, ZERO
9D007B30  8FBF0034   LW RA, 52(SP)
9D007B34  8FB70030   LW S7, 48(SP)
9D007B38  8FB6002C   LW S6, 44(SP)
9D007B3C  8FB50028   LW S5, 40(SP)
9D007B40  8FB40024   LW S4, 36(SP)
9D007B44  8FB30020   LW S3, 32(SP)
9D007B48  8FB2001C   LW S2, 28(SP)
9D007B4C  8FB10018   LW S1, 24(SP)
9D007B50  8FB00014   LW S0, 20(SP)
9D007B54  03E00008   JR RA
9D007B58  27BD0038   ADDIU SP, SP, 56
3061:                
3062:                /*-----------------------------------------------------------------------*/
3063:                /* Truncate File                                                         */
3064:                /*-----------------------------------------------------------------------*/
3065:                
3066:                FRESULT f_truncate(FIL *fp /* Pointer to the file object */
3067:                ) {
9D007B5C  27BDFFE0   ADDIU SP, SP, -32
9D007B60  AFBF001C   SW RA, 28(SP)
9D007B64  AFB20018   SW S2, 24(SP)
9D007B68  AFB10014   SW S1, 20(SP)
9D007B6C  AFB00010   SW S0, 16(SP)
9D007B70  00808021   ADDU S0, A0, ZERO
3068:                	FRESULT res;
3069:                	DWORD ncl;
3070:                
3071:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
9D007B74  8C840000   LW A0, 0(A0)
9D007B78  0F401370   JAL validate
9D007B7C  96050004   LHU A1, 4(S0)
3072:                	if (res == FR_OK) {
9D007B80  1440003E   BNE V0, ZERO, 0x9D007C7C
9D007B84  00408821   ADDU S1, V0, ZERO
3073:                		if (fp->flag & FA__ERROR) { /* Check abort flag */
9D007B88  92020006   LBU V0, 6(S0)
9D007B8C  7C021C20   SEB V1, V0
9D007B90  04600036   BLTZ V1, 0x9D007C6C
9D007B94  30420002   ANDI V0, V0, 2
3074:                			res = FR_INT_ERR;
9D007C6C  0B401F1F   J 0x9D007C7C
9D007C70  24110002   ADDIU S1, ZERO, 2
3075:                		} else {
3076:                			if (!(fp->flag & FA_WRITE)) /* Check access mode */
9D007B98  304200FF   ANDI V0, V0, 255
9D007B9C  50400037   BEQL V0, ZERO, 0x9D007C7C
9D007BA0  24110007   ADDIU S1, ZERO, 7
9D007BA4  0B401F15   J 0x9D007C54
9D007BA8  8E020008   LW V0, 8(S0)
3077:                				res = FR_DENIED;
3078:                		}
3079:                	}
3080:                	if (res == FR_OK) {
3081:                		if (fp->fsize > fp->fptr) {
9D007C54  8E03000C   LW V1, 12(S0)
9D007C58  0043182B   SLTU V1, V0, V1
9D007C5C  5460FFD3   BNEL V1, ZERO, 0x9D007BAC
9D007C60  AE02000C   SW V0, 12(S0)
9D007C64  0B401F20   J 0x9D007C80
9D007C68  02201021   ADDU V0, S1, ZERO
3082:                			fp->fsize = fp->fptr; /* Set file size to current R/W point */
3083:                			fp->flag |= FA__WRITTEN;
9D007BAC  92030006   LBU V1, 6(S0)
9D007BB0  34630020   ORI V1, V1, 32
3084:                			if (fp->fptr == 0) { /* When set file size to zero, remove entire cluster chain */
9D007BB4  14400007   BNE V0, ZERO, 0x9D007BD4
9D007BB8  A2030006   SB V1, 6(S0)
3085:                				res = remove_chain(fp->fs, fp->sclust);
9D007BBC  8E040000   LW A0, 0(S0)
9D007BC0  0F401758   JAL remove_chain
9D007BC4  8E050010   LW A1, 16(S0)
9D007BC8  00408821   ADDU S1, V0, ZERO
9D007BCC  0B401F0E   J 0x9D007C38
9D007BD0  AE000010   SW ZERO, 16(S0)
3086:                				fp->sclust = 0;
3087:                			} else { /* When truncate a part of the file, remove remaining clusters */
3088:                				ncl = get_fat(fp->fs, fp->clust);
9D007BD4  8E040000   LW A0, 0(S0)
9D007BD8  0F4013D7   JAL get_fat
9D007BDC  8E050014   LW A1, 20(S0)
9D007BE0  00409021   ADDU S2, V0, ZERO
3089:                				res = FR_OK;
3090:                				if (ncl == 0xFFFFFFFF)
9D007BF0  2C420001   SLTIU V0, V0, 1
3091:                					res = FR_DISK_ERR;
3092:                				if (ncl == 1)
9D007BE4  24020001   ADDIU V0, ZERO, 1
9D007BE8  12420022   BEQ S2, V0, 0x9D007C74
9D007BEC  26420001   ADDIU V0, S2, 1
3093:                					res = FR_INT_ERR;
9D007C74  0B401F10   J 0x9D007C40
9D007C78  24110002   ADDIU S1, ZERO, 2
3094:                				if (res == FR_OK && ncl < fp->fs->n_fatent) {
9D007BF4  54400012   BNEL V0, ZERO, 0x9D007C40
9D007BF8  00408821   ADDU S1, V0, ZERO
9D007BFC  8E040000   LW A0, 0(S0)
9D007C00  8C82001C   LW V0, 28(A0)
9D007C04  0242102B   SLTU V0, S2, V0
9D007C08  1040001D   BEQ V0, ZERO, 0x9D007C80
9D007C0C  02201021   ADDU V0, S1, ZERO
3095:                					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
9D007C10  8E050014   LW A1, 20(S0)
9D007C14  3C060FFF   LUI A2, 4095
9D007C18  0F4014A0   JAL put_fat
9D007C1C  34C6FFFF   ORI A2, A2, -1
3096:                					if (res == FR_OK)
9D007C20  14400007   BNE V0, ZERO, 0x9D007C40
9D007C24  00408821   ADDU S1, V0, ZERO
3097:                						res = remove_chain(fp->fs, ncl);
9D007C28  8E040000   LW A0, 0(S0)
9D007C2C  0F401758   JAL remove_chain
9D007C30  02402821   ADDU A1, S2, ZERO
9D007C34  00408821   ADDU S1, V0, ZERO
3098:                				}
3099:                			}
3100:                		}
3101:                		if (res != FR_OK)
9D007C38  12200011   BEQ S1, ZERO, 0x9D007C80
9D007C3C  02201021   ADDU V0, S1, ZERO
3102:                			fp->flag |= FA__ERROR;
9D007C40  92030006   LBU V1, 6(S0)
9D007C44  2402FF80   ADDIU V0, ZERO, -128
9D007C48  00621025   OR V0, V1, V0
9D007C4C  0B401F1F   J 0x9D007C7C
9D007C50  A2020006   SB V0, 6(S0)
3103:                	}
3104:                
3105:                	LEAVE_FF(fp->fs, res);
3106:                }
9D007C7C  02201021   ADDU V0, S1, ZERO
9D007C80  8FBF001C   LW RA, 28(SP)
9D007C84  8FB20018   LW S2, 24(SP)
9D007C88  8FB10014   LW S1, 20(SP)
9D007C8C  8FB00010   LW S0, 16(SP)
9D007C90  03E00008   JR RA
9D007C94  27BD0020   ADDIU SP, SP, 32
3107:                
3108:                /*-----------------------------------------------------------------------*/
3109:                /* Delete a File or Directory                                            */
3110:                /*-----------------------------------------------------------------------*/
3111:                
3112:                FRESULT f_unlink(const TCHAR *path /* Pointer to the file or directory path */
3113:                ) {
9D007C98  27BDFFA0   ADDIU SP, SP, -96
9D007C9C  AFBF005C   SW RA, 92(SP)
9D007CA0  AFB00058   SW S0, 88(SP)
9D007CA4  AFA40060   SW A0, 96(SP)
3114:                	FRESULT res;
3115:                	DIR dj, sdj;
3116:                	PF_BYTE *dir;
3117:                	DWORD dclst;
3118:                	DEF_NAMEBUF;
3119:                
3120:                	res = chk_mounted(&path, &dj.fs, 1);
9D007CA8  27A40060   ADDIU A0, SP, 96
9D007CAC  27A50010   ADDIU A1, SP, 16
9D007CB0  0F401790   JAL chk_mounted
9D007CB4  24060001   ADDIU A2, ZERO, 1
3121:                	if (res == FR_OK) {
9D007CB8  14400058   BNE V0, ZERO, 0x9D007E1C
9D007CBC  8FBF005C   LW RA, 92(SP)
3122:                		INIT_BUF(dj);
9D007CC0  27A20048   ADDIU V0, SP, 72
9D007CC4  AFA20028   SW V0, 40(SP)
3123:                		res = follow_path(&dj, path); /* Follow the file path */
9D007CC8  27A40010   ADDIU A0, SP, 16
9D007CCC  0F4015F0   JAL follow_path
9D007CD0  8FA50060   LW A1, 96(SP)
3124:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D007CD4  14400051   BNE V0, ZERO, 0x9D007E1C
9D007CD8  8FBF005C   LW RA, 92(SP)
9D007CDC  8FA20028   LW V0, 40(SP)
9D007CE0  9043000B   LBU V1, 11(V0)
9D007CE4  30630020   ANDI V1, V1, 32
9D007CE8  306300FF   ANDI V1, V1, 255
9D007CEC  1460004A   BNE V1, ZERO, 0x9D007E18
9D007CF0  24020006   ADDIU V0, ZERO, 6
9D007CF4  0B401F69   J 0x9D007DA4
9D007CF8  27A40010   ADDIU A0, SP, 16
3125:                			res = FR_INVALID_NAME; /* Cannot remove dot entry */
3126:                #if _FS_SHARE
3127:                		if (res == FR_OK) res = chk_lock(&dj, 2); /* Cannot remove open file */
9D007DA4  0F401262   JAL chk_lock
9D007DA8  24050002   ADDIU A1, ZERO, 2
3128:                #endif
3129:                		if (res == FR_OK) { /* The object is accessible */
9D007DAC  1040FFD3   BEQ V0, ZERO, 0x9D007CFC
9D007DB0  8FA30024   LW V1, 36(SP)
9D007DB4  0B401F87   J 0x9D007E1C
9D007DB8  8FBF005C   LW RA, 92(SP)
3130:                			dir = dj.dir;
3131:                			if (!dir) {
9D007CFC  50600046   BEQL V1, ZERO, 0x9D007E18
9D007D00  24020006   ADDIU V0, ZERO, 6
3132:                				res = FR_INVALID_NAME; /* Cannot remove the start directory */
3133:                			} else {
3134:                				if (dir[DIR_Attr] & AM_RDO)
9D007D04  9064000B   LBU A0, 11(V1)
9D007D08  30840001   ANDI A0, A0, 1
9D007D0C  14800042   BNE A0, ZERO, 0x9D007E18
9D007D10  24020007   ADDIU V0, ZERO, 7
9D007D14  0B401F75   J 0x9D007DD4
9D007D18  90620015   LBU V0, 21(V1)
3135:                					res = FR_DENIED; /* Cannot remove R/O object */
3136:                			}
3137:                			dclst = LD_CLUST(dir);
9D007DD4  00021200   SLL V0, V0, 8
9D007DD8  90640014   LBU A0, 20(V1)
9D007DDC  00441025   OR V0, V0, A0
9D007DE0  00021400   SLL V0, V0, 16
9D007DE4  9070001B   LBU S0, 27(V1)
9D007DE8  00108200   SLL S0, S0, 8
9D007DEC  9064001A   LBU A0, 26(V1)
9D007DF0  02048025   OR S0, S0, A0
9D007DF4  00508025   OR S0, V0, S0
3138:                			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) { /* Is it a sub-dir? */
9D007DF8  9062000B   LBU V0, 11(V1)
9D007DFC  30420010   ANDI V0, V0, 16
9D007E00  304200FF   ANDI V0, V0, 255
9D007E04  1440FFC5   BNE V0, ZERO, 0x9D007D1C
9D007E08  2E030002   SLTIU V1, S0, 2
9D007E0C  0B401F6F   J 0x9D007DBC
9D007E10  00000000   NOP
9D007E14  24020007   ADDIU V0, ZERO, 7
3139:                				if (dclst < 2) {
9D007D1C  1460003E   BNE V1, ZERO, 0x9D007E18
9D007D20  24020002   ADDIU V0, ZERO, 2
3140:                					res = FR_INT_ERR;
3141:                				} else {
3142:                					mem_cpy(&sdj, &dj, sizeof(DIR)); /* Check if the sub-dir is empty or not */
9D007D24  27A4002C   ADDIU A0, SP, 44
9D007D28  27A50010   ADDIU A1, SP, 16
9D007D2C  0F401259   JAL mem_cpy
9D007D30  2406001C   ADDIU A2, ZERO, 28
3143:                					sdj.sclust = dclst;
9D007D34  AFB00034   SW S0, 52(SP)
3144:                					res = dir_sdi(&sdj, 2); /* Exclude dot entries */
9D007D38  27A4002C   ADDIU A0, SP, 44
9D007D3C  0F401439   JAL dir_sdi
9D007D40  24050002   ADDIU A1, ZERO, 2
3145:                					if (res == FR_OK) {
9D007D44  14400035   BNE V0, ZERO, 0x9D007E1C
9D007D48  8FBF005C   LW RA, 92(SP)
3146:                						res = dir_read(&sdj);
9D007D4C  0F401731   JAL dir_read
9D007D50  27A4002C   ADDIU A0, SP, 44
3147:                						if (res == FR_OK /* Not empty dir */
9D007D54  50400030   BEQL V0, ZERO, 0x9D007E18
9D007D58  24020007   ADDIU V0, ZERO, 7
3148:                #if _FS_RPATH
3149:                							|| dclst == sdj.fs->cdir /* Current dir */
9D007D5C  8FA3002C   LW V1, 44(SP)
9D007D60  8C630018   LW V1, 24(V1)
9D007D64  1070002B   BEQ V1, S0, 0x9D007E14
9D007D68  24030004   ADDIU V1, ZERO, 4
3150:                #endif
3151:                							) res = FR_DENIED;
3152:                						if (res == FR_NO_FILE)
9D007D6C  10430013   BEQ V0, V1, 0x9D007DBC
9D007D70  8FBF005C   LW RA, 92(SP)
9D007D74  0B401F88   J 0x9D007E20
9D007D78  8FB00058   LW S0, 88(SP)
3153:                							res = FR_OK; /* Empty */
3154:                					}
3155:                				}
3156:                			}
3157:                			if (res == FR_OK) {
3158:                				res = dir_remove(&dj); /* Remove the directory entry */
9D007DBC  0F40148A   JAL dir_remove
9D007DC0  27A40010   ADDIU A0, SP, 16
3159:                				if (res == FR_OK) {
9D007DC4  1040FFED   BEQ V0, ZERO, 0x9D007D7C
9D007DC8  8FBF005C   LW RA, 92(SP)
9D007DCC  0B401F88   J 0x9D007E20
9D007DD0  8FB00058   LW S0, 88(SP)
3160:                					if (dclst) /* Remove the cluster chain if exist */
9D007D7C  12000005   BEQ S0, ZERO, 0x9D007D94
9D007D80  8FA40010   LW A0, 16(SP)
3161:                						res = remove_chain(dj.fs, dclst);
9D007D84  0F401758   JAL remove_chain
9D007D88  02002821   ADDU A1, S0, ZERO
3162:                					if (res == FR_OK)
9D007D8C  54400023   BNEL V0, ZERO, 0x9D007E1C
9D007D90  8FBF005C   LW RA, 92(SP)
3163:                						res = sync(dj.fs);
9D007D94  0F401387   JAL sync
9D007D98  8FA40010   LW A0, 16(SP)
3164:                				}
3165:                			}
3166:                		}FREE_BUF();
3167:                	}
3168:                	LEAVE_FF(dj.fs, res);
3169:                }
9D007D9C  0B401F87   J 0x9D007E1C
9D007DA0  8FBF005C   LW RA, 92(SP)
9D007E18  8FBF005C   LW RA, 92(SP)
9D007E1C  8FB00058   LW S0, 88(SP)
9D007E20  03E00008   JR RA
9D007E24  27BD0060   ADDIU SP, SP, 96
3170:                
3171:                /*-----------------------------------------------------------------------*/
3172:                /* Create a Directory                                                    */
3173:                /*-----------------------------------------------------------------------*/
3174:                
3175:                FRESULT f_mkdir(const TCHAR *path /* Pointer to the directory path */
3176:                ) {
9D007E28  27BDFF88   ADDIU SP, SP, -120
9D007E2C  AFBF0074   SW RA, 116(SP)
9D007E30  AFBE0070   SW S8, 112(SP)
9D007E34  AFB7006C   SW S7, 108(SP)
9D007E38  AFB60068   SW S6, 104(SP)
9D007E3C  AFB50064   SW S5, 100(SP)
9D007E40  AFB40060   SW S4, 96(SP)
9D007E44  AFB3005C   SW S3, 92(SP)
9D007E48  AFB20058   SW S2, 88(SP)
9D007E4C  AFB10054   SW S1, 84(SP)
9D007E50  AFB00050   SW S0, 80(SP)
3177:                	FRESULT res;
3178:                	DIR dj;
3179:                	PF_BYTE *dir, n;
3180:                	DWORD dsc, dcl, pcl, tim = get_fattime();
9D007E54  0F4042BB   JAL get_fattime
9D007E58  AFA40078   SW A0, 120(SP)
9D007E5C  0040A821   ADDU S5, V0, ZERO
3181:                	DEF_NAMEBUF;
3182:                
3183:                	res = chk_mounted(&path, &dj.fs, 1);
9D007E60  27A40078   ADDIU A0, SP, 120
9D007E64  27A50010   ADDIU A1, SP, 16
9D007E68  0F401790   JAL chk_mounted
9D007E6C  24060001   ADDIU A2, ZERO, 1
3184:                	if (res == FR_OK) {
9D007E70  144000A0   BNE V0, ZERO, 0x9D0080F4
9D007E74  00408021   ADDU S0, V0, ZERO
3185:                		INIT_BUF(dj);
9D007E78  27A2002C   ADDIU V0, SP, 44
9D007E7C  AFA20028   SW V0, 40(SP)
3186:                		res = follow_path(&dj, path); /* Follow the file path */
9D007E80  27A40010   ADDIU A0, SP, 16
9D007E84  0F4015F0   JAL follow_path
9D007E88  8FA50078   LW A1, 120(SP)
3187:                		if (res == FR_OK)
9D007E8C  50400099   BEQL V0, ZERO, 0x9D0080F4
9D007E90  24100008   ADDIU S0, ZERO, 8
3188:                			res = FR_EXIST; /* Any object with same name is already existing */
3189:                		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
9D007E94  24030004   ADDIU V1, ZERO, 4
9D007E98  54430096   BNEL V0, V1, 0x9D0080F4
9D007E9C  00408021   ADDU S0, V0, ZERO
9D007EA0  8FA20028   LW V0, 40(SP)
9D007EA4  9042000B   LBU V0, 11(V0)
9D007EA8  30420020   ANDI V0, V0, 32
9D007EAC  304200FF   ANDI V0, V0, 255
9D007EB0  54400090   BNEL V0, ZERO, 0x9D0080F4
9D007EB4  24100006   ADDIU S0, ZERO, 6
9D007EB8  0B402031   J 0x9D0080C4
9D007EBC  8FA40010   LW A0, 16(SP)
3190:                			res = FR_INVALID_NAME;
3191:                		if (res == FR_NO_FILE) { /* Can create a new directory */
3192:                			dcl = create_chain(dj.fs, 0); /* Allocate a cluster for the new directory table */
9D0080C4  0F40150D   JAL create_chain
9D0080C8  00002821   ADDU A1, ZERO, ZERO
3193:                			res = FR_OK;
3194:                			if (dcl == 0)
9D0080CC  1040FF83   BEQ V0, ZERO, 0x9D007EDC
9D0080D0  0040A021   ADDU S4, V0, ZERO
9D0080D4  0B401FB0   J 0x9D007EC0
9D0080D8  24020001   ADDIU V0, ZERO, 1
3195:                				res = FR_DENIED; /* No space to allocate a new cluster */
9D007EDC  24100007   ADDIU S0, ZERO, 7
3196:                			if (dcl == 1)
9D007EC0  52820064   BEQL S4, V0, 0x9D008054
9D007EC4  24100002   ADDIU S0, ZERO, 2
3197:                				res = FR_INT_ERR;
3198:                			if (dcl == 0xFFFFFFFF)
9D007EC8  2402FFFF   ADDIU V0, ZERO, -1
9D007ECC  52820061   BEQL S4, V0, 0x9D008054
9D007ED0  24100001   ADDIU S0, ZERO, 1
9D007ED4  0B401FB8   J 0x9D007EE0
9D007ED8  00000000   NOP
3199:                				res = FR_DISK_ERR;
3200:                			if (res == FR_OK) /* Flush FAT */
9D007EE0  1600005C   BNE S0, ZERO, 0x9D008054
9D007EE4  8FA40010   LW A0, 16(SP)
3201:                				res = move_window(dj.fs, 0);
9D007EE8  0F4012F8   JAL move_window
9D007EEC  00002821   ADDU A1, ZERO, ZERO
3202:                			if (res == FR_OK) { /* Initialize the new directory table */
9D007EF0  14400058   BNE V0, ZERO, 0x9D008054
9D007EF4  00408021   ADDU S0, V0, ZERO
3203:                				dsc = clust2sect(dj.fs, dcl);
9D007EF8  8FB20010   LW S2, 16(SP)
9D007EFC  02402021   ADDU A0, S2, ZERO
9D007F00  0F4013CB   JAL clust2sect
9D007F04  02802821   ADDU A1, S4, ZERO
9D007F08  00408021   ADDU S0, V0, ZERO
3204:                				dir = dj.fs->win;
9D007F0C  26530034   ADDIU S3, S2, 52
9D007F10  26510234   ADDIU S1, S2, 564
3205:                				mem_set(dir, 0, SS(dj.fs));
3206:                				mem_set(dir + DIR_Name, ' ', 8 + 3); /* Create "." entry */
3207:                				dir[DIR_Name] = '.';
9D007F3C  2416002E   ADDIU S6, ZERO, 46
9D007F40  A2560034   SB S6, 52(S2)
3208:                				dir[DIR_Attr] = AM_DIR;
9D007F44  24020010   ADDIU V0, ZERO, 16
9D007F48  A242003F   SB V0, 63(S2)
3209:                				ST_DWORD(dir+DIR_WrtTime, tim);
9D007F4C  32A200FF   ANDI V0, S5, 255
9D007F50  AFA20038   SW V0, 56(SP)
9D007F54  A242004A   SB V0, 74(S2)
9D007F58  7EA33A00   EXT V1, S5, 8, 8
9D007F5C  AFA3003C   SW V1, 60(SP)
9D007F60  A243004B   SB V1, 75(S2)
9D007F64  7EA23C00   EXT V0, S5, 16, 8
9D007F68  AFA20040   SW V0, 64(SP)
9D007F6C  A242004C   SB V0, 76(S2)
9D007F70  0015AE02   SRL S5, S5, 24
9D007F74  AFB50044   SW S5, 68(SP)
9D007F78  A255004D   SB S5, 77(S2)
3210:                				ST_CLUST(dir, dcl);
9D007F7C  328300FF   ANDI V1, S4, 255
9D007F80  AFA30048   SW V1, 72(SP)
9D007F84  A243004E   SB V1, 78(S2)
9D007F88  7E823A00   EXT V0, S4, 8, 8
9D007F8C  AFA2004C   SW V0, 76(SP)
9D007F90  A242004F   SB V0, 79(S2)
9D007F94  0014F402   SRL S8, S4, 16
9D007F98  33D700FF   ANDI S7, S8, 255
9D007F9C  A2570048   SB S7, 72(S2)
9D007FA0  001EF202   SRL S8, S8, 8
9D007FA4  A25E0049   SB S8, 73(S2)
3211:                				mem_cpy(dir + SZ_DIR, dir, SZ_DIR); /* Create ".." entry */
9D007FA8  26440054   ADDIU A0, S2, 84
9D007FAC  02602821   ADDU A1, S3, ZERO
9D007FB0  0F401259   JAL mem_cpy
9D007FB4  24060020   ADDIU A2, ZERO, 32
3212:                				dir[33] = '.';
9D007FB8  A2560055   SB S6, 85(S2)
3213:                				pcl = dj.sclust;
3214:                				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
9D007FBC  8FA30010   LW V1, 16(SP)
9D007FC0  90650000   LBU A1, 0(V1)
9D007FC4  24040003   ADDIU A0, ZERO, 3
9D007FC8  14A40004   BNE A1, A0, 0x9D007FDC
9D007FCC  8FA20018   LW V0, 24(SP)
9D007FD0  8C640028   LW A0, 40(V1)
3215:                					pcl = 0;
9D007FD4  00822026   XOR A0, A0, V0
9D007FD8  0004100A   MOVZ V0, ZERO, A0
3216:                				ST_CLUST(dir+SZ_DIR, pcl);
9D007FDC  A242006E   SB V0, 110(S2)
9D007FE0  7C443A00   EXT A0, V0, 8, 8
9D007FE4  A244006F   SB A0, 111(S2)
9D007FE8  00021402   SRL V0, V0, 16
9D007FEC  A2420068   SB V0, 104(S2)
9D007FF0  00021202   SRL V0, V0, 8
9D007FF4  A2420069   SB V0, 105(S2)
3217:                				for (n = dj.fs->csize; n; n--) { /* Write dot entries and clear following sectors */
9D007FF8  90620002   LBU V0, 2(V1)
9D007FFC  10400037   BEQ V0, ZERO, 0x9D0080DC
9D008000  2442FFFF   ADDIU V0, V0, -1
9D008004  305600FF   ANDI S6, V0, 255
9D008008  26D60001   ADDIU S6, S6, 1
9D00800C  02D0B021   ADDU S6, S6, S0
9D008044  12560025   BEQ S2, S6, 0x9D0080DC
9D008048  00000000   NOP
3218:                					dj.fs->winsect = dsc++;
9D008014  8FA40010   LW A0, 16(SP)
9D008018  26120001   ADDIU S2, S0, 1
9D00801C  AC900030   SW S0, 48(A0)
9D00804C  0B402005   J 0x9D008014
9D008050  02408021   ADDU S0, S2, ZERO
3219:                					dj.fs->wflag = 1;
9D008010  24150001   ADDIU S5, ZERO, 1
9D008020  A0950004   SB S5, 4(A0)
3220:                					res = move_window(dj.fs, 0);
9D008024  0F4012F8   JAL move_window
9D008028  00002821   ADDU A1, ZERO, ZERO
3221:                					if (res != FR_OK)
9D00802C  14400009   BNE V0, ZERO, 0x9D008054
9D008030  00408021   ADDU S0, V0, ZERO
9D008034  02601021   ADDU V0, S3, ZERO
3222:                						break;
3223:                					mem_set(dir, 0, SS(dj.fs));
3224:                				}
3225:                			}
3226:                			if (res == FR_OK)
3227:                				res = dir_register(&dj); /* Register the object to the directoy */
9D0080DC  0F4016FC   JAL dir_register
9D0080E0  27A40010   ADDIU A0, SP, 16
3228:                			if (res != FR_OK) {
9D0080E4  1040FFE0   BEQ V0, ZERO, 0x9D008068
9D0080E8  00408021   ADDU S0, V0, ZERO
9D0080EC  0B402016   J 0x9D008058
9D0080F0  8FA40010   LW A0, 16(SP)
3229:                				remove_chain(dj.fs, dcl); /* Could not register, remove cluster chain */
9D008054  8FA40010   LW A0, 16(SP)
9D008058  0F401758   JAL remove_chain
9D00805C  02802821   ADDU A1, S4, ZERO
9D008060  0B40203E   J 0x9D0080F8
9D008064  02001021   ADDU V0, S0, ZERO
3230:                			} else {
3231:                				dir = dj.dir;
9D008068  8FA20024   LW V0, 36(SP)
3232:                				dir[DIR_Attr] = AM_DIR; /* Attribute */
9D00806C  24030010   ADDIU V1, ZERO, 16
9D008070  A043000B   SB V1, 11(V0)
3233:                				ST_DWORD(dir+DIR_WrtTime, tim); /* Created time */
9D008074  8FA30038   LW V1, 56(SP)
9D008078  A0430016   SB V1, 22(V0)
9D00807C  8FA3003C   LW V1, 60(SP)
9D008080  A0430017   SB V1, 23(V0)
9D008084  8FA30040   LW V1, 64(SP)
9D008088  A0430018   SB V1, 24(V0)
9D00808C  8FA30044   LW V1, 68(SP)
9D008090  A0430019   SB V1, 25(V0)
3234:                				ST_CLUST(dir, dcl); /* Table start cluster */
9D008094  8FA30048   LW V1, 72(SP)
9D008098  A043001A   SB V1, 26(V0)
9D00809C  8FA3004C   LW V1, 76(SP)
9D0080A0  A043001B   SB V1, 27(V0)
9D0080A4  A0570014   SB S7, 20(V0)
9D0080A8  A05E0015   SB S8, 21(V0)
3235:                				dj.fs->wflag = 1;
9D0080AC  8FA40010   LW A0, 16(SP)
9D0080B0  24020001   ADDIU V0, ZERO, 1
3236:                				res = sync(dj.fs);
9D0080B4  0F401387   JAL sync
9D0080B8  A0820004   SB V0, 4(A0)
9D0080BC  0B40203D   J 0x9D0080F4
9D0080C0  00408021   ADDU S0, V0, ZERO
3237:                			}
3238:                		}FREE_BUF();
3239:                	}
3240:                
3241:                	LEAVE_FF(dj.fs, res);
3242:                }
9D0080F4  02001021   ADDU V0, S0, ZERO
9D0080F8  8FBF0074   LW RA, 116(SP)
9D0080FC  8FBE0070   LW S8, 112(SP)
9D008100  8FB7006C   LW S7, 108(SP)
9D008104  8FB60068   LW S6, 104(SP)
9D008108  8FB50064   LW S5, 100(SP)
9D00810C  8FB40060   LW S4, 96(SP)
9D008110  8FB3005C   LW S3, 92(SP)
9D008114  8FB20058   LW S2, 88(SP)
9D008118  8FB10054   LW S1, 84(SP)
9D00811C  8FB00050   LW S0, 80(SP)
9D008120  03E00008   JR RA
9D008124  27BD0078   ADDIU SP, SP, 120
3243:                
3244:                /*-----------------------------------------------------------------------*/
3245:                /* Change Attribute                                                      */
3246:                /*-----------------------------------------------------------------------*/
3247:                
3248:                FRESULT f_chmod(const TCHAR *path, /* Pointer to the file path */
3249:                PF_BYTE value, /* Attribute bits */
3250:                PF_BYTE mask /* Attribute mask to change */
3251:                ) {
9D008128  27BDFFB8   ADDIU SP, SP, -72
9D00812C  AFBF0044   SW RA, 68(SP)
9D008130  AFB10040   SW S1, 64(SP)
9D008134  AFB0003C   SW S0, 60(SP)
9D008138  AFA40048   SW A0, 72(SP)
9D00813C  00A08021   ADDU S0, A1, ZERO
9D008140  00C08821   ADDU S1, A2, ZERO
3252:                	FRESULT res;
3253:                	DIR dj;
3254:                	PF_BYTE *dir;
3255:                	DEF_NAMEBUF;
3256:                
3257:                	res = chk_mounted(&path, &dj.fs, 1);
9D008144  27A40048   ADDIU A0, SP, 72
9D008148  27A50010   ADDIU A1, SP, 16
9D00814C  0F401790   JAL chk_mounted
9D008150  24060001   ADDIU A2, ZERO, 1
3258:                	if (res == FR_OK) {
9D008154  14400020   BNE V0, ZERO, 0x9D0081D8
9D008158  8FBF0044   LW RA, 68(SP)
3259:                		INIT_BUF(dj);
9D00815C  27A2002C   ADDIU V0, SP, 44
9D008160  AFA20028   SW V0, 40(SP)
3260:                		res = follow_path(&dj, path); /* Follow the file path */
9D008164  27A40010   ADDIU A0, SP, 16
9D008168  0F4015F0   JAL follow_path
9D00816C  8FA50048   LW A1, 72(SP)
3261:                		FREE_BUF();
3262:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D008170  14400019   BNE V0, ZERO, 0x9D0081D8
9D008174  8FBF0044   LW RA, 68(SP)
9D008178  8FA20028   LW V0, 40(SP)
9D00817C  9043000B   LBU V1, 11(V0)
9D008180  30630020   ANDI V1, V1, 32
9D008184  306300FF   ANDI V1, V1, 255
9D008188  14600012   BNE V1, ZERO, 0x9D0081D4
9D00818C  24020006   ADDIU V0, ZERO, 6
9D008190  0B402073   J 0x9D0081CC
9D008194  8FA30024   LW V1, 36(SP)
3263:                			res = FR_INVALID_NAME;
3264:                		if (res == FR_OK) {
3265:                			dir = dj.dir;
3266:                			if (!dir) { /* Is it a root directory? */
9D0081CC  1460FFF2   BNE V1, ZERO, 0x9D008198
9D0081D0  24020006   ADDIU V0, ZERO, 6
3267:                				res = FR_INVALID_NAME;
3268:                			} else { /* File or sub directory */
3269:                				mask &= AM_RDO | AM_HID | AM_SYS | AM_ARC; /* Valid attribute mask */
9D008198  32310027   ANDI S1, S1, 39
3270:                				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr]
9D0081A0  9062000B   LBU V0, 11(V1)
9D0081A4  00821024   AND V0, A0, V0
9D0081A8  02308824   AND S1, S1, S0
9D0081AC  00518825   OR S1, V0, S1
9D0081B0  A071000B   SB S1, 11(V1)
3271:                						& (PF_BYTE) ~mask); /* Apply attribute change */
9D00819C  00112027   NOR A0, ZERO, S1
3272:                				dj.fs->wflag = 1;
9D0081B4  8FA40010   LW A0, 16(SP)
9D0081B8  24020001   ADDIU V0, ZERO, 1
3273:                				res = sync(dj.fs);
9D0081BC  0F401387   JAL sync
9D0081C0  A0820004   SB V0, 4(A0)
3274:                			}
3275:                		}
3276:                	}
3277:                
3278:                	LEAVE_FF(dj.fs, res);
3279:                }
9D0081C4  0B402076   J 0x9D0081D8
9D0081C8  8FBF0044   LW RA, 68(SP)
9D0081D4  8FBF0044   LW RA, 68(SP)
9D0081D8  8FB10040   LW S1, 64(SP)
9D0081DC  8FB0003C   LW S0, 60(SP)
9D0081E0  03E00008   JR RA
9D0081E4  27BD0048   ADDIU SP, SP, 72
3280:                
3281:                /*-----------------------------------------------------------------------*/
3282:                /* Change Timestamp                                                      */
3283:                /*-----------------------------------------------------------------------*/
3284:                
3285:                FRESULT f_utime(const TCHAR *path, /* Pointer to the file/directory name */
3286:                const FILINFO *fno /* Pointer to the time stamp to be set */
3287:                ) {
9D0081E8  27BDFFC0   ADDIU SP, SP, -64
9D0081EC  AFBF003C   SW RA, 60(SP)
9D0081F0  AFB00038   SW S0, 56(SP)
9D0081F4  AFA40040   SW A0, 64(SP)
9D0081F8  00A08021   ADDU S0, A1, ZERO
3288:                	FRESULT res;
3289:                	DIR dj;
3290:                	PF_BYTE *dir;
3291:                	DEF_NAMEBUF;
3292:                
3293:                	res = chk_mounted(&path, &dj.fs, 1);
9D0081FC  27A40040   ADDIU A0, SP, 64
9D008200  27A50010   ADDIU A1, SP, 16
9D008204  0F401790   JAL chk_mounted
9D008208  24060001   ADDIU A2, ZERO, 1
3294:                	if (res == FR_OK) {
9D00820C  14400023   BNE V0, ZERO, 0x9D00829C
9D008210  8FBF003C   LW RA, 60(SP)
3295:                		INIT_BUF(dj);
9D008214  27A2002C   ADDIU V0, SP, 44
9D008218  AFA20028   SW V0, 40(SP)
3296:                		res = follow_path(&dj, path); /* Follow the file path */
9D00821C  27A40010   ADDIU A0, SP, 16
9D008220  0F4015F0   JAL follow_path
9D008224  8FA50040   LW A1, 64(SP)
3297:                		FREE_BUF();
3298:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D008228  1440001C   BNE V0, ZERO, 0x9D00829C
9D00822C  8FBF003C   LW RA, 60(SP)
9D008230  8FA20028   LW V0, 40(SP)
9D008234  9043000B   LBU V1, 11(V0)
9D008238  30630020   ANDI V1, V1, 32
9D00823C  306300FF   ANDI V1, V1, 255
9D008240  14600015   BNE V1, ZERO, 0x9D008298
9D008244  24020006   ADDIU V0, ZERO, 6
9D008248  0B4020A4   J 0x9D008290
9D00824C  8FA30024   LW V1, 36(SP)
3299:                			res = FR_INVALID_NAME;
3300:                		if (res == FR_OK) {
3301:                			dir = dj.dir;
3302:                			if (!dir) { /* Root directory */
9D008290  1460FFEF   BNE V1, ZERO, 0x9D008250
9D008294  24020006   ADDIU V0, ZERO, 6
3303:                				res = FR_INVALID_NAME;
3304:                			} else { /* File or sub-directory */
3305:                				ST_WORD(dir+DIR_WrtTime, fno->ftime);
9D008250  96020006   LHU V0, 6(S0)
9D008254  A0620016   SB V0, 22(V1)
9D008258  96020006   LHU V0, 6(S0)
9D00825C  00021202   SRL V0, V0, 8
9D008260  A0620017   SB V0, 23(V1)
3306:                				ST_WORD(dir+DIR_WrtDate, fno->fdate);
9D008264  96020004   LHU V0, 4(S0)
9D008268  A0620018   SB V0, 24(V1)
9D00826C  96020004   LHU V0, 4(S0)
9D008270  00021202   SRL V0, V0, 8
9D008274  A0620019   SB V0, 25(V1)
3307:                				dj.fs->wflag = 1;
9D008278  8FA40010   LW A0, 16(SP)
9D00827C  24020001   ADDIU V0, ZERO, 1
3308:                				res = sync(dj.fs);
9D008280  0F401387   JAL sync
9D008284  A0820004   SB V0, 4(A0)
3309:                			}
3310:                		}
3311:                	}
3312:                
3313:                	LEAVE_FF(dj.fs, res);
3314:                }
9D008288  0B4020A7   J 0x9D00829C
9D00828C  8FBF003C   LW RA, 60(SP)
9D008298  8FBF003C   LW RA, 60(SP)
9D00829C  8FB00038   LW S0, 56(SP)
9D0082A0  03E00008   JR RA
9D0082A4  27BD0040   ADDIU SP, SP, 64
3315:                
3316:                /*-----------------------------------------------------------------------*/
3317:                /* Rename File/Directory                                                 */
3318:                /*-----------------------------------------------------------------------*/
3319:                
3320:                FRESULT f_rename(const TCHAR *path_old, /* Pointer to the old name */
3321:                const TCHAR *path_new /* Pointer to the new name */
3322:                ) {
9D0082A8  27BDFF80   ADDIU SP, SP, -128
9D0082AC  AFBF007C   SW RA, 124(SP)
9D0082B0  AFB10078   SW S1, 120(SP)
9D0082B4  AFB00074   SW S0, 116(SP)
9D0082B8  AFA40080   SW A0, 128(SP)
9D0082BC  00A08021   ADDU S0, A1, ZERO
3323:                	FRESULT res;
3324:                	DIR djo, djn;
3325:                	PF_BYTE buf[21], *dir;
3326:                	DWORD dw;
3327:                	DEF_NAMEBUF;
3328:                
3329:                	res = chk_mounted(&path_old, &djo.fs, 1);
9D0082C0  27A40080   ADDIU A0, SP, 128
9D0082C4  27A50010   ADDIU A1, SP, 16
9D0082C8  0F401790   JAL chk_mounted
9D0082CC  24060001   ADDIU A2, ZERO, 1
3330:                	if (res == FR_OK) {
9D0082D0  14400074   BNE V0, ZERO, 0x9D0084A4
9D0082D4  8FBF007C   LW RA, 124(SP)
3331:                		djn.fs = djo.fs;
9D0082D8  8FA20010   LW V0, 16(SP)
9D0082DC  AFA2002C   SW V0, 44(SP)
3332:                		INIT_BUF(djo);
9D0082E0  27A20060   ADDIU V0, SP, 96
9D0082E4  AFA20028   SW V0, 40(SP)
3333:                		res = follow_path(&djo, path_old); /* Check old object */
9D0082E8  27A40010   ADDIU A0, SP, 16
9D0082EC  0F4015F0   JAL follow_path
9D0082F0  8FA50080   LW A1, 128(SP)
3334:                		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
9D0082F4  1440006B   BNE V0, ZERO, 0x9D0084A4
9D0082F8  8FBF007C   LW RA, 124(SP)
9D0082FC  8FA20028   LW V0, 40(SP)
9D008300  9043000B   LBU V1, 11(V0)
9D008304  30630020   ANDI V1, V1, 32
9D008308  306300FF   ANDI V1, V1, 255
9D00830C  14600064   BNE V1, ZERO, 0x9D0084A0
9D008310  24020006   ADDIU V0, ZERO, 6
9D008314  0B40211E   J 0x9D008478
9D008318  27A40010   ADDIU A0, SP, 16
3335:                			res = FR_INVALID_NAME;
3336:                #if _FS_SHARE
3337:                		if (res == FR_OK) res = chk_lock(&djo, 2);
9D008478  0F401262   JAL chk_lock
9D00847C  24050002   ADDIU A1, ZERO, 2
3338:                #endif
3339:                		if (res == FR_OK) { /* Old object is found */
9D008480  5040FFA6   BEQL V0, ZERO, 0x9D00831C
9D008484  8FA50024   LW A1, 36(SP)
9D008488  0B402129   J 0x9D0084A4
9D00848C  8FBF007C   LW RA, 124(SP)
3340:                			if (!djo.dir) { /* Is root dir? */
9D00831C  10A00060   BEQ A1, ZERO, 0x9D0084A0
9D008320  24020004   ADDIU V0, ZERO, 4
3341:                				res = FR_NO_FILE;
3342:                			} else {
3343:                				mem_cpy(buf, djo.dir + DIR_Attr, 21); /* Save the object information except for name */
9D008324  27A40048   ADDIU A0, SP, 72
9D008328  24A5000B   ADDIU A1, A1, 11
9D00832C  0F401259   JAL mem_cpy
9D008330  24060015   ADDIU A2, ZERO, 21
3344:                				mem_cpy(&djn, &djo, sizeof(DIR)); /* Check new object */
9D008334  27A4002C   ADDIU A0, SP, 44
9D008338  27A50010   ADDIU A1, SP, 16
9D00833C  0F401259   JAL mem_cpy
9D008340  2406001C   ADDIU A2, ZERO, 28
3345:                				res = follow_path(&djn, path_new);
9D008344  27A4002C   ADDIU A0, SP, 44
9D008348  0F4015F0   JAL follow_path
9D00834C  02002821   ADDU A1, S0, ZERO
3346:                				if (res == FR_OK)
9D008350  50400053   BEQL V0, ZERO, 0x9D0084A0
9D008354  24020008   ADDIU V0, ZERO, 8
3347:                					res = FR_EXIST; /* The new object name is already existing */
3348:                				if (res == FR_NO_FILE) { /* Is it a valid path and no name collision? */
9D008358  24030004   ADDIU V1, ZERO, 4
9D00835C  14430051   BNE V0, V1, 0x9D0084A4
9D008360  8FBF007C   LW RA, 124(SP)
3349:                					/* Start critical section that any interruption or error can cause cross-link */
3350:                					res = dir_register(&djn); /* Register the new entry */
9D008364  0F4016FC   JAL dir_register
9D008368  27A4002C   ADDIU A0, SP, 44
3351:                					if (res == FR_OK) {
9D00836C  1440004D   BNE V0, ZERO, 0x9D0084A4
9D008370  8FBF007C   LW RA, 124(SP)
3352:                						dir = djn.dir; /* Copy object information except for name */
9D008374  8FB00040   LW S0, 64(SP)
3353:                						mem_cpy(dir + 13, buf + 2, 19);
9D008378  2604000D   ADDIU A0, S0, 13
9D00837C  27A5004A   ADDIU A1, SP, 74
9D008380  0F401259   JAL mem_cpy
9D008384  24060013   ADDIU A2, ZERO, 19
3354:                						dir[DIR_Attr] = buf[0] | AM_ARC;
9D008388  93A20048   LBU V0, 72(SP)
9D00838C  34420020   ORI V0, V0, 32
9D008390  A202000B   SB V0, 11(S0)
3355:                						djo.fs->wflag = 1;
9D008394  24030001   ADDIU V1, ZERO, 1
9D008398  8FA20010   LW V0, 16(SP)
9D00839C  A0430004   SB V1, 4(V0)
3356:                						if (djo.sclust != djn.sclust
9D0083A0  8FA20034   LW V0, 52(SP)
9D0083A4  8FA30018   LW V1, 24(SP)
9D0083A8  10620039   BEQ V1, V0, 0x9D008490
9D0083AC  00000000   NOP
3357:                								&& (dir[DIR_Attr] & AM_DIR)) { /* Update .. entry in the directory if needed */
9D0083B0  9202000B   LBU V0, 11(S0)
9D0083B4  30420010   ANDI V0, V0, 16
9D0083B8  304200FF   ANDI V0, V0, 255
9D0083BC  10400034   BEQ V0, ZERO, 0x9D008490
9D0083C0  8FB1002C   LW S1, 44(SP)
3358:                							dw = clust2sect(djn.fs, LD_CLUST(dir));
9D0083C4  92050015   LBU A1, 21(S0)
9D0083C8  00052A00   SLL A1, A1, 8
9D0083CC  92020014   LBU V0, 20(S0)
9D0083D0  00A22825   OR A1, A1, V0
9D0083D4  00052C00   SLL A1, A1, 16
9D0083D8  9203001B   LBU V1, 27(S0)
9D0083DC  00031A00   SLL V1, V1, 8
9D0083E0  9202001A   LBU V0, 26(S0)
9D0083E4  00621025   OR V0, V1, V0
9D0083E8  02202021   ADDU A0, S1, ZERO
9D0083EC  0F4013CB   JAL clust2sect
9D0083F0  00A22825   OR A1, A1, V0
9D0083F4  00402821   ADDU A1, V0, ZERO
3359:                							if (!dw) {
9D0083F8  10A00029   BEQ A1, ZERO, 0x9D0084A0
9D0083FC  24020002   ADDIU V0, ZERO, 2
3360:                								res = FR_INT_ERR;
3361:                							} else {
3362:                								res = move_window(djn.fs, dw);
9D008400  0F4012F8   JAL move_window
9D008404  02202021   ADDU A0, S1, ZERO
3363:                								dir = djn.fs->win + SZ_DIR; /* .. entry */
3364:                								if (res == FR_OK && dir[1] == '.') {
9D008408  14400025   BNE V0, ZERO, 0x9D0084A0
9D00840C  8FA3002C   LW V1, 44(SP)
9D008410  90640055   LBU A0, 85(V1)
9D008414  2402002E   ADDIU V0, ZERO, 46
9D008418  1482001D   BNE A0, V0, 0x9D008490
9D00841C  24020003   ADDIU V0, ZERO, 3
3365:                									dw
3366:                											= (djn.fs->fs_type == FS_FAT32
3367:                													&& djn.sclust
9D00842C  8C620028   LW V0, 40(V1)
9D008430  8FA40034   LW A0, 52(SP)
9D008434  14820002   BNE A0, V0, 0x9D008440
9D008438  8FA20034   LW V0, 52(SP)
3368:                															== djn.fs->dirbase) ? 0
3369:                													: djn.sclust;
9D008420  90640000   LBU A0, 0(V1)
9D008424  14820006   BNE A0, V0, 0x9D008440
9D008428  8FA20034   LW V0, 52(SP)
9D00843C  00001021   ADDU V0, ZERO, ZERO
3370:                									ST_CLUST(dir, dw);
9D008440  A062006E   SB V0, 110(V1)
9D008444  7C443A00   EXT A0, V0, 8, 8
9D008448  A064006F   SB A0, 111(V1)
9D00844C  00021402   SRL V0, V0, 16
9D008450  A0620068   SB V0, 104(V1)
9D008454  00021202   SRL V0, V0, 8
9D008458  A0620069   SB V0, 105(V1)
3371:                									djn.fs->wflag = 1;
9D00845C  24020001   ADDIU V0, ZERO, 1
9D008460  0B402124   J 0x9D008490
9D008464  A0620004   SB V0, 4(V1)
3372:                								}
3373:                							}
3374:                						}
3375:                						if (res == FR_OK) {
3376:                							res = dir_remove(&djo); /* Remove old entry */
9D008490  0F40148A   JAL dir_remove
9D008494  27A40010   ADDIU A0, SP, 16
3377:                							if (res == FR_OK)
9D008498  1040FFF3   BEQ V0, ZERO, 0x9D008468
9D00849C  00000000   NOP
3378:                								res = sync(djo.fs);
9D008468  0F401387   JAL sync
9D00846C  8FA40010   LW A0, 16(SP)
3379:                						}
3380:                					}
3381:                					/* End critical section */
3382:                				}
3383:                			}
3384:                		}FREE_BUF();
3385:                	}
3386:                	LEAVE_FF(djo.fs, res);
3387:                }
9D008470  0B402129   J 0x9D0084A4
9D008474  8FBF007C   LW RA, 124(SP)
9D0084A0  8FBF007C   LW RA, 124(SP)
9D0084A4  8FB10078   LW S1, 120(SP)
9D0084A8  8FB00074   LW S0, 116(SP)
9D0084AC  03E00008   JR RA
9D0084B0  27BD0080   ADDIU SP, SP, 128
3388:                
3389:                #endif /* !_FS_READONLY */
3390:                #endif /* _FS_MINIMIZE == 0 */
3391:                #endif /* _FS_MINIMIZE <= 1 */
3392:                #endif /* _FS_MINIMIZE <= 2 */
3393:                
3394:                /*-----------------------------------------------------------------------*/
3395:                /* Forward data to the stream directly (available on only tiny cfg)      */
3396:                /*-----------------------------------------------------------------------*/
3397:                #if _USE_FORWARD && _FS_TINY
3398:                
3399:                FRESULT f_forward (
3400:                		FIL *fp, /* Pointer to the file object */
3401:                		UINT (*func)(const PF_BYTE*,UINT), /* Pointer to the streaming function */
3402:                		UINT btr, /* Number of bytes to forward */
3403:                		UINT *bf /* Pointer to number of bytes forwarded */
3404:                )
3405:                {
3406:                	FRESULT res;
3407:                	DWORD remain, clst, sect;
3408:                	UINT rcnt;
3409:                	PF_BYTE csect;
3410:                
3411:                	*bf = 0; /* Initialize byte counter */
3412:                
3413:                	res = validate(fp->fs, fp->id); /* Check validity of the object */
3414:                	if (res != FR_OK) LEAVE_FF(fp->fs, res);
3415:                	if (fp->flag & FA__ERROR) /* Check error flag */
3416:                	LEAVE_FF(fp->fs, FR_INT_ERR);
3417:                	if (!(fp->flag & FA_READ)) /* Check access mode */
3418:                	LEAVE_FF(fp->fs, FR_DENIED);
3419:                
3420:                	remain = fp->fsize - fp->fptr;
3421:                	if (btr > remain) btr = (UINT)remain; /* Truncate btr by remaining bytes */
3422:                
3423:                	for (; btr && (*func)(0, 0); /* Repeat until all data transferred or stream becomes busy */
3424:                			fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
3425:                		csect = (PF_BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1)); /* Sector offset in the cluster */
3426:                		if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
3427:                			if (!csect) { /* On the cluster boundary? */
3428:                				clst = (fp->fptr == 0) ? /* On the top of the file? */
3429:                				fp->sclust : get_fat(fp->fs, fp->clust);
3430:                				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
3431:                				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
3432:                				fp->clust = clst; /* Update current cluster */
3433:                			}
3434:                		}
3435:                		sect = clust2sect(fp->fs, fp->clust); /* Get current data sector */
3436:                		if (!sect) ABORT(fp->fs, FR_INT_ERR);
3437:                		sect += csect;
3438:                		if (move_window(fp->fs, sect)) /* Move sector window */
3439:                		ABORT(fp->fs, FR_DISK_ERR);
3440:                		fp->dsect = sect;
3441:                		rcnt = SS(fp->fs) - (PF_WORD)(fp->fptr % SS(fp->fs)); /* Forward data from sector window */
3442:                		if (rcnt > btr) rcnt = btr;
3443:                		rcnt = (*func)(&fp->fs->win[(PF_WORD)fp->fptr % SS(fp->fs)], rcnt);
3444:                		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
3445:                	}
3446:                
3447:                	LEAVE_FF(fp->fs, FR_OK);
3448:                }
3449:                #endif /* _USE_FORWARD */
3450:                
3451:                #if _USE_MKFS && !_FS_READONLY
3452:                /*-----------------------------------------------------------------------*/
3453:                /* Create File System on the Drive                                       */
3454:                /*-----------------------------------------------------------------------*/
3455:                #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
3456:                #define N_FATS		1		/* Number of FAT copies (1 or 2) */
3457:                
3458:                FRESULT f_mkfs (
3459:                		PF_BYTE drv, /* Logical drive number */
3460:                		PF_BYTE sfd, /* Partitioning rule 0:FDISK, 1:SFD */
3461:                		UINT au /* Allocation unit size [bytes] */
3462:                )
3463:                {
3464:                	static const PF_WORD vst[] = {1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0};
3465:                	static const PF_WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
3466:                	PF_BYTE fmt, md, sys, *tbl, pdrv, part;
3467:                	DWORD n_clst, vs, n, wsect;
3468:                	UINT i;
3469:                	DWORD b_vol, b_fat, b_dir, b_data; /* LBA */
3470:                	DWORD n_vol, n_rsv, n_fat, n_dir; /* Size */
3471:                	FATFS *fs;
3472:                	DSTATUS stat;
3473:                
3474:                	/* Check mounted drive and clear work area */
3475:                	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
3476:                	if (sfd > 1) return FR_INVALID_PARAMETER;
3477:                	if (au & (au - 1)) return FR_INVALID_PARAMETER;
3478:                	fs = FatFs[drv];
3479:                	if (!fs) return FR_NOT_ENABLED;
3480:                	fs->fs_type = 0;
3481:                	pdrv = LD2PD(drv); /* Physical drive */
3482:                	part = LD2PT(drv); /* Partition (0:auto detect, 1-4:get from partition table)*/
3483:                
3484:                	/* Get disk statics */
3485:                	stat = disk_initialize(pdrv);
3486:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3487:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3488:                #if _MAX_SS != 512					/* Get disk sector size */
3489:                	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
3490:                	return FR_DISK_ERR;
3491:                #endif
3492:                	if (_MULTI_PARTITION && part) {
3493:                		/* Get partition information from partition table in the MBR */
3494:                		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3495:                		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
3496:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3497:                		if (!tbl[4]) return FR_MKFS_ABORTED; /* No partition? */
3498:                		b_vol = LD_DWORD(tbl+8); /* Volume start sector */
3499:                		n_vol = LD_DWORD(tbl+12); /* Volume size */
3500:                	} else {
3501:                		/* Create a partition in this function */
3502:                		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
3503:                		return FR_DISK_ERR;
3504:                		b_vol = (sfd) ? 0 : 63; /* Volume start sector */
3505:                		n_vol -= b_vol; /* Volume size */
3506:                	}
3507:                
3508:                	if (!au) { /* AU auto selection */
3509:                		vs = n_vol / (2000 / (SS(fs) / 512));
3510:                		for (i = 0; vs < vst[i]; i++);
3511:                		au = cst[i];
3512:                	}
3513:                	au /= SS(fs); /* Number of sectors per cluster */
3514:                	if (au == 0) au = 1;
3515:                	if (au > 128) au = 128;
3516:                
3517:                	/* Pre-compute number of clusters and FAT syb-type */
3518:                	n_clst = n_vol / au;
3519:                	fmt = FS_FAT12;
3520:                	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
3521:                	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
3522:                
3523:                	/* Determine offset and size of FAT structure */
3524:                	if (fmt == FS_FAT32) {
3525:                		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
3526:                		n_rsv = 32;
3527:                		n_dir = 0;
3528:                	} else {
3529:                		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
3530:                		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
3531:                		n_rsv = 1;
3532:                		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
3533:                	}
3534:                	b_fat = b_vol + n_rsv; /* FAT area start sector */
3535:                	b_dir = b_fat + n_fat * N_FATS; /* Directory area start sector */
3536:                	b_data = b_dir + n_dir; /* Data area start sector */
3537:                	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED; /* Too small volume */
3538:                
3539:                	/* Align data start sector to erase block boundary (for flash memory media) */
3540:                	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
3541:                	n = (b_data + n - 1) & ~(n - 1); /* Next nearest erase block from current data start */
3542:                	n = (n - b_data) / N_FATS;
3543:                	if (fmt == FS_FAT32) { /* FAT32: Move FAT offset */
3544:                		n_rsv += n;
3545:                		b_fat += n;
3546:                	} else { /* FAT12/16: Expand FAT size */
3547:                		n_fat += n;
3548:                	}
3549:                
3550:                	/* Determine number of clusters and final check of validity of the FAT sub-type */
3551:                	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
3552:                	if ( (fmt == FS_FAT16 && n_clst < MIN_FAT16)
3553:                			|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
3554:                	return FR_MKFS_ABORTED;
3555:                
3556:                	switch (fmt) { /* Determine system ID for partition table */
3557:                		case FS_FAT12: sys = 0x01; break;
3558:                		case FS_FAT16: sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
3559:                		default: sys = 0x0C;
3560:                	}
3561:                
3562:                	if (_MULTI_PARTITION && part) {
3563:                		/* Update system ID in the partition table */
3564:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
3565:                		tbl[4] = sys;
3566:                		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
3567:                		md = 0xF8;
3568:                	} else {
3569:                		if (sfd) { /* No patition table (SFD) */
3570:                			md = 0xF0;
3571:                		} else { /* Create partition table (FDISK) */
3572:                			mem_set(fs->win, 0, SS(fs));
3573:                			tbl = fs->win+MBR_Table; /* Create partiton table for single partition in the drive */
3574:                			tbl[1] = 1; /* Partition start head */
3575:                			tbl[2] = 1; /* Partition start sector */
3576:                			tbl[3] = 0; /* Partition start cylinder */
3577:                			tbl[4] = sys; /* System type */
3578:                			tbl[5] = 254; /* Partition end head */
3579:                			n = (b_vol + n_vol) / 63 / 255;
3580:                			tbl[6] = (PF_BYTE)((n >> 2) | 63); /* Partiiton end sector */
3581:                			tbl[7] = (PF_BYTE)n; /* End cylinder */
3582:                			ST_DWORD(tbl+8, 63); /* Partition start in LBA */
3583:                			ST_DWORD(tbl+12, n_vol); /* Partition size in LBA */
3584:                			ST_WORD(fs->win+BS_55AA, 0xAA55); /* MBR signature */
3585:                			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) /* Write it to the MBR sector */
3586:                			return FR_DISK_ERR;
3587:                			md = 0xF8;
3588:                		}
3589:                	}
3590:                
3591:                	/* Create BPB in the VBR */
3592:                	tbl = fs->win; /* Clear sector */
3593:                	mem_set(tbl, 0, SS(fs));
3594:                	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
3595:                	i = SS(fs); /* Sector size */
3596:                	ST_WORD(tbl+BPB_BytsPerSec, i);
3597:                	tbl[BPB_SecPerClus] = (PF_BYTE)au; /* Sectors per cluster */
3598:                	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv); /* Reserved sectors */
3599:                	tbl[BPB_NumFATs] = N_FATS; /* Number of FATs */
3600:                	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR; /* Number of rootdir entries */
3601:                	ST_WORD(tbl+BPB_RootEntCnt, i);
3602:                	if (n_vol < 0x10000) { /* Number of total sectors */
3603:                		ST_WORD(tbl+BPB_TotSec16, n_vol);
3604:                	} else {
3605:                		ST_DWORD(tbl+BPB_TotSec32, n_vol);
3606:                	}
3607:                	tbl[BPB_Media] = md; /* Media descriptor */
3608:                	ST_WORD(tbl+BPB_SecPerTrk, 63); /* Number of sectors per track */
3609:                	ST_WORD(tbl+BPB_NumHeads, 255); /* Number of heads */
3610:                	ST_DWORD(tbl+BPB_HiddSec, b_vol); /* Hidden sectors */
3611:                	n = get_fattime(); /* Use current time as VSN */
3612:                	if (fmt == FS_FAT32) {
3613:                		ST_DWORD(tbl+BS_VolID32, n); /* VSN */
3614:                		ST_DWORD(tbl+BPB_FATSz32, n_fat); /* Number of sectors per FAT */
3615:                		ST_DWORD(tbl+BPB_RootClus, 2); /* Root directory start cluster (2) */
3616:                		ST_WORD(tbl+BPB_FSInfo, 1); /* FSInfo record offset (VBR+1) */
3617:                		ST_WORD(tbl+BPB_BkBootSec, 6); /* Backup boot record offset (VBR+6) */
3618:                		tbl[BS_DrvNum32] = 0x80; /* Drive number */
3619:                		tbl[BS_BootSig32] = 0x29; /* Extended boot signature */
3620:                		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19); /* Volume label, FAT signature */
3621:                	} else {
3622:                		ST_DWORD(tbl+BS_VolID, n); /* VSN */
3623:                		ST_WORD(tbl+BPB_FATSz16, n_fat); /* Number of sectors per FAT */
3624:                		tbl[BS_DrvNum] = 0x80; /* Drive number */
3625:                		tbl[BS_BootSig] = 0x29; /* Extended boot signature */
3626:                		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19); /* Volume label, FAT signature */
3627:                	}
3628:                	ST_WORD(tbl+BS_55AA, 0xAA55); /* Signature (Offset is fixed here regardless of sector size) */
3629:                	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK) /* Write it to the VBR sector */
3630:                	return FR_DISK_ERR;
3631:                	if (fmt == FS_FAT32) /* Write backup VBR if needed (VBR+6) */
3632:                	disk_write(pdrv, tbl, b_vol + 6, 1);
3633:                
3634:                	/* Initialize FAT area */
3635:                	wsect = b_fat;
3636:                	for (i = 0; i < N_FATS; i++) { /* Initialize each FAT copy */
3637:                		mem_set(tbl, 0, SS(fs)); /* 1st sector of the FAT  */
3638:                		n = md; /* Media descriptor byte */
3639:                		if (fmt != FS_FAT32) {
3640:                			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
3641:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT12/16) */
3642:                		} else {
3643:                			n |= 0xFFFFFF00;
3644:                			ST_DWORD(tbl+0, n); /* Reserve cluster #0-1 (FAT32) */
3645:                			ST_DWORD(tbl+4, 0xFFFFFFFF);
3646:                			ST_DWORD(tbl+8, 0x0FFFFFFF); /* Reserve cluster #2 for root dir */
3647:                		}
3648:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3649:                		return FR_DISK_ERR;
3650:                		mem_set(tbl, 0, SS(fs)); /* Fill following FAT entries with zero */
3651:                		for (n = 1; n < n_fat; n++) { /* This loop may take a time on FAT32 volume due to many single sector writes */
3652:                			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3653:                			return FR_DISK_ERR;
3654:                		}
3655:                	}
3656:                
3657:                	/* Initialize root directory */
3658:                	i = (fmt == FS_FAT32) ? au : n_dir;
3659:                	do {
3660:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
3661:                		return FR_DISK_ERR;
3662:                	}while (--i);
3663:                
3664:                #if _USE_ERASE	/* Erase data area if needed */
3665:                	{
3666:                		DWORD eb[2];
3667:                
3668:                		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
3669:                		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
3670:                	}
3671:                #endif
3672:                
3673:                	/* Create FSInfo if needed */
3674:                	if (fmt == FS_FAT32) {
3675:                		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
3676:                		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
3677:                		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1); /* Number of free clusters */
3678:                		ST_DWORD(tbl+FSI_Nxt_Free, 2); /* Last allocated cluster# */
3679:                		ST_WORD(tbl+BS_55AA, 0xAA55);
3680:                		disk_write(pdrv, tbl, b_vol + 1, 1); /* Write original (VBR+1) */
3681:                		disk_write(pdrv, tbl, b_vol + 7, 1); /* Write backup (VBR+7) */
3682:                	}
3683:                
3684:                	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
3685:                }
3686:                
3687:                #if _MULTI_PARTITION == 2
3688:                /*-----------------------------------------------------------------------*/
3689:                /* Divide Physical Drive                                                 */
3690:                /*-----------------------------------------------------------------------*/
3691:                
3692:                FRESULT f_fdisk (
3693:                		PF_BYTE pdrv, /* Physical drive number */
3694:                		const DWORD szt[], /* Pointer to the size table for each partitions */
3695:                		void* work /* Pointer to the working buffer */
3696:                )
3697:                {
3698:                	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
3699:                	PF_BYTE s_hd, e_hd, *p, *buf = (PF_BYTE*)work;
3700:                	DSTATUS stat;
3701:                	DWORD sz_disk, sz_part, s_part;
3702:                
3703:                	stat = disk_initialize(pdrv);
3704:                	if (stat & STA_NOINIT) return FR_NOT_READY;
3705:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
3706:                	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
3707:                
3708:                	/* Determine CHS in the table regardless of the drive geometry */
3709:                	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2);
3710:                	if (n == 256) n--;
3711:                	e_hd = n - 1;
3712:                	sz_cyl = 63 * n;
3713:                	tot_cyl = sz_disk / sz_cyl;
3714:                
3715:                	/* Create partition table */
3716:                	mem_set(buf, 0, _MAX_SS);
3717:                	p = buf + MBR_Table; b_cyl = 0;
3718:                	for (i = 0; i < 4; i++, p += SZ_PTE) {
3719:                		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
3720:                		if (!p_cyl) continue;
3721:                		s_part = (DWORD)sz_cyl * b_cyl;
3722:                		sz_part = (DWORD)sz_cyl * p_cyl;
3723:                		if (i == 0) { /* Exclude first track of cylinder 0 */
3724:                			s_hd = 1;
3725:                			s_part += 63; sz_part -= 63;
3726:                		} else {
3727:                			s_hd = 0;
3728:                		}
3729:                		e_cyl = b_cyl + p_cyl - 1;
3730:                		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
3731:                
3732:                		/* Set partition table */
3733:                		p[1] = s_hd; /* Start head */
3734:                		p[2] = (PF_BYTE)((b_cyl >> 2) + 1); /* Start sector */
3735:                		p[3] = (PF_BYTE)b_cyl; /* Start cylinder */
3736:                		p[4] = 0x06; /* System type (temporary setting) */
3737:                		p[5] = e_hd; /* End head */
3738:                		p[6] = (PF_BYTE)((e_cyl >> 2) + 63); /* End sector */
3739:                		p[7] = (PF_BYTE)e_cyl; /* End cylinder */
3740:                		ST_DWORD(p + 8, s_part); /* Start sector in LBA */
3741:                		ST_DWORD(p + 12, sz_part); /* Partition size */
3742:                
3743:                		/* Next partition */
3744:                		b_cyl += p_cyl;
3745:                	}
3746:                	ST_WORD(p, 0xAA55);
3747:                
3748:                	/* Write it to the MBR */
3749:                	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
3750:                }
3751:                
3752:                #endif /* _MULTI_PARTITION == 2 */
3753:                #endif /* _USE_MKFS && !_FS_READONLY */
3754:                
3755:                #if _USE_STRFUNC
3756:                /*-----------------------------------------------------------------------*/
3757:                /* Get a string from the file                                            */
3758:                /*-----------------------------------------------------------------------*/
3759:                TCHAR* f_gets (
3760:                		TCHAR* buff, /* Pointer to the string buffer to read */
3761:                		int len, /* Size of string buffer (characters) */
3762:                		FIL* fil /* Pointer to the file object */
3763:                )
3764:                {
3765:                	int n = 0;
3766:                	TCHAR c, *p = buff;
3767:                	PF_BYTE s[2];
3768:                	UINT rc;
3769:                
3770:                	while (n < len - 1) { /* Read bytes until buffer gets filled */
3771:                		f_read(fil, s, 1, &rc);
3772:                		if (rc != 1) break; /* Break on EOF or error */
3773:                		c = s[0];
3774:                #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
3775:                		if (c >= 0x80) {
3776:                			if (c < 0xC0) continue; /* Skip stray trailer */
3777:                			if (c < 0xE0) { /* Two-byte sequense */
3778:                				f_read(fil, s, 1, &rc);
3779:                				if (rc != 1) break;
3780:                				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
3781:                				if (c < 0x80) c = '?';
3782:                			} else {
3783:                				if (c < 0xF0) { /* Three-byte sequense */
3784:                					f_read(fil, s, 2, &rc);
3785:                					if (rc != 2) break;
3786:                					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
3787:                					if (c < 0x800) c = '?';
3788:                				} else { /* Reject four-byte sequense */
3789:                					c = '?';
3790:                				}
3791:                			}
3792:                		}
3793:                #endif
3794:                #if _USE_STRFUNC >= 2
3795:                		if (c == '\r') continue; /* Strip '\r' */
3796:                #endif
3797:                		*p++ = c;
3798:                		n++;
3799:                		if (c == '\n') break; /* Break on EOL */
3800:                	}
3801:                	*p = 0;
3802:                	return n ? buff : 0; /* When no data read (eof or error), return with error. */
3803:                }
3804:                
3805:                #if !_FS_READONLY
3806:                #include <stdarg.h>
3807:                /*-----------------------------------------------------------------------*/
3808:                /* Put a character to the file                                           */
3809:                /*-----------------------------------------------------------------------*/
3810:                int f_putc (
3811:                		TCHAR c, /* A character to be output */
3812:                		FIL* fil /* Pointer to the file object */
3813:                )
3814:                {
3815:                	UINT bw, btw;
3816:                	PF_BYTE s[3];
3817:                
3818:                #if _USE_STRFUNC >= 2
3819:                	if (c == '\n') f_putc ('\r', fil); /* LF -> CRLF conversion */
3820:                #endif
3821:                
3822:                #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
3823:                	if (c < 0x80) { /* 7-bit */
3824:                		s[0] = (PF_BYTE)c;
3825:                		btw = 1;
3826:                	} else {
3827:                		if (c < 0x800) { /* 11-bit */
3828:                			s[0] = (PF_BYTE)(0xC0 | (c >> 6));
3829:                			s[1] = (PF_BYTE)(0x80 | (c & 0x3F));
3830:                			btw = 2;
3831:                		} else { /* 16-bit */
3832:                			s[0] = (PF_BYTE)(0xE0 | (c >> 12));
3833:                			s[1] = (PF_BYTE)(0x80 | ((c >> 6) & 0x3F));
3834:                			s[2] = (PF_BYTE)(0x80 | (c & 0x3F));
3835:                			btw = 3;
3836:                		}
3837:                	}
3838:                #else				/* Write the character without conversion */
3839:                	s[0] = (PF_BYTE)c;
3840:                	btw = 1;
3841:                #endif
3842:                	f_write(fil, s, btw, &bw); /* Write the char to the file */
3843:                	return (bw == btw) ? 1 : EOF; /* Return the result */
3844:                }
3845:                
3846:                /*-----------------------------------------------------------------------*/
3847:                /* Put a string to the file                                              */
3848:                /*-----------------------------------------------------------------------*/
3849:                int f_puts (
3850:                		const TCHAR* str, /* Pointer to the string to be output */
3851:                		FIL* fil /* Pointer to the file object */
3852:                )
3853:                {
3854:                	int n;
3855:                
3856:                	for (n = 0; *str; str++, n++) {
3857:                		if (f_putc(*str, fil) == EOF) return EOF;
3858:                	}
3859:                	return n;
3860:                }
3861:                
3862:                /*-----------------------------------------------------------------------*/
3863:                /* Put a formatted string to the file                                    */
3864:                /*-----------------------------------------------------------------------*/
3865:                int f_printf (
3866:                		FIL* fil, /* Pointer to the file object */
3867:                		const TCHAR* str, /* Pointer to the format string */
3868:                		... /* Optional arguments... */
3869:                )
3870:                {
3871:                	va_list arp;
3872:                	PF_BYTE f, r;
3873:                	UINT i, j, w;
3874:                	ULONG v;
3875:                	TCHAR c, d, s[16], *p;
3876:                	int res, chc, cc;
3877:                
3878:                	va_start(arp, str);
3879:                
3880:                	for (cc = res = 0; cc != EOF; res += cc) {
3881:                		c = *str++;
3882:                		if (c == 0) break; /* End of string */
3883:                		if (c != '%') { /* Non escape character */
3884:                			cc = f_putc(c, fil);
3885:                			if (cc != EOF) cc = 1;
3886:                			continue;
3887:                		}
3888:                		w = f = 0;
3889:                		c = *str++;
3890:                		if (c == '0') { /* Flag: '0' padding */
3891:                			f = 1; c = *str++;
3892:                		} else {
3893:                			if (c == '-') { /* Flag: left justified */
3894:                				f = 2; c = *str++;
3895:                			}
3896:                		}
3897:                		while (IsDigit(c)) { /* Precision */
3898:                			w = w * 10 + c - '0';
3899:                			c = *str++;
3900:                		}
3901:                		if (c == 'l' || c == 'L') { /* Prefix: Size is long int */
3902:                			f |= 4; c = *str++;
3903:                		}
3904:                		if (!c) break;
3905:                		d = c;
3906:                		if (IsLower(d)) d -= 0x20;
3907:                		switch (d) { /* Type is... */
3908:                			case 'S' : /* String */
3909:                			p = va_arg(arp, TCHAR*);
3910:                			for (j = 0; p[j]; j++);
3911:                			chc = 0;
3912:                			if (!(f & 2)) {
3913:                				while (j++ < w) chc += (cc = f_putc(' ', fil));
3914:                			}
3915:                			chc += (cc = f_puts(p, fil));
3916:                			while (j++ < w) chc += (cc = f_putc(' ', fil));
3917:                			if (cc != EOF) cc = chc;
3918:                			continue;
3919:                			case 'C' : /* Character */
3920:                			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
3921:                			case 'B' : /* Binary */
3922:                			r = 2; break;
3923:                			case 'O' : /* Octal */
3924:                			r = 8; break;
3925:                			case 'D' : /* Signed decimal */
3926:                			case 'U' : /* Unsigned decimal */
3927:                			r = 10; break;
3928:                			case 'X' : /* Hexdecimal */
3929:                			r = 16; break;
3930:                			default: /* Unknown type (passthrough) */
3931:                			cc = f_putc(c, fil); continue;
3932:                		}
3933:                
3934:                		/* Get an argument and put it in numeral */
3935:                		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
3936:                		if (d == 'D' && (v & 0x80000000)) {
3937:                			v = 0 - v;
3938:                			f |= 8;
3939:                		}
3940:                		i = 0;
3941:                		do {
3942:                			d = (TCHAR)(v % r); v /= r;
3943:                			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
3944:                			s[i++] = d + '0';
3945:                		}while (v && i < sizeof(s) / sizeof(s[0]));
3946:                		if (f & 8) s[i++] = '-';
3947:                		j = i; d = (f & 1) ? '0' : ' ';
3948:                		res = 0;
3949:                		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
3950:                		do res += (cc = f_putc(s[--i], fil)); while(i);
3951:                		while (j++ < w) res += (cc = f_putc(' ', fil));
3952:                		if (cc != EOF) cc = res;
3953:                	}
3954:                
3955:                	va_end(arp);
3956:                	return (cc == EOF) ? cc : res;
3957:                }
3958:                
3959:                #endif /* !_FS_READONLY */
3960:                #endif /* _USE_STRFUNC */
---  /home/jacques/github/vpc-32vga/hardware/Pinguino/diskio.c  -----------------------------------------
1:                   /*------------------------------------------------------------------------/
2:                    /  MMCv3/SDv1/SDv2 (in SPI mode) control module
3:                    /-------------------------------------------------------------------------/
4:                    /
5:                    /  Copyright (C) 2010, ChaN, all right reserved.
6:                    /
7:                    / * This software is a free software and there is NO WARRANTY.
8:                    / * No restriction on use. You can use, modify and redistribute it for
9:                    /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
10:                   / * Redistributions of source code must retain the above copyright notice.
11:                   /
12:                   /-------------------------------------------------------------------------*/
13:                  
14:                  // 07 May 2012 Changes made to allow SD card library to support
15:                  //					PIC32 Pinguino Micro and potentially other cards that
16:                  //					do not support the use of the RTCC library.
17:                  // 25 May 2012 Added includes for delay.c and digitalw.c
18:                  
19:                  #include <stdlib.h>
20:                  
21:                  //#include "ff.h"
22:                  #include "diskio.h"
23:                  //#include <delay.c>
24:                  //#include <digitalw.c>
25:                  #include "../HardwareProfile.h"
26:                  #include "sdmmc.h"
27:                  #include "../store/store_spi.h"
28:                  #include "../../shell.h"
29:                  
30:                  // For boards known to support the RTCC library ***Added 07 May 2012
31:                  // to allow SD Library to support PIC32 Pinguino Micro, which
32:                  // which does not have a RTCC crystal and associated components,
33:                  // and would not operate if #include <rtcc.c> is included.
34:                  // See also changes to get_fattime() below.
35:                  
36:                  #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
37:                  	#include <rtcc.c>
38:                  #endif
39:                  
40:                  /* Definitions for MMC/SDC command */
41:                  #define CMD0   (0)			/* GO_IDLE_STATE */
42:                  #define CMD1   (1)			/* SEND_OP_COND */
43:                  #define ACMD41 (41|0x80)	/* SEND_OP_COND (SDC) */
44:                  #define CMD8   (8)			/* SEND_IF_COND */
45:                  #define CMD9   (9)			/* SEND_CSD */
46:                  #define CMD10  (10)			/* SEND_CID */
47:                  #define CMD12  (12)			/* STOP_TRANSMISSION */
48:                  #define ACMD13 (13|0x80)	/* SD_STATUS (SDC) */
49:                  #define CMD16  (16)			/* SET_BLOCKLEN */
50:                  #define CMD17  (17)			/* READ_SINGLE_BLOCK */
51:                  #define CMD18  (18)			/* READ_MULTIPLE_BLOCK */
52:                  #define CMD23  (23)			/* SET_BLOCK_COUNT */
53:                  #define ACMD23 (23|0x80)	/* SET_WR_BLK_ERASE_COUNT (SDC) */
54:                  #define CMD24  (24)			/* WRITE_BLOCK */
55:                  #define CMD25  (25)			/* WRITE_MULTIPLE_BLOCK */
56:                  #define CMD41  (41)			/* SEND_OP_COND (ACMD) */
57:                  #define CMD55  (55)			/* APP_CMD */
58:                  #define CMD58  (58)			/* READ_OCR */
59:                  
60:                  /* Port Controls  (Platform dependent) */
61:                  //#define SOCKPORT	PORTB		/* Socket contact port */
62:                  //#define SOCKWP	(1<<10)		/* Write protect switch (RB10) */
63:                  //#define SOCKINS	(1<<11)		/* Card detect switch (RB11) */
64:                  
65:                  //#define	FCLK_SLOW()			/* Set slow clock (100k-400k) */
66:                  //#define	FCLK_FAST()			/* Set fast clock (depends on the CSD) */
67:                  
68:                  
69:                  /*--------------------------------------------------------------------------
70:                  
71:                   Module Private Functions
72:                  
73:                   ---------------------------------------------------------------------------*/
74:                  
75:                  static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
76:                  
77:                  static volatile UINT16 Timer1, Timer2; /* 1000Hz decrement timer */
78:                  
79:                  static UINT16 CardType;
80:                  
81:                  /*-----------------------------------------------------------------------*/
82:                  /* Exchange a byte between PIC and MMC via SPI  (Platform dependent)     */
83:                  /*-----------------------------------------------------------------------*/
84:                  
85:                  #define xmit_spi(dat) 	writeSPI(dat)
86:                  #define rcvr_spi()	writeSPI(0xFF)
87:                  #define rcvr_spi_m(p)	SDC_SPIBUF = 0xFF; while (!SDC_SPISTATbits.SPIRBF); *(p) = (PF_BYTE)SDC_SPIBUF;
88:                  #define xchg_spi (dat)  writeSPI(dat)
89:                  #define DLY_US(i)	delay_us(i)
90:                  #define CS_H()		_sdc_deselect()//digitalwrite(SDCS, HIGH)
91:                  #define CS_L()		_sdc_select()//digitalwrite(SDCS, LOW)
92:                  
93:                  /*-----------------------------------------------------------------------*/
94:                  /* Wait for card ready                                                   */
95:                  /*-----------------------------------------------------------------------*/
96:                  
97:                  static
98:                  int wait_ready(void) {
9D00FFA0  27BDFFE0   ADDIU SP, SP, -32
9D00FFA4  AFBF001C   SW RA, 28(SP)
9D00FFA8  AFB10018   SW S1, 24(SP)
9D00FFAC  AFB00014   SW S0, 20(SP)
9D00FFB0  24101388   ADDIU S0, ZERO, 5000
99:                  	PF_BYTE d;
100:                 	UINT16 tmr;
101:                 
102:                 	for (tmr = 5000; tmr; tmr--) { /* Wait for ready in timeout of 500ms */
9D00FFDC  1600FFF5   BNE S0, ZERO, 0x9D00FFB4
9D00FFE0  3A2200FF   XORI V0, S1, 255
103:                 		d = rcvr_spi();
9D00FFB4  0F407642   JAL writeSPI
9D00FFB8  240400FF   ADDIU A0, ZERO, 255
9D00FFBC  00408821   ADDU S1, V0, ZERO
104:                 		if (d == 0xFF)
9D00FFC0  240200FF   ADDIU V0, ZERO, 255
9D00FFC4  12220007   BEQ S1, V0, 0x9D00FFE4
9D00FFC8  3A2200FF   XORI V0, S1, 255
105:                 			break;
106:                 		DLY_US(100);
9D00FFCC  0F405286   JAL delay_us
9D00FFD0  24040064   ADDIU A0, ZERO, 100
9D00FFD4  2610FFFF   ADDIU S0, S0, -1
9D00FFD8  3210FFFF   ANDI S0, S0, -1
107:                 	}
108:                 
109:                 	return (d == 0xFF) ? 1 : 0;
110:                 }
9D00FFE4  2C420001   SLTIU V0, V0, 1
9D00FFE8  8FBF001C   LW RA, 28(SP)
9D00FFEC  8FB10018   LW S1, 24(SP)
9D00FFF0  8FB00014   LW S0, 20(SP)
9D00FFF4  03E00008   JR RA
9D00FFF8  27BD0020   ADDIU SP, SP, 32
111:                 
112:                 /*-----------------------------------------------------------------------*/
113:                 /* Deselect the card and release SPI bus                                 */
114:                 /*-----------------------------------------------------------------------*/
115:                 
116:                 #define deselect() disableSD();
117:                 
118:                 /*-----------------------------------------------------------------------*/
119:                 /* Select the card and wait ready                                        */
120:                 /*-----------------------------------------------------------------------*/
121:                 
122:                 static int select(void) /* 1:Successful, 0:Timeout */
123:                 {
9D0101A8  27BDFFE8   ADDIU SP, SP, -24
9D0101AC  AFBF0014   SW RA, 20(SP)
124:                 	enableSD();
9D0101B0  0F4062B9   JAL enableSD
9D0101B4  AFB00010   SW S0, 16(SP)
125:                 	rcvr_spi(); /* Dummy clock (force DO enabled) */
9D0101B8  0F407642   JAL writeSPI
9D0101BC  240400FF   ADDIU A0, ZERO, 255
126:                 
127:                 	if (wait_ready())
9D0101C0  0F403FE8   JAL wait_ready
9D0101C4  00000000   NOP
9D0101C8  14400005   BNE V0, ZERO, 0x9D0101E0
9D0101CC  00408021   ADDU S0, V0, ZERO
128:                 		return 1; /* OK */
9D0101E0  24100001   ADDIU S0, ZERO, 1
129:                 	deselect();
9D0101D0  0F4062AF   JAL disableSD
9D0101D4  00000000   NOP
130:                 	return 0; /* Timeout */
9D0101D8  0B40407A   J 0x9D0101E8
9D0101DC  02001021   ADDU V0, S0, ZERO
131:                 }
9D0101E4  02001021   ADDU V0, S0, ZERO
9D0101E8  8FBF0014   LW RA, 20(SP)
9D0101EC  8FB00010   LW S0, 16(SP)
9D0101F0  03E00008   JR RA
9D0101F4  27BD0018   ADDIU SP, SP, 24
132:                 
133:                 void unmountSD(){
9D01030C  27BDFFE8   ADDIU SP, SP, -24
9D010310  AFBF0014   SW RA, 20(SP)
134:                     deselect();
9D010314  0F4062AF   JAL disableSD
9D010318  00000000   NOP
135:                     Stat=STA_NOINIT;
9D01031C  24020001   ADDIU V0, ZERO, 1
9D010320  A3828010   SB V0, -32752(GP)
136:                 }
9D010324  8FBF0014   LW RA, 20(SP)
9D010328  03E00008   JR RA
9D01032C  27BD0018   ADDIU SP, SP, 24
137:                 
138:                 /*-----------------------------------------------------------------------*/
139:                 /* Receive a data packet from MMC                                        */
140:                 /*-----------------------------------------------------------------------*/
141:                 
142:                 static int rcvr_datablock( /* 1:OK, 0:Failed */
143:                                           PF_BYTE *buff, /* Data buffer to store received data */
144:                                           UINT16 btr /* Byte count (must be multiple of 4) */
145:                                           ) {
9D010090  27BDFFE0   ADDIU SP, SP, -32
9D010094  AFBF001C   SW RA, 28(SP)
9D010098  AFB20018   SW S2, 24(SP)
9D01009C  AFB10014   SW S1, 20(SP)
9D0100A0  AFB00010   SW S0, 16(SP)
9D0100A4  00808021   ADDU S0, A0, ZERO
9D0100A8  00A08821   ADDU S1, A1, ZERO
9D0100AC  241203E8   ADDIU S2, ZERO, 1000
146:                 	PF_BYTE d;
147:                 	UINT16 tmr;
148:                 
149:                 	for (tmr = 1000; tmr; tmr--) { /* Wait for data packet in timeout of 100ms */
9D0100D4  1640FFF6   BNE S2, ZERO, 0x9D0100B0
9D0100D8  00001821   ADDU V1, ZERO, ZERO
9D0100DC  0B404064   J 0x9D010190
9D0100E0  00601021   ADDU V0, V1, ZERO
150:                 		d = rcvr_spi();
9D0100B0  0F407642   JAL writeSPI
9D0100B4  240400FF   ADDIU A0, ZERO, 255
151:                 		if (d != 0xFF)
9D0100B8  240300FF   ADDIU V1, ZERO, 255
9D0100BC  14430009   BNE V0, V1, 0x9D0100E4
9D0100C0  240400FE   ADDIU A0, ZERO, 254
152:                 			break;
153:                 		DLY_US(100);
9D0100C4  0F405286   JAL delay_us
9D0100C8  24040064   ADDIU A0, ZERO, 100
9D0100CC  2652FFFF   ADDIU S2, S2, -1
9D0100D0  3252FFFF   ANDI S2, S2, -1
154:                 	}
155:                 	if (d != 0xFE)
9D0100E4  14440029   BNE V0, A0, 0x9D01018C
9D0100E8  00001821   ADDU V1, ZERO, ZERO
156:                 		return 0; /* If not valid data token, return with error */
157:                 
158:                 	do { /* Receive the data block into buffer */
159:                 		rcvr_spi_m(buff++);
9D0100EC  3C04BF80   LUI A0, -16512
9D0100F0  240500FF   ADDIU A1, ZERO, 255
9D0100F4  3C02BF80   LUI V0, -16512
9D0100F8  AC855A20   SW A1, 23072(A0)
9D0100FC  8C435A10   LW V1, 23056(V0)
9D010100  30630001   ANDI V1, V1, 1
9D010104  1060FFFD   BEQ V1, ZERO, 0x9D0100FC
9D010108  00000000   NOP
9D01010C  8C835A20   LW V1, 23072(A0)
9D010110  A2030000   SB V1, 0(S0)
160:                 		rcvr_spi_m(buff++);
9D010114  AC855A20   SW A1, 23072(A0)
9D010118  8C435A10   LW V1, 23056(V0)
9D01011C  30630001   ANDI V1, V1, 1
9D010120  1060FFFD   BEQ V1, ZERO, 0x9D010118
9D010124  00000000   NOP
9D010128  8C835A20   LW V1, 23072(A0)
9D01012C  A2030001   SB V1, 1(S0)
161:                 		rcvr_spi_m(buff++);
9D010130  AC855A20   SW A1, 23072(A0)
9D010134  8C435A10   LW V1, 23056(V0)
9D010138  30630001   ANDI V1, V1, 1
9D01013C  1060FFFD   BEQ V1, ZERO, 0x9D010134
9D010140  00000000   NOP
9D010144  8C835A20   LW V1, 23072(A0)
9D010148  A2030002   SB V1, 2(S0)
162:                 		rcvr_spi_m(buff++);
9D01014C  AC855A20   SW A1, 23072(A0)
9D010150  8C435A10   LW V1, 23056(V0)
9D010154  30630001   ANDI V1, V1, 1
9D010158  1060FFFD   BEQ V1, ZERO, 0x9D010150
9D01015C  00000000   NOP
9D010160  26100004   ADDIU S0, S0, 4
9D010164  8C835A20   LW V1, 23072(A0)
163:                 	} while (btr -= 4);
9D010168  2631FFFC   ADDIU S1, S1, -4
9D01016C  3231FFFF   ANDI S1, S1, -1
9D010170  1620FFE1   BNE S1, ZERO, 0x9D0100F8
9D010174  A203FFFF   SB V1, -1(S0)
164:                 	rcvr_spi(); /* Discard CRC */
9D010178  0F407642   JAL writeSPI
9D01017C  240400FF   ADDIU A0, ZERO, 255
165:                 	rcvr_spi();
9D010180  0F407642   JAL writeSPI
9D010184  240400FF   ADDIU A0, ZERO, 255
9D010188  24030001   ADDIU V1, ZERO, 1
166:                 
167:                 	return 1; /* Return with success */
168:                 }
9D01018C  00601021   ADDU V0, V1, ZERO
9D010190  8FBF001C   LW RA, 28(SP)
9D010194  8FB20018   LW S2, 24(SP)
9D010198  8FB10014   LW S1, 20(SP)
9D01019C  8FB00010   LW S0, 16(SP)
9D0101A0  03E00008   JR RA
9D0101A4  27BD0020   ADDIU SP, SP, 32
169:                 
170:                 /*-----------------------------------------------------------------------*/
171:                 /* Send a data packet to MMC                                             */
172:                 /*-----------------------------------------------------------------------*/
173:                 
174:                 #if _READONLY == 0
175:                 static int xmit_datablock( /* 1:OK, 0:Failed */
176:                                           const PF_BYTE *buff, /* 512 byte data block to be transmitted */
177:                                           PF_BYTE token /* Data token */
178:                                           ) {
9D00FFFC  27BDFFE0   ADDIU SP, SP, -32
9D010000  AFBF001C   SW RA, 28(SP)
9D010004  AFB10018   SW S1, 24(SP)
9D010008  AFB00014   SW S0, 20(SP)
9D01000C  00808021   ADDU S0, A0, ZERO
179:                 	PF_BYTE resp;
180:                 	UINT16 bc = BLK_SIZE;
181:                 
182:                 	if (!wait_ready())
9D010010  0F403FE8   JAL wait_ready
9D010014  00A08821   ADDU S1, A1, ZERO
9D010018  10400019   BEQ V0, ZERO, 0x9D010080
9D01001C  8FBF001C   LW RA, 28(SP)
183:                 		return 0;
184:                 
185:                 	xmit_spi(token); /* Xmit a token */
9D010020  0F407642   JAL writeSPI
9D010024  02202021   ADDU A0, S1, ZERO
186:                 	if (token != 0xFD) { /* Not StopTran token */
9D010028  240200FD   ADDIU V0, ZERO, 253
9D01002C  12220012   BEQ S1, V0, 0x9D010078
9D010030  26110200   ADDIU S1, S0, 512
187:                 		do { /* Xmit the 512 byte data block to the MMC */
188:                 			xmit_spi(*buff++);
9D010034  0F407642   JAL writeSPI
9D010038  92040000   LBU A0, 0(S0)
9D01003C  26100002   ADDIU S0, S0, 2
189:                 			xmit_spi(*buff++);
9D010040  0F407642   JAL writeSPI
9D010044  9204FFFF   LBU A0, -1(S0)
190:                 		} while (bc -= 2);
9D010048  1630FFFA   BNE S1, S0, 0x9D010034
9D01004C  00000000   NOP
191:                 		xmit_spi(0xFF); /* CRC (Dummy) */
9D010050  0F407642   JAL writeSPI
9D010054  240400FF   ADDIU A0, ZERO, 255
192:                 		xmit_spi(0xFF);
9D010058  0F407642   JAL writeSPI
9D01005C  240400FF   ADDIU A0, ZERO, 255
193:                 		resp = rcvr_spi(); /* Receive a data response */
9D010060  0F407642   JAL writeSPI
9D010064  240400FF   ADDIU A0, ZERO, 255
194:                 		if ((resp & 0x1F) != 0x05) /* If not accepted, return with error */
9D010068  3042001F   ANDI V0, V0, 31
9D01006C  38420005   XORI V0, V0, 5
9D010070  0B40401F   J 0x9D01007C
9D010074  2C420001   SLTIU V0, V0, 1
195:                 			return 0;
196:                 	}
197:                 
198:                 	return 1;
9D010078  24020001   ADDIU V0, ZERO, 1
199:                 }
9D01007C  8FBF001C   LW RA, 28(SP)
9D010080  8FB10018   LW S1, 24(SP)
9D010084  8FB00014   LW S0, 20(SP)
9D010088  03E00008   JR RA
9D01008C  27BD0020   ADDIU SP, SP, 32
200:                 #endif	/* _READONLY */
201:                 
202:                 /*-----------------------------------------------------------------------*/
203:                 /* Send a command packet to MMC                                          */
204:                 /*-----------------------------------------------------------------------*/
205:                 
206:                 static PF_BYTE send_cmd(PF_BYTE cmd, /* Command byte */
207:                                         DWORD arg /* Argument */
208:                                         ) {
9D0101F8  27BDFFE0   ADDIU SP, SP, -32
9D0101FC  AFBF001C   SW RA, 28(SP)
9D010200  AFB10018   SW S1, 24(SP)
9D010204  AFB00014   SW S0, 20(SP)
9D010208  00808021   ADDU S0, A0, ZERO
9D0102A0  2410000A   ADDIU S0, ZERO, 10
9D0102DC  0B4040A9   J 0x9D0102A4
9D0102E0  2410000A   ADDIU S0, ZERO, 10
9D0102EC  0B4040A9   J 0x9D0102A4
9D0102F0  2410000A   ADDIU S0, ZERO, 10
209:                 	PF_BYTE n, res;
210:                 
211:                 	if (cmd & 0x80) { /* ACMD<n> is the command sequense of CMD55-CMD<n> */
9D01020C  7C041420   SEB V0, A0
9D010210  04410008   BGEZ V0, 0x9D010234
9D010214  00A08821   ADDU S1, A1, ZERO
212:                 		cmd &= 0x7F;
9D010230  3210007F   ANDI S0, S0, 127
213:                 		res = send_cmd(CMD55, 0);
9D010218  24040037   ADDIU A0, ZERO, 55
9D01021C  0F40407E   JAL send_cmd
9D010220  00002821   ADDU A1, ZERO, ZERO
214:                 		if (res > 1)
9D010224  2C440002   SLTIU A0, V0, 2
9D010228  10800032   BEQ A0, ZERO, 0x9D0102F4
9D01022C  00401821   ADDU V1, V0, ZERO
215:                 			return res;
216:                 	}
217:                 
218:                 	/* Select the card and wait for ready */
219:                 	deselect();
9D010234  0F4062AF   JAL disableSD
9D010238  00000000   NOP
220:                 	if (!select())
9D01023C  0F40406A   JAL select
9D010240  00000000   NOP
9D010244  1040002B   BEQ V0, ZERO, 0x9D0102F4
9D010248  240300FF   ADDIU V1, ZERO, 255
221:                 		return 0xFF;
222:                 
223:                 	/* Send command packet */
224:                 	xmit_spi(0x40 | cmd); /* Start + Command index */
9D01024C  0F407642   JAL writeSPI
9D010250  36040040   ORI A0, S0, 64
225:                 	xmit_spi((PF_BYTE)(arg >> 24)); /* Argument[31..24] */
9D010254  0F407642   JAL writeSPI
9D010258  00112602   SRL A0, S1, 24
226:                 	xmit_spi((PF_BYTE)(arg >> 16)); /* Argument[23..16] */
9D01025C  0F407642   JAL writeSPI
9D010260  7E243C00   EXT A0, S1, 16, 8
227:                 	xmit_spi((PF_BYTE)(arg >> 8)); /* Argument[15..8] */
9D010264  0F407642   JAL writeSPI
9D010268  7E243A00   EXT A0, S1, 8, 8
228:                 	xmit_spi((PF_BYTE)arg); /* Argument[7..0] */
9D01026C  0F407642   JAL writeSPI
9D010270  322400FF   ANDI A0, S1, 255
229:                 	n = 0x01; /* Dummy CRC + Stop */
230:                 	if (cmd == CMD0)
9D010274  1200001B   BEQ S0, ZERO, 0x9D0102E4
9D010278  24020008   ADDIU V0, ZERO, 8
231:                 		n = 0x95; /* Valid CRC for CMD0(0) */
232:                 	if (cmd == CMD8)
9D01027C  12020015   BEQ S0, V0, 0x9D0102D4
9D010280  00000000   NOP
233:                 		n = 0x87; /* Valid CRC for CMD8(0x1AA) */
234:                 	xmit_spi(n);
9D010284  0F407642   JAL writeSPI
9D010288  24040001   ADDIU A0, ZERO, 1
9D0102D4  0F407642   JAL writeSPI
9D0102D8  24040087   ADDIU A0, ZERO, 135
9D0102E4  0F407642   JAL writeSPI
9D0102E8  24040095   ADDIU A0, ZERO, 149
235:                 
236:                 	/* Receive command response */
237:                 	if (cmd == CMD12)
9D01028C  2402000C   ADDIU V0, ZERO, 12
9D010290  16020004   BNE S0, V0, 0x9D0102A4
9D010294  2410000A   ADDIU S0, ZERO, 10
238:                 		rcvr_spi(); /* Skip a stuff byte when stop reading */
9D010298  0F407642   JAL writeSPI
9D01029C  240400FF   ADDIU A0, ZERO, 255
239:                 	n = 10; /* Wait for a valid response in timeout of 10 attempts */
240:                 	do
241:                 		res = rcvr_spi();
9D0102A4  0F407642   JAL writeSPI
9D0102A8  240400FF   ADDIU A0, ZERO, 255
9D0102CC  0B4040BD   J 0x9D0102F4
9D0102D0  00401821   ADDU V1, V0, ZERO
242:                 	while ((res & 0x80) && --n);
9D0102AC  7C021C20   SEB V1, V0
9D0102B0  04610006   BGEZ V1, 0x9D0102CC
9D0102B4  2610FFFF   ADDIU S0, S0, -1
9D0102B8  321000FF   ANDI S0, S0, 255
9D0102BC  1600FFF9   BNE S0, ZERO, 0x9D0102A4
9D0102C0  00401821   ADDU V1, V0, ZERO
9D0102C4  0B4040BE   J 0x9D0102F8
9D0102C8  00601021   ADDU V0, V1, ZERO
243:                 
244:                 	return res; /* Return with the response value */
245:                 }
9D0102F4  00601021   ADDU V0, V1, ZERO
9D0102F8  8FBF001C   LW RA, 28(SP)
9D0102FC  8FB10018   LW S1, 24(SP)
9D010300  8FB00014   LW S0, 20(SP)
9D010304  03E00008   JR RA
9D010308  27BD0020   ADDIU SP, SP, 32
246:                 
247:                 /*--------------------------------------------------------------------------
248:                 
249:                  Public Functions
250:                 
251:                  ---------------------------------------------------------------------------*/
252:                 
253:                 /*-----------------------------------------------------------------------*/
254:                 /* Initialize Disk Drive                                                 */
255:                 /*-----------------------------------------------------------------------*/
256:                 
257:                 DSTATUS disk_initialize(PF_BYTE drv /* Physical drive number (0) */
258:                                         ) {
9D010338  27BDFFD8   ADDIU SP, SP, -40
9D01033C  AFBF0024   SW RA, 36(SP)
9D010340  AFB10020   SW S1, 32(SP)
9D010344  AFB0001C   SW S0, 28(SP)
259:                 	PF_BYTE n, ty, cmd, buf[4];
260:                 	UINT16 tmr;
261:                 	DSTATUS s = 0;
262:                 	if (drv)
9D010330  1480008A   BNE A0, ZERO, 0x9D01055C
9D010334  24020001   ADDIU V0, ZERO, 1
263:                 		return STA_NOINIT; /* Supports only single drive */
264:                 	if (Stat & STA_NODISK)
9D010348  93828010   LBU V0, -32752(GP)
9D01034C  30420002   ANDI V0, V0, 2
9D010350  304200FF   ANDI V0, V0, 255
9D010354  10400004   BEQ V0, ZERO, 0x9D010368
9D010358  00000000   NOP
265:                 		return Stat; /* No card in the socket */
9D01035C  93828010   LBU V0, -32752(GP)
9D010360  0B404153   J 0x9D01054C
9D010364  304200FF   ANDI V0, V0, 255
266:                 
267:                 	deselect(); /* Force socket power on */
9D010368  0F4062AF   JAL disableSD
9D01036C  2410000A   ADDIU S0, ZERO, 10
268:                 	spi_clock_freq(SLOW_CLOCK);
9D010370  3C040001   LUI A0, 1
9D010374  0F40761C   JAL spi_clock_freq
9D010378  348486A0   ORI A0, A0, -31072
269:                 	for (n = 10; n; n--)
9D01038C  1600FFFB   BNE S0, ZERO, 0x9D01037C
9D010390  24030008   ADDIU V1, ZERO, 8
270:                 		rcvr_spi(); /* 80 dummy clocks */
9D01037C  0F407642   JAL writeSPI
9D010380  240400FF   ADDIU A0, ZERO, 255
9D010384  2610FFFF   ADDIU S0, S0, -1
9D010388  321000FF   ANDI S0, S0, 255
271:                 //	CS_H();
272:                 //	for (n = 10; n; n--)
273:                 //		rcvr_spi(); /* 80 dummy clocks */
274:                     CS_L();
9D010394  3C02BF88   LUI V0, -16504
9D010398  AC436124   SW V1, 24868(V0)
275:                 	ty = 0;
276:                 	if (send_cmd(CMD0, 0) == 1) { /* Enter Idle state */
9D01039C  00002021   ADDU A0, ZERO, ZERO
9D0103A0  0F40407E   JAL send_cmd
9D0103A4  00002821   ADDU A1, ZERO, ZERO
9D0103A8  24030001   ADDIU V1, ZERO, 1
9D0103AC  54430065   BNEL V0, V1, 0x9D010544
9D0103B0  A780801E   SH ZERO, -32738(GP)
277:                 		if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2? */
9D0103B4  24040008   ADDIU A0, ZERO, 8
9D0103B8  0F40407E   JAL send_cmd
9D0103BC  240501AA   ADDIU A1, ZERO, 426
9D0103C0  24030001   ADDIU V1, ZERO, 1
9D0103C4  14430033   BNE V0, V1, 0x9D010494
9D0103C8  240400A9   ADDIU A0, ZERO, 169
9D0103CC  27B10014   ADDIU S1, SP, 20
9D0103D0  27B00010   ADDIU S0, SP, 16
278:                 			for (n = 0; n < 4; n++)
9D0103E4  1611FFFB   BNE S0, S1, 0x9D0103D4
9D0103E8  93A30012   LBU V1, 18(SP)
279:                 				buf[n] = rcvr_spi(); /* Get trailing return value of R7 resp */
9D0103D4  0F407642   JAL writeSPI
9D0103D8  240400FF   ADDIU A0, ZERO, 255
9D0103DC  A2020000   SB V0, 0(S0)
9D0103E0  26100001   ADDIU S0, S0, 1
280:                 			if (buf[2] == 0x01 && buf[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
9D0103EC  24020001   ADDIU V0, ZERO, 1
9D0103F0  5462004E   BNEL V1, V0, 0x9D01052C
9D0103F4  A780801E   SH ZERO, -32738(GP)
9D0103F8  93A30013   LBU V1, 19(SP)
9D0103FC  240200AA   ADDIU V0, ZERO, 170
9D010400  54620050   BNEL V1, V0, 0x9D010544
9D010404  A780801E   SH ZERO, -32738(GP)
9D010408  241003E8   ADDIU S0, ZERO, 1000
281:                 				for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state (ACMD41 with HCS bit) */
9D010428  2610FFFF   ADDIU S0, S0, -1
9D01042C  3210FFFF   ANDI S0, S0, -1
9D010430  1600FFF7   BNE S0, ZERO, 0x9D010410
9D010434  240400A9   ADDIU A0, ZERO, 169
9D010438  0B404151   J 0x9D010544
9D01043C  A780801E   SH ZERO, -32738(GP)
282:                 					if (send_cmd(ACMD41, 1UL << 30) == 0)
9D01040C  240400A9   ADDIU A0, ZERO, 169
9D010410  0F40407E   JAL send_cmd
9D010414  3C054000   LUI A1, 16384
9D010418  10400009   BEQ V0, ZERO, 0x9D010440
9D01041C  00000000   NOP
283:                 						break;
284:                 					DLY_US(1000);
9D010420  0F405286   JAL delay_us
9D010424  240403E8   ADDIU A0, ZERO, 1000
285:                 				}
286:                 				if (tmr && send_cmd(CMD58, 0) == 0) { /* Check CCS bit in the OCR */
9D010440  52000040   BEQL S0, ZERO, 0x9D010544
9D010444  A780801E   SH ZERO, -32738(GP)
9D010448  2404003A   ADDIU A0, ZERO, 58
9D01044C  0F40407E   JAL send_cmd
9D010450  00002821   ADDU A1, ZERO, ZERO
9D010454  5440003B   BNEL V0, ZERO, 0x9D010544
9D010458  A780801E   SH ZERO, -32738(GP)
9D01045C  27B00010   ADDIU S0, SP, 16
287:                 					for (n = 0; n < 4; n++)
9D010470  1630FFFB   BNE S1, S0, 0x9D010460
9D010474  93A40010   LBU A0, 16(SP)
288:                 						buf[n] = rcvr_spi();
9D010460  0F407642   JAL writeSPI
9D010464  240400FF   ADDIU A0, ZERO, 255
9D010468  A2020000   SB V0, 0(S0)
9D01046C  26100001   ADDIU S0, S0, 1
289:                 					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; /* SDv2 */
9D010478  30840040   ANDI A0, A0, 64
9D01047C  308400FF   ANDI A0, A0, 255
9D010480  24030004   ADDIU V1, ZERO, 4
9D010484  2402000C   ADDIU V0, ZERO, 12
9D010488  0064100A   MOVZ V0, V1, A0
290:                 				}
291:                 			}
292:                 		} else { /* SDv1 or MMCv3 */
293:                 			if (send_cmd(ACMD41, 0) <= 1) {
9D010494  0F40407E   JAL send_cmd
9D010498  00002821   ADDU A1, ZERO, ZERO
9D01049C  2C420002   SLTIU V0, V0, 2
294:                 				ty = CT_SD1;
9D0104A0  24030002   ADDIU V1, ZERO, 2
9D0104A4  24040001   ADDIU A0, ZERO, 1
9D0104A8  00608821   ADDU S1, V1, ZERO
9D0104AC  0082880A   MOVZ S1, A0, V0
295:                 				cmd = ACMD41; /* SDv1 */
296:                 			} else {
297:                 				ty = CT_MMC;
298:                 				cmd = CMD1; /* MMCv3 */
299:                 			}
300:                 			for (tmr = 1000; tmr; tmr--) { /* Wait for leaving idle state */
9D0104B0  241003E8   ADDIU S0, ZERO, 1000
9D0104D0  2610FFFF   ADDIU S0, S0, -1
9D0104D4  3210FFFF   ANDI S0, S0, -1
9D0104D8  1600FFF7   BNE S0, ZERO, 0x9D0104B8
9D0104DC  240400A9   ADDIU A0, ZERO, 169
9D0104E0  0B404151   J 0x9D010544
9D0104E4  A780801E   SH ZERO, -32738(GP)
301:                 				if (send_cmd(ACMD41, 0) == 0)
9D0104B4  240400A9   ADDIU A0, ZERO, 169
9D0104B8  0F40407E   JAL send_cmd
9D0104BC  00002821   ADDU A1, ZERO, ZERO
9D0104C0  10400009   BEQ V0, ZERO, 0x9D0104E8
9D0104C4  00000000   NOP
302:                 					break;
303:                 				DLY_US(1000);
9D0104C8  0F405286   JAL delay_us
9D0104CC  240403E8   ADDIU A0, ZERO, 1000
304:                 			}
305:                 			if (!tmr || send_cmd(CMD16, 512) != 0) /* Set R/W block length to 512 */
9D0104E8  52000016   BEQL S0, ZERO, 0x9D010544
9D0104EC  A780801E   SH ZERO, -32738(GP)
9D0104F0  24040010   ADDIU A0, ZERO, 16
9D0104F4  0F40407E   JAL send_cmd
9D0104F8  24050200   ADDIU A1, ZERO, 512
9D0104FC  54400011   BNEL V0, ZERO, 0x9D010544
9D010500  A780801E   SH ZERO, -32738(GP)
306:                 				ty = 0;
307:                 		}
308:                 	}
309:                 	CardType = ty;
9D01048C  0B404144   J 0x9D010510
9D010490  A782801E   SH V0, -32738(GP)
9D010504  A791801E   SH S1, -32738(GP)
310:                 	if (ty) {/* Initialization succeded */
9D010508  12200008   BEQ S1, ZERO, 0x9D01052C
9D01050C  24020001   ADDIU V0, ZERO, 1
311:                 		s &= ~STA_NOINIT;
9D010528  00001021   ADDU V0, ZERO, ZERO
312:                 		// 6. increase speed
313:                 		SPI2CON = 0; // disable the SPI2 module
9D010510  3C02BF80   LUI V0, -16512
9D010514  AC405A00   SW ZERO, 23040(V0)
314:                 		SPI2BRG = 0; // maximum possible baud rate = Fpb/2
9D010518  3C03BF80   LUI V1, -16512
9D01051C  AC605A30   SW ZERO, 23088(V1)
315:                 		SPI2CON = 0x8120; // re-enable the SPI2 module
9D010520  34038120   ORI V1, ZERO, -32480
9D010524  AC435A00   SW V1, 23040(V0)
316:                 	} else {
317:                 		/* Initialization failed */
318:                 		s |= STA_NOINIT;
9D010544  0B40414B   J 0x9D01052C
9D010548  24020001   ADDIU V0, ZERO, 1
319:                 	}
320:                 	Stat = s;
9D01052C  A3828010   SB V0, -32752(GP)
321:                 
322:                 	deselect();
9D010530  0F4062AF   JAL disableSD
9D010534  00000000   NOP
323:                 	return Stat;
9D010538  93828010   LBU V0, -32752(GP)
9D01053C  0B404153   J 0x9D01054C
9D010540  304200FF   ANDI V0, V0, 255
324:                 }
9D01054C  8FBF0024   LW RA, 36(SP)
9D010550  8FB10020   LW S1, 32(SP)
9D010554  8FB0001C   LW S0, 28(SP)
9D010558  27BD0028   ADDIU SP, SP, 40
9D01055C  03E00008   JR RA
9D010560  00000000   NOP
325:                 
326:                 /*-----------------------------------------------------------------------*/
327:                 /* Get Disk Status                                                       */
328:                 /*-----------------------------------------------------------------------*/
329:                 
330:                 DSTATUS disk_status(PF_BYTE drv /* Physical drive number (0) */
331:                 ) {
332:                 	if (drv)
9D010564  14800003   BNE A0, ZERO, 0x9D010574
9D010568  24020001   ADDIU V0, ZERO, 1
333:                 		return STA_NOINIT; /* Supports only single drive */
334:                 	return Stat;
9D01056C  93828010   LBU V0, -32752(GP)
9D010570  304200FF   ANDI V0, V0, 255
335:                 }
9D010574  03E00008   JR RA
9D010578  00000000   NOP
336:                 
337:                 /*-----------------------------------------------------------------------*/
338:                 /* Read Sector(s)                                                        */
339:                 /*-----------------------------------------------------------------------*/
340:                 
341:                 DRESULT disk_read(PF_BYTE drv, /* Physical drive nmuber (0) */
342:                                   PF_BYTE *buff, /* Pointer to the data buffer to store read data */
343:                                   DWORD sector, /* Start sector number (LBA) */
344:                                   PF_BYTE count /* Sector count (1..255) */
345:                                   ) {
9D010584  27BDFFE0   ADDIU SP, SP, -32
9D010588  AFBF001C   SW RA, 28(SP)
9D01058C  AFB10018   SW S1, 24(SP)
9D010590  AFB00014   SW S0, 20(SP)
346:                 	if (drv || !count)
9D01057C  14800034   BNE A0, ZERO, 0x9D010650
9D010580  24020004   ADDIU V0, ZERO, 4
9D010594  10E0002A   BEQ A3, ZERO, 0x9D010640
9D010598  00E08021   ADDU S0, A3, ZERO
347:                 		return RES_PARERR;
348:                 	if (Stat & STA_NOINIT)
9D01059C  93838010   LBU V1, -32752(GP)
9D0105A0  30630001   ANDI V1, V1, 1
9D0105A4  14600026   BNE V1, ZERO, 0x9D010640
9D0105A8  24020003   ADDIU V0, ZERO, 3
349:                 		return RES_NOTRDY;
350:                 
351:                 	if (!(CardType & CT_BLOCK))
9D0105AC  9783801E   LHU V1, -32738(GP)
9D0105B0  30630008   ANDI V1, V1, 8
9D0105B4  3063FFFF   ANDI V1, V1, -1
352:                 		sector *= BLK_SIZE; /* Convert to byte address if needed */
9D0105B8  00061240   SLL V0, A2, 9
9D0105BC  0043300A   MOVZ A2, V0, V1
353:                 
354:                 	if (count == 1) { /* Single block read */
9D0105C0  24020001   ADDIU V0, ZERO, 1
9D0105C4  14E2000A   BNE A3, V0, 0x9D0105F0
9D0105C8  00A08821   ADDU S1, A1, ZERO
355:                 		if ((send_cmd(CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
9D0105CC  24040011   ADDIU A0, ZERO, 17
9D0105D0  0F40407E   JAL send_cmd
9D0105D4  00C02821   ADDU A1, A2, ZERO
9D0105D8  14400016   BNE V0, ZERO, 0x9D010634
9D0105DC  02202021   ADDU A0, S1, ZERO
356:                 		&& rcvr_datablock(buff, BLK_SIZE))
9D0105E0  0F404024   JAL rcvr_datablock
9D0105E4  24050200   ADDIU A1, ZERO, 512
9D0105E8  0B40418D   J 0x9D010634
9D0105EC  2C500001   SLTIU S0, V0, 1
357:                 			count = 0;
358:                 	} else { /* Multiple block read */
359:                 		if (send_cmd(CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
9D0105F0  24040012   ADDIU A0, ZERO, 18
9D0105F4  0F40407E   JAL send_cmd
9D0105F8  00C02821   ADDU A1, A2, ZERO
9D0105FC  1440000D   BNE V0, ZERO, 0x9D010634
9D010600  00000000   NOP
360:                 			do {
361:                 				if (!rcvr_datablock(buff, BLK_SIZE))
9D010604  02202021   ADDU A0, S1, ZERO
9D010608  0F404024   JAL rcvr_datablock
9D01060C  24050200   ADDIU A1, ZERO, 512
9D010610  10400006   BEQ V0, ZERO, 0x9D01062C
9D010614  2404000C   ADDIU A0, ZERO, 12
362:                 					break;
363:                 				buff += BLK_SIZE;
364:                 			} while (--count);
9D010618  2610FFFF   ADDIU S0, S0, -1
9D01061C  321000FF   ANDI S0, S0, 255
9D010620  1600FFF8   BNE S0, ZERO, 0x9D010604
9D010624  26310200   ADDIU S1, S1, 512
365:                 			send_cmd(CMD12, 0); /* STOP_TRANSMISSION */
9D010628  2404000C   ADDIU A0, ZERO, 12
9D01062C  0F40407E   JAL send_cmd
9D010630  00002821   ADDU A1, ZERO, ZERO
366:                 		}
367:                 	}
368:                 	deselect();
9D010634  0F4062AF   JAL disableSD
9D010638  00000000   NOP
369:                 
370:                 	return count ? RES_ERROR : RES_OK;
9D01063C  0010102B   SLTU V0, ZERO, S0
371:                 }
9D010640  8FBF001C   LW RA, 28(SP)
9D010644  8FB10018   LW S1, 24(SP)
9D010648  8FB00014   LW S0, 20(SP)
9D01064C  27BD0020   ADDIU SP, SP, 32
9D010650  03E00008   JR RA
9D010654  00000000   NOP
372:                 
373:                 /*-----------------------------------------------------------------------*/
374:                 /* Write Sector(s)                                                       */
375:                 /*-----------------------------------------------------------------------*/
376:                 
377:                 #if _READONLY == 0
378:                 DRESULT disk_write(PF_BYTE drv, /* Physical drive number (0) */
379:                                    const PF_BYTE *buff, /* Pointer to the data to be written */
380:                                    DWORD sector, /* Start sector number (LBA) */
381:                                    PF_BYTE count /* Sector count (1..255) */
382:                                    ) {
9D010660  27BDFFE0   ADDIU SP, SP, -32
9D010664  AFBF001C   SW RA, 28(SP)
9D010668  AFB20018   SW S2, 24(SP)
9D01066C  AFB10014   SW S1, 20(SP)
9D010670  AFB00010   SW S0, 16(SP)
383:                 	if (drv || !count)
9D010658  14800044   BNE A0, ZERO, 0x9D01076C
9D01065C  24020004   ADDIU V0, ZERO, 4
9D010674  10E00038   BEQ A3, ZERO, 0x9D010758
9D010678  00E08021   ADDU S0, A3, ZERO
384:                 		return RES_PARERR;
385:                 	if (Stat & STA_NOINIT)
9D01067C  93838010   LBU V1, -32752(GP)
9D010680  30630001   ANDI V1, V1, 1
9D010684  14600034   BNE V1, ZERO, 0x9D010758
9D010688  24020003   ADDIU V0, ZERO, 3
386:                 		return RES_NOTRDY;
387:                 	if (Stat & STA_PROTECT)
9D01068C  93838010   LBU V1, -32752(GP)
9D010690  30630004   ANDI V1, V1, 4
9D010694  306300FF   ANDI V1, V1, 255
9D010698  1460002F   BNE V1, ZERO, 0x9D010758
9D01069C  24020002   ADDIU V0, ZERO, 2
9D0106A0  00C09021   ADDU S2, A2, ZERO
388:                 		return RES_WRPRT;
389:                 
390:                 	if (!(CardType & CT_BLOCK))
9D0106A4  9782801E   LHU V0, -32738(GP)
9D0106A8  30440008   ANDI A0, V0, 8
9D0106AC  3084FFFF   ANDI A0, A0, -1
391:                 		sector *= 512; /* Convert to byte address if needed */
9D0106B0  00061A40   SLL V1, A2, 9
9D0106B4  0064900A   MOVZ S2, V1, A0
392:                 
393:                 	if (count == 1) { /* Single block write */
9D0106B8  24030001   ADDIU V1, ZERO, 1
9D0106BC  14E3000A   BNE A3, V1, 0x9D0106E8
9D0106C0  00A08821   ADDU S1, A1, ZERO
394:                 		if ((send_cmd(CMD24, sector) == 0) /* WRITE_BLOCK */
9D0106C4  24040018   ADDIU A0, ZERO, 24
9D0106C8  0F40407E   JAL send_cmd
9D0106CC  02402821   ADDU A1, S2, ZERO
9D0106D0  1440001E   BNE V0, ZERO, 0x9D01074C
9D0106D4  02202021   ADDU A0, S1, ZERO
395:                 		&& xmit_datablock(buff, 0xFE))
9D0106D8  0F403FFF   JAL xmit_datablock
9D0106DC  240500FE   ADDIU A1, ZERO, 254
9D0106E0  0B4041D3   J 0x9D01074C
9D0106E4  2C500001   SLTIU S0, V0, 1
396:                 			count = 0;
397:                 	} else { /* Multiple block write */
398:                 		if (CardType & CT_SDC)
9D0106E8  30420006   ANDI V0, V0, 6
9D0106EC  10400005   BEQ V0, ZERO, 0x9D010704
9D0106F0  24040019   ADDIU A0, ZERO, 25
399:                 			send_cmd(ACMD23, count);
9D0106F4  24040097   ADDIU A0, ZERO, 151
9D0106F8  0F40407E   JAL send_cmd
9D0106FC  00E02821   ADDU A1, A3, ZERO
400:                 		if (send_cmd(CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
9D010700  24040019   ADDIU A0, ZERO, 25
9D010704  0F40407E   JAL send_cmd
9D010708  02402821   ADDU A1, S2, ZERO
9D01070C  1440000F   BNE V0, ZERO, 0x9D01074C
9D010710  00000000   NOP
401:                 			do {
402:                 				if (!xmit_datablock(buff, 0xFC))
9D010714  02202021   ADDU A0, S1, ZERO
9D010718  0F403FFF   JAL xmit_datablock
9D01071C  240500FC   ADDIU A1, ZERO, 252
9D010720  10400006   BEQ V0, ZERO, 0x9D01073C
9D010724  00002021   ADDU A0, ZERO, ZERO
403:                 					break;
404:                 				buff += 512;
405:                 			} while (--count);
9D010728  2610FFFF   ADDIU S0, S0, -1
9D01072C  321000FF   ANDI S0, S0, 255
9D010730  1600FFF8   BNE S0, ZERO, 0x9D010714
9D010734  26310200   ADDIU S1, S1, 512
406:                 			if (!xmit_datablock(0, 0xFD)) /* STOP_TRAN token */
9D010738  00002021   ADDU A0, ZERO, ZERO
9D01073C  0F403FFF   JAL xmit_datablock
9D010740  240500FD   ADDIU A1, ZERO, 253
407:                 				count = 1;
9D010744  24030001   ADDIU V1, ZERO, 1
9D010748  0062800A   MOVZ S0, V1, V0
408:                 		}
409:                 	}
410:                 	deselect();
9D01074C  0F4062AF   JAL disableSD
9D010750  00000000   NOP
411:                 
412:                 	return count ? RES_ERROR : RES_OK;
9D010754  0010102B   SLTU V0, ZERO, S0
413:                 }
9D010758  8FBF001C   LW RA, 28(SP)
9D01075C  8FB20018   LW S2, 24(SP)
9D010760  8FB10014   LW S1, 20(SP)
9D010764  8FB00010   LW S0, 16(SP)
9D010768  27BD0020   ADDIU SP, SP, 32
9D01076C  03E00008   JR RA
9D010770  00000000   NOP
414:                 #endif /* _READONLY */
415:                 
416:                 /*-----------------------------------------------------------------------*/
417:                 /* Miscellaneous Functions                                               */
418:                 /*-----------------------------------------------------------------------*/
419:                 
420:                 DRESULT disk_ioctl(PF_BYTE drv, /* Physical drive number (0) */
421:                                    PF_BYTE ctrl, /* Control code */
422:                                    void *buff /* Buffer to send/receive data block */
423:                                    ) {
9D01077C  27BDFFD0   ADDIU SP, SP, -48
9D010780  AFBF002C   SW RA, 44(SP)
9D010784  AFB20028   SW S2, 40(SP)
9D010788  AFB10024   SW S1, 36(SP)
9D01078C  AFB00020   SW S0, 32(SP)
424:                 	DRESULT res;
425:                 	PF_BYTE n, csd[16], *ptr = buff;
426:                 	DWORD csize;
427:                 
428:                 	if (drv)
9D010774  148000DB   BNE A0, ZERO, 0x9D010AE4
9D010778  24020004   ADDIU V0, ZERO, 4
429:                 		return RES_PARERR;
430:                 	if (Stat & STA_NOINIT)
9D010790  93838010   LBU V1, -32752(GP)
9D010794  30630001   ANDI V1, V1, 1
9D010798  146000CD   BNE V1, ZERO, 0x9D010AD0
9D01079C  24020003   ADDIU V0, ZERO, 3
431:                 		return RES_NOTRDY;
432:                 
433:                 	res = RES_ERROR;
434:                 	switch (ctrl) {
9D0107A0  2CA2000F   SLTIU V0, A1, 15
9D0107A4  104000C6   BEQ V0, ZERO, 0x9D010AC0
9D0107A8  00052880   SLL A1, A1, 2
9D0107AC  3C029D01   LUI V0, -25343
9D0107B0  244207C4   ADDIU V0, V0, 1988
9D0107B4  00452821   ADDU A1, V0, A1
9D0107B8  8CA20000   LW V0, 0(A1)
9D0107BC  00400008   JR V0
9D0107C0  00C08021   ADDU S0, A2, ZERO
435:                 	case CTRL_SYNC: /* Flush dirty buffer if present */
436:                 		if (select()) {
9D010800  0F40406A   JAL select
9D010804  24110001   ADDIU S1, ZERO, 1
9D010808  104000AE   BEQ V0, ZERO, 0x9D010AC4
9D01080C  00000000   NOP
437:                 			deselect();
9D010810  0F4062AF   JAL disableSD
9D010814  00008821   ADDU S1, ZERO, ZERO
9D010818  0B4042B1   J 0x9D010AC4
9D01081C  00000000   NOP
438:                 			res = RES_OK;
439:                 		}
440:                 		break;
441:                 
442:                 	case GET_SECTOR_COUNT: /* Get number of sectors on the disk (WORD) */
443:                 		if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
9D010820  24040009   ADDIU A0, ZERO, 9
9D010824  0F40407E   JAL send_cmd
9D010828  00002821   ADDU A1, ZERO, ZERO
9D01082C  144000A5   BNE V0, ZERO, 0x9D010AC4
9D010830  24110001   ADDIU S1, ZERO, 1
9D010834  27A40010   ADDIU A0, SP, 16
9D010838  0F404024   JAL rcvr_datablock
9D01083C  24050010   ADDIU A1, ZERO, 16
9D010840  104000A0   BEQ V0, ZERO, 0x9D010AC4
9D010844  93A30010   LBU V1, 16(SP)
444:                 			if ((csd[0] >> 6) == 1) { /* SDv2? */
9D010848  00031982   SRL V1, V1, 6
9D01084C  24020001   ADDIU V0, ZERO, 1
9D010850  1462000A   BNE V1, V0, 0x9D01087C
9D010854  93A30018   LBU V1, 24(SP)
445:                 				csize = csd[9] + ((WORD) csd[8] << 8) + 1;
9D010858  93A30019   LBU V1, 25(SP)
9D01085C  93A20018   LBU V0, 24(SP)
9D010860  00021200   SLL V0, V0, 8
9D010864  00621021   ADDU V0, V1, V0
9D010868  24420001   ADDIU V0, V0, 1
446:                 				*(DWORD*) buff = (DWORD) csize << 10;
9D01086C  00021280   SLL V0, V0, 10
9D010870  AE020000   SW V0, 0(S0)
9D010874  0B4042B1   J 0x9D010AC4
9D010878  00008821   ADDU S1, ZERO, ZERO
447:                 			} else { /* SDv1 or MMCv2 */
448:                 				n = (csd[5] & 15) + ((csd[10] & 128) >> 7)
9D0108A0  93A40015   LBU A0, 21(SP)
9D0108A4  3084000F   ANDI A0, A0, 15
9D0108A8  93A2001A   LBU V0, 26(SP)
9D0108AC  000211C2   SRL V0, V0, 7
9D0108B0  00822021   ADDU A0, A0, V0
9D0108B4  93A20019   LBU V0, 25(SP)
9D0108B8  30420003   ANDI V0, V0, 3
9D0108BC  00021040   SLL V0, V0, 1
449:                 						+ ((csd[9] & 3) << 1) + 2;
450:                 				csize = (csd[8] >> 6) + ((WORD) csd[7] << 2) + ((WORD) (csd[6]
9D01087C  00031982   SRL V1, V1, 6
9D010880  93A20017   LBU V0, 23(SP)
9D010884  00021080   SLL V0, V0, 2
9D010888  00621821   ADDU V1, V1, V0
9D010898  00621821   ADDU V1, V1, V0
451:                 						& 3) << 10) + 1;
9D01088C  93A20016   LBU V0, 22(SP)
9D010890  30420003   ANDI V0, V0, 3
9D010894  00021280   SLL V0, V0, 10
9D01089C  24630001   ADDIU V1, V1, 1
452:                 				*(DWORD*) buff = (DWORD) csize << (n - 9);
9D0108C0  00821021   ADDU V0, A0, V0
9D0108C4  2442FFF9   ADDIU V0, V0, -7
9D0108C8  00431004   SLLV V0, V1, V0
9D0108CC  AE020000   SW V0, 0(S0)
453:                 			}
454:                 			res = RES_OK;
9D0108D0  0B4042B1   J 0x9D010AC4
9D0108D4  00008821   ADDU S1, ZERO, ZERO
455:                 		}
456:                 		break;
457:                 
458:                 	case GET_SECTOR_SIZE: /* Get sectors on the disk (WORD) */
459:                 		*(WORD*) buff = 512;
9D0108D8  24020200   ADDIU V0, ZERO, 512
9D0108DC  A4C20000   SH V0, 0(A2)
460:                 		res = RES_OK;
461:                 		break;
9D0108E0  0B4042B1   J 0x9D010AC4
9D0108E4  00008821   ADDU S1, ZERO, ZERO
462:                 
463:                 	case GET_BLOCK_SIZE: /* Get erase block size in unit of sectors (DWORD) */
464:                 		if (CardType & CT_SD2) { /* SDv2? */
9D0108E8  9782801E   LHU V0, -32738(GP)
9D0108EC  30420004   ANDI V0, V0, 4
9D0108F0  3042FFFF   ANDI V0, V0, -1
9D0108F4  10400019   BEQ V0, ZERO, 0x9D01095C
9D0108F8  24040009   ADDIU A0, ZERO, 9
465:                 			if (send_cmd(ACMD13, 0) == 0) { /* Read SD status */
9D0108FC  2404008D   ADDIU A0, ZERO, 141
9D010900  0F40407E   JAL send_cmd
9D010904  00002821   ADDU A1, ZERO, ZERO
9D010908  1440006E   BNE V0, ZERO, 0x9D010AC4
9D01090C  24110001   ADDIU S1, ZERO, 1
466:                 				rcvr_spi();
9D010910  0F407642   JAL writeSPI
9D010914  240400FF   ADDIU A0, ZERO, 255
467:                 				if (rcvr_datablock(csd, 16)) { /* Read partial block */
9D010918  27A40010   ADDIU A0, SP, 16
9D01091C  0F404024   JAL rcvr_datablock
9D010920  24050010   ADDIU A1, ZERO, 16
9D010924  10400067   BEQ V0, ZERO, 0x9D010AC4
9D010928  00000000   NOP
9D01092C  24110030   ADDIU S1, ZERO, 48
468:                 					for (n = 64 - 16; n; n--)
9D010940  1620FFFB   BNE S1, ZERO, 0x9D010930
9D010944  93A2001A   LBU V0, 26(SP)
469:                 						rcvr_spi(); /* Purge trailing data */
9D010930  0F407642   JAL writeSPI
9D010934  240400FF   ADDIU A0, ZERO, 255
9D010938  2631FFFF   ADDIU S1, S1, -1
9D01093C  323100FF   ANDI S1, S1, 255
470:                 					*(DWORD*) buff = 16UL << (csd[10] >> 4);
9D010948  00021102   SRL V0, V0, 4
9D01094C  24030010   ADDIU V1, ZERO, 16
9D010950  00431004   SLLV V0, V1, V0
9D010954  0B4042B1   J 0x9D010AC4
9D010958  AE020000   SW V0, 0(S0)
471:                 					res = RES_OK;
472:                 				}
473:                 			}
474:                 		} else { /* SDv1 or MMCv3 */
475:                 			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) { /* Read CSD */
9D01095C  0F40407E   JAL send_cmd
9D010960  00002821   ADDU A1, ZERO, ZERO
9D010964  14400057   BNE V0, ZERO, 0x9D010AC4
9D010968  24110001   ADDIU S1, ZERO, 1
9D01096C  27A40010   ADDIU A0, SP, 16
9D010970  0F404024   JAL rcvr_datablock
9D010974  24050010   ADDIU A1, ZERO, 16
9D010978  10400052   BEQ V0, ZERO, 0x9D010AC4
9D01097C  9782801E   LHU V0, -32738(GP)
476:                 				if (CardType & CT_SD1) { /* SDv1 */
9D010980  30420002   ANDI V0, V0, 2
9D010984  3042FFFF   ANDI V0, V0, -1
9D010988  1040000E   BEQ V0, ZERO, 0x9D0109C4
9D01098C  93A2001B   LBU V0, 27(SP)
477:                 					*(DWORD*) buff = (((csd[10] & 63) << 1) + ((WORD) (csd[11]
9D010990  93A3001A   LBU V1, 26(SP)
9D010994  3063003F   ANDI V1, V1, 63
9D010998  00031840   SLL V1, V1, 1
9D0109A0  00621821   ADDU V1, V1, V0
9D0109B8  AE020000   SW V0, 0(S0)
9D0109BC  0B4042B1   J 0x9D010AC4
9D0109C0  00008821   ADDU S1, ZERO, ZERO
478:                 							& 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
9D01099C  000211C2   SRL V0, V0, 7
9D0109A4  24630001   ADDIU V1, V1, 1
9D0109A8  93A2001D   LBU V0, 29(SP)
9D0109AC  00021182   SRL V0, V0, 6
9D0109B0  2442FFFF   ADDIU V0, V0, -1
9D0109B4  00431004   SLLV V0, V1, V0
479:                 				} else { /* MMCv3 */
480:                 					*(DWORD*) buff = ((WORD) ((csd[10] & 124) >> 2) + 1)
9D0109C4  93A3001A   LBU V1, 26(SP)
9D0109C8  7C632080   EXT V1, V1, 2, 5
9D0109CC  24630001   ADDIU V1, V1, 1
9D0109E8  AE020000   SW V0, 0(S0)
481:                 							* (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5)
9D0109D0  30440003   ANDI A0, V0, 3
9D0109D4  000420C0   SLL A0, A0, 3
9D0109D8  00021142   SRL V0, V0, 5
9D0109DC  00821021   ADDU V0, A0, V0
9D0109E4  70621002   MUL V0, V1, V0
482:                 									+ 1);
9D0109E0  24420001   ADDIU V0, V0, 1
483:                 				}
484:                 				res = RES_OK;
9D0109EC  0B4042B1   J 0x9D010AC4
9D0109F0  00008821   ADDU S1, ZERO, ZERO
485:                 			}
486:                 		}
487:                 		break;
488:                 
489:                 	case MMC_GET_TYPE: /* Get card type flags (1 byte) */
490:                 		*ptr = CardType;
9D0109F4  9782801E   LHU V0, -32738(GP)
9D0109F8  A0C20000   SB V0, 0(A2)
491:                 		res = RES_OK;
492:                 		break;
9D0109FC  0B4042B1   J 0x9D010AC4
9D010A00  00008821   ADDU S1, ZERO, ZERO
493:                 
494:                 	case MMC_GET_CSD: /* Receive CSD as a data block (16 bytes) */
495:                 		if ((send_cmd(CMD9, 0) == 0) /* READ_CSD */
9D010A04  24040009   ADDIU A0, ZERO, 9
9D010A08  0F40407E   JAL send_cmd
9D010A0C  00002821   ADDU A1, ZERO, ZERO
9D010A10  1440002C   BNE V0, ZERO, 0x9D010AC4
9D010A14  24110001   ADDIU S1, ZERO, 1
496:                 		&& rcvr_datablock(buff, 16))
9D010A18  02002021   ADDU A0, S0, ZERO
9D010A1C  0F404024   JAL rcvr_datablock
9D010A20  24050010   ADDIU A1, ZERO, 16
9D010A24  0B4042B1   J 0x9D010AC4
9D010A28  2C510001   SLTIU S1, V0, 1
497:                 			res = RES_OK;
498:                 		break;
499:                 
500:                 	case MMC_GET_CID: /* Receive CID as a data block (16 bytes) */
501:                 		if ((send_cmd(CMD10, 0) == 0) /* READ_CID */
9D010A2C  2404000A   ADDIU A0, ZERO, 10
9D010A30  0F40407E   JAL send_cmd
9D010A34  00002821   ADDU A1, ZERO, ZERO
9D010A38  14400022   BNE V0, ZERO, 0x9D010AC4
9D010A3C  24110001   ADDIU S1, ZERO, 1
502:                 		&& rcvr_datablock(buff, 16))
9D010A40  02002021   ADDU A0, S0, ZERO
9D010A44  0F404024   JAL rcvr_datablock
9D010A48  24050010   ADDIU A1, ZERO, 16
9D010A4C  0B4042B1   J 0x9D010AC4
9D010A50  2C510001   SLTIU S1, V0, 1
503:                 			res = RES_OK;
504:                 		break;
505:                 
506:                 	case MMC_GET_OCR: /* Receive OCR as an R3 resp (4 bytes) */
507:                 		if (send_cmd(CMD58, 0) == 0) { /* READ_OCR */
9D010A54  2404003A   ADDIU A0, ZERO, 58
9D010A58  0F40407E   JAL send_cmd
9D010A5C  00002821   ADDU A1, ZERO, ZERO
9D010A60  14400018   BNE V0, ZERO, 0x9D010AC4
9D010A64  24110001   ADDIU S1, ZERO, 1
9D010A68  00008821   ADDU S1, ZERO, ZERO
508:                 			for (n = 0; n < 4; n++)
9D010A6C  24120004   ADDIU S2, ZERO, 4
9D010A80  1632FFFB   BNE S1, S2, 0x9D010A70
9D010A84  A0620000   SB V0, 0(V1)
9D010A88  0B4042B1   J 0x9D010AC4
9D010A8C  00008821   ADDU S1, ZERO, ZERO
509:                 				*((PF_BYTE*) buff + n) = rcvr_spi();
9D010A70  0F407642   JAL writeSPI
9D010A74  240400FF   ADDIU A0, ZERO, 255
9D010A78  02111821   ADDU V1, S0, S1
9D010A7C  26310001   ADDIU S1, S1, 1
510:                 			res = RES_OK;
511:                 		}
512:                 		break;
513:                 
514:                 	case MMC_GET_SDSTAT: /* Receive SD status as a data block (64 bytes) */
515:                 		if (send_cmd(ACMD13, 0) == 0) { /* SD_STATUS */
9D010A90  2404008D   ADDIU A0, ZERO, 141
9D010A94  0F40407E   JAL send_cmd
9D010A98  00002821   ADDU A1, ZERO, ZERO
9D010A9C  14400009   BNE V0, ZERO, 0x9D010AC4
9D010AA0  24110001   ADDIU S1, ZERO, 1
516:                 			rcvr_spi();
9D010AA4  0F407642   JAL writeSPI
9D010AA8  240400FF   ADDIU A0, ZERO, 255
517:                 			if (rcvr_datablock(buff, 64))
9D010AAC  02002021   ADDU A0, S0, ZERO
9D010AB0  0F404024   JAL rcvr_datablock
9D010AB4  24050040   ADDIU A1, ZERO, 64
9D010AB8  0B4042B1   J 0x9D010AC4
9D010ABC  2C510001   SLTIU S1, V0, 1
9D010AC0  24110004   ADDIU S1, ZERO, 4
518:                 				res = RES_OK;
519:                 		}
520:                 		break;
521:                 
522:                 	default:
523:                 		res = RES_PARERR;
524:                 	}
525:                 
526:                 	deselect();
9D010AC4  0F4062AF   JAL disableSD
9D010AC8  00000000   NOP
527:                 
528:                 	return res;
9D010ACC  02201021   ADDU V0, S1, ZERO
529:                 }//disk_ioctl()
9D010AD0  8FBF002C   LW RA, 44(SP)
9D010AD4  8FB20028   LW S2, 40(SP)
9D010AD8  8FB10024   LW S1, 36(SP)
9D010ADC  8FB00020   LW S0, 32(SP)
9D010AE0  27BD0030   ADDIU SP, SP, 48
9D010AE4  03E00008   JR RA
9D010AE8  00000000   NOP
530:                 
531:                 /*-----------------------------------------------------------------------*/
532:                 /* Device Timer Interrupt Procedure  (Platform dependent)                */
533:                 /*-----------------------------------------------------------------------*/
534:                 /* This function must be called in period of 1ms                         */
535:                 /*
536:                 void disk_timerproc(void) {
537:                 	static WORD pv;
538:                 	WORD p;
539:                 	PF_BYTE s;
540:                 	UINT16 n;
541:                 
542:                 	n = Timer1; // 1000Hz decrement timer
543:                 	if (n)
544:                 		Timer1 = --n;
545:                 	n = Timer2;
546:                 	if (n)
547:                 		Timer2 = --n;
548:                 
549:                 	p = pv;
550:                 	pv = getCD() & getWP(); // Sample socket switch
551:                 
552:                 	if (p == pv) { // Have contacts stabled?
553:                 		s = Stat;
554:                 
555:                 		if (p & getWP()) // WP is H (write protected)
556:                 			s |= STA_PROTECT;
557:                 		else
558:                 			//* WP is L (write enabled)
559:                 			s &= ~STA_PROTECT;
560:                 
561:                 		if (p & getCD()) // INS = H (Socket empty)
562:                 			s |= (STA_NODISK | STA_NOINIT);
563:                 		else
564:                 			// INS = L (Card inserted)
565:                 			s &= ~STA_NODISK;
566:                 
567:                 		Stat = s;
568:                 	}
569:                 }
570:                 */
571:                 
572:                 /*---------------------------------------------------------*/
573:                 /* User Provided RTC Function for FatFs module             */
574:                 /*---------------------------------------------------------*/
575:                 /* This is a real time clock service to be called from     */
576:                 /* FatFs module. Any valid time must be returned even if   */
577:                 /* the system does not support an RTC.                     */
578:                 /* This function is not required in read-only cfg.         */
579:                 
580:                 /*	The current time is returned packed into a DWORD
581:                 	(32 bit) value. The bit fields are as follows:
582:                 		bits 31:25	Year from 1980 (0..127)
583:                 		bits 24:21	Month (1..12)
584:                 		bits 20:16	Day in month (1..31)
585:                 		bits 15:11	Hour (0..23)
586:                 		bits 10:05	Minute (0..59)
587:                 		bits 04:00	Second / 2 (0..29)						*/
588:                 
589:                 DWORD get_fattime(void) {
9D010AEC  27BDFFE0   ADDIU SP, SP, -32
9D010AF0  AFBF001C   SW RA, 28(SP)
590:                 	DWORD tmr = 0;
591:                 
592:                 // Pre-processor commands added so only use RTCC if the board is known
593:                 // to support the RTCC ** Added 07 May 2012
594:                 
595:                 // For boards known to support the RTCC library
596:                 
597:                 #if defined (PIC32_PINGUINO) || defined (PIC32_PINGUINO_OTG)
598:                 	rtccTime pTm, cTm;
599:                 	rtccDate pDt, cDt;
600:                 
601:                 	RTCC_GetTimeDate(&pTm, &pDt);	// get time and date from RTC
602:                 											// assumes RTC has been set and is running
603:                 											// OK - could be expanded to check that RTC
604:                 											// is running and that a valid value is
605:                 											// being returned by the RTC
606:                 	cTm = RTCC_ConvertTime(&pTm);	// convert time from bcd to decimal format
607:                 	cDt = RTCC_ConvertDate(&pDt);	// convert date from bcd to decimal format
608:                 
609:                 	/* Pack date and time into a DWORD variable */
610:                 //	tmr = (((DWORD) pDt.year - 80)) | ((DWORD) pDt.mon) | ((DWORD) pDt.mday)
611:                 //			| (WORD) (pTm.hour) | (WORD) (pTm.min) | (WORD) (pTm.sec);
612:                 	tmr = cDt.year + 20;
613:                    
614:                   // Correction according to a newer rtcc library, with diff struct members.
615:                   
616:                 	 tmr = (tmr << 4) | cDt.month;		// shifts left 4 bits and adds monthth
617:                 	tmr = (tmr << 5) | cDt.dayofmonth;		// shifts left 5 bits and adds m.day
618:                 	tmr = (tmr << 5) | cTm.hours;		// shifts left 5 bits and adds hour
619:                 	tmr = (tmr << 6) | cTm.minutes;		// shift left 6 bits and adds minutes
620:                 	tmr = (tmr << 5) | (cTm.seconds/2);	// shifts left 5 bits and adds seconds/2
621:                 
622:                     // pour ordinateur VPC_32VGA, Jacques Deschênes, mars 2018
623:                 #elif defined (VPC_32)
624:                 #include "../rtcc/rtcc.h"
625:                     sdate_t date;
626:                     stime_t time;
627:                     
628:                     rtcc_get_time(&time);
9D010AF4  0F4036DC   JAL rtcc_get_time
9D010AF8  27A40014   ADDIU A0, SP, 20
629:                     rtcc_get_date(&date);
9D010AFC  0F403710   JAL rtcc_get_date
9D010B00  27A40010   ADDIU A0, SP, 16
630:                     tmr=date.year-1980; // nombre d'années depuis 1980
9D010B04  97A30010   LHU V1, 16(SP)
9D010B08  2463F844   ADDIU V1, V1, -1980
631:                     tmr=(tmr<<4)|date.month; // mois
9D010B0C  00031900   SLL V1, V1, 4
9D010B10  8FA20010   LW V0, 16(SP)
9D010B14  7C441C00   EXT A0, V0, 16, 4
9D010B18  00641825   OR V1, V1, A0
632:                     tmr=(tmr<<5)|date.day; // jour du mois
9D010B1C  00031940   SLL V1, V1, 5
9D010B20  7C422500   EXT V0, V0, 20, 5
9D010B24  00621025   OR V0, V1, V0
633:                     tmr=(tmr<<5)|time.hour; // heures
9D010B28  00021140   SLL V0, V0, 5
9D010B2C  8FA30014   LW V1, 20(SP)
9D010B30  7C642300   EXT A0, V1, 12, 5
9D010B34  00441025   OR V0, V0, A0
634:                     tmr=(tmr<<6)|time.min; // minutes
9D010B38  00021180   SLL V0, V0, 6
9D010B3C  7C642980   EXT A0, V1, 6, 6
9D010B40  00441025   OR V0, V0, A0
635:                     tmr=(tmr<<5)|time.sec; // secondes/2
9D010B44  00021140   SLL V0, V0, 5
9D010B48  3063003F   ANDI V1, V1, 63
636:                     
637:                 //	For other boards use a fixed date and time of 01 Jan 2012 12:00:00
638:                 #else
639:                      tmr = 12 + 20;
640:                      tmr = (tmr << 4) | 1;       // shifts left 4 bits and adds month
641:                      tmr = (tmr << 5) | 1;    	// shifts left 5 bits and adds m.day
642:                      tmr = (tmr << 5) | 12;    	// shifts left 5 bits and adds hour
643:                      tmr = (tmr << 6) | 0;       // shift left 6 bits and adds minutes
644:                      tmr = (tmr << 5) | (0/2);   // shifts left 5 bits and adds seconds/2
645:                 #endif
646:                 
647:                 	return tmr;
648:                 } // get_fattime()
9D010B4C  00431025   OR V0, V0, V1
9D010B50  8FBF001C   LW RA, 28(SP)
9D010B54  03E00008   JR RA
9D010B58  27BD0020   ADDIU SP, SP, 32
649:                 
650:                 void put_rc(FRESULT rc) {
651:                     char *fmt;
652:                 
653:                 	const char *str =
654:                                         "OK\0" "DISK_ERR\0" "INT_ERR\0" "NOT_READY\0" "NO_FILE\0" "NO_PATH\0"
655:                                                 "INVALID_NAME\0" "DENIED\0" "EXIST\0" "INVALID_OBJECT\0" "WRITE_PROTECTED\0"
656:                                                 "INVALID_DRIVE\0" "NOT_ENABLED\0" "NO_FILE_SYSTEM\0" "MKFS_ABORTED\0" "TIMEOUT\0"
657:                                                 "LOCKED\0" "NOT_ENOUGH_CORE\0" "TOO_MANY_OPEN_FILES\0";
658:                 	FRESULT i;
659:                             for (i = 0; i != rc && *str; i++) {
660:                                     while (*str++)
661:                                             ;
662:                             }
663:                             print_error_msg(ERR_FIO,str,rc);
664:                 }//put_rc()
665:                 
---  /home/jacques/github/vpc-32vga/hardware/HardwareProfile.c  -----------------------------------------
1:                   /*
2:                   * Copyright 2013,2014,2017,2018 Jacques Deschênes
3:                   * This file is part of VPC-32VGA.
4:                   *
5:                   *     VPC-32VGA is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32VGA.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   * File:   HardwareProfile.h
21:                   * Author: Jacques Deschênes
22:                   * Description: MCU hardware configuration
23:                   * Created on 17 avril 2013, 14:41
24:                   * rev: 2017-07-31
25:                   */
26:                  
27:                  #include "HardwareProfile.h"
28:                  #include "rtcc/rtcc.h"
29:                  #include <plib.h>
30:                  #include "sound/sound.h"
31:                  
32:                  #define TMR_COUNT 4
33:                  volatile unsigned int  sys_ticks; // milliseconds counter.
34:                  static volatile unsigned int timers[TMR_COUNT]; // count down timer
35:                  
36:                  // initialisation matérielle au démarrage.
37:                  void cold_start_init(){
9D014818  27BDFFE8   ADDIU SP, SP, -24
9D01481C  AFBF0014   SW RA, 20(SP)
38:                     SYSTEMConfig(mGetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
39:                     INTEnableSystemMultiVectoredInt();
9D014844  0F407B4C   JAL INTEnableSystemMultiVectoredInt
9D014848  00000000   NOP
40:                      // MCU core timer configuration
41:                     OpenCoreTimer(CORE_TICK_RATE); // 1 msec interrupt rate.
9D01484C  0F407D0C   JAL OpenCoreTimer
9D014850  24044E20   ADDIU A0, ZERO, 20000
42:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_2 | CT_INT_SUB_PRIOR_2));
9D014854  24020001   ADDIU V0, ZERO, 1
9D014858  3C03BF88   LUI V1, -16504
9D01485C  AC621034   SW V0, 4148(V1)
9D014860  3C04BF88   LUI A0, -16504
9D014864  2403001C   ADDIU V1, ZERO, 28
9D014868  AC831094   SW V1, 4244(A0)
9D01486C  3C03BF88   LUI V1, -16504
9D014870  24050008   ADDIU A1, ZERO, 8
9D014874  AC651098   SW A1, 4248(V1)
9D014878  24070003   ADDIU A3, ZERO, 3
9D01487C  AC871094   SW A3, 4244(A0)
9D014880  24060002   ADDIU A2, ZERO, 2
9D014884  AC661098   SW A2, 4248(V1)
9D014888  3C03BF88   LUI V1, -16504
9D01488C  AC621064   SW V0, 4196(V1)
9D014890  3C03BF88   LUI V1, -16504
9D014894  AC621068   SW V0, 4200(V1)
43:                     // disable all analogs inputs, not used by vpc32-v.
44:                     ANSELBCLR=0xFFFFFFFF;
9D014898  2403FFFF   ADDIU V1, ZERO, -1
9D01489C  3C04BF88   LUI A0, -16504
9D0148A0  AC836104   SW V1, 24836(A0)
45:                     ANSELACLR=0xFFFFFFFF;
9D0148A4  3C04BF88   LUI A0, -16504
9D0148A8  AC836004   SW V1, 24580(A0)
46:                     //power LED config
47:                     PLED_TRISCLR=PLED_PIN; // output mode
9D0148AC  3C03BF88   LUI V1, -16504
9D0148B0  24044000   ADDIU A0, ZERO, 16384
9D0148B4  AC646114   SW A0, 24852(V1)
48:                     PLED_ODCSET=PLED_PIN; // open drain
9D0148B8  3C05BF88   LUI A1, -16504
9D0148BC  ACA46148   SW A0, 24904(A1)
49:                     PLED_RPR=PLED_FN;  // PPS analog comparator output Cxout
9D0148C0  24050007   ADDIU A1, ZERO, 7
9D0148C4  3C04BF81   LUI A0, -16511
9D0148C8  AC85FB64   SW A1, -1180(A0)
50:                     // configuration du comparateur analogique
51:                     // ON=1,OE=1,CPOL=1,CREF=1,CCH=3
52:                     PLED_CMCON=PLED_CMENBL|PLED_OE|PLED_CPOL|PLED_CREF|PLED_CM_CCH;
9D0148CC  3405E013   ORI A1, ZERO, -8173
9D0148D0  3C04BF81   LUI A0, -16511
9D0148D4  AC85A000   SW A1, -24576(A0)
53:                     // configuration CVref ON=1,CVRR=1,CVR=9
54:                     CVRCON=BIT_15|BIT_5|9;
9D0148D8  34058029   ORI A1, ZERO, -32727
9D0148DC  3C04BF81   LUI A0, -16511
9D0148E0  AC859800   SW A1, -26624(A0)
55:                      // serial port config
56:                     SER_LATSET=TX; // Set TX to high (idle state).
9D0148E4  24040400   ADDIU A0, ZERO, 1024
9D0148E8  3C05BF88   LUI A1, -16504
9D0148EC  ACA46138   SW A0, 24888(A1)
57:                     SER_TRISCLR=TX;  // set serial output pin.
9D0148F0  AC646114   SW A0, 24852(V1)
58:                     //keyboard
59:                     I2C1CONbits.DISSLW=1; // see pic32mx1xxx/2xxx-errata.pdf rev. E, point 9
9D0148F4  3C04BF80   LUI A0, -16512
9D0148F8  94855000   LHU A1, 20480(A0)
9D0148FC  7C454A44   INS A1, V0, 9, 1
9D014900  A4855000   SH A1, 20480(A0)
60:                     // Peripheral Pin Select
61:                     // see pps.h
62:                     PPSUnLock;  // unlock PPS to enable configuration
9D014904  3C04BF81   LUI A0, -16511
9D014908  9485F200   LHU A1, -3584(A0)
9D01490C  7C056B44   INS A1, ZERO, 13, 1
9D014910  A485F200   SH A1, -3584(A0)
63:                     PPSOutput(4, RPB10, U2TX);  // U2TX on PB10
9D014914  3C05BF81   LUI A1, -16511
9D014918  90A8FB54   LBU T0, -1196(A1)
9D01491C  7CC81804   INS T0, A2, 0, 4
9D014920  A0A8FB54   SB T0, -1196(A1)
64:                     PPSInput (2, U2RX, RPB11);  // U2RX on PB11
9D014924  3C05BF81   LUI A1, -16511
9D014928  90A8FA58   LBU T0, -1448(A1)
9D01492C  7CE81804   INS T0, A3, 0, 4
9D014930  A0A8FA58   SB T0, -1448(A1)
65:                     PPSOutput(2,RPB5,OC2); // OC2  on PB5, VGA HSync signal.
9D014934  3C08BF81   LUI T0, -16511
9D014938  9109FB40   LBU T1, -1216(T0)
9D01493C  24050005   ADDIU A1, ZERO, 5
9D014940  7CA91804   INS T1, A1, 0, 4
9D014944  A109FB40   SB T1, -1216(T0)
66:                     PPSOutput(3,RPB13,OC4); // video SPI1 frame sync pulse ouput.
9D014948  3C08BF81   LUI T0, -16511
9D01494C  9109FB60   LBU T1, -1184(T0)
9D014950  7CA91804   INS T1, A1, 0, 4
9D014954  A109FB60   SB T1, -1184(T0)
67:                     PPSOutput(3,RPB6,SDO1); // SDO1 VGA video output on RB6
9D014958  3C08BF81   LUI T0, -16511
9D01495C  9109FB44   LBU T1, -1212(T0)
9D014960  7CE91804   INS T1, A3, 0, 4
9D014964  A109FB44   SB T1, -1212(T0)
68:                     PPSInput(1,SS1,RPB7); // SPI1 SS1 input on RPB7
9D014968  3C07BF81   LUI A3, -16511
9D01496C  90E9FA88   LBU T1, -1400(A3)
9D014970  24080004   ADDIU T0, ZERO, 4
9D014974  7D091804   INS T1, T0, 0, 4
9D014978  A0E9FA88   SB T1, -1400(A3)
69:                     PPSInput(3,SDI2,RPA4); // SD card and SPI RAM SDI (MISO) on RA4
9D01497C  3C07BF81   LUI A3, -16511
9D014980  90E9FA90   LBU T1, -1392(A3)
9D014984  7CC91804   INS T1, A2, 0, 4
9D014988  A0E9FA90   SB T1, -1392(A3)
70:                     PPSOutput(2,RPB8,SDO2); // SD card and SPI RAM SDO  (MOSI) on RB8
9D01498C  3C06BF81   LUI A2, -16511
9D014990  90C7FB4C   LBU A3, -1204(A2)
9D014994  7D071804   INS A3, T0, 0, 4
9D014998  A0C7FB4C   SB A3, -1204(A2)
71:                     PPSOutput(4,RPB9,OC3); //  OC3 audio output on PB9
9D01499C  3C06BF81   LUI A2, -16511
9D0149A0  90C7FB50   LBU A3, -1200(A2)
9D0149A4  7CA71804   INS A3, A1, 0, 4
9D0149A8  A0C7FB50   SB A3, -1200(A2)
72:                     PPSLock; // lock PPS to avoid accidental modification.
9D0149AC  9485F200   LHU A1, -3584(A0)
9D0149B0  7C456B44   INS A1, V0, 13, 1
9D0149B4  A485F200   SH A1, -3584(A0)
73:                     // all these pins are VGA output pins
74:                     VGA_TRISCLR=(SPI_TRIG_OUT|VSYNC_OUT|HSYNC_OUT|VIDEO_OUT);
9D0149B8  24042070   ADDIU A0, ZERO, 8304
9D0149BC  AC646114   SW A0, 24852(V1)
75:                     VGA_LATCLR=VIDEO_OUT;
9D0149C0  AC706114   SW S0, 24852(V1)
76:                     // store interface output pins
77:                     STORE_TRISCLR=STORE_MOSI|STORE_CLK|SDC_SEL;
9D0149C4  34048108   ORI A0, ZERO, -32504
9D0149C8  AC646114   SW A0, 24852(V1)
78:                     SRAM_TRISCLR=SRAM_SEL;
9D0149CC  3C03BF88   LUI V1, -16504
9D0149D0  AC626014   SW V0, 24596(V1)
79:                  }
9D0149D4  8FBF0014   LW RA, 20(SP)
9D0149D8  8FB00010   LW S0, 16(SP)
9D0149DC  03E00008   JR RA
9D0149E0  27BD0018   ADDIU SP, SP, 24
80:                  
81:                  // contrôle de la LED power
82:                  void power_led(pled_state_t state){
83:                      if (state){
9D0149E4  10800005   BEQ A0, ZERO, 0x9D0149FC
9D0149E8  24032000   ADDIU V1, ZERO, 8192
84:                          PLED_CMCONSET=PLED_CPOL;
9D0149EC  3C02BF81   LUI V0, -16511
9D0149F0  AC43A008   SW V1, -24568(V0)
9D0149F4  03E00008   JR RA
9D0149F8  00000000   NOP
85:                      }else{
86:                          PLED_CMCONCLR=PLED_CPOL;
9D0149FC  3C02BF81   LUI V0, -16511
9D014A00  AC43A004   SW V1, -24572(V0)
9D014A04  03E00008   JR RA
9D014A08  00000000   NOP
87:                      }
88:                  }
89:                  
90:                  // return the value of systicks counter
91:                  // millisecond since bootup
92:                  // rollover after ~ 50 days.
93:                  inline unsigned int ticks(void){
94:                      return sys_ticks;
9D014A0C  8F8280B0   LW V0, -32592(GP)
95:                  } //ticks()
9D014A10  03E00008   JR RA
9D014A14  00000000   NOP
96:                  
97:                  
98:                  
99:                  // suspend exécution pour une durée en microsecondes.
100:                 inline void delay_us(unsigned int usec){
101:                     T1CON=0;
9D014A18  3C02BF80   LUI V0, -16512
9D014A1C  AC400600   SW ZERO, 1536(V0)
102:                     IFS0bits.T1IF=0;
9D014A20  3C02BF88   LUI V0, -16504
9D014A24  8C431030   LW V1, 4144(V0)
9D014A28  7C032104   INS V1, ZERO, 4, 1
9D014A2C  AC431030   SW V1, 4144(V0)
103:                     PR1=40*usec;
9D014A30  000410C0   SLL V0, A0, 3
9D014A34  00042140   SLL A0, A0, 5
9D014A38  00442021   ADDU A0, V0, A0
9D014A3C  3C02BF80   LUI V0, -16512
9D014A40  AC440620   SW A0, 1568(V0)
104:                     T1CONbits.ON=1;
9D014A44  3C02BF80   LUI V0, -16512
9D014A48  94430600   LHU V1, 1536(V0)
9D014A4C  24040001   ADDIU A0, ZERO, 1
9D014A50  7C837BC4   INS V1, A0, 15, 1
9D014A54  A4430600   SH V1, 1536(V0)
105:                     while (!IFS0bits.T1IF);
9D014A58  3C03BF88   LUI V1, -16504
9D014A5C  8C621030   LW V0, 4144(V1)
9D014A60  30420010   ANDI V0, V0, 16
9D014A64  1040FFFD   BEQ V0, ZERO, 0x9D014A5C
9D014A68  3C02BF80   LUI V0, -16512
106:                     T1CONbits.ON=0;
9D014A6C  94430600   LHU V1, 1536(V0)
9D014A70  7C037BC4   INS V1, ZERO, 15, 1
9D014A74  A4430600   SH V1, 1536(V0)
9D014A78  03E00008   JR RA
9D014A7C  00000000   NOP
107:                 }//delay_us()
108:                 
109:                 // pause execution for duration in millisecond.
110:                 // idle loop.
111:                 void delay_ms(unsigned int msec){
112:                     unsigned int t0;
113:                     t0=sys_ticks+msec;
9D014A80  8F8280B0   LW V0, -32592(GP)
9D014A84  00822021   ADDU A0, A0, V0
114:                     while (sys_ticks!=t0);
9D014A88  8F8280B0   LW V0, -32592(GP)
9D014A8C  1444FFFE   BNE V0, A0, 0x9D014A88
9D014A90  00000000   NOP
115:                 } // delay_ms()
9D014A94  03E00008   JR RA
9D014A98  00000000   NOP
116:                 
117:                 // get_timer())
118:                 //  initialize a timer and return a pointer to it.
119:                 // input:
120:                 //      msec  duration in milliseconds
121:                 // output:
122:                 //      tmr*   Pointer to countdown variable, return NULL if none available
123:                 volatile unsigned int* get_timer(unsigned int msec){
124:                     int i;
125:                     for (i=0;i<TMR_COUNT;i++){
126:                         if (!timers[i]){
9D014A9C  3C02A000   LUI V0, -24576
9D014AA0  8C424608   LW V0, 17928(V0)
9D014AA4  10400011   BEQ V0, ZERO, 0x9D014AEC
9D014AA8  00001821   ADDU V1, ZERO, ZERO
9D014AAC  3C02A000   LUI V0, -24576
9D014AB0  24424608   ADDIU V0, V0, 17928
9D014AB4  8C420004   LW V0, 4(V0)
9D014AB8  1040000C   BEQ V0, ZERO, 0x9D014AEC
9D014ABC  24030001   ADDIU V1, ZERO, 1
9D014AC0  3C02A000   LUI V0, -24576
9D014AC4  24424608   ADDIU V0, V0, 17928
9D014AC8  8C420008   LW V0, 8(V0)
9D014ACC  10400007   BEQ V0, ZERO, 0x9D014AEC
9D014AD0  24030002   ADDIU V1, ZERO, 2
9D014AD4  3C02A000   LUI V0, -24576
9D014AD8  24424608   ADDIU V0, V0, 17928
9D014ADC  8C43000C   LW V1, 12(V0)
9D014AE0  14600007   BNE V1, ZERO, 0x9D014B00
9D014AE4  00001021   ADDU V0, ZERO, ZERO
9D014AE8  24030003   ADDIU V1, ZERO, 3
127:                             timers[i]=msec;
9D014AEC  00031880   SLL V1, V1, 2
9D014AF0  3C02A000   LUI V0, -24576
9D014AF4  24424608   ADDIU V0, V0, 17928
9D014AF8  00621021   ADDU V0, V1, V0
9D014AFC  AC440000   SW A0, 0(V0)
128:                             return &timers[i];
129:                         }
130:                     }
131:                     return NULL;
132:                 }
9D014B00  03E00008   JR RA
9D014B04  00000000   NOP
133:                 
134:                 // essaie d'obtenir le plus morceau de mémoire RAM disponible.
135:                 // retourne la grandeur de ce morceau.
136:                 unsigned biggest_chunk(){
9D014B08  27BDFFE0   ADDIU SP, SP, -32
9D014B0C  AFBF001C   SW RA, 28(SP)
9D014B10  AFB20018   SW S2, 24(SP)
9D014B14  AFB10014   SW S1, 20(SP)
9D014B18  AFB00010   SW S0, 16(SP)
137:                     unsigned size, last_failed=RAM_SIZE, last_succeed=0;
9D014B1C  00008821   ADDU S1, ZERO, ZERO
9D014B20  3C120001   LUI S2, 1
138:                     void *ptr=NULL;
139:                 
140:                     size=RAM_SIZE;
9D014B24  3C100001   LUI S0, 1
141:                     while ((last_failed-last_succeed)>8){
9D014B6C  02511023   SUBU V0, S2, S1
9D014B70  2C420009   SLTIU V0, V0, 9
9D014B74  1040FFEC   BEQ V0, ZERO, 0x9D014B28
9D014B78  02201021   ADDU V0, S1, ZERO
142:                         ptr=malloc(size);
9D014B28  0F4064A8   JAL malloc
9D014B2C  02002021   ADDU A0, S0, ZERO
143:                         if (!ptr){
9D014B30  14400007   BNE V0, ZERO, 0x9D014B50
9D014B34  00000000   NOP
144:                             last_failed=size;
145:                             size-=(last_failed-last_succeed)>1;
9D014B38  02111023   SUBU V0, S0, S1
9D014B3C  2C420002   SLTIU V0, V0, 2
9D014B40  38420001   XORI V0, V0, 1
9D014B44  02009021   ADDU S2, S0, ZERO
9D014B48  0B4052DB   J 0x9D014B6C
9D014B4C  02028023   SUBU S0, S0, V0
146:                         }else{
147:                             free(ptr);
9D014B50  0F407BCB   JAL free
9D014B54  00402021   ADDU A0, V0, ZERO
148:                             last_succeed=size;
149:                             size+=(last_failed-last_succeed)>1;
9D014B58  02501023   SUBU V0, S2, S0
9D014B5C  2C420002   SLTIU V0, V0, 2
9D014B60  38420001   XORI V0, V0, 1
9D014B64  02008821   ADDU S1, S0, ZERO
9D014B68  00508021   ADDU S0, V0, S0
150:                         }
151:                     }
152:                     return last_succeed;
153:                 }
9D014B7C  8FBF001C   LW RA, 28(SP)
9D014B80  8FB20018   LW S2, 24(SP)
9D014B84  8FB10014   LW S1, 20(SP)
9D014B88  8FB00010   LW S0, 16(SP)
9D014B8C  03E00008   JR RA
9D014B90  27BD0020   ADDIU SP, SP, 32
154:                 
155:                 
156:                 // retourne le total de la mémoire RAM disponible.
157:                 // en additionnant la taille des morceaux allouables.
158:                 // Si le heap est très fragmenté et contient plus de 32
159:                 // morceaux allouables la valeur retournée sera incorrecte.
160:                 unsigned free_heap(){
9D014B94  27BDFF58   ADDIU SP, SP, -168
9D014B98  AFBF00A4   SW RA, 164(SP)
9D014B9C  AFB300A0   SW S3, 160(SP)
9D014BA0  AFB2009C   SW S2, 156(SP)
9D014BA4  AFB10098   SW S1, 152(SP)
9D014BA8  AFB00094   SW S0, 148(SP)
9D014BAC  27B10010   ADDIU S1, SP, 16
161:                     unsigned count=0,size, total=0;
9D014BB0  00009021   ADDU S2, ZERO, ZERO
9D014BB4  00008021   ADDU S0, ZERO, ZERO
162:                     void* list[32];
163:                     
164:                     do{
165:                         size=biggest_chunk();
9D014BBC  0F4052C2   JAL biggest_chunk
9D014BC0  00000000   NOP
166:                         total+=size;
167:                         if (size) list[count++]=malloc(size);
9D014BC4  10400009   BEQ V0, ZERO, 0x9D014BEC
9D014BC8  02429021   ADDU S2, S2, V0
9D014BCC  26100001   ADDIU S0, S0, 1
9D014BD0  0F4064A8   JAL malloc
9D014BD4  00402021   ADDU A0, V0, ZERO
9D014BD8  AE220000   SW V0, 0(S1)
168:                     }while (size && (count<32));
9D014BB8  24130020   ADDIU S3, ZERO, 32
9D014BDC  1613FFF7   BNE S0, S3, 0x9D014BBC
9D014BE0  26310004   ADDIU S1, S1, 4
9D014BE4  0B4052FD   J 0x9D014BF4
9D014BE8  2611FFFF   ADDIU S1, S0, -1
169:                     while (count){
9D014BEC  12000009   BEQ S0, ZERO, 0x9D014C14
9D014BF0  2611FFFF   ADDIU S1, S0, -1
9D014BF4  00118880   SLL S1, S1, 2
9D014BF8  27A20010   ADDIU V0, SP, 16
9D014BFC  00518821   ADDU S1, V0, S1
9D014C0C  1600FFFC   BNE S0, ZERO, 0x9D014C00
9D014C10  2631FFFC   ADDIU S1, S1, -4
170:                         free(list[--count]);
9D014C00  2610FFFF   ADDIU S0, S0, -1
9D014C04  0F407BCB   JAL free
9D014C08  8E240000   LW A0, 0(S1)
171:                     }
172:                     return total;
173:                 }
9D014C14  02401021   ADDU V0, S2, ZERO
9D014C18  8FBF00A4   LW RA, 164(SP)
9D014C1C  8FB300A0   LW S3, 160(SP)
9D014C20  8FB2009C   LW S2, 156(SP)
9D014C24  8FB10098   LW S1, 152(SP)
9D014C28  8FB00094   LW S0, 148(SP)
9D014C2C  03E00008   JR RA
9D014C30  27BD00A8   ADDIU SP, SP, 168
174:                 
175:                 
176:                 //MCU core timer interrupt
177:                 // period 1msec
178:                 // also control TONE timer
179:                 void __ISR(_CORE_TIMER_VECTOR, IPL2SOFT) CoreTimerHandler(void){
9D014C34  415DE800   RDPGPR SP, SP
9D014C38  401A7000   MFC0 K0, EPC
9D014C3C  401B6000   MFC0 K1, Status
9D014C40  27BDFFD8   ADDIU SP, SP, -40
9D014C44  AFBA0024   SW K0, 36(SP)
9D014C48  401A6002   MFC0 K0, SRSCtl
9D014C4C  AFBB0020   SW K1, 32(SP)
9D014C50  AFBA001C   SW K0, 28(SP)
9D014C54  7C1B7844   INS K1, ZERO, 1, 15
9D014C58  377B0800   ORI K1, K1, 2048
9D014C5C  409B6000   MTC0 K1, Status
9D014C60  AFA60014   SW A2, 20(SP)
9D014C64  AFA50010   SW A1, 16(SP)
9D014C68  AFA4000C   SW A0, 12(SP)
9D014C6C  AFA30008   SW V1, 8(SP)
9D014C70  AFA20004   SW V0, 4(SP)
9D014CD8  0B405347   J 0x9D014D1C
9D014CDC  00001021   ADDU V0, ZERO, ZERO
180:                      sys_ticks++;
9D014C74  8F8280B0   LW V0, -32592(GP)
9D014C78  24420001   ADDIU V0, V0, 1
9D014C7C  AF8280B0   SW V0, -32592(GP)
181:                 //     __asm__("addiu $sp,$sp,-4");
182:                 //     __asm__("sw $v0,0($sp)");
183:                      __asm__("mfc0 $v0, $11");
9D014C80  40025800   MFC0 V0, Compare
184:                      __asm__("addiu $v0,$v0,%0"::"I"(CORE_TICK_RATE));
9D014C84  24424E20   ADDIU V0, V0, 20000
185:                      __asm__("mtc0 $v0, $11");
9D014C88  40825800   MTC0 V0, Compare
186:                 //     __asm__("lw $v0,0($sp)");
187:                 //     __asm__("addiu $sp,$sp,4");
188:                      mCTClearIntFlag();
9D014C8C  24030001   ADDIU V1, ZERO, 1
9D014C90  3C02BF88   LUI V0, -16504
9D014C94  AC431034   SW V1, 4148(V0)
189:                      if ((fSound & TONE_ON) && !(--duration)){
9D014C98  93828038   LBU V0, -32712(GP)
9D014C9C  30420001   ANDI V0, V0, 1
9D014CA0  1040001E   BEQ V0, ZERO, 0x9D014D1C
9D014CA4  00001021   ADDU V0, ZERO, ZERO
9D014CA8  8F8280AC   LW V0, -32596(GP)
9D014CAC  2442FFFF   ADDIU V0, V0, -1
9D014CB0  AF8280AC   SW V0, -32596(GP)
9D014CB4  54400019   BNEL V0, ZERO, 0x9D014D1C
9D014CB8  00001021   ADDU V0, ZERO, ZERO
190:                          fSound&=~TONE_ON;
9D014CBC  93828038   LBU V0, -32712(GP)
9D014CC0  304200FE   ANDI V0, V0, 254
9D014CC4  A3828038   SB V0, -32712(GP)
191:                          mTone_off();
9D014CC8  3C02BF80   LUI V0, -16512
9D014CCC  94433400   LHU V1, 13312(V0)
9D014CD0  7C037BC4   INS V1, ZERO, 15, 1
9D014CD4  A4433400   SH V1, 13312(V0)
192:                      }
193:                      int i;
194:                      for (i=0;i<TMR_COUNT;i++){
9D014D08  24420001   ADDIU V0, V0, 1
9D014D0C  1445FFF5   BNE V0, A1, 0x9D014CE4
9D014D10  00021880   SLL V1, V0, 2
9D014D14  0B40534B   J 0x9D014D2C
9D014D18  00000000   NOP
9D014D24  0B405338   J 0x9D014CE0
9D014D28  24050004   ADDIU A1, ZERO, 4
195:                         if (timers[i]) timers[i]--;
9D014CE0  00021880   SLL V1, V0, 2
9D014CE4  00641821   ADDU V1, V1, A0
9D014CE8  8C630000   LW V1, 0(V1)
9D014CEC  50600007   BEQL V1, ZERO, 0x9D014D0C
9D014CF0  24420001   ADDIU V0, V0, 1
9D014CF4  00021880   SLL V1, V0, 2
9D014CF8  00641821   ADDU V1, V1, A0
9D014CFC  8C660000   LW A2, 0(V1)
9D014D00  24C6FFFF   ADDIU A2, A2, -1
9D014D04  AC660000   SW A2, 0(V1)
9D014D1C  3C04A000   LUI A0, -24576
9D014D20  24844608   ADDIU A0, A0, 17928
196:                      }
197:                 }
9D014D2C  8FA60014   LW A2, 20(SP)
9D014D30  8FA50010   LW A1, 16(SP)
9D014D34  8FA4000C   LW A0, 12(SP)
9D014D38  8FA30008   LW V1, 8(SP)
9D014D3C  8FA20004   LW V0, 4(SP)
9D014D40  41606000   DI ZERO
9D014D44  000000C0   EHB
9D014D48  8FBA0024   LW K0, 36(SP)
9D014D4C  8FBB0020   LW K1, 32(SP)
9D014D50  409A7000   MTC0 K0, EPC
9D014D54  8FBA001C   LW K0, 28(SP)
9D014D58  27BD0028   ADDIU SP, SP, 40
9D014D5C  409A6002   MTC0 K0, SRSCtl
9D014D60  41DDE800   WRPGPR SP, SP
9D014D64  409B6000   MTC0 K1, Status
9D014D68  42000018   ERET
198:                 
199:                 
---  /home/jacques/github/vpc-32vga/graphics.c  ---------------------------------------------------------
1:                   /*
2:                   * Copyright 2013, Jacques Deschênes
3:                   * This file is part of VPC-32.
4:                   *
5:                   *     VPC-32 is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32 is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  /*
19:                   *  File: graphics.c
20:                   *  Author: Jacques Deschênes
21:                   *  Created on 2 novembre 2013
22:                   *  Description: fonctions graphiques.
23:                   *  REF: http://en.wikipedia.org/wiki/Midpoint_circle_algorithm
24:                   *  REF: http://members.chello.at/~easyfilter/bresenham.html
25:                   */
26:                  #include "hardware/tvout/vga.h"
27:                  #include <math.h>
28:                  
29:                  int getPixel(int x, int y){
30:                      int h,ofs;
31:                      h=x/32;
9D0115C4  2486001F   ADDIU A2, A0, 31
9D0115C8  28870000   SLTI A3, A0, 0
9D0115CC  00C7200B   MOVN A0, A2, A3
9D0115D0  00042143   SRA A0, A0, 5
32:                      ofs=31-x%32;
9D0115A4  000417C3   SRA V0, A0, 31
9D0115A8  000216C2   SRL V0, V0, 27
9D0115AC  00821821   ADDU V1, A0, V0
9D0115B0  3063001F   ANDI V1, V1, 31
9D0115B4  00431823   SUBU V1, V0, V1
9D0115B8  2463001F   ADDIU V1, V1, 31
33:                      return (video_bmp[y][h]&(1<<ofs))>>ofs;
9D0115BC  24020001   ADDIU V0, ZERO, 1
9D0115C0  00621004   SLLV V0, V0, V1
9D0115D4  00053100   SLL A2, A1, 4
9D0115D8  00C52823   SUBU A1, A2, A1
9D0115DC  00A42021   ADDU A0, A1, A0
9D0115E0  00042080   SLL A0, A0, 2
9D0115E4  3C05A000   LUI A1, -24576
9D0115E8  24A500C0   ADDIU A1, A1, 192
9D0115EC  00852021   ADDU A0, A0, A1
9D0115F0  8C840000   LW A0, 0(A0)
9D0115F4  00441024   AND V0, V0, A0
34:                  }//getPixel()
9D0115F8  03E00008   JR RA
9D0115FC  00621006   SRLV V0, V0, V1
35:                  
36:                  void setPixel(int x, int y){
37:                      int h,ofs;
38:                      if (y>(VRES-1)) return; // hors limites
9D011600  28A200F0   SLTI V0, A1, 240
9D011604  10400018   BEQ V0, ZERO, 0x9D011668
9D011608  2482001F   ADDIU V0, A0, 31
39:                      h= x/32;
9D01160C  28830000   SLTI V1, A0, 0
9D011610  0083100A   MOVZ V0, A0, V1
9D011614  00021143   SRA V0, V0, 5
40:                      if (h>HRES/32) return; // hors limites
9D011618  28430010   SLTI V1, V0, 16
9D01161C  10600012   BEQ V1, ZERO, 0x9D011668
9D011620  00051900   SLL V1, A1, 4
41:                      ofs = 31 - x%32;
9D01163C  00041FC3   SRA V1, A0, 31
9D011640  00031EC2   SRL V1, V1, 27
9D011644  00832021   ADDU A0, A0, V1
9D011648  3084001F   ANDI A0, A0, 31
9D01164C  00641823   SUBU V1, V1, A0
9D011650  2463001F   ADDIU V1, V1, 31
42:                      video_bmp[y][h]|= (1<<ofs);
9D011624  00652823   SUBU A1, V1, A1
9D011628  00A21021   ADDU V0, A1, V0
9D01162C  00021080   SLL V0, V0, 2
9D011630  3C03A000   LUI V1, -24576
9D011634  246300C0   ADDIU V1, V1, 192
9D011638  00431021   ADDU V0, V0, V1
9D011654  24040001   ADDIU A0, ZERO, 1
9D011658  00641804   SLLV V1, A0, V1
9D01165C  8C440000   LW A0, 0(V0)
9D011660  00641825   OR V1, V1, A0
9D011664  AC430000   SW V1, 0(V0)
9D011668  03E00008   JR RA
9D01166C  00000000   NOP
43:                  } // setPixel()
44:                  
45:                  void clearPixel(int x, int y){
46:                      int h,ofs;
47:                      if (y>(VRES-1)) return; // hors limites
9D011670  28A200F0   SLTI V0, A1, 240
9D011674  10400019   BEQ V0, ZERO, 0x9D0116DC
9D011678  2482001F   ADDIU V0, A0, 31
48:                      h= x/32;
9D01167C  28830000   SLTI V1, A0, 0
9D011680  0083100A   MOVZ V0, A0, V1
9D011684  00021143   SRA V0, V0, 5
49:                      if (h>HRES/32) return; // hors limites
9D011688  28430010   SLTI V1, V0, 16
9D01168C  10600013   BEQ V1, ZERO, 0x9D0116DC
9D011690  00051900   SLL V1, A1, 4
50:                      ofs = 31 - x%32;
9D0116AC  00041FC3   SRA V1, A0, 31
9D0116B0  00031EC2   SRL V1, V1, 27
9D0116B4  00832021   ADDU A0, A0, V1
9D0116B8  3084001F   ANDI A0, A0, 31
9D0116BC  00641823   SUBU V1, V1, A0
9D0116C0  2463001F   ADDIU V1, V1, 31
51:                      video_bmp[y][h]&= ~(1<<ofs);
9D011694  00652823   SUBU A1, V1, A1
9D011698  00A21021   ADDU V0, A1, V0
9D01169C  00021080   SLL V0, V0, 2
9D0116A0  3C03A000   LUI V1, -24576
9D0116A4  246300C0   ADDIU V1, V1, 192
9D0116A8  00431021   ADDU V0, V0, V1
9D0116C4  24040001   ADDIU A0, ZERO, 1
9D0116C8  00641804   SLLV V1, A0, V1
9D0116CC  00031827   NOR V1, ZERO, V1
9D0116D0  8C440000   LW A0, 0(V0)
9D0116D4  00641824   AND V1, V1, A0
9D0116D8  AC430000   SW V1, 0(V0)
9D0116DC  03E00008   JR RA
9D0116E0  00000000   NOP
52:                  }//clearPixel()
53:                  
54:                  //  REF: http://members.chello.at/~easyfilter/bresenham.html
55:                  void line(int x0, int y0, int x1, int y1)
56:                  {
9D0116E4  27BDFFC8   ADDIU SP, SP, -56
9D0116E8  AFBF0034   SW RA, 52(SP)
9D0116EC  AFBE0030   SW S8, 48(SP)
9D0116F0  AFB7002C   SW S7, 44(SP)
9D0116F4  AFB60028   SW S6, 40(SP)
9D0116F8  AFB50024   SW S5, 36(SP)
9D0116FC  AFB40020   SW S4, 32(SP)
9D011700  AFB3001C   SW S3, 28(SP)
9D011704  AFB20018   SW S2, 24(SP)
9D011708  AFB10014   SW S1, 20(SP)
9D01170C  AFB00010   SW S0, 16(SP)
9D011710  00808021   ADDU S0, A0, ZERO
9D011714  00A09021   ADDU S2, A1, ZERO
9D011718  00C0A021   ADDU S4, A2, ZERO
9D01171C  AFA70044   SW A3, 68(SP)
57:                     int dx =  abs(x1-x0), sx = x0<x1 ? 1 : -1;
9D011720  00C49823   SUBU S3, A2, A0
9D011724  001317C3   SRA V0, S3, 31
9D011728  00539826   XOR S3, V0, S3
9D01172C  02629823   SUBU S3, S3, V0
9D011730  0086F02A   SLT S8, A0, A2
9D011734  24020001   ADDIU V0, ZERO, 1
9D011738  2403FFFF   ADDIU V1, ZERO, -1
9D01173C  007E100A   MOVZ V0, V1, S8
9D011740  0040F021   ADDU S8, V0, ZERO
58:                     int dy = -abs(y1-y0), sy = y0<y1 ? 1 : -1;
9D011744  00E5B023   SUBU S6, A3, A1
9D011748  001617C3   SRA V0, S6, 31
9D01174C  0056B026   XOR S6, V0, S6
9D011750  02C2B023   SUBU S6, S6, V0
9D011754  0016A823   SUBU S5, ZERO, S6
9D011758  00A7B82A   SLT S7, A1, A3
9D01175C  24020001   ADDIU V0, ZERO, 1
9D011760  0077100A   MOVZ V0, V1, S7
9D011764  0040B821   ADDU S7, V0, ZERO
59:                     int err = dx+dy, e2; /* error value e_xy */
9D011768  02768823   SUBU S1, S3, S6
60:                  
61:                     for(;;){  /* loop */
62:                        setPixel(x0,y0);
9D01176C  02002021   ADDU A0, S0, ZERO
9D011770  0F404580   JAL setPixel
9D011774  02402821   ADDU A1, S2, ZERO
63:                        if (x0==x1 && y0==y1) break;
9D011778  16140004   BNE S0, S4, 0x9D01178C
9D01177C  00111040   SLL V0, S1, 1
9D011780  8FA20044   LW V0, 68(SP)
9D011784  1242000B   BEQ S2, V0, 0x9D0117B4
9D011788  00111040   SLL V0, S1, 1
64:                        e2 = 2*err;
65:                        if (e2 >= dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
9D01178C  0055182A   SLT V1, V0, S5
9D011790  14600003   BNE V1, ZERO, 0x9D0117A0
9D011794  0262102A   SLT V0, S3, V0
9D011798  02368823   SUBU S1, S1, S6
9D01179C  021E8021   ADDU S0, S0, S8
66:                        if (e2 <= dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
9D0117A0  1440FFF3   BNE V0, ZERO, 0x9D011770
9D0117A4  02002021   ADDU A0, S0, ZERO
9D0117A8  02338821   ADDU S1, S1, S3
9D0117AC  0B4045DC   J 0x9D011770
9D0117B0  02579021   ADDU S2, S2, S7
67:                     }
68:                  }//line()
9D0117B4  8FBF0034   LW RA, 52(SP)
9D0117B8  8FBE0030   LW S8, 48(SP)
9D0117BC  8FB7002C   LW S7, 44(SP)
9D0117C0  8FB60028   LW S6, 40(SP)
9D0117C4  8FB50024   LW S5, 36(SP)
9D0117C8  8FB40020   LW S4, 32(SP)
9D0117CC  8FB3001C   LW S3, 28(SP)
9D0117D0  8FB20018   LW S2, 24(SP)
9D0117D4  8FB10014   LW S1, 20(SP)
9D0117D8  8FB00010   LW S0, 16(SP)
9D0117DC  03E00008   JR RA
9D0117E0  27BD0038   ADDIU SP, SP, 56
69:                  
70:                  void rectangle(int x1, int y1, int x2, int y2){
9D0117E4  27BDFFD8   ADDIU SP, SP, -40
9D0117E8  AFBF0024   SW RA, 36(SP)
9D0117EC  AFB30020   SW S3, 32(SP)
9D0117F0  AFB2001C   SW S2, 28(SP)
9D0117F4  AFB10018   SW S1, 24(SP)
9D0117F8  AFB00014   SW S0, 20(SP)
9D0117FC  00809021   ADDU S2, A0, ZERO
9D011800  00A09821   ADDU S3, A1, ZERO
9D011804  00C08021   ADDU S0, A2, ZERO
9D011808  00E08821   ADDU S1, A3, ZERO
71:                      line(x1,y1,x1,y2);
9D01180C  0F4045B9   JAL line
9D011810  00803021   ADDU A2, A0, ZERO
72:                      line(x2,y1,x2,y2);
9D011814  02002021   ADDU A0, S0, ZERO
9D011818  02602821   ADDU A1, S3, ZERO
9D01181C  02003021   ADDU A2, S0, ZERO
9D011820  0F4045B9   JAL line
9D011824  02203821   ADDU A3, S1, ZERO
73:                      line(x1,y1,x2,y1);
9D011828  02402021   ADDU A0, S2, ZERO
9D01182C  02602821   ADDU A1, S3, ZERO
9D011830  02003021   ADDU A2, S0, ZERO
9D011834  0F4045B9   JAL line
9D011838  02603821   ADDU A3, S3, ZERO
74:                      line(x1,y2,x2,y2);
9D01183C  02402021   ADDU A0, S2, ZERO
9D011840  02202821   ADDU A1, S1, ZERO
9D011844  02003021   ADDU A2, S0, ZERO
9D011848  0F4045B9   JAL line
9D01184C  02203821   ADDU A3, S1, ZERO
75:                  }//rectangle()
9D011850  8FBF0024   LW RA, 36(SP)
9D011854  8FB30020   LW S3, 32(SP)
9D011858  8FB2001C   LW S2, 28(SP)
9D01185C  8FB10018   LW S1, 24(SP)
9D011860  8FB00014   LW S0, 20(SP)
9D011864  03E00008   JR RA
9D011868  27BD0028   ADDIU SP, SP, 40
76:                  
77:                  //  REF: http://members.chello.at/~easyfilter/bresenham.html
78:                  void circle(int xc, int yc, int r)
79:                  {
9D01186C  27BDFFD8   ADDIU SP, SP, -40
9D011870  AFBF0024   SW RA, 36(SP)
9D011874  AFB40020   SW S4, 32(SP)
9D011878  AFB3001C   SW S3, 28(SP)
9D01187C  AFB20018   SW S2, 24(SP)
9D011880  AFB10014   SW S1, 20(SP)
9D011884  AFB00010   SW S0, 16(SP)
9D011888  0080A021   ADDU S4, A0, ZERO
9D01188C  00A09821   ADDU S3, A1, ZERO
80:                     int x = -r, y = 0, err = 2-2*r; /* II. Quadrant */
9D011890  00068023   SUBU S0, ZERO, A2
9D011894  00109040   SLL S2, S0, 1
9D011898  26520002   ADDIU S2, S2, 2
9D01189C  00008821   ADDU S1, ZERO, ZERO
81:                     do {
82:                        setPixel(xc-x, yc+y); /*   I. Quadrant */
9D0118A0  02902023   SUBU A0, S4, S0
9D0118A4  0F404580   JAL setPixel
9D0118A8  02712821   ADDU A1, S3, S1
83:                        setPixel(xc-y, yc-x); /*  II. Quadrant */
9D0118AC  02912023   SUBU A0, S4, S1
9D0118B0  0F404580   JAL setPixel
9D0118B4  02702823   SUBU A1, S3, S0
84:                        setPixel(xc+x, yc-y); /* III. Quadrant */
9D0118B8  02902021   ADDU A0, S4, S0
9D0118BC  0F404580   JAL setPixel
9D0118C0  02712823   SUBU A1, S3, S1
85:                        setPixel(xc+y, yc+x); /*  IV. Quadrant */
9D0118C4  02912021   ADDU A0, S4, S1
9D0118C8  0F404580   JAL setPixel
9D0118CC  02702821   ADDU A1, S3, S0
86:                        r = err;
87:                        if (r <= y) err += ++y*2+1;           /* e_xy+e_y < 0 */
9D0118D0  0232102A   SLT V0, S1, S2
9D0118D4  5440000E   BNEL V0, ZERO, 0x9D011910
9D0118D8  26100001   ADDIU S0, S0, 1
9D0118DC  26310001   ADDIU S1, S1, 1
9D0118E0  00111040   SLL V0, S1, 1
9D0118E4  24420001   ADDIU V0, V0, 1
9D0118E8  00521021   ADDU V0, V0, S2
88:                        if (r > x || err > y) err += ++x*2+1; /* e_xy+e_x > 0 or no 2nd y-step */
9D0118EC  0212902A   SLT S2, S0, S2
9D0118F0  16400006   BNE S2, ZERO, 0x9D01190C
9D0118F4  00409021   ADDU S2, V0, ZERO
9D0118F8  0222182A   SLT V1, S1, V0
9D0118FC  10600007   BEQ V1, ZERO, 0x9D01191C
9D011900  00000000   NOP
9D011904  0B404644   J 0x9D011910
9D011908  26100001   ADDIU S0, S0, 1
9D01190C  26100001   ADDIU S0, S0, 1
9D011910  00101040   SLL V0, S0, 1
9D011914  24420001   ADDIU V0, V0, 1
9D011918  02429021   ADDU S2, S2, V0
89:                     } while (x < 0);
9D01191C  0600FFE1   BLTZ S0, 0x9D0118A4
9D011920  02902023   SUBU A0, S4, S0
90:                  }//circle()
9D011924  8FBF0024   LW RA, 36(SP)
9D011928  8FB40020   LW S4, 32(SP)
9D01192C  8FB3001C   LW S3, 28(SP)
9D011930  8FB20018   LW S2, 24(SP)
9D011934  8FB10014   LW S1, 20(SP)
9D011938  8FB00010   LW S0, 16(SP)
9D01193C  03E00008   JR RA
9D011940  27BD0028   ADDIU SP, SP, 40
91:                  
92:                  /* REF: http://members.chello.at/~easyfilter/bresenham.html
93:                   * dessine une ellipse circoncrite par un rectangle
94:                   */
95:                  void ellipse (int x0, int y0, int x1, int y1){
9D011944  27BDFFC0   ADDIU SP, SP, -64
9D011948  AFBF003C   SW RA, 60(SP)
9D01194C  AFBE0038   SW S8, 56(SP)
9D011950  AFB70034   SW S7, 52(SP)
9D011954  AFB60030   SW S6, 48(SP)
9D011958  AFB5002C   SW S5, 44(SP)
9D01195C  AFB40028   SW S4, 40(SP)
9D011960  AFB30024   SW S3, 36(SP)
9D011964  AFB20020   SW S2, 32(SP)
9D011968  AFB1001C   SW S1, 28(SP)
9D01196C  AFB00018   SW S0, 24(SP)
9D011970  00809821   ADDU S3, A0, ZERO
96:                     int a = abs(x1-x0), b = abs(y1-y0), b1 = b&1; /* values of diameter */
9D011974  00C41023   SUBU V0, A2, A0
9D011978  00021FC3   SRA V1, V0, 31
9D01197C  00621026   XOR V0, V1, V0
9D011980  00431023   SUBU V0, V0, V1
9D011984  00E5B823   SUBU S7, A3, A1
9D011988  00171FC3   SRA V1, S7, 31
9D01198C  0077B826   XOR S7, V1, S7
9D011990  02E3B823   SUBU S7, S7, V1
9D011994  32F10001   ANDI S1, S7, 1
97:                     long dx = 4*(1-a)*b*b, dy = 4*(b1+1)*a*a; /* error increment */
9D011998  24150001   ADDIU S5, ZERO, 1
9D01199C  02A2A823   SUBU S5, S5, V0
9D0119A0  0015A880   SLL S5, S5, 2
9D0119A4  72B7A802   MUL S5, S5, S7
9D0119A8  72B7A802   MUL S5, S5, S7
9D0119AC  26360001   ADDIU S6, S1, 1
9D0119B0  0016B080   SLL S6, S6, 2
9D0119B4  72C2B002   MUL S6, S6, V0
9D0119B8  72C2B002   MUL S6, S6, V0
98:                     long err = dx+dy+b1*a*a, e2; /* error of 1.step */
9D0119BC  02B61821   ADDU V1, S5, S6
9D0119C0  7222A002   MUL S4, S1, V0
9D0119C4  72822002   MUL A0, S4, V0
9D0119C8  0083A021   ADDU S4, A0, V1
99:                  
100:                    if (x0 > x1) { x0 = x1; x1 += a; } /* if called with swapped points */
9D0119CC  00D3182A   SLT V1, A2, S3
9D0119D0  10600003   BEQ V1, ZERO, 0x9D0119E0
9D0119D4  00C09021   ADDU S2, A2, ZERO
9D0119D8  00C09821   ADDU S3, A2, ZERO
9D0119DC  00C29021   ADDU S2, A2, V0
9D0119E0  00A7802A   SLT S0, A1, A3
9D0119E4  00F0280A   MOVZ A1, A3, S0
101:                    if (y0 > y1) y0 = y1; /* .. exchange them */
102:                    y0 += (b+1)/2; y1 = y0-b1;   /* starting pixel */
9D0119E8  26E30001   ADDIU V1, S7, 1
9D0119EC  000387C2   SRL S0, V1, 31
9D0119F0  02038021   ADDU S0, S0, V1
9D0119F4  00108043   SRA S0, S0, 1
9D0119F8  02058021   ADDU S0, S0, A1
9D0119FC  02118823   SUBU S1, S0, S1
103:                    a *= 8*a; b1 = 8*b*b;
9D011A00  70421002   MUL V0, V0, V0
9D011A04  000210C0   SLL V0, V0, 3
9D011A08  AFA20010   SW V0, 16(SP)
9D011A0C  72F7F002   MUL S8, S7, S7
9D011A10  001EF0C0   SLL S8, S8, 3
104:                 
105:                    do {
106:                        setPixel(x1, y0); /*   I. Quadrant */
9D011A14  02402021   ADDU A0, S2, ZERO
9D011A18  0F404580   JAL setPixel
9D011A1C  02002821   ADDU A1, S0, ZERO
107:                        setPixel(x0, y0); /*  II. Quadrant */
9D011A20  02602021   ADDU A0, S3, ZERO
9D011A24  0F404580   JAL setPixel
9D011A28  02002821   ADDU A1, S0, ZERO
108:                        setPixel(x0, y1); /* III. Quadrant */
9D011A2C  02602021   ADDU A0, S3, ZERO
9D011A30  0F404580   JAL setPixel
9D011A34  02202821   ADDU A1, S1, ZERO
109:                        setPixel(x1, y1); /*  IV. Quadrant */
9D011A38  02402021   ADDU A0, S2, ZERO
9D011A3C  0F404580   JAL setPixel
9D011A40  02202821   ADDU A1, S1, ZERO
110:                        e2 = 2*err;
9D011A44  00141040   SLL V0, S4, 1
111:                        if (e2 <= dy) { y0++; y1--; err += dy += a; }  /* y step */
9D011A48  02C2182A   SLT V1, S6, V0
9D011A4C  14600006   BNE V1, ZERO, 0x9D011A68
9D011A50  0055102A   SLT V0, V0, S5
9D011A54  26100001   ADDIU S0, S0, 1
9D011A58  2631FFFF   ADDIU S1, S1, -1
9D011A5C  8FA30010   LW V1, 16(SP)
9D011A60  02C3B021   ADDU S6, S6, V1
9D011A64  0296A021   ADDU S4, S4, S6
112:                        if (e2 >= dx || 2*err > dy) { x0++; x1--; err += dx += b1; } /* x step */
9D011A68  50400006   BEQL V0, ZERO, 0x9D011A84
9D011A6C  26730001   ADDIU S3, S3, 1
9D011A70  00141040   SLL V0, S4, 1
9D011A74  02C2102A   SLT V0, S6, V0
9D011A78  10400006   BEQ V0, ZERO, 0x9D011A94
9D011A7C  0253102A   SLT V0, S2, S3
9D011A80  26730001   ADDIU S3, S3, 1
9D011A84  2652FFFF   ADDIU S2, S2, -1
9D011A88  02BEA821   ADDU S5, S5, S8
9D011A8C  0295A021   ADDU S4, S4, S5
113:                    } while (x0 <= x1);
9D011A90  0253102A   SLT V0, S2, S3
9D011A94  1040FFE0   BEQ V0, ZERO, 0x9D011A18
9D011A98  02402021   ADDU A0, S2, ZERO
114:                 
115:                    while (y0-y1 < b) {  /* too early stop of flat ellipses a=1 */
9D011A9C  0211A023   SUBU S4, S0, S1
9D011AA0  0297102A   SLT V0, S4, S7
9D011AA4  10400016   BEQ V0, ZERO, 0x9D011B00
9D011AA8  2673FFFF   ADDIU S3, S3, -1
9D011AEC  0297102A   SLT V0, S4, S7
9D011AF0  10400003   BEQ V0, ZERO, 0x9D011B00
9D011AF4  02008821   ADDU S1, S0, ZERO
116:                        setPixel(x0-1, y0); /* -> finish tip of ellipse */
9D011AB0  02602021   ADDU A0, S3, ZERO
9D011AB4  0F404580   JAL setPixel
9D011AB8  02002821   ADDU A1, S0, ZERO
117:                        setPixel(x1+1, y0++);
9D011AAC  26520001   ADDIU S2, S2, 1
9D011ABC  26150001   ADDIU S5, S0, 1
9D011AC0  02402021   ADDU A0, S2, ZERO
9D011AC4  0F404580   JAL setPixel
9D011AC8  02002821   ADDU A1, S0, ZERO
9D011AF8  0B4046AC   J 0x9D011AB0
9D011AFC  02A08021   ADDU S0, S5, ZERO
118:                        setPixel(x0-1, y1);
9D011ACC  02602021   ADDU A0, S3, ZERO
9D011AD0  0F404580   JAL setPixel
9D011AD4  02202821   ADDU A1, S1, ZERO
119:                        setPixel(x1+1, y1--);
9D011AD8  2630FFFF   ADDIU S0, S1, -1
9D011ADC  02402021   ADDU A0, S2, ZERO
9D011AE0  0F404580   JAL setPixel
9D011AE4  02202821   ADDU A1, S1, ZERO
9D011AE8  26940002   ADDIU S4, S4, 2
120:                    }
121:                 }//ellipse()
9D011B00  8FBF003C   LW RA, 60(SP)
9D011B04  8FBE0038   LW S8, 56(SP)
9D011B08  8FB70034   LW S7, 52(SP)
9D011B0C  8FB60030   LW S6, 48(SP)
9D011B10  8FB5002C   LW S5, 44(SP)
9D011B14  8FB40028   LW S4, 40(SP)
9D011B18  8FB30024   LW S3, 36(SP)
9D011B1C  8FB20020   LW S2, 32(SP)
9D011B20  8FB1001C   LW S1, 28(SP)
9D011B24  8FB00018   LW S0, 24(SP)
9D011B28  03E00008   JR RA
9D011B2C  27BD0040   ADDIU SP, SP, 64
122:                 
123:                 /*
124:                  * points[]={x1,y1,x2,y2,x3,y3,...}
125:                  * vertices est le nombre de points
126:                  */
127:                 void polygon(const int points[], int vertices){
9D011B30  27BDFFD8   ADDIU SP, SP, -40
9D011B34  AFBF0024   SW RA, 36(SP)
9D011B38  AFB30020   SW S3, 32(SP)
9D011B3C  AFB2001C   SW S2, 28(SP)
9D011B40  AFB10018   SW S1, 24(SP)
9D011B44  AFB00014   SW S0, 20(SP)
128:                     int i;
129:                     for(i=0;i<(2*vertices-2);i+=2){
9D011B48  24A5FFFF   ADDIU A1, A1, -1
9D011B4C  00059040   SLL S2, A1, 1
9D011B50  1A40000E   BLEZ S2, 0x9D011B8C
9D011B54  00809821   ADDU S3, A0, ZERO
9D011B58  00808021   ADDU S0, A0, ZERO
9D011B5C  00008821   ADDU S1, ZERO, ZERO
9D011B74  26310002   ADDIU S1, S1, 2
9D011B78  0232102A   SLT V0, S1, S2
9D011B7C  1440FFF8   BNE V0, ZERO, 0x9D011B60
9D011B80  26100008   ADDIU S0, S0, 8
9D011B84  0B4046E5   J 0x9D011B94
9D011B88  00118880   SLL S1, S1, 2
9D011B8C  00008821   ADDU S1, ZERO, ZERO
130:                         line(points[i],points[i+1],points[i+2],points[i+3]);
9D011B60  8E040000   LW A0, 0(S0)
9D011B64  8E050004   LW A1, 4(S0)
9D011B68  8E060008   LW A2, 8(S0)
9D011B6C  0F4045B9   JAL line
9D011B70  8E07000C   LW A3, 12(S0)
131:                     }
132:                     line(points[0],points[1],points[i],points[i+1]);
9D011B90  00118880   SLL S1, S1, 2
9D011B94  02718821   ADDU S1, S3, S1
9D011B98  8E640000   LW A0, 0(S3)
9D011B9C  8E650004   LW A1, 4(S3)
9D011BA0  8E260000   LW A2, 0(S1)
9D011BA4  0F4045B9   JAL line
9D011BA8  8E270004   LW A3, 4(S1)
133:                 }//polygon()
9D011BAC  8FBF0024   LW RA, 36(SP)
9D011BB0  8FB30020   LW S3, 32(SP)
9D011BB4  8FB2001C   LW S2, 28(SP)
9D011BB8  8FB10018   LW S1, 24(SP)
9D011BBC  8FB00014   LW S0, 20(SP)
9D011BC0  03E00008   JR RA
9D011BC4  27BD0028   ADDIU SP, SP, 40
134:                 
135:                 //  REF: http://members.chello.at/~easyfilter/bresenham.html
136:                 void bezier(int x0, int y0, int x1, int y1, int x2, int y2){
9D011BC8  27BDFFB0   ADDIU SP, SP, -80
9D011BCC  AFBF004C   SW RA, 76(SP)
9D011BD0  AFBE0048   SW S8, 72(SP)
9D011BD4  AFB70044   SW S7, 68(SP)
9D011BD8  AFB60040   SW S6, 64(SP)
9D011BDC  AFB5003C   SW S5, 60(SP)
9D011BE0  AFB40038   SW S4, 56(SP)
9D011BE4  AFB30034   SW S3, 52(SP)
9D011BE8  AFB20030   SW S2, 48(SP)
9D011BEC  AFB1002C   SW S1, 44(SP)
9D011BF0  AFB00028   SW S0, 40(SP)
9D011BF4  00809821   ADDU S3, A0, ZERO
9D011BF8  00A0B021   ADDU S6, A1, ZERO
9D011BFC  AFA60058   SW A2, 88(SP)
9D011C00  AFA7005C   SW A3, 92(SP)
9D011C04  8FB70060   LW S7, 96(SP)
137:                   int sx = x2-x1, sy = y2-y1;
9D011C08  02E6A023   SUBU S4, S7, A2
9D011C0C  8FA20064   LW V0, 100(SP)
9D011C10  00478823   SUBU S1, V0, A3
138:                   long xx = x0-x1, yy = y0-y1, xy;         /* relative values for checks */
9D011C14  0086A823   SUBU S5, A0, A2
9D011C18  00A79023   SUBU S2, A1, A3
139:                   double dx, dy, err, cur = xx*sy-yy*sx;                    /* curvature */
9D011C1C  72B12002   MUL A0, S5, S1
9D011C20  72541002   MUL V0, S2, S4
9D011C24  0F4079D9   JAL sitofp
9D011C28  00822023   SUBU A0, A0, V0
9D011C2C  00408021   ADDU S0, V0, ZERO
140:                 
141:                   //if(xx*sx <= 0 && yy*sy <= 0) return;  /* sign of gradient must not change */
142:                 
143:                   if (sx*(long)sx+sy*(long)sy > xx*xx+yy*yy) { /* begin with longer part */
9D011C30  02310018   MULT 0, S1, S1
9D011C34  72940000   MADD 0, S4, S4
9D011C38  00001812   MFLO V1
9D011C3C  02520018   MULT 0, S2, S2
9D011C40  72B50000   MADD 0, S5, S5
9D011C44  00001012   MFLO V0
9D011C48  0043102A   SLT V0, V0, V1
9D011C4C  1040000A   BEQ V0, ZERO, 0x9D011C78
9D011C50  02002021   ADDU A0, S0, ZERO
144:                     x2 = x0; x0 = sx+x1; y2 = y0; y0 = sy+y1; cur = -cur;  /* swap P0 P2 */
9D011C54  3C028000   LUI V0, -32768
9D011C58  00508026   XOR S0, V0, S0
9D011C5C  02C01021   ADDU V0, S6, ZERO
9D011C60  8FB60064   LW S6, 100(SP)
9D011C64  AFA20064   SW V0, 100(SP)
9D011C68  02601021   ADDU V0, S3, ZERO
9D011C6C  02E09821   ADDU S3, S7, ZERO
9D011C70  0040B821   ADDU S7, V0, ZERO
145:                   }
146:                   if (cur != 0) {                                    /* no straight line */
9D011C74  02002021   ADDU A0, S0, ZERO
9D011C78  0F407800   JAL __lesf2
9D011C7C  00002821   ADDU A1, ZERO, ZERO
9D011C80  1040009F   BEQ V0, ZERO, 0x9D011F00
9D011C84  02B4A821   ADDU S5, S5, S4
147:                     xx += sx; xx *= sx = x0 < x2 ? 1 : -1;           /* x step direction */
9D011C88  0277202A   SLT A0, S3, S7
9D011C8C  24020001   ADDIU V0, ZERO, 1
9D011C90  2403FFFF   ADDIU V1, ZERO, -1
9D011C94  0064100A   MOVZ V0, V1, A0
9D011C98  AFA20018   SW V0, 24(SP)
9D011C9C  7055A802   MUL S5, V0, S5
148:                     yy += sy; yy *= sy = y0 < y2 ? 1 : -1;           /* y step direction */
9D011CA0  02518821   ADDU S1, S2, S1
9D011CA4  8FA20064   LW V0, 100(SP)
9D011CA8  02C2202A   SLT A0, S6, V0
9D011CAC  24020001   ADDIU V0, ZERO, 1
9D011CB0  0064100A   MOVZ V0, V1, A0
9D011CB4  AFA2001C   SW V0, 28(SP)
9D011CB8  70518802   MUL S1, V0, S1
149:                     xy = 2*xx*yy; xx *= xx; yy *= yy;          /* differences 2nd degree */
9D011CBC  0015F040   SLL S8, S5, 1
9D011CC0  73D1F002   MUL S8, S8, S1
9D011CC4  72B5A802   MUL S5, S5, S5
9D011CC8  72318802   MUL S1, S1, S1
150:                     if (cur*sx*sy < 0) {                           /* negated curvature? */
9D011CCC  0F4079D9   JAL sitofp
9D011CD0  8FA40018   LW A0, 24(SP)
9D011CD4  AFA20020   SW V0, 32(SP)
9D011CD8  0F4079D9   JAL sitofp
9D011CDC  8FA4001C   LW A0, 28(SP)
9D011CE0  00409021   ADDU S2, V0, ZERO
9D011CE4  8FA40020   LW A0, 32(SP)
9D011CE8  0F406B24   JAL __mulsf3
9D011CEC  02002821   ADDU A1, S0, ZERO
9D011CF0  00402021   ADDU A0, V0, ZERO
9D011CF4  0F406B24   JAL __mulsf3
9D011CF8  02402821   ADDU A1, S2, ZERO
9D011CFC  00402021   ADDU A0, V0, ZERO
9D011D00  0F407800   JAL __lesf2
9D011D04  00002821   ADDU A1, ZERO, ZERO
9D011D08  04410005   BGEZ V0, 0x9D011D20
9D011D0C  3C028000   LUI V0, -32768
151:                       xx = -xx; yy = -yy; xy = -xy; cur = -cur;
9D011D10  0015A823   SUBU S5, ZERO, S5
9D011D14  00118823   SUBU S1, ZERO, S1
9D011D18  001EF023   SUBU S8, ZERO, S8
9D011D1C  00508026   XOR S0, V0, S0
152:                     }
153:                     dx = 4.0*sy*cur*(x1-x0)+xx-xy;             /* differences 1st degree */
9D011D20  0F4079D9   JAL sitofp
9D011D24  03C02021   ADDU A0, S8, ZERO
9D011D28  0040F021   ADDU S8, V0, ZERO
9D011D2C  02402021   ADDU A0, S2, ZERO
9D011D30  3C029D02   LUI V0, -25342
9D011D34  0F406B24   JAL __mulsf3
9D011D38  8C45F41C   LW A1, -3044(V0)
9D011D3C  00402021   ADDU A0, V0, ZERO
9D011D40  0F406B24   JAL __mulsf3
9D011D44  02002821   ADDU A1, S0, ZERO
9D011D48  00409021   ADDU S2, V0, ZERO
9D011D4C  8FA30058   LW V1, 88(SP)
9D011D50  0F4079D9   JAL sitofp
9D011D54  00732023   SUBU A0, V1, S3
9D011D58  02402021   ADDU A0, S2, ZERO
9D011D5C  0F406B24   JAL __mulsf3
9D011D60  00402821   ADDU A1, V0, ZERO
9D011D64  00409021   ADDU S2, V0, ZERO
9D011D68  0F4079D9   JAL sitofp
9D011D6C  02A02021   ADDU A0, S5, ZERO
9D011D70  02402021   ADDU A0, S2, ZERO
9D011D74  0F40654D   JAL fpadd
9D011D78  00402821   ADDU A1, V0, ZERO
9D011D7C  00402021   ADDU A0, V0, ZERO
9D011D80  0F40654B   JAL __subsf3
9D011D84  03C02821   ADDU A1, S8, ZERO
9D011D88  0040A021   ADDU S4, V0, ZERO
154:                     dy = 4.0*sx*cur*(y0-y1)+yy-xy;
9D011D8C  8FA40020   LW A0, 32(SP)
9D011D90  3C029D02   LUI V0, -25342
9D011D94  0F406B24   JAL __mulsf3
9D011D98  8C45F41C   LW A1, -3044(V0)
9D011D9C  00402021   ADDU A0, V0, ZERO
9D011DA0  0F406B24   JAL __mulsf3
9D011DA4  02002821   ADDU A1, S0, ZERO
9D011DA8  00408021   ADDU S0, V0, ZERO
9D011DAC  8FA3005C   LW V1, 92(SP)
9D011DB0  0F4079D9   JAL sitofp
9D011DB4  02C32023   SUBU A0, S6, V1
9D011DB8  02002021   ADDU A0, S0, ZERO
9D011DBC  0F406B24   JAL __mulsf3
9D011DC0  00402821   ADDU A1, V0, ZERO
9D011DC4  00408021   ADDU S0, V0, ZERO
9D011DC8  0F4079D9   JAL sitofp
9D011DCC  02202021   ADDU A0, S1, ZERO
9D011DD0  02002021   ADDU A0, S0, ZERO
9D011DD4  0F40654D   JAL fpadd
9D011DD8  00402821   ADDU A1, V0, ZERO
9D011DDC  00402021   ADDU A0, V0, ZERO
9D011DE0  0F40654B   JAL __subsf3
9D011DE4  03C02821   ADDU A1, S8, ZERO
9D011DE8  00408021   ADDU S0, V0, ZERO
155:                     xx += xx; yy += yy; err = dx+dy+xy;                /* error 1st step */
9D011DEC  0015A840   SLL S5, S5, 1
9D011DF0  AFB50010   SW S5, 16(SP)
9D011DF4  00118840   SLL S1, S1, 1
9D011DF8  AFB10014   SW S1, 20(SP)
9D011DFC  02802021   ADDU A0, S4, ZERO
9D011E00  0F40654D   JAL fpadd
9D011E04  00402821   ADDU A1, V0, ZERO
9D011E08  03C02021   ADDU A0, S8, ZERO
9D011E0C  0F40654D   JAL fpadd
9D011E10  00402821   ADDU A1, V0, ZERO
9D011E14  00409021   ADDU S2, V0, ZERO
156:                     do {
157:                       setPixel(x0,y0);                                     /* setPixel curve */
9D011E18  02602021   ADDU A0, S3, ZERO
9D011E1C  0F404580   JAL setPixel
9D011E20  02C02821   ADDU A1, S6, ZERO
158:                       if (x0 == x2 && y0 == y2) return;  /* last pixel -> curve finished */
9D011E24  16770004   BNE S3, S7, 0x9D011E38
9D011E28  02402021   ADDU A0, S2, ZERO
9D011E2C  8FA40064   LW A0, 100(SP)
9D011E30  12C40038   BEQ S6, A0, 0x9D011F14
9D011E34  02402021   ADDU A0, S2, ZERO
159:                       y1 = 2*err < dx;                  /* save value for test of y step */
9D011E38  0F40654D   JAL fpadd
9D011E3C  02402821   ADDU A1, S2, ZERO
9D011E40  0040A821   ADDU S5, V0, ZERO
160:                       if (2*err > dy) { x0 += sx; dx -= xy; err += dy += yy; } /* x step */
9D011E44  02002021   ADDU A0, S0, ZERO
9D011E48  0F407800   JAL __lesf2
9D011E4C  00402821   ADDU A1, V0, ZERO
9D011E50  04410012   BGEZ V0, 0x9D011E9C
9D011E54  02808821   ADDU S1, S4, ZERO
9D011E58  8FA20018   LW V0, 24(SP)
9D011E5C  02629821   ADDU S3, S3, V0
9D011E60  02802021   ADDU A0, S4, ZERO
9D011E64  0F40654B   JAL __subsf3
9D011E68  03C02821   ADDU A1, S8, ZERO
9D011E6C  00408821   ADDU S1, V0, ZERO
9D011E70  0F4079D9   JAL sitofp
9D011E74  8FA40014   LW A0, 20(SP)
9D011E78  02002021   ADDU A0, S0, ZERO
9D011E7C  0F40654D   JAL fpadd
9D011E80  00402821   ADDU A1, V0, ZERO
9D011E84  00408021   ADDU S0, V0, ZERO
9D011E88  02402021   ADDU A0, S2, ZERO
9D011E8C  0F40654D   JAL fpadd
9D011E90  00402821   ADDU A1, V0, ZERO
9D011E94  0B4047A7   J 0x9D011E9C
9D011E98  00409021   ADDU S2, V0, ZERO
161:                       if (    y1    ) { y0 += sy; dy -= xy; err += dx += xx; } /* y step */
9D011E9C  02A02021   ADDU A0, S5, ZERO
9D011EA0  0F407800   JAL __lesf2
9D011EA4  02802821   ADDU A1, S4, ZERO
9D011EA8  04410011   BGEZ V0, 0x9D011EF0
9D011EAC  02002021   ADDU A0, S0, ZERO
9D011EB0  8FA3001C   LW V1, 28(SP)
9D011EB4  02C3B021   ADDU S6, S6, V1
9D011EB8  0F40654B   JAL __subsf3
9D011EBC  03C02821   ADDU A1, S8, ZERO
9D011EC0  00408021   ADDU S0, V0, ZERO
9D011EC4  0F4079D9   JAL sitofp
9D011EC8  8FA40010   LW A0, 16(SP)
9D011ECC  02202021   ADDU A0, S1, ZERO
9D011ED0  0F40654D   JAL fpadd
9D011ED4  00402821   ADDU A1, V0, ZERO
9D011ED8  00408821   ADDU S1, V0, ZERO
9D011EDC  02402021   ADDU A0, S2, ZERO
9D011EE0  0F40654D   JAL fpadd
9D011EE4  00402821   ADDU A1, V0, ZERO
9D011EE8  00409021   ADDU S2, V0, ZERO
162:                     } while (dy < dx );           /* gradient negates -> algorithm fails */
9D011EEC  02002021   ADDU A0, S0, ZERO
9D011EF0  0F407800   JAL __lesf2
9D011EF4  02202821   ADDU A1, S1, ZERO
9D011EF8  0440FFC7   BLTZ V0, 0x9D011E18
9D011EFC  0220A021   ADDU S4, S1, ZERO
163:                   }
164:                   line(x0,y0, x2,y2);                  /* setPixel remaining part to end */
9D011F00  02602021   ADDU A0, S3, ZERO
9D011F04  02C02821   ADDU A1, S6, ZERO
9D011F08  02E03021   ADDU A2, S7, ZERO
9D011F0C  0F4045B9   JAL line
9D011F10  8FA70064   LW A3, 100(SP)
165:                 }//besiez()
9D011F14  8FBF004C   LW RA, 76(SP)
9D011F18  8FBE0048   LW S8, 72(SP)
9D011F1C  8FB70044   LW S7, 68(SP)
9D011F20  8FB60040   LW S6, 64(SP)
9D011F24  8FB5003C   LW S5, 60(SP)
9D011F28  8FB40038   LW S4, 56(SP)
9D011F2C  8FB30034   LW S3, 52(SP)
9D011F30  8FB20030   LW S2, 48(SP)
9D011F34  8FB1002C   LW S1, 44(SP)
9D011F38  8FB00028   LW S0, 40(SP)
9D011F3C  03E00008   JR RA
9D011F40  27BD0050   ADDIU SP, SP, 80
166:                 
167:                 
168:                 void fill(int x, int y){
9D011F44  03E00008   JR RA
169:                 }//fill()
---  /home/jacques/github/vpc-32vga/editor.c  -----------------------------------------------------------
1:                   /*
2:                   * Copyright 2013,2014,2017,2018 Jacques Deschênes
3:                   * This file is part of VPC-32VGA.
4:                   *
5:                   *     VPC-32VGA is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32VGA.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /* NOTES:
20:                  *   La mémoire SPI RAM est utilisée comme tampon texte.
21:                  *   La technique du 'split buffer' est utilisée. 
22:                  *   Il y a un fente au milieu du texte entre la position
23:                   *  du curseur texte et la fin du texte. Les nouveaux caractères
24:                   *  sont insérés dans cette fente et lorsque le curseur texte est
25:                   *  déplacé les caractères sont déplacés d'une extrémité à l'autre de la fente.
26:                   *  'state->gap_first' est l'adresse du début de  la fente et représente la position
27:                   *  d'insertion d'un caractère dans la mémoire tampon.
28:                   *  'state->tail' est l'adresse du premier caractère après la fente et pointe le
29:                   *  caractère à la position du curseur texte. 
30:                   *  Chaque ligne de texte est terminée par un caractère ASCII LF (0xA).
31:                   *  Une ligne a une longueur maximale de 80 caractères incluant le LF.    
32:                   */ 
33:                  
34:                  
35:                  
36:                  #include <stdlib.h>
37:                  #include <string.h>
38:                  #include <stdint.h>
39:                  #include <ctype.h>
40:                  #include <stdio.h>
41:                  #include <stdbool.h>
42:                  
43:                  #include "console.h"
44:                  #include "hardware/spiram/spiram.h"
45:                  #include "hardware/ps2_kbd/keyboard.h"
46:                  #include "hardware/Pinguino/fileio.h"
47:                  #include "hardware/sound/sound.h"
48:                  #include "graphics.h"
49:                  #include "font.h"
50:                  #include "reader.h"
51:                  
52:                  
53:                  #define EDITOR_LINES (LINE_PER_SCREEN-1)
54:                  #define LAST_LINE (EDITOR_LINES-1)
55:                  #define LINE_MAX_LEN (CHAR_PER_LINE-1)
56:                  #define LAST_COL (LINE_MAX_LEN-1)
57:                  #define SCREEN_SIZE (EDITOR_LINES*CHAR_PER_LINE)
58:                  #define ED_BUFF_SIZE (SRAM_SIZE)
59:                  #define MAX_SIZE (ED_BUFF_SIZE)
60:                  #define STATUS_LINE (LINE_PER_SCREEN-1)
61:                  
62:                  #define _beep()  tone(500,100)
63:                  
64:                  #define MODE_INSERT 1
65:                  #define MODE_OVERWR 0
66:                  #define NAME_MAX_LEN 32
67:                  
68:                  #define _screen_get(l,c) *(screen+l*CHAR_PER_LINE+c)
69:                  #define _screen_put(l,c,chr) *(screen+l*CHAR_PER_LINE+c)=chr
70:                  #define _screen_line(l) (screen+l*CHAR_PER_LINE)
71:                  #define _screen_addr(l,c) (screen+l*CHAR_PER_LINE+c)
72:                  
73:                  //contient 1'écran texte
74:                  //typedef char text_line_t[CHAR_PER_LINE];
75:                  //text_line_t *screen[LINE_PER_SCREEN];
76:                  char *screen;
77:                  
78:                  typedef struct editor_state{
79:                      uint32_t fsize; // grandeur du fichier en octets.
80:                      uint32_t scr_first; //premier caractère visible
81:                      uint32_t gap_first; //position début gap
82:                      uint32_t tail; // position fin gap
83:                      int8_t scr_line; // ligne du curseur
84:                      int8_t scr_col; //colonne du curseur
85:                      uint32_t file_line; // ligne courante dans le fichier.
86:                      uint32_t lines_count; // nombre de lignes dans le fichier.
87:                      struct {
88:                        uint8_t insert:1;
89:                        uint8_t modified:1;
90:                        uint8_t new:1;
91:                        uint8_t update:1;
92:                      }flags;
93:                  } ed_state_t;
94:                  
95:                  
96:                  //static char *split_buffer; // ligne en edition
97:                  static ed_state_t *state;
98:                  
99:                  static char *fname;
100:                 
101:                 typedef struct search_struct{
102:                    bool ignore_case;
103:                    bool loop;
104:                    bool found;
105:                    uint32_t file_line;
106:                    uint8_t col;
107:                    char target[CHAR_PER_LINE];
108:                 } search_t;
109:                 
110:                 static search_t *search_info;
111:                 
112:                 static void update_status_line();
113:                 static bool file_exist(const char *name);
114:                 static void open_file();
115:                 static void load_file(const char *name);
116:                 static void save_file();
117:                 static void save_file_as();
118:                 static void line_up();
119:                 static void line_down();
120:                 static bool char_left();
121:                 static bool char_right();
122:                 static void delete_left();
123:                 static void delete_at();
124:                 static void delete_to_end();
125:                 static void delete_to_start();
126:                 static void insert_char(char c);
127:                 static void replace_char(char c);
128:                 static void line_home();
129:                 static void line_end();
130:                 static void line_break();
131:                 static void file_home();
132:                 static void file_end();
133:                 static void fill_screen();
134:                 static void update_display();
135:                 static void page_up();
136:                 static void page_down();
137:                 static void word_right();
138:                 static void word_left();
139:                 static void goto_line();
140:                 static int get_line(char *line, unsigned *from);
141:                 static uint32_t get_line_back();
142:                 static void jump_to_line(uint16_t line_no);
143:                 static void insert_tabulation();
144:                 
145:                 
146:                 static void invert_display(bool enable){
9D0084B4  27BDFFE8   ADDIU SP, SP, -24
147:                     if (enable){
9D0084B8  10800008   BEQ A0, ZERO, 0x9D0084DC
9D0084BC  AFBF0014   SW RA, 20(SP)
148:                         clear_screen(con);
9D0084C0  0F404F63   JAL clear_screen
9D0084C4  97848062   LHU A0, -32670(GP)
149:                         invert_video(con,true);
9D0084C8  97848062   LHU A0, -32670(GP)
9D0084CC  0F404FE7   JAL invert_video
9D0084D0  24050001   ADDIU A1, ZERO, 1
9D0084D4  0B402140   J 0x9D008500
9D0084D8  8FBF0014   LW RA, 20(SP)
150:                     }else{
151:                         invert_video(con,false);
9D0084DC  97848062   LHU A0, -32670(GP)
9D0084E0  0F404FE7   JAL invert_video
9D0084E4  00002821   ADDU A1, ZERO, ZERO
152:                         state->flags.update=1;
9D0084E8  8F828074   LW V0, -32652(GP)
9D0084EC  9043001C   LBU V1, 28(V0)
9D0084F0  24040001   ADDIU A0, ZERO, 1
9D0084F4  7C8318C4   INS V1, A0, 3, 1
9D0084F8  A043001C   SB V1, 28(V0)
153:                     }
154:                 }
9D0084FC  8FBF0014   LW RA, 20(SP)
9D008500  03E00008   JR RA
9D008504  27BD0018   ADDIU SP, SP, 24
155:                 
156:                 
157:                 static void prompt_continue(){
9D0085F0  27BDFFE8   ADDIU SP, SP, -24
9D0085F4  AFBF0014   SW RA, 20(SP)
158:                     print(con,"\nany key...");//static uint8_t *llen;
9D0085F8  97848062   LHU A0, -32670(GP)
9D0085FC  3C059D02   LUI A1, -25342
9D008600  0F404FCC   JAL print
9D008604  24A587C0   ADDIU A1, A1, -30784
159:                     wait_key(con);
9D008608  0F404F87   JAL wait_key
9D00860C  97848062   LHU A0, -32670(GP)
160:                 }
9D008610  8FBF0014   LW RA, 20(SP)
9D008614  03E00008   JR RA
9D008618  27BD0018   ADDIU SP, SP, 24
161:                 
162:                 static void ed_error(const char *msg, int code){//static uint8_t *llen;
9D008938  27BDFFE8   ADDIU SP, SP, -24
9D00893C  AFBF0014   SW RA, 20(SP)
9D008940  AFB00010   SW S0, 16(SP)
9D008944  00801021   ADDU V0, A0, ZERO
9D008948  00A08021   ADDU S0, A1, ZERO
163:                     println(con,msg);
9D00894C  97848062   LHU A0, -32670(GP)
9D008950  0F405062   JAL println
9D008954  00402821   ADDU A1, V0, ZERO
164:                     print(con,"error code: ");
9D008958  97848062   LHU A0, -32670(GP)
9D00895C  3C059D02   LUI A1, -25342
9D008960  0F404FCC   JAL print
9D008964  24A587F8   ADDIU A1, A1, -30728
165:                     print_int(con,code,0);
9D008968  97848062   LHU A0, -32670(GP)
9D00896C  02002821   ADDU A1, S0, ZERO
9D008970  0F404FFF   JAL print_int
9D008974  00003021   ADDU A2, ZERO, ZERO
166:                     if (con==VGA_CONSOLE){
9D008978  97828062   LHU V0, -32670(GP)
9D00897C  14400006   BNE V0, ZERO, 0x9D008998
9D008980  8FBF0014   LW RA, 20(SP)
167:                         prompt_continue();
9D008984  0F40217C   JAL prompt_continue
9D008988  00000000   NOP
168:                         clear_screen(con);
9D00898C  0F404F63   JAL clear_screen
9D008990  97848062   LHU A0, -32670(GP)
169:                     }
170:                 }
9D008994  8FBF0014   LW RA, 20(SP)
9D008998  8FB00010   LW S0, 16(SP)
9D00899C  03E00008   JR RA
9D0089A0  27BD0018   ADDIU SP, SP, 24
171:                 
172:                 //si fichier modifié confirme 
173:                 //avant de continuer
174:                 static bool ask_confirm(){
9D00861C  27BDFFE8   ADDIU SP, SP, -24
9D008620  AFBF0014   SW RA, 20(SP)
9D008624  AFB00010   SW S0, 16(SP)
175:                     char key;
176:                     
177:                     bool answer=state->flags.modified;
9D008628  8F828074   LW V0, -32652(GP)
9D00862C  8C42001C   LW V0, 28(V0)
178:                     if (answer){
9D008630  7C420040   EXT V0, V0, 1, 1
9D008634  10400011   BEQ V0, ZERO, 0x9D00867C
9D008638  24100001   ADDIU S0, ZERO, 1
179:                         _beep();
9D00863C  240401F4   ADDIU A0, ZERO, 500
9D008640  0F406085   JAL tone
9D008644  24050064   ADDIU A1, ZERO, 100
180:                         invert_display(true);
9D008648  0F40212D   JAL invert_display
9D00864C  24040001   ADDIU A0, ZERO, 1
181:                         print(con,"file unsaved! continue (y/n)?");
9D008650  97848062   LHU A0, -32670(GP)
9D008654  3C059D02   LUI A1, -25342
9D008658  0F404FCC   JAL print
9D00865C  24A587CC   ADDIU A1, A1, -30772
182:                         key= wait_key(con);
9D008660  0F404F87   JAL wait_key
9D008664  97848062   LHU A0, -32670(GP)
183:                         answer=(key=='y')||(key=='Y');
9D008668  304200DF   ANDI V0, V0, 223
9D00866C  38500059   XORI S0, V0, 89
9D008670  2E100001   SLTIU S0, S0, 1
184:                         invert_display(false);
9D008674  0F40212D   JAL invert_display
9D008678  00002021   ADDU A0, ZERO, ZERO
185:                     }else{
186:                         answer=true;
187:                     }
188:                     return answer;
189:                 }// ask_confirm()
9D00867C  02001021   ADDU V0, S0, ZERO
9D008680  8FBF0014   LW RA, 20(SP)
9D008684  8FB00010   LW S0, 16(SP)
9D008688  03E00008   JR RA
9D00868C  27BD0018   ADDIU SP, SP, 24
190:                 
191:                 static void clear_all_states(){
9D008508  27BDFFE8   ADDIU SP, SP, -24
9D00850C  AFBF0014   SW RA, 20(SP)
9D008510  AFB00010   SW S0, 16(SP)
192:                     fname[0]=0;
9D008514  8F828070   LW V0, -32656(GP)
9D008518  A0400000   SB ZERO, 0(V0)
193:                     sram_clear_block(0,ED_BUFF_SIZE);
9D00851C  00002021   ADDU A0, ZERO, ZERO
9D008520  0F404E40   JAL sram_clear_block
9D008524  3C050001   LUI A1, 1
194:                     memset(state,0,sizeof(ed_state_t));
9D008528  8F908074   LW S0, -32652(GP)
9D00852C  02002021   ADDU A0, S0, ZERO
9D008530  00002821   ADDU A1, ZERO, ZERO
9D008534  0F40775D   JAL memset
9D008538  24060020   ADDIU A2, ZERO, 32
195:                     memset(screen,0,SCREEN_SIZE);
9D00853C  8F8480CC   LW A0, -32564(GP)
9D008540  00002821   ADDU A1, ZERO, ZERO
9D008544  0F40775D   JAL memset
9D008548  24060910   ADDIU A2, ZERO, 2320
196:                     state->flags.insert=MODE_INSERT;
9D00854C  9202001C   LBU V0, 28(S0)
9D008550  24030001   ADDIU V1, ZERO, 1
9D008554  7C620004   INS V0, V1, 0, 1
197:                     state->flags.new=true;
9D008558  7C621084   INS V0, V1, 2, 1
198:                     state->flags.update=false;
9D00855C  7C0218C4   INS V0, ZERO, 3, 1
199:                     state->flags.modified=false;
9D008560  7C020844   INS V0, ZERO, 1, 1
9D008564  A202001C   SB V0, 28(S0)
200:                     state->tail=MAX_SIZE;
9D008568  3C020001   LUI V0, 1
9D00856C  AE02000C   SW V0, 12(S0)
201:                 }//clear_all_states()
9D008570  8FBF0014   LW RA, 20(SP)
9D008574  8FB00010   LW S0, 16(SP)
9D008578  03E00008   JR RA
9D00857C  27BD0018   ADDIU SP, SP, 24
202:                 
203:                 static void new_file(const char *name){
9D009824  27BDFFE8   ADDIU SP, SP, -24
9D009828  AFBF0014   SW RA, 20(SP)
9D00982C  AFB00010   SW S0, 16(SP)
204:                     if (!state->flags.modified || ask_confirm()){
9D009830  8F828074   LW V0, -32652(GP)
9D009834  8C42001C   LW V0, 28(V0)
9D009838  30420002   ANDI V0, V0, 2
9D00983C  10400005   BEQ V0, ZERO, 0x9D009854
9D009840  00808021   ADDU S0, A0, ZERO
9D009844  0F402187   JAL ask_confirm
9D009848  00000000   NOP
9D00984C  10400010   BEQ V0, ZERO, 0x9D009890
9D009850  8FBF0014   LW RA, 20(SP)
205:                         clear_all_states();
9D009854  0F402142   JAL clear_all_states
9D009858  00000000   NOP
206:                         if (file_exist(name)){
9D00985C  0F40223A   JAL file_exist
9D009860  02002021   ADDU A0, S0, ZERO
9D009864  10400005   BEQ V0, ZERO, 0x9D00987C
9D009868  00000000   NOP
207:                             load_file(name);
9D00986C  0F402578   JAL load_file
9D009870  02002021   ADDU A0, S0, ZERO
9D009874  0B402624   J 0x9D009890
9D009878  8FBF0014   LW RA, 20(SP)
208:                         }else if(name){
9D00987C  12000003   BEQ S0, ZERO, 0x9D00988C
9D009880  8F848070   LW A0, -32656(GP)
209:                             strcpy(fname,name);
9D009884  0F406D40   JAL strcpy
9D009888  02002821   ADDU A1, S0, ZERO
210:                         }
211:                     }
212:                 }//new_file()
9D00988C  8FBF0014   LW RA, 20(SP)
9D009890  8FB00010   LW S0, 16(SP)
9D009894  03E00008   JR RA
9D009898  27BD0018   ADDIU SP, SP, 24
213:                 
214:                 static bool quit;
215:                 
216:                 static void leave_editor(){
217:                     if (ask_confirm()){
9D00AC4C  0F402187   JAL ask_confirm
9D00AC50  00000000   NOP
9D00AC54  1040001E   BEQ V0, ZERO, 0x9D00ACD0
9D00AC58  93828068   LBU V0, -32664(GP)
218:                         free(fname);
9D00AC5C  0F407BCB   JAL free
9D00AC60  8F848070   LW A0, -32656(GP)
219:                         free(state);
9D00AC64  0F407BCB   JAL free
9D00AC68  8F848074   LW A0, -32652(GP)
220:                         free(search_info);
9D00AC6C  0F407BCB   JAL free
9D00AC70  8F84806C   LW A0, -32660(GP)
221:                         free(screen);
9D00AC74  0F407BCB   JAL free
9D00AC78  8F8480CC   LW A0, -32564(GP)
222:                         vga_set_cursor(CR_UNDER);
9D00AC7C  0F403BF3   JAL vga_set_cursor
9D00AC80  00002021   ADDU A0, ZERO, ZERO
223:                         quit=true;
9D00AC84  24020001   ADDIU V0, ZERO, 1
9D00AC88  0B402B36   J 0x9D00ACD8
9D00AC8C  A3828068   SB V0, -32664(GP)
224:                     }
225:                 }
226:                  
227:                 static void list_files(){
228:                     clear_screen(con);
9D00AB28  0F404F63   JAL clear_screen
9D00AB2C  97848062   LHU A0, -32670(GP)
229:                     invert_display(true);
9D00AB30  0F40212D   JAL invert_display
9D00AB34  24040001   ADDIU A0, ZERO, 1
230:                     listDir(".");
9D00AB38  3C049D02   LUI A0, -25342
9D00AB3C  0F405941   JAL listDir
9D00AB40  248488E0   ADDIU A0, A0, -30496
231:                     prompt_continue();
9D00AB44  0F40217C   JAL prompt_continue
9D00AB48  00000000   NOP
232:                     invert_display(false);
9D00AB4C  0F40212D   JAL invert_display
9D00AB50  00002021   ADDU A0, ZERO, ZERO
233:                     clear_screen(con);
9D00AB54  0F404F63   JAL clear_screen
9D00AB58  97848062   LHU A0, -32670(GP)
234:                     state->flags.update=true;
9D00AB5C  8F828074   LW V0, -32652(GP)
9D00AB60  9043001C   LBU V1, 28(V0)
9D00AB64  24040001   ADDIU A0, ZERO, 1
9D00AB68  7C8318C4   INS V1, A0, 3, 1
9D00AB6C  0B402B33   J 0x9D00ACCC
9D00AB70  A043001C   SB V1, 28(V0)
235:                 }//f
236:                 
237:                 //affiche la chaîne trouvée en inverse vidéo.
238:                 //initialement le curseur est au début de la ligne
239:                 static void mark_target(){
9D0094D4  27BDFFE0   ADDIU SP, SP, -32
9D0094D8  AFBF001C   SW RA, 28(SP)
9D0094DC  AFB10018   SW S1, 24(SP)
9D0094E0  AFB00014   SW S0, 20(SP)
240:                     int i,len;
241:                     jump_to_line(search_info->file_line);
9D0094E4  8F82806C   LW V0, -32660(GP)
9D0094E8  0F402502   JAL jump_to_line
9D0094EC  94440004   LHU A0, 4(V0)
242:                     while (state->scr_col<search_info->col){char_right();}
9D0094F0  8F828074   LW V0, -32652(GP)
9D0094F4  80440011   LB A0, 17(V0)
9D0094F8  8F83806C   LW V1, -32660(GP)
9D0094FC  90630008   LBU V1, 8(V1)
9D009500  0083182A   SLT V1, A0, V1
9D009504  5060000B   BEQL V1, ZERO, 0x9D009534
9D009508  8C42001C   LW V0, 28(V0)
9D00950C  0F402416   JAL char_right
9D009510  00000000   NOP
9D009514  8F828074   LW V0, -32652(GP)
9D009518  80440011   LB A0, 17(V0)
9D00951C  8F83806C   LW V1, -32660(GP)
9D009520  90630008   LBU V1, 8(V1)
9D009524  0083182A   SLT V1, A0, V1
9D009528  1460FFF8   BNE V1, ZERO, 0x9D00950C
9D00952C  00000000   NOP
243:                     if (state->flags.update){update_display();}
9D009530  8C42001C   LW V0, 28(V0)
9D009534  30420008   ANDI V0, V0, 8
9D009538  50400004   BEQL V0, ZERO, 0x9D00954C
9D00953C  8F84806C   LW A0, -32660(GP)
9D009540  0F402160   JAL update_display
9D009544  00000000   NOP
244:                     len=strlen(search_info->target);
9D009548  8F84806C   LW A0, -32660(GP)
9D00954C  0F406EC2   JAL strlen
9D009550  24840009   ADDIU A0, A0, 9
9D009554  00408821   ADDU S1, V0, ZERO
245:                     invert_video(con,true);
9D009558  97848062   LHU A0, -32670(GP)
9D00955C  0F404FE7   JAL invert_video
9D009560  24050001   ADDIU A1, ZERO, 1
246:                     for (i=0;i<len;i++) put_char(con,_screen_get(state->scr_line,state->scr_col+i));
9D009564  1A200011   BLEZ S1, 0x9D0095AC
9D009568  00008021   ADDU S0, ZERO, ZERO
9D00956C  8F848074   LW A0, -32652(GP)
9D009570  80830010   LB V1, 16(A0)
9D009574  80840011   LB A0, 17(A0)
9D009578  00031100   SLL V0, V1, 4
9D00957C  00031980   SLL V1, V1, 6
9D009580  00431821   ADDU V1, V0, V1
9D009584  00641821   ADDU V1, V1, A0
9D009588  00701821   ADDU V1, V1, S0
9D00958C  8F8480CC   LW A0, -32564(GP)
9D009590  00831821   ADDU V1, A0, V1
9D009594  97848062   LHU A0, -32670(GP)
9D009598  0F404FC0   JAL put_char
9D00959C  80650000   LB A1, 0(V1)
9D0095A0  26100001   ADDIU S0, S0, 1
9D0095A4  1630FFF2   BNE S1, S0, 0x9D009570
9D0095A8  8F848074   LW A0, -32652(GP)
247:                     invert_video(con,false);
9D0095AC  97848062   LHU A0, -32670(GP)
9D0095B0  0F404FE7   JAL invert_video
9D0095B4  00002821   ADDU A1, ZERO, ZERO
248:                     set_curpos(con,state->scr_col,state->scr_line);
9D0095B8  8F828074   LW V0, -32652(GP)
9D0095BC  97848062   LHU A0, -32670(GP)
9D0095C0  80450011   LB A1, 17(V0)
9D0095C4  0F404FB2   JAL set_curpos
9D0095C8  80460010   LB A2, 16(V0)
249:                 }//mark_target()
9D0095CC  8FBF001C   LW RA, 28(SP)
9D0095D0  8FB10018   LW S1, 24(SP)
9D0095D4  8FB00014   LW S0, 20(SP)
9D0095D8  03E00008   JR RA
9D0095DC  27BD0020   ADDIU SP, SP, 32
250:                 
251:                 // recherche une la chaîne 'target' dans la chaîne 'line'
252:                 // retourne la position à partir du début de 'line' ou -1 si non trouvée.
253:                 static int search_line(char *line, char *target, int from){
9D008690  27BDFFD8   ADDIU SP, SP, -40
9D008694  AFBF0024   SW RA, 36(SP)
9D008698  AFB30020   SW S3, 32(SP)
9D00869C  AFB2001C   SW S2, 28(SP)
9D0086A0  AFB10018   SW S1, 24(SP)
9D0086A4  AFB00014   SW S0, 20(SP)
9D0086A8  00808821   ADDU S1, A0, ZERO
9D0086AC  00C08021   ADDU S0, A2, ZERO
254:                     int i,j=0,tlen,llen;
9D0086D8  00001821   ADDU V1, ZERO, ZERO
9D008720  00001821   ADDU V1, ZERO, ZERO
255:                     
256:                     tlen=strlen(target);
9D0086B0  0F406EC2   JAL strlen
9D0086B4  00A02021   ADDU A0, A1, ZERO
9D0086B8  00409821   ADDU S3, V0, ZERO
9D0086BC  00409021   ADDU S2, V0, ZERO
257:                     llen=strlen(line);
9D0086C0  0F406EC2   JAL strlen
9D0086C4  02202021   ADDU A0, S1, ZERO
9D0086C8  00403821   ADDU A3, V0, ZERO
258:                     for (i=from;i<llen;i++){
9D0086CC  0202102A   SLT V0, S0, V0
9D0086D0  10400013   BEQ V0, ZERO, 0x9D008720
9D0086D4  8F84806C   LW A0, -32660(GP)
9D008708  26100001   ADDIU S0, S0, 1
9D00870C  0207102A   SLT V0, S0, A3
9D008710  1440FFF3   BNE V0, ZERO, 0x9D0086E0
9D008714  00833021   ADDU A2, A0, V1
9D008718  0B4021C9   J 0x9D008724
9D00871C  00000000   NOP
259:                         if (search_info->target[j]==line[i]){
9D0086DC  00833021   ADDU A2, A0, V1
9D0086E0  02302821   ADDU A1, S1, S0
9D0086E4  80C60009   LB A2, 9(A2)
9D0086E8  80A50000   LB A1, 0(A1)
9D0086EC  54C50006   BNEL A2, A1, 0x9D008708
9D0086F0  00001821   ADDU V1, ZERO, ZERO
260:                             j++;
9D0086F4  24630001   ADDIU V1, V1, 1
9D008700  0B4021CB   J 0x9D00872C
9D008704  02601821   ADDU V1, S3, ZERO
261:                             if (j==tlen){
9D0086F8  14720004   BNE V1, S2, 0x9D00870C
9D0086FC  26100001   ADDIU S0, S0, 1
262:                                 i++;
263:                                 break;
264:                             }
265:                         }else{
266:                              j=0; 
267:                         }
268:                     }
269:                     return j==tlen?i-j:-1;
9D008724  54720002   BNEL V1, S2, 0x9D008730
9D008728  2402FFFF   ADDIU V0, ZERO, -1
9D00872C  02031023   SUBU V0, S0, V1
270:                 }//search_line()
9D008730  8FBF0024   LW RA, 36(SP)
9D008734  8FB30020   LW S3, 32(SP)
9D008738  8FB2001C   LW S2, 28(SP)
9D00873C  8FB10018   LW S1, 24(SP)
9D008740  8FB00014   LW S0, 20(SP)
9D008744  03E00008   JR RA
9D008748  27BD0028   ADDIU SP, SP, 40
271:                 
272:                 // chaîne trop courte pour contenir la chaîne cible.
273:                 #define _string_too_short(addr) ((MAX_SIZE-(addr))<strlen(search_info->target))
274:                 
275:                 static bool search_completed(uint32_t limit){
276:                     search_info->col=0;
9D009ACC  A0400008   SB ZERO, 8(V0)
277:                     search_info->file_line++;
9D009AD0  8C430004   LW V1, 4(V0)
9D009AD4  24630001   ADDIU V1, V1, 1
9D009AD8  AC430004   SW V1, 4(V0)
278:                     if (search_info->file_line>state->lines_count){
9D009ADC  8F848074   LW A0, -32652(GP)
9D009AE0  8C840018   LW A0, 24(A0)
9D009AE4  0083182B   SLTU V1, A0, V1
9D009AE8  54600001   BNEL V1, ZERO, 0x9D009AF0
9D009AEC  AC400004   SW ZERO, 4(V0)
279:                         search_info->file_line=0;
280:                     }
281:                     return (!(search_info->loop || search_info->file_line) ||
9D009AF0  90430001   LBU V1, 1(V0)
9D009AF4  14600005   BNE V1, ZERO, 0x9D009B0C
9D009AF8  8C420004   LW V0, 4(V0)
9D009AFC  54400005   BNEL V0, ZERO, 0x9D009B14
9D009B00  27A40010   ADDIU A0, SP, 16
282:                             (search_info->loop && (search_info->file_line==limit)));
9D009B0C  12220010   BEQ S1, V0, 0x9D009B50
9D009B10  27A40010   ADDIU A0, SP, 16
283:                 }
284:                 
285:                 
286:                 // recherche l'occurance suivante de 'search_info->target' dans le texte.
287:                 static void search_next(){
9D009974  27BDFF80   ADDIU SP, SP, -128
9D009978  AFBF007C   SW RA, 124(SP)
9D00997C  AFB30078   SW S3, 120(SP)
9D009980  AFB20074   SW S2, 116(SP)
9D009984  AFB10070   SW S1, 112(SP)
9D009988  AFB0006C   SW S0, 108(SP)
288:                     char line[CHAR_PER_LINE];
289:                     int pos;
290:                     uint32_t limit;
291:                     unsigned saddr;
292:                     
293:                     if (!search_info->target[0] || (!search_info->loop && 
9D00998C  8F90806C   LW S0, -32660(GP)
9D009990  82020009   LB V0, 9(S0)
9D009994  1040000E   BEQ V0, ZERO, 0x9D0099D0
9D009998  240401F4   ADDIU A0, ZERO, 500
9D00999C  92020001   LBU V0, 1(S0)
9D0099A0  5440000F   BNEL V0, ZERO, 0x9D0099E0
9D0099A4  92020002   LBU V0, 2(S0)
9D0099C0  0062102B   SLTU V0, V1, V0
9D0099C4  50400006   BEQL V0, ZERO, 0x9D0099E0
9D0099C8  92020002   LBU V0, 2(S0)
294:                             _string_too_short(state->tail+1))){
9D0099A8  0F406EC2   JAL strlen
9D0099AC  26040009   ADDIU A0, S0, 9
9D0099B0  8F838074   LW V1, -32652(GP)
9D0099B4  8C63000C   LW V1, 12(V1)
9D0099B8  3404FFFF   ORI A0, ZERO, -1
9D0099BC  00831823   SUBU V1, A0, V1
295:                         _beep();
9D0099CC  240401F4   ADDIU A0, ZERO, 500
9D0099D0  0F406085   JAL tone
9D0099D4  24050064   ADDIU A1, ZERO, 100
296:                         return;
9D0099D8  0B4026D8   J 0x9D009B60
9D0099DC  8FBF007C   LW RA, 124(SP)
297:                     }
298:                     if (search_info->found && (search_info->file_line==state->file_line) && 
9D0099E0  10400011   BEQ V0, ZERO, 0x9D009A28
9D0099E4  8F828074   LW V0, -32652(GP)
9D0099E8  8E040004   LW A0, 4(S0)
9D0099EC  8C430014   LW V1, 20(V0)
9D0099F0  5483000F   BNEL A0, V1, 0x9D009A30
9D0099F4  AE030004   SW V1, 4(S0)
9D009A00  5464000A   BNEL V1, A0, 0x9D009A2C
9D009A04  8C430014   LW V1, 20(V0)
299:                             (search_info->col==state->scr_col)){
9D0099F8  92030008   LBU V1, 8(S0)
9D0099FC  80440011   LB A0, 17(V0)
300:                         search_info->col++;
9D009A08  24630001   ADDIU V1, V1, 1
9D009A0C  A2030008   SB V1, 8(S0)
301:                         saddr=state->gap_first-state->scr_col+1;
9D009A10  8C430008   LW V1, 8(V0)
9D009A14  24630001   ADDIU V1, V1, 1
9D009A18  80420011   LB V0, 17(V0)
9D009A1C  00621023   SUBU V0, V1, V0
9D009A20  0B402692   J 0x9D009A48
9D009A24  AFA20060   SW V0, 96(SP)
302:                     }else{
303:                         search_info->file_line=state->file_line;
9D009A28  8C430014   LW V1, 20(V0)
9D009A2C  AE030004   SW V1, 4(S0)
304:                         search_info->col=state->scr_col;
9D009A30  90430011   LBU V1, 17(V0)
9D009A34  A2030008   SB V1, 8(S0)
305:                         saddr=state->gap_first-state->scr_col;
9D009A38  80430011   LB V1, 17(V0)
9D009A3C  8C420008   LW V0, 8(V0)
9D009A40  00431023   SUBU V0, V0, V1
9D009A44  AFA20060   SW V0, 96(SP)
306:                     }
307:                     search_info->found=false;
9D009A48  8F82806C   LW V0, -32660(GP)
9D009A4C  A0400002   SB ZERO, 2(V0)
308:                     get_line(line,&saddr);
9D009A50  27A40010   ADDIU A0, SP, 16
9D009A54  0F40232E   JAL get_line
9D009A58  27A50060   ADDIU A1, SP, 96
309:                     if (search_info->ignore_case) uppercase(line);
9D009A5C  8F82806C   LW V0, -32660(GP)
9D009A60  90420000   LBU V0, 0(V0)
9D009A64  10400004   BEQ V0, ZERO, 0x9D009A78
9D009A68  8F90806C   LW S0, -32660(GP)
9D009A6C  0F404F53   JAL uppercase
9D009A70  27A40010   ADDIU A0, SP, 16
310:                     pos=search_line(line,search_info->target,search_info->col);
9D009A74  8F90806C   LW S0, -32660(GP)
9D009A78  27A40010   ADDIU A0, SP, 16
9D009A7C  26050009   ADDIU A1, S0, 9
9D009A80  0F4021A4   JAL search_line
9D009A84  92060008   LBU A2, 8(S0)
311:                     if (pos!=-1){
9D009A88  2403FFFF   ADDIU V1, ZERO, -1
9D009A8C  50430007   BEQL V0, V1, 0x9D009AAC
9D009A90  8E110004   LW S1, 4(S0)
312:                         search_info->col=pos;
9D009A94  A2020008   SB V0, 8(S0)
313:                         search_info->found=true;
9D009A98  24020001   ADDIU V0, ZERO, 1
314:                         mark_target();
9D009A9C  0F402535   JAL mark_target
9D009AA0  A2020002   SB V0, 2(S0)
315:                         return;
9D009AA4  0B4026D8   J 0x9D009B60
9D009AA8  8FBF007C   LW RA, 124(SP)
316:                     }
317:                     limit=search_info->file_line;
318:                     while (!(search_info->found || search_completed(limit))){
9D009AB0  0B4026AF   J 0x9D009ABC
9D009AB4  24120001   ADDIU S2, ZERO, 1
9D009ABC  8F82806C   LW V0, -32660(GP)
9D009AC0  90430002   LBU V1, 2(V0)
9D009AC4  1460001E   BNE V1, ZERO, 0x9D009B40
9D009AC8  00000000   NOP
319:                         get_line(line,&saddr);
9D009B14  0F40232E   JAL get_line
9D009B18  27A50060   ADDIU A1, SP, 96
320:                         pos=search_line(line,search_info->target,0);
9D009B1C  8F93806C   LW S3, -32660(GP)
9D009B20  27A40010   ADDIU A0, SP, 16
9D009B24  26650009   ADDIU A1, S3, 9
9D009B28  0F4021A4   JAL search_line
9D009B2C  00003021   ADDU A2, ZERO, ZERO
321:                         if (pos!=-1){
9D009AAC  2410FFFF   ADDIU S0, ZERO, -1
9D009B30  5050FFE3   BEQL V0, S0, 0x9D009AC0
9D009B34  8F82806C   LW V0, -32660(GP)
9D009B38  0B4026AE   J 0x9D009AB8
9D009B3C  A2720002   SB S2, 2(S3)
322:                             search_info->found=true;
323:                             search_info->col=pos;
9D009AB8  A2620008   SB V0, 8(S3)
324:                         }
325:                     }
326:                     if (search_info->found){
327:                         mark_target();
9D009B40  0F402535   JAL mark_target
9D009B44  00000000   NOP
9D009B48  0B4026D8   J 0x9D009B60
9D009B4C  8FBF007C   LW RA, 124(SP)
328:                     }else{
329:                         _beep();
9D009B04  0B4026D5   J 0x9D009B54
9D009B08  240401F4   ADDIU A0, ZERO, 500
9D009B50  240401F4   ADDIU A0, ZERO, 500
9D009B54  0F406085   JAL tone
9D009B58  24050064   ADDIU A1, ZERO, 100
330:                     }
331:                 }//search_next()
9D009B5C  8FBF007C   LW RA, 124(SP)
9D009B60  8FB30078   LW S3, 120(SP)
9D009B64  8FB20074   LW S2, 116(SP)
9D009B68  8FB10070   LW S1, 112(SP)
9D009B6C  8FB0006C   LW S0, 108(SP)
9D009B70  03E00008   JR RA
9D009B74  27BD0080   ADDIU SP, SP, 128
332:                 
333:                 
334:                 static bool parse_search_line(){
335:                     int pos=0;
9D00A940  00001021   ADDU V0, ZERO, ZERO
336:                     char *str, prev=0;
9D00A948  00002821   ADDU A1, ZERO, ZERO
337:                     int options=0;
338:                     
339:                     str=search_info->target;
9D00A930  8F82806C   LW V0, -32660(GP)
340:                     while (str[pos]){
9D00A934  80430009   LB V1, 9(V0)
9D00A938  1060006F   BEQ V1, ZERO, 0x9D00AAF8
9D00A93C  24540009   ADDIU S4, V0, 9
9D00A944  00003021   ADDU A2, ZERO, ZERO
9D00A990  80840000   LB A0, 0(A0)
9D00A994  10800058   BEQ A0, ZERO, 0x9D00AAF8
9D00A998  00403021   ADDU A2, V0, ZERO
9D00A99C  00602821   ADDU A1, V1, ZERO
9D00A9A0  0B402A55   J 0x9D00A954
9D00A9A4  00801821   ADDU V1, A0, ZERO
9D00A9A8  0282A821   ADDU S5, S4, V0
341:                         if (str[pos]=='-' && prev==' '){
9D00A94C  2407002D   ADDIU A3, ZERO, 45
9D00A950  24080020   ADDIU T0, ZERO, 32
9D00A954  5467000D   BNEL V1, A3, 0x9D00A98C
9D00A958  24420001   ADDIU V0, V0, 1
9D00A95C  54A8000B   BNEL A1, T0, 0x9D00A98C
9D00A960  24420001   ADDIU V0, V0, 1
342:                             str[pos-1]=0;
9D00A964  02863021   ADDU A2, S4, A2
9D00A968  A0C0FFFF   SB ZERO, -1(A2)
343:                             prev='-';
344:                             pos++;
9D00A96C  24570001   ADDIU S7, V0, 1
345:                             break;
346:                         }
347:                         prev=str[pos];
348:                         pos++;
349:                     }    
350:                     while (str[pos] && options!=3){
9D00A970  AFB70068   SW S7, 104(SP)
9D00A974  0297F021   ADDU S8, S4, S7
9D00A978  83C40000   LB A0, 0(S8)
9D00A97C  5480000A   BNEL A0, ZERO, 0x9D00A9A8
9D00A980  24420002   ADDIU V0, V0, 2
9D00A984  0B402ABE   J 0x9D00AAF8
9D00A988  00000000   NOP
9D00A98C  02822021   ADDU A0, S4, V0
9D00A9AC  AFA0006C   SW ZERO, 108(SP)
9D00AAD8  AFB70068   SW S7, 104(SP)
9D00AADC  82A40000   LB A0, 0(S5)
9D00AAE0  10800005   BEQ A0, ZERO, 0x9D00AAF8
9D00AAE4  02A0F021   ADDU S8, S5, ZERO
9D00AAE8  24020003   ADDIU V0, ZERO, 3
9D00AAEC  8FA5006C   LW A1, 108(SP)
9D00AAF0  14A2FFAF   BNE A1, V0, 0x9D00A9B0
9D00AAF4  26B50001   ADDIU S5, S5, 1
351:                         switch(str[pos]){
9D00A9B0  24020049   ADDIU V0, ZERO, 73
9D00A9B4  10820028   BEQ A0, V0, 0x9D00AA58
9D00A9B8  2882004A   SLTI V0, A0, 74
9D00A9BC  10400008   BEQ V0, ZERO, 0x9D00A9E0
9D00A9C0  24050069   ADDIU A1, ZERO, 105
9D00A9C4  24020020   ADDIU V0, ZERO, 32
9D00A9C8  10820041   BEQ A0, V0, 0x9D00AAD0
9D00A9CC  2403002D   ADDIU V1, ZERO, 45
9D00A9D0  50830040   BEQL A0, V1, 0x9D00AAD4
9D00A9D4  83C30000   LB V1, 0(S8)
9D00A9E0  1085001D   BEQ A0, A1, 0x9D00AA58
9D00A9E4  2402006C   ADDIU V0, ZERO, 108
9D00A9E8  10820003   BEQ A0, V0, 0x9D00A9F8
9D00A9EC  2402004C   ADDIU V0, ZERO, 76
9D00A9F0  14820033   BNE A0, V0, 0x9D00AAC0
9D00A9F4  240401F4   ADDIU A0, ZERO, 500
352:                             case '-':
353:                             case ' ':
354:                                 break;
355:                             case 'l':
356:                             case 'L':
357:                                 if (prev!='-'){
9D00A9F8  2405002D   ADDIU A1, ZERO, 45
9D00A9FC  50650006   BEQL V1, A1, 0x9D00AA18
9D00AA00  8F82806C   LW V0, -32660(GP)
358:                                     _beep();
9D00AA04  240401F4   ADDIU A0, ZERO, 500
9D00AA08  0F406085   JAL tone
9D00AA0C  24050064   ADDIU A1, ZERO, 100
359:                                     return false;
360:                                 }
361:                                 search_info->loop=true;
9D00AA18  24030001   ADDIU V1, ZERO, 1
9D00AA1C  A0430001   SB V1, 1(V0)
362:                                 options|=1; 
9D00AA38  8FA2006C   LW V0, 108(SP)
9D00AA3C  34420001   ORI V0, V0, 1
9D00AA40  0B402AB4   J 0x9D00AAD0
9D00AA44  AFA2006C   SW V0, 108(SP)
363:                                 if (str[pos+1] && str[pos+1]!=' '){
9D00AA20  8FA50068   LW A1, 104(SP)
9D00AA24  02851021   ADDU V0, S4, A1
9D00AA28  80420001   LB V0, 1(V0)
9D00AA2C  7C022944   INS V0, ZERO, 5, 1
9D00AA30  14400005   BNE V0, ZERO, 0x9D00AA48
9D00AA34  240401F4   ADDIU A0, ZERO, 500
364:                                     _beep();
9D00AA48  0F406085   JAL tone
9D00AA4C  24050064   ADDIU A1, ZERO, 100
365:                                     return false;
366:                                 }
367:                                 break;
368:                             case 'i':
369:                             case 'I':
370:                                 if (prev!='-'){
9D00AA58  2405002D   ADDIU A1, ZERO, 45
9D00AA5C  50650006   BEQL V1, A1, 0x9D00AA78
9D00AA60  8F82806C   LW V0, -32660(GP)
371:                                     _beep();
9D00AA64  240401F4   ADDIU A0, ZERO, 500
9D00AA68  0F406085   JAL tone
9D00AA6C  24050064   ADDIU A1, ZERO, 100
372:                                     return false;
373:                                 }
374:                                 search_info->ignore_case=true;
9D00AA78  24030001   ADDIU V1, ZERO, 1
9D00AA7C  A0430000   SB V1, 0(V0)
375:                                 options|=2;
9D00AAA0  8FA2006C   LW V0, 108(SP)
9D00AAA4  34420002   ORI V0, V0, 2
9D00AAA8  0B402AB4   J 0x9D00AAD0
9D00AAAC  AFA2006C   SW V0, 108(SP)
376:                                 uppercase(str);
9D00AA80  0F404F53   JAL uppercase
9D00AA84  02802021   ADDU A0, S4, ZERO
377:                                 if (str[pos+1] && str[pos+1]!=' '){
9D00AA88  8FA50068   LW A1, 104(SP)
9D00AA8C  02851021   ADDU V0, S4, A1
9D00AA90  80420001   LB V0, 1(V0)
9D00AA94  7C022944   INS V0, ZERO, 5, 1
9D00AA98  14400005   BNE V0, ZERO, 0x9D00AAB0
9D00AA9C  240401F4   ADDIU A0, ZERO, 500
378:                                     _beep();
9D00AAB0  0F406085   JAL tone
9D00AAB4  24050064   ADDIU A1, ZERO, 100
379:                                     return false;
380:                                 }
381:                                 break;
382:                             default:
383:                                 _beep();
9D00A9D8  0B402AB0   J 0x9D00AAC0
9D00A9DC  240401F4   ADDIU A0, ZERO, 500
9D00AAC0  0F406085   JAL tone
9D00AAC4  24050064   ADDIU A1, ZERO, 100
384:                                 return false;
385:                         }//switch
386:                         prev=str[pos];
9D00AAD0  83C30000   LB V1, 0(S8)
387:                         pos++;
9D00AAD4  26F70001   ADDIU S7, S7, 1
388:                     }//while
389:                     return true;
390:                 }//f
391:                 
392:                 static void search(){
393:                     int len;
394:                 
395:                     invert_display(true);
9D00A8AC  0F40212D   JAL invert_display
9D00A8B0  24040001   ADDIU A0, ZERO, 1
396:                     print(con,"USAGE: target [-I] [-L]\n");
9D00A8B4  97848062   LHU A0, -32670(GP)
9D00A8B8  3C059D02   LUI A1, -25342
9D00A8BC  0F404FCC   JAL print
9D00A8C0  24A588C0   ADDIU A1, A1, -30528
397:                     search_info->found=false;
9D00A8C4  8F82806C   LW V0, -32660(GP)
9D00A8C8  A0400002   SB ZERO, 2(V0)
398:                     search_info->loop=false;
9D00A8CC  A0400001   SB ZERO, 1(V0)
399:                     search_info->ignore_case=false;
9D00A8D0  A0400000   SB ZERO, 0(V0)
400:                     print(con,"? ");
9D00A8D4  97848062   LHU A0, -32670(GP)
9D00A8D8  3C059D02   LUI A1, -25342
9D00A8DC  0F404FCC   JAL print
9D00A8E0  24A588DC   ADDIU A1, A1, -30500
401:                     len=read_line(con,search_info->target,CHAR_PER_LINE);
9D00A8E4  97848062   LHU A0, -32670(GP)
9D00A8E8  8F85806C   LW A1, -32660(GP)
9D00A8EC  24A50009   ADDIU A1, A1, 9
9D00A8F0  0F404F93   JAL read_line
9D00A8F4  24060050   ADDIU A2, ZERO, 80
9D00A8F8  0040A021   ADDU S4, V0, ZERO
402:                     if (search_info->target[len-1]=='\n'){
9D00A8FC  8F83806C   LW V1, -32660(GP)
9D00A900  2442FFFF   ADDIU V0, V0, -1
9D00A904  00622021   ADDU A0, V1, V0
9D00A908  80850009   LB A1, 9(A0)
9D00A90C  2404000A   ADDIU A0, ZERO, 10
9D00A910  14A40003   BNE A1, A0, 0x9D00A920
9D00A914  00621821   ADDU V1, V1, V0
403:                         search_info->target[len-1]=0;
9D00A918  A0600009   SB ZERO, 9(V1)
404:                         len--;
9D00A91C  0040A021   ADDU S4, V0, ZERO
405:                     }
406:                     invert_display(false);
9D00A920  0F40212D   JAL invert_display
9D00A924  00002021   ADDU A0, ZERO, ZERO
407:                     if (len && parse_search_line()){
9D00A928  128000E9   BEQ S4, ZERO, 0x9D00ACD0
9D00A92C  93828068   LBU V0, -32664(GP)
408:                         search_next();
9D00AAF8  0F40265D   JAL search_next
9D00AAFC  00000000   NOP
409:                     }
410:                 }//f
411:                 
412:                 static bool get_file_name(char *name){
9D008880  27BDFFE0   ADDIU SP, SP, -32
9D008884  AFBF001C   SW RA, 28(SP)
9D008888  AFB10018   SW S1, 24(SP)
9D00888C  AFB00014   SW S0, 20(SP)
9D008890  00808021   ADDU S0, A0, ZERO
413:                     int len;
414:                 
415:                     invert_display(true);
9D008894  0F40212D   JAL invert_display
9D008898  24040001   ADDIU A0, ZERO, 1
416:                     print(con,"file name? ");
9D00889C  97848062   LHU A0, -32670(GP)
9D0088A0  3C059D02   LUI A1, -25342
9D0088A4  0F404FCC   JAL print
9D0088A8  24A587EC   ADDIU A1, A1, -30740
417:                     len=read_line(con,name,NAME_MAX_LEN);
9D0088AC  97848062   LHU A0, -32670(GP)
9D0088B0  02002821   ADDU A1, S0, ZERO
9D0088B4  0F404F93   JAL read_line
9D0088B8  24060020   ADDIU A2, ZERO, 32
9D0088BC  00408821   ADDU S1, V0, ZERO
418:                     uppercase(name);
9D0088C0  0F404F53   JAL uppercase
9D0088C4  02002021   ADDU A0, S0, ZERO
419:                     invert_display(false);
9D0088C8  0F40212D   JAL invert_display
9D0088CC  00002021   ADDU A0, ZERO, ZERO
420:                     return len;
421:                 }//f()
9D0088D0  0011102B   SLTU V0, ZERO, S1
9D0088D4  8FBF001C   LW RA, 28(SP)
9D0088D8  8FB10018   LW S1, 24(SP)
9D0088DC  8FB00014   LW S0, 20(SP)
9D0088E0  03E00008   JR RA
9D0088E4  27BD0020   ADDIU SP, SP, 32
422:                 
423:                 static void load_file(const char *name){
9D0095E0  27BDFE48   ADDIU SP, SP, -440
9D0095E4  AFBF01B4   SW RA, 436(SP)
9D0095E8  AFB401B0   SW S4, 432(SP)
9D0095EC  AFB301AC   SW S3, 428(SP)
9D0095F0  AFB201A8   SW S2, 424(SP)
9D0095F4  AFB101A4   SW S1, 420(SP)
9D0095F8  AFB001A0   SW S0, 416(SP)
424:                     uint32_t saddr,fsize;
425:                     FRESULT result;
426:                     FIL fh;
427:                     int count, lines=0;
9D0096C4  00009821   ADDU S3, ZERO, ZERO
428:                     char prev_c=0, c=0, buffer[CHAR_PER_LINE];
429:                     reader_t r;
430:                     
431:                     clear_all_states();
9D0095FC  0F402142   JAL clear_all_states
9D009600  00808821   ADDU S1, A0, ZERO
432:                     strcpy(fname,name);
9D009604  8F908070   LW S0, -32656(GP)
9D009608  02002021   ADDU A0, S0, ZERO
9D00960C  0F406D40   JAL strcpy
9D009610  02202821   ADDU A1, S1, ZERO
433:                     result=f_open(&fh,fname,FA_READ);
9D009614  27A40010   ADDIU A0, SP, 16
9D009618  02002821   ADDU A1, S0, ZERO
9D00961C  0F4018E7   JAL f_open
9D009620  24060001   ADDIU A2, ZERO, 1
434:                     if (result){
9D009624  50400007   BEQL V0, ZERO, 0x9D009644
9D009628  8FA2001C   LW V0, 28(SP)
435:                         ed_error("File open failed!\n",result);
9D00962C  3C049D02   LUI A0, -25342
9D009630  24848808   ADDIU A0, A0, -30712
9D009634  0F40224E   JAL ed_error
9D009638  00402821   ADDU A1, V0, ZERO
436:                         return;
9D00963C  0B402602   J 0x9D009808
9D009640  8FBF01B4   LW RA, 436(SP)
437:                     }
438:                     if (fh.fsize>MAX_SIZE){
9D009644  3C030001   LUI V1, 1
9D009648  24630001   ADDIU V1, V1, 1
9D00964C  0043182B   SLTU V1, V0, V1
9D009650  14600007   BNE V1, ZERO, 0x9D009670
9D009654  3C100001   LUI S0, 1
439:                         ed_error("File too big!\n",0);
9D009658  3C049D02   LUI A0, -25342
9D00965C  2484881C   ADDIU A0, A0, -30692
9D009660  0F40224E   JAL ed_error
9D009664  00002821   ADDU A1, ZERO, ZERO
440:                         return;
9D009668  0B402602   J 0x9D009808
9D00966C  8FBF01B4   LW RA, 436(SP)
441:                     }
442:                     count=0;
9D0096C8  00008821   ADDU S1, ZERO, ZERO
443:                     saddr=MAX_SIZE-fh.fsize;
9D009670  02028023   SUBU S0, S0, V0
444:                     state->tail=saddr;
9D009674  8F828074   LW V0, -32652(GP)
9D009678  AC50000C   SW S0, 12(V0)
445:                     state->fsize=fh.fsize;
9D00967C  8FA3001C   LW V1, 28(SP)
9D009680  AC430000   SW V1, 0(V0)
446:                     print(con,"loading file...\n");
9D009684  97848062   LHU A0, -32670(GP)
9D009688  3C059D02   LUI A1, -25342
9D00968C  0F404FCC   JAL print
9D009690  24A5882C   ADDIU A1, A1, -30676
447:                     print_int(con,fsize,0);
9D009694  97848062   LHU A0, -32670(GP)
9D009698  00002821   ADDU A1, ZERO, ZERO
9D00969C  0F404FFF   JAL print_int
9D0096A0  00003021   ADDU A2, ZERO, ZERO
448:                     print(con," bytes");
9D0096A4  97848062   LHU A0, -32670(GP)
9D0096A8  3C059D02   LUI A1, -25342
9D0096AC  0F404FCC   JAL print
9D0096B0  24A58840   ADDIU A1, A1, -30656
449:                     reader_init(&r,eDEV_SDCARD,&fh);
9D0096B4  27A4008C   ADDIU A0, SP, 140
9D0096B8  24050002   ADDIU A1, ZERO, 2
9D0096BC  0F406849   JAL reader_init
9D0096C0  27A60010   ADDIU A2, SP, 16
450:                     while (!r.eof){
9D0096D0  0B4025D8   J 0x9D009760
9D0096D4  2414000D   ADDIU S4, ZERO, 13
9D009760  8FA20198   LW V0, 408(SP)
9D009764  1040FFDC   BEQ V0, ZERO, 0x9D0096D8
9D009768  00000000   NOP
451:                         c=reader_getc(&r);
9D0096D8  0F40684F   JAL reader_getc
9D0096DC  27A4008C   ADDIU A0, SP, 140
452:                         switch(c){
9D0096CC  2412000A   ADDIU S2, ZERO, 10
9D0096E0  50520013   BEQL V0, S2, 0x9D009730
9D0096E4  2402004F   ADDIU V0, ZERO, 79
9D0096E8  1054000D   BEQ V0, S4, 0x9D009720
9D0096EC  2403FFFF   ADDIU V1, ZERO, -1
9D0096F0  1043000B   BEQ V0, V1, 0x9D009720
9D0096F4  28430020   SLTI V1, V0, 32
453:                             case -1:
454:                             case A_CR:
455:                                 break;
456:                             case A_LF:
457:                                break;
458:                             default:
459:                                 if (c>=32 && c<(32+FONT_SIZE)) buffer[count++]=c; else buffer[count++]=' ';
9D0096F8  14600005   BNE V1, ZERO, 0x9D009710
9D0096FC  27A40010   ADDIU A0, SP, 16
9D009700  00911821   ADDU V1, A0, S1
9D009704  A062002C   SB V0, 44(V1)
9D009708  0B4025C8   J 0x9D009720
9D00970C  26310001   ADDIU S1, S1, 1
9D009710  00911821   ADDU V1, A0, S1
9D009714  24040020   ADDIU A0, ZERO, 32
9D009718  A064002C   SB A0, 44(V1)
9D00971C  26310001   ADDIU S1, S1, 1
460:                         }//switch(c)
461:                         if ((c==A_LF) || (count==(CHAR_PER_LINE-1))){
9D009720  10520003   BEQ V0, S2, 0x9D009730
9D009724  2402004F   ADDIU V0, ZERO, 79
9D009728  1622000E   BNE S1, V0, 0x9D009764
9D00972C  8FA20198   LW V0, 408(SP)
462:                             buffer[count++]=A_LF;
9D009730  27A30010   ADDIU V1, SP, 16
9D009734  00711021   ADDU V0, V1, S1
9D009738  2403000A   ADDIU V1, ZERO, 10
9D00973C  A043002C   SB V1, 44(V0)
9D009744  26310001   ADDIU S1, S1, 1
463:                             lines++;
9D009740  26730001   ADDIU S3, S3, 1
464:                             sram_write_block(saddr,(uint8_t*)buffer,count);
9D009748  02002021   ADDU A0, S0, ZERO
9D00974C  27A5003C   ADDIU A1, SP, 60
9D009750  0F404EA1   JAL sram_write_block
9D009754  02203021   ADDU A2, S1, ZERO
465:                             saddr+=count;
9D009758  02118021   ADDU S0, S0, S1
466:                             count=0;
9D00975C  00008821   ADDU S1, ZERO, ZERO
467:                         }
468:                         prev_c=c;
469:                     }//while
470:                     if (count){
9D00976C  12200008   BEQ S1, ZERO, 0x9D009790
9D009770  27A4003C   ADDIU A0, SP, 60
471:                         sram_write_block(saddr,(uint8_t*)buffer,count);
9D009774  02002021   ADDU A0, S0, ZERO
9D009778  27A5003C   ADDIU A1, SP, 60
9D00977C  0F404EA1   JAL sram_write_block
9D009780  02203021   ADDU A2, S1, ZERO
472:                         saddr+=count;
9D009784  02308021   ADDU S0, S1, S0
473:                         lines++;
9D009788  26730001   ADDIU S3, S3, 1
474:                     }
475:                     memset(buffer,' ',CHAR_PER_LINE);
9D00978C  27A4003C   ADDIU A0, SP, 60
9D009790  24050020   ADDIU A1, ZERO, 32
9D009794  0F40775D   JAL memset
9D009798  24060050   ADDIU A2, ZERO, 80
476:                     while (saddr<MAX_SIZE){
9D00979C  3C020001   LUI V0, 1
9D0097A0  0202102B   SLTU V0, S0, V0
9D0097A4  1040000D   BEQ V0, ZERO, 0x9D0097DC
9D0097A8  3C120001   LUI S2, 1
9D0097D0  0212102B   SLTU V0, S0, S2
9D0097D4  1440FFF7   BNE V0, ZERO, 0x9D0097B4
9D0097D8  02508823   SUBU S1, S2, S0
477:                         count=min(CHAR_PER_LINE,MAX_SIZE-saddr);
9D0097AC  24140050   ADDIU S4, ZERO, 80
9D0097B0  02508823   SUBU S1, S2, S0
9D0097B4  2E220051   SLTIU V0, S1, 81
9D0097B8  0282880A   MOVZ S1, S4, V0
478:                         sram_write_block(saddr,(uint8_t*)buffer,count);
9D0097BC  02002021   ADDU A0, S0, ZERO
9D0097C0  27A5003C   ADDIU A1, SP, 60
9D0097C4  0F404EA1   JAL sram_write_block
9D0097C8  02203021   ADDU A2, S1, ZERO
479:                         saddr+=count;
9D0097CC  02118021   ADDU S0, S0, S1
480:                     }
481:                     f_close(&fh);
9D0097DC  0F401BC6   JAL f_close
9D0097E0  27A40010   ADDIU A0, SP, 16
482:                     state->lines_count=lines;
9D0097E4  8F828074   LW V0, -32652(GP)
483:                     fill_screen();
9D0097E8  0F40238E   JAL fill_screen
9D0097EC  AC530018   SW S3, 24(V0)
484:                     state->flags.update=true;
9D0097F0  8F828074   LW V0, -32652(GP)
9D0097F4  9043001C   LBU V1, 28(V0)
9D0097F8  24040001   ADDIU A0, ZERO, 1
9D0097FC  7C8318C4   INS V1, A0, 3, 1
9D009800  A043001C   SB V1, 28(V0)
485:                 }//f()
9D009804  8FBF01B4   LW RA, 436(SP)
9D009808  8FB401B0   LW S4, 432(SP)
9D00980C  8FB301AC   LW S3, 428(SP)
9D009810  8FB201A8   LW S2, 424(SP)
9D009814  8FB101A4   LW S1, 420(SP)
9D009818  8FB001A0   LW S0, 416(SP)
9D00981C  03E00008   JR RA
9D009820  27BD01B8   ADDIU SP, SP, 440
486:                 
487:                 bool file_exist(const char *name){
9D0088F0  27BDFFB8   ADDIU SP, SP, -72
9D0088F4  AFBF0044   SW RA, 68(SP)
9D0088F8  AFB00040   SW S0, 64(SP)
488:                     FIL fh;
489:                     FRESULT result;
490:                     
491:                     if (!name) return false;
9D0088E8  1080000D   BEQ A0, ZERO, 0x9D008920
9D0088EC  00802821   ADDU A1, A0, ZERO
9D008920  03E00008   JR RA
9D008924  00001021   ADDU V0, ZERO, ZERO
492:                     result=f_open(&fh,name,FA_READ);
9D0088FC  27A40010   ADDIU A0, SP, 16
9D008900  0F4018E7   JAL f_open
9D008904  24060001   ADDIU A2, ZERO, 1
493:                     if (!result) f_close(&fh);
9D008908  14400003   BNE V0, ZERO, 0x9D008918
9D00890C  00408021   ADDU S0, V0, ZERO
9D008910  0F401BC6   JAL f_close
9D008914  27A40010   ADDIU A0, SP, 16
494:                     return !result;
9D008918  0B40224A   J 0x9D008928
9D00891C  2E020001   SLTIU V0, S0, 1
495:                 }// file_exist()
9D008928  8FBF0044   LW RA, 68(SP)
9D00892C  8FB00040   LW S0, 64(SP)
9D008930  03E00008   JR RA
9D008934  27BD0048   ADDIU SP, SP, 72
496:                 
497:                 static void open_file(){
498:                     FIL fh;
499:                     FRESULT result;
500:                     char name[32];
501:                 
502:                     if (ask_confirm()){
9D00ABDC  0F402187   JAL ask_confirm
9D00ABE0  00000000   NOP
9D00ABE4  1040003A   BEQ V0, ZERO, 0x9D00ACD0
9D00ABE8  93828068   LBU V0, -32664(GP)
503:                         invert_display(true);
9D00ABEC  0F40212D   JAL invert_display
9D00ABF0  24040001   ADDIU A0, ZERO, 1
504:                         print(con,"open file\n");
9D009DD4  3C169D02   LUI S6, -25342
9D009DD8  26D688F0   ADDIU S6, S6, -30480
9D00ABF4  97848062   LHU A0, -32670(GP)
9D00ABF8  0F404FCC   JAL print
9D00ABFC  02C02821   ADDU A1, S6, ZERO
505:                         if (get_file_name(name) && file_exist(name)){
9D00AC00  0F402220   JAL get_file_name
9D00AC04  27A40018   ADDIU A0, SP, 24
9D00AC08  10400009   BEQ V0, ZERO, 0x9D00AC30
9D00AC0C  3C049D02   LUI A0, -25342
9D00AC10  0F40223A   JAL file_exist
9D00AC14  27A40018   ADDIU A0, SP, 24
9D00AC18  10400005   BEQ V0, ZERO, 0x9D00AC30
9D00AC1C  3C049D02   LUI A0, -25342
506:                                 load_file(name);
9D00AC20  0F402578   JAL load_file
9D00AC24  27A40018   ADDIU A0, SP, 24
9D00AC28  0B402B0F   J 0x9D00AC3C
9D00AC2C  00000000   NOP
507:                         }else{
508:                                 ed_error("failed to open file.",result);
9D00AC30  248488FC   ADDIU A0, A0, -30468
9D00AC34  0F40224E   JAL ed_error
9D00AC38  00002821   ADDU A1, ZERO, ZERO
509:                         }
510:                         
511:                         invert_display(false);
9D00AC3C  0F40212D   JAL invert_display
9D00AC40  00002021   ADDU A0, ZERO, ZERO
512:                     }
513:                 }//open_file()
514:                 
515:                 
516:                 static void save_file(){
9D009B78  27BDFF28   ADDIU SP, SP, -216
9D009B7C  AFBF00D4   SW RA, 212(SP)
9D009B80  AFB100D0   SW S1, 208(SP)
9D009B84  AFB000CC   SW S0, 204(SP)
517:                 #define BUFFER_SIZE 128
518:                     uint8_t buffer[BUFFER_SIZE];
519:                     int size;
520:                     uint32_t saddr=0;
9D009B88  AFA00094   SW ZERO, 148(SP)
521:                     FRESULT result;
522:                     FIL fh;
523:                 
524:                     if (!strlen(fname)){
9D009B8C  8F858070   LW A1, -32656(GP)
9D009B90  80A20000   LB V0, 0(A1)
9D009B94  54400005   BNEL V0, ZERO, 0x9D009BAC
9D009B98  27A40098   ADDIU A0, SP, 152
525:                         save_file_as();
9D009B9C  0F40273C   JAL save_file_as
9D009BA0  00000000   NOP
9D009BA4  0B402738   J 0x9D009CE0
9D009BA8  8FBF00D4   LW RA, 212(SP)
526:                     }else{
527:                         if ((result=f_open(&fh,fname,FA_WRITE+FA_CREATE_ALWAYS))){
9D009BAC  0F4018E7   JAL f_open
9D009BB0  2406000A   ADDIU A2, ZERO, 10
9D009BB4  1040000B   BEQ V0, ZERO, 0x9D009BE4
9D009BB8  00408021   ADDU S0, V0, ZERO
528:                             sprintf(buffer,"Failed to create '%s' file\r",fname);
9D009BBC  27A40010   ADDIU A0, SP, 16
9D009BC0  3C059D02   LUI A1, -25342
9D009BC4  24A58848   ADDIU A1, A1, -30648
9D009BC8  0F407973   JAL _sprintf_cdnopsuxX
9D009BCC  8F868070   LW A2, -32656(GP)
529:                             ed_error(buffer,result);
9D009BD0  27A40010   ADDIU A0, SP, 16
9D009BD4  0F40224E   JAL ed_error
9D009BD8  02002821   ADDU A1, S0, ZERO
530:                             return;
9D009BDC  0B402738   J 0x9D009CE0
9D009BE0  8FBF00D4   LW RA, 212(SP)
531:                         }
532:                         invert_display(true);
9D009BE4  0F40212D   JAL invert_display
9D009BE8  24040001   ADDIU A0, ZERO, 1
533:                         print(con,"saving file...\n");
9D009BEC  97848062   LHU A0, -32670(GP)
9D009BF0  3C059D02   LUI A1, -25342
9D009BF4  0F404FCC   JAL print
9D009BF8  24A58864   ADDIU A1, A1, -30620
534:                         saddr=0;
9D009BFC  AFA00094   SW ZERO, 148(SP)
535:                         while ((result==FR_OK) && (saddr < MAX_SIZE)){
9D009C34  14400008   BNE V0, ZERO, 0x9D009C58
9D009C38  00408021   ADDU S0, V0, ZERO
9D009C3C  3C020001   LUI V0, 1
9D009C40  8FA30094   LW V1, 148(SP)
9D009C44  0062102B   SLTU V0, V1, V0
9D009C48  5440FFEF   BNEL V0, ZERO, 0x9D009C08
9D009C4C  27A40010   ADDIU A0, SP, 16
9D009C50  0B40271E   J 0x9D009C78
9D009C54  00000000   NOP
536:                             size=get_line(buffer,&saddr);
9D009C04  27A40010   ADDIU A0, SP, 16
9D009C08  0F40232E   JAL get_line
9D009C0C  27A50094   ADDIU A1, SP, 148
9D009C10  AFA20090   SW V0, 144(SP)
537:                             buffer[size]=A_CR;
9D009C00  2411000D   ADDIU S1, ZERO, 13
9D009C14  27A40010   ADDIU A0, SP, 16
9D009C18  00821821   ADDU V1, A0, V0
9D009C1C  A0710000   SB S1, 0(V1)
538:                             result=f_write(&fh,buffer,size+1,&size);
9D009C20  27A40098   ADDIU A0, SP, 152
9D009C24  27A50010   ADDIU A1, SP, 16
9D009C28  24460001   ADDIU A2, V0, 1
9D009C2C  0F401AAC   JAL f_write
9D009C30  27A70090   ADDIU A3, SP, 144
539:                         }
540:                         f_close(&fh);
9D009C58  0F401BC6   JAL f_close
9D009C5C  27A40098   ADDIU A0, SP, 152
9D009C78  0F401BC6   JAL f_close
9D009C7C  27A40098   ADDIU A0, SP, 152
541:                         if (result){
542:                             ed_error("diksI/O error...\n",result);
9D009C60  3C049D02   LUI A0, -25342
9D009C64  24848874   ADDIU A0, A0, -30604
9D009C68  0F40224E   JAL ed_error
9D009C6C  02002821   ADDU A1, S0, ZERO
543:                             return;
9D009C70  0B402738   J 0x9D009CE0
9D009C74  8FBF00D4   LW RA, 212(SP)
544:                         }
545:                         state->flags.modified=false;
9D009C80  8F828074   LW V0, -32652(GP)
9D009C84  9043001C   LBU V1, 28(V0)
9D009C88  7C030844   INS V1, ZERO, 1, 1
546:                         state->flags.new=0;
9D009C8C  7C031084   INS V1, ZERO, 2, 1
9D009C90  A043001C   SB V1, 28(V0)
547:                         crlf(con);
9D009C94  0F404FF3   JAL crlf
9D009C98  97848062   LHU A0, -32670(GP)
548:                         print(con,fname);
9D009C9C  97848062   LHU A0, -32670(GP)
9D009CA0  0F404FCC   JAL print
9D009CA4  8F858070   LW A1, -32656(GP)
549:                         print(con," saved, size: ");
9D009CA8  97848062   LHU A0, -32670(GP)
9D009CAC  3C059D02   LUI A1, -25342
9D009CB0  0F404FCC   JAL print
9D009CB4  24A58888   ADDIU A1, A1, -30584
550:                         print_int(con,state->fsize,0);
9D009CB8  97848062   LHU A0, -32670(GP)
9D009CBC  8F828074   LW V0, -32652(GP)
9D009CC0  8C450000   LW A1, 0(V0)
9D009CC4  0F404FFF   JAL print_int
9D009CC8  00003021   ADDU A2, ZERO, ZERO
551:                         prompt_continue();
9D009CCC  0F40217C   JAL prompt_continue
9D009CD0  00000000   NOP
552:                         invert_display(false);
9D009CD4  0F40212D   JAL invert_display
9D009CD8  00002021   ADDU A0, ZERO, ZERO
553:                     }
554:                 }//f()
9D009CDC  8FBF00D4   LW RA, 212(SP)
9D009CE0  8FB100D0   LW S1, 208(SP)
9D009CE4  8FB000CC   LW S0, 204(SP)
9D009CE8  03E00008   JR RA
9D009CEC  27BD00D8   ADDIU SP, SP, 216
555:                 
556:                 static void save_file_as(){
9D009CF0  27BDFFC8   ADDIU SP, SP, -56
9D009CF4  AFBF0034   SW RA, 52(SP)
557:                     char name[32];
558:                 
559:                     if (get_file_name(name)){
9D009CF8  0F402220   JAL get_file_name
9D009CFC  27A40010   ADDIU A0, SP, 16
9D009D00  10400008   BEQ V0, ZERO, 0x9D009D24
9D009D04  83A20010   LB V0, 16(SP)
560:                         if (strlen(name)){
9D009D08  10400007   BEQ V0, ZERO, 0x9D009D28
9D009D0C  8FBF0034   LW RA, 52(SP)
561:                             strcpy(fname,name);
9D009D10  8F848070   LW A0, -32656(GP)
9D009D14  0F406D40   JAL strcpy
9D009D18  27A50010   ADDIU A1, SP, 16
562:                             save_file();
9D009D1C  0F4026DE   JAL save_file
9D009D20  00000000   NOP
563:                         }
564:                     }
565:                 }//f()
9D009D24  8FBF0034   LW RA, 52(SP)
9D009D28  03E00008   JR RA
9D009D2C  27BD0038   ADDIU SP, SP, 56
566:                 
567:                 
568:                 const char* hkeys[]={
569:                   "<CTRL-DEL> delete to end of line\n",
570:                   "<CTRL-A> save as\n",
571:                   "<CTRL-END> file end\n",
572:                   "<CTRL-F> list SDcard files\n",
573:                   "<CTRL-G> goto line...\n",
574:                   "<CTRL-HOME> file start\n",
575:                   "<CTRL_LEFT> word left\n",
576:                   "<CTRL-N> new file...\n",
577:                   "<CTRL-O> open file...\n",
578:                   "<CTRL-Q> Quit editor\n",
579:                   "<CTRL-RIGHT> word right\n",
580:                   "<CTRL-S> save file\n",
581:                   "<F1> display hotkeys\n",
582:                   "<F3> set search criterion\n",
583:                   "<F4> search next\n",
584:                   ""
585:                 };
586:                 
587:                 //affiche les touches d'action
588:                 static void hot_keys(){
589:                     int i=0;
590:                 
591:                     invert_display(true);
9D00A848  0F40212D   JAL invert_display
9D00A84C  24040001   ADDIU A0, ZERO, 1
592:                     clear_screen(con);
9D00A850  0F404F63   JAL clear_screen
9D00A854  97848062   LHU A0, -32670(GP)
593:                     while (strlen(hkeys[i])){    
9D00A858  3C02A000   LUI V0, -24576
9D00A85C  8C454454   LW A1, 17492(V0)
9D00A860  80A20000   LB V0, 0(A1)
9D00A864  10400009   BEQ V0, ZERO, 0x9D00A88C
9D00A868  00000000   NOP
9D00A86C  3C14A000   LUI S4, -24576
9D00A870  26944458   ADDIU S4, S4, 17496
9D00A87C  8E850000   LW A1, 0(S4)
9D00A880  80A20000   LB V0, 0(A1)
9D00A884  1440FFFB   BNE V0, ZERO, 0x9D00A874
9D00A888  26940004   ADDIU S4, S4, 4
594:                         print(con,hkeys[i++]);
9D00A874  0F404FCC   JAL print
9D00A878  97848062   LHU A0, -32670(GP)
595:                     }
596:                     crlf(con);
9D00A88C  0F404FF3   JAL crlf
9D00A890  97848062   LHU A0, -32670(GP)
597:                     prompt_continue();
9D00A894  0F40217C   JAL prompt_continue
9D00A898  00000000   NOP
598:                     invert_display(false);
9D00A89C  0F40212D   JAL invert_display
9D00A8A0  00002021   ADDU A0, ZERO, ZERO
599:                 }
600:                 
601:                 static void editor_init(const char *file_name){
602:                     clear_screen(con);
9D009D60  0F404F63   JAL clear_screen
603:                     screen=malloc(SCREEN_SIZE);
9D009D68  0F4064A8   JAL malloc
604:                     search_info=malloc(sizeof(search_t));
9D009D74  0F4064A8   JAL malloc
605:                     state=malloc(sizeof(ed_state_t));
9D009D80  0F4064A8   JAL malloc
606:                     fname=malloc(NAME_MAX_LEN);
9D009D8C  0F4064A8   JAL malloc
607:                     clear_all_states();
9D009D94  0F402142   JAL clear_all_states
608:                     invert_video(con,false);
9D009D9C  97848062   LHU A0, -32670(GP)
609:                     vga_set_cursor(CR_UNDER);
9D009DA8  0F403BF3   JAL vga_set_cursor
610:                     new_file(file_name);
9D009DB0  0F402609   JAL new_file
611:                 }//f()
612:                 
613:                 
614:                 void editor(const char* file_name){
9D009D30  27BDFF68   ADDIU SP, SP, -152
9D009D34  AFBF0094   SW RA, 148(SP)
9D009D38  AFBE0090   SW S8, 144(SP)
9D009D3C  AFB7008C   SW S7, 140(SP)
9D009D40  AFB60088   SW S6, 136(SP)
9D009D44  AFB50084   SW S5, 132(SP)
9D009D48  AFB40080   SW S4, 128(SP)
9D009D4C  AFB3007C   SW S3, 124(SP)
9D009D50  AFB20078   SW S2, 120(SP)
9D009D54  AFB10074   SW S1, 116(SP)
9D009D58  AFB00070   SW S0, 112(SP)
9D009D5C  00808021   ADDU S0, A0, ZERO
615:                     unsigned char key;
616:                     FATFS fh;
617:                     FRESULT result;
618:                     
619:                     editor_init(file_name);
620:                     quit=false;
9D009DB8  A3808068   SB ZERO, -32664(GP)
621:                     while(!quit){
9D00A318  0B402B34   J 0x9D00ACD0
9D00A31C  93828068   LBU V0, -32664(GP)
9D00A448  0B402B34   J 0x9D00ACD0
9D00A44C  93828068   LBU V0, -32664(GP)
9D00A4B4  0B402B34   J 0x9D00ACD0
9D00A4B8  93828068   LBU V0, -32664(GP)
9D00A540  0B402B34   J 0x9D00ACD0
9D00A544  93828068   LBU V0, -32664(GP)
9D00A58C  0B402B34   J 0x9D00ACD0
9D00A590  93828068   LBU V0, -32664(GP)
9D00A62C  0B402B34   J 0x9D00ACD0
9D00A630  93828068   LBU V0, -32664(GP)
9D00A63C  0B402B34   J 0x9D00ACD0
9D00A640  93828068   LBU V0, -32664(GP)
9D00A6EC  0B402B34   J 0x9D00ACD0
9D00A6F0  93828068   LBU V0, -32664(GP)
9D00A75C  0B402B34   J 0x9D00ACD0
9D00A760  93828068   LBU V0, -32664(GP)
9D00A7BC  0B402B34   J 0x9D00ACD0
9D00A7C0  93828068   LBU V0, -32664(GP)
9D00A82C  0B402B34   J 0x9D00ACD0
9D00A830  93828068   LBU V0, -32664(GP)
9D00A840  0B402B34   J 0x9D00ACD0
9D00A844  93828068   LBU V0, -32664(GP)
9D00A8A4  0B402B34   J 0x9D00ACD0
9D00A8A8  93828068   LBU V0, -32664(GP)
9D00AA10  0B402B34   J 0x9D00ACD0
9D00AA14  93828068   LBU V0, -32664(GP)
9D00AA50  0B402B34   J 0x9D00ACD0
9D00AA54  93828068   LBU V0, -32664(GP)
9D00AA70  0B402B34   J 0x9D00ACD0
9D00AA74  93828068   LBU V0, -32664(GP)
9D00AAB8  0B402B34   J 0x9D00ACD0
9D00AABC  93828068   LBU V0, -32664(GP)
9D00AAC8  0B402B34   J 0x9D00ACD0
9D00AACC  93828068   LBU V0, -32664(GP)
9D00AB00  0B402B34   J 0x9D00ACD0
9D00AB04  93828068   LBU V0, -32664(GP)
9D00ABC4  0B402B34   J 0x9D00ACD0
9D00ABC8  93828068   LBU V0, -32664(GP)
9D00AC44  0B402B34   J 0x9D00ACD0
9D00AC48  93828068   LBU V0, -32664(GP)
9D00ACCC  93828068   LBU V0, -32664(GP)
9D00ACD0  1040FC45   BEQ V0, ZERO, 0x9D009DE8
9D00ACD4  8F828074   LW V0, -32652(GP)
622:                         if (state->flags.update){
9D009DE4  8F828074   LW V0, -32652(GP)
9D009DE8  8C42001C   LW V0, 28(V0)
9D009DEC  30420008   ANDI V0, V0, 8
9D009DF0  10400004   BEQ V0, ZERO, 0x9D009E04
9D009DF4  97848062   LHU A0, -32670(GP)
623:                             update_display();
9D009DF8  0F402160   JAL update_display
9D009DFC  00000000   NOP
624:                         }
625:                         update_status_line();
626:                         key=wait_key(con);
9D009EB4  0F404F87   JAL wait_key
9D009EB8  97848062   LHU A0, -32670(GP)
627:                         //print_int(SERIAL_CONSOLE,key,0);
628:                         switch(key){
9D009DCC  3C139D01   LUI S3, -25343
9D009DD0  26739ED8   ADDIU S3, S3, -24872
9D009EBC  2C4300C0   SLTIU V1, V0, 192
9D009EC0  10600377   BEQ V1, ZERO, 0x9D00ACA0
9D009EC4  00021880   SLL V1, V0, 2
9D009EC8  02631821   ADDU V1, S3, V1
9D009ECC  8C630000   LW V1, 0(V1)
9D009ED0  00600008   JR V1
9D009ED4  00000000   NOP
629:                             case VK_UP:
630:                                 line_up();
9D00A1F0  0F402401   JAL line_up
9D00A1F4  00000000   NOP
631:                                 break;
9D00A1F8  0B402B34   J 0x9D00ACD0
9D00A1FC  93828068   LBU V0, -32664(GP)
632:                             case VK_DOWN:
633:                                 line_down();
9D00A200  0F40245A   JAL line_down
9D00A204  00000000   NOP
634:                                 break;
9D00A208  0B402B34   J 0x9D00ACD0
9D00A20C  93828068   LBU V0, -32664(GP)
635:                             case VK_LEFT:
636:                                 char_left();
9D00A210  0F4023C2   JAL char_left
9D00A214  00000000   NOP
637:                                 break;
9D00A218  0B402B34   J 0x9D00ACD0
9D00A21C  93828068   LBU V0, -32664(GP)
638:                             case VK_CLEFT:
639:                                 word_left();
640:                                 break;
641:                             case VK_RIGHT:
642:                                 char_right();
9D00A320  0F402416   JAL char_right
9D00A324  00000000   NOP
643:                                 break;
9D00A328  0B402B34   J 0x9D00ACD0
9D00A32C  93828068   LBU V0, -32664(GP)
644:                             case VK_CRIGHT:
645:                                 word_right();
646:                                 break;
647:                             case VK_HOME:
648:                                 line_home();
9D00A418  0F4022B9   JAL line_home
9D00A41C  00000000   NOP
649:                                 break;
9D00A420  0B402B34   J 0x9D00ACD0
9D00A424  93828068   LBU V0, -32664(GP)
650:                             case VK_CHOME:
651:                                 file_home();
652:                                 break;
653:                             case VK_END:
654:                                 line_end();
9D00A450  0F40230A   JAL line_end
9D00A454  00000000   NOP
655:                                 break;
9D00A458  0B402B34   J 0x9D00ACD0
9D00A45C  93828068   LBU V0, -32664(GP)
656:                             case VK_CEND:
657:                                 file_end();
9D00A460  0F402486   JAL file_end
9D00A464  00000000   NOP
658:                                 break;
9D00A468  0B402B34   J 0x9D00ACD0
9D00A46C  93828068   LBU V0, -32664(GP)
659:                             case VK_PGUP:
660:                                 page_up();
661:                                 break;
662:                             case VK_PGDN:
663:                                 page_down();
664:                                 break;
665:                             case VK_INSERT:
666:                                 state->flags.insert=~state->flags.insert;
9D00A548  8F828074   LW V0, -32652(GP)
9D00A54C  8C44001C   LW A0, 28(V0)
9D00A550  7C840000   EXT A0, A0, 0, 1
9D00A554  00042027   NOR A0, ZERO, A0
9D00A558  9043001C   LBU V1, 28(V0)
9D00A55C  7C830004   INS V1, A0, 0, 1
9D00A560  A043001C   SB V1, 28(V0)
667:                                 if (state->flags.insert){
9D00A564  8C42001C   LW V0, 28(V0)
9D00A568  30420001   ANDI V0, V0, 1
9D00A56C  10400005   BEQ V0, ZERO, 0x9D00A584
9D00A570  00000000   NOP
668:                                     vga_set_cursor(CR_UNDER);
9D00A574  0F403BF3   JAL vga_set_cursor
9D00A578  00002021   ADDU A0, ZERO, ZERO
9D00A57C  0B402B34   J 0x9D00ACD0
9D00A580  93828068   LBU V0, -32664(GP)
669:                                 }else{
670:                                     vga_set_cursor(CR_BLOCK);
9D00A584  0F403BF3   JAL vga_set_cursor
9D00A588  24040001   ADDIU A0, ZERO, 1
671:                                 }
672:                                 break;
673:                             case VK_TAB:
674:                                 insert_tabulation();
675:                                 break;
676:                             case VK_DELETE:
677:                                 delete_at();
9D00A604  0F40249B   JAL delete_at
9D00A608  00000000   NOP
678:                                 break;
9D00A60C  0B402B34   J 0x9D00ACD0
9D00A610  93828068   LBU V0, -32664(GP)
679:                             case VK_BACK:
680:                                 delete_left();
681:                                 break;
682:                             case VK_SDEL: //<SHIFT>+<DELETE>
683:                                 delete_to_start();
684:                                 break;
685:                             case VK_CDEL: // <CTRL>+<DELETE>
686:                                 delete_to_end();
687:                                 break;
688:                             case VK_ENTER:
689:                                 line_break();
690:                                 break;
691:                             case VK_F1: // display hotkeys
692:                                 hot_keys();
693:                                 break;
694:                             case VK_F3: // search string
695:                                 search();
696:                                 break;
697:                             case VK_F4: // search next occurance
698:                                 search_next();
9D00AB08  0F40265D   JAL search_next
9D00AB0C  00000000   NOP
699:                                 break;
9D00AB10  0B402B34   J 0x9D00ACD0
9D00AB14  93828068   LBU V0, -32664(GP)
700:                             case VK_CA: // <CTRL>-A  sauvegarde sous...
701:                                 save_file_as();
9D00AB18  0F40273C   JAL save_file_as
9D00AB1C  00000000   NOP
702:                                 break;
9D00AB20  0B402B34   J 0x9D00ACD0
9D00AB24  93828068   LBU V0, -32664(GP)
703:                             case VK_CF: // <CTRL>-F liste des fichiers
704:                                 list_files();
705:                                 break;
706:                             case VK_CG:// <CTRL>-G  va à la ligne
707:                                 goto_line();
708:                                 break;
709:                             case VK_CN: // <CTRL>-N  nouveau fichier
710:                                 new_file(NULL);
9D00ABCC  0F402609   JAL new_file
9D00ABD0  00002021   ADDU A0, ZERO, ZERO
711:                                 break;
9D00ABD4  0B402B34   J 0x9D00ACD0
9D00ABD8  93828068   LBU V0, -32664(GP)
712:                             case VK_CO: // <CTRL>-O  ouvrir un fichier
713:                                 open_file();
714:                                 break;
715:                             case VK_CQ: // <CTRL>-Q  quitter
716:                                 leave_editor();
717:                                 break;
718:                             case VK_CS: // <CTRL>-S  sauvegarde
719:                                 save_file();
9D00AC90  0F4026DE   JAL save_file
9D00AC94  00000000   NOP
720:                                 break;
9D00AC98  0B402B34   J 0x9D00ACD0
9D00AC9C  93828068   LBU V0, -32664(GP)
721:                             default:
722:                                 if ((key>=32)&(key<FONT_SIZE+32)){
9D00ACA0  2443FFE0   ADDIU V1, V0, -32
9D00ACA4  306300FF   ANDI V1, V1, 255
9D00ACA8  2C630060   SLTIU V1, V1, 96
9D00ACAC  10600005   BEQ V1, ZERO, 0x9D00ACC4
9D00ACB0  240401F4   ADDIU A0, ZERO, 500
723:                                     insert_char(key);
9D00ACB4  0F402627   JAL insert_char
9D00ACB8  7C022420   SEB A0, V0
9D00ACBC  0B402B34   J 0x9D00ACD0
9D00ACC0  93828068   LBU V0, -32664(GP)
724:                                 }else{
725:                                     _beep();
9D00ACC4  0F406085   JAL tone
9D00ACC8  24050064   ADDIU A1, ZERO, 100
726:                                 }
727:                             }//switch
728:                     }//while
729:                     invert_video(con,false);
9D00ACD8  97848062   LHU A0, -32670(GP)
9D00ACDC  0F404FE7   JAL invert_video
9D00ACE0  00002821   ADDU A1, ZERO, ZERO
730:                     clear_screen(con);
9D00ACE4  0F404F63   JAL clear_screen
9D00ACE8  97848062   LHU A0, -32670(GP)
731:                 }//editor()
9D00ACEC  8FBF0094   LW RA, 148(SP)
732:                 
733:                 /**************************************/
734:                 /* OPRÉATIONS SUR LA MÉMOIRE SPI RAM  */
735:                 /**************************************/
736:                 
737:                 // char sram_get_char()
738:                 // retourne le caractère à la position du curseur.
739:                 static char sram_get_char(){
9D00874C  27BDFFE8   ADDIU SP, SP, -24
9D008750  AFBF0014   SW RA, 20(SP)
740:                     if (state->tail<MAX_SIZE){
9D008754  8F828074   LW V0, -32652(GP)
9D008758  8C44000C   LW A0, 12(V0)
9D00875C  3C030001   LUI V1, 1
9D008760  0083182B   SLTU V1, A0, V1
9D008764  10600004   BEQ V1, ZERO, 0x9D008778
9D008768  00001021   ADDU V0, ZERO, ZERO
741:                         return sram_read_byte(state->tail);
9D00876C  0F404E5B   JAL sram_read_byte
9D008770  00000000   NOP
9D008774  7C021420   SEB V0, V0
742:                     }else{
743:                         return 0;
744:                     }
745:                 }// char sram_get_char()
9D008778  8FBF0014   LW RA, 20(SP)
9D00877C  03E00008   JR RA
9D008780  27BD0018   ADDIU SP, SP, 24
746:                 
747:                 
748:                 //bool sram_insert_char(char c)
749:                 // insère ou remplace un caractère à la position du curseur.
750:                 // met à jour les états: fsize, tail et gap_first.
751:                 // Retourne vrai s'il y a de l'espace sinon retourne faux.
752:                 static bool sram_insert_char(char c){
9D008784  27BDFFE0   ADDIU SP, SP, -32
9D008788  AFBF001C   SW RA, 28(SP)
9D00878C  AFB10018   SW S1, 24(SP)
9D008790  AFB00014   SW S0, 20(SP)
753:                     bool result=true;
9D008860  0B40221B   J 0x9D00886C
9D008864  24020001   ADDIU V0, ZERO, 1
754:                     char tail_char;
755:                     int llen;
756:                     
757:                     if ((state->flags.insert && (state->fsize==MAX_SIZE))){
9D008794  8F908074   LW S0, -32652(GP)
9D008798  8E02001C   LW V0, 28(S0)
9D00879C  30420001   ANDI V0, V0, 1
9D0087A0  1040001B   BEQ V0, ZERO, 0x9D008810
9D0087A4  00808821   ADDU S1, A0, ZERO
9D0087A8  8E030000   LW V1, 0(S0)
9D0087AC  3C020001   LUI V0, 1
9D0087B0  1062002D   BEQ V1, V0, 0x9D008868
9D0087B4  8F8480CC   LW A0, -32564(GP)
758:                         result=false;
9D008868  00001021   ADDU V0, ZERO, ZERO
759:                     }else if (state->flags.insert){
760:                         llen=strlen(_screen_line(state->scr_line));
9D0087B8  82020010   LB V0, 16(S0)
9D0087BC  00021900   SLL V1, V0, 4
9D0087C0  00021180   SLL V0, V0, 6
9D0087C4  00621021   ADDU V0, V1, V0
9D0087C8  0F406EC2   JAL strlen
9D0087CC  00822021   ADDU A0, A0, V0
761:                         if ((llen<LINE_MAX_LEN)||(c==A_LF)){
9D0087D0  2842004F   SLTI V0, V0, 79
9D0087D4  14400003   BNE V0, ZERO, 0x9D0087E4
9D0087D8  2403000A   ADDIU V1, ZERO, 10
9D0087DC  16230024   BNE S1, V1, 0x9D008870
9D0087E0  8FBF001C   LW RA, 28(SP)
762:                             sram_write_byte(state->gap_first++,c);
9D0087E4  8E040008   LW A0, 8(S0)
9D0087E8  24820001   ADDIU V0, A0, 1
9D0087EC  AE020008   SW V0, 8(S0)
9D0087F0  0F404E6C   JAL sram_write_byte
9D0087F4  322500FF   ANDI A1, S1, 255
763:                             state->fsize++;
9D0087F8  8F828074   LW V0, -32652(GP)
9D0087FC  8C430000   LW V1, 0(V0)
9D008800  24630001   ADDIU V1, V1, 1
9D008804  AC430000   SW V1, 0(V0)
9D008808  0B40221B   J 0x9D00886C
9D00880C  24020001   ADDIU V0, ZERO, 1
764:                         }else{
765:                             result=false;
766:                         }
767:                     }else{
768:                         tail_char=sram_get_char();
9D008810  0F4021D3   JAL sram_get_char
9D008814  00000000   NOP
769:                         sram_write_byte(state->gap_first++,c);
9D008818  8F828074   LW V0, -32652(GP)
9D00881C  8C440008   LW A0, 8(V0)
9D008820  24830001   ADDIU V1, A0, 1
9D008824  AC430008   SW V1, 8(V0)
9D008828  0F404E6C   JAL sram_write_byte
9D00882C  322500FF   ANDI A1, S1, 255
770:                         if (state->tail<MAX_SIZE){state->tail++;}else{state->fsize++;}
9D008830  8F828074   LW V0, -32652(GP)
9D008834  8C43000C   LW V1, 12(V0)
9D008838  3C040001   LUI A0, 1
9D00883C  0064202B   SLTU A0, V1, A0
9D008840  50800005   BEQL A0, ZERO, 0x9D008858
9D008844  8C430000   LW V1, 0(V0)
9D008848  24630001   ADDIU V1, V1, 1
9D00884C  AC43000C   SW V1, 12(V0)
9D008850  0B40221B   J 0x9D00886C
9D008854  24020001   ADDIU V0, ZERO, 1
9D008858  24630001   ADDIU V1, V1, 1
9D00885C  AC430000   SW V1, 0(V0)
771:                     }
772:                     return result;
773:                 } // bool sram_insert_char(char c)
9D00886C  8FBF001C   LW RA, 28(SP)
9D008870  8FB10018   LW S1, 24(SP)
9D008874  8FB00014   LW S0, 20(SP)
9D008878  03E00008   JR RA
9D00887C  27BD0020   ADDIU SP, SP, 32
774:                 
775:                 
776:                 // char sram_char_left()
777:                 // recule d'un caractère dans la mémoire SPI RAM
778:                 // renvoie le caractère ou zéro si déjà au début du texte.
779:                 static char sram_char_left(){
780:                     char c;
781:                     
782:                     if (state->gap_first){
9D008F14  8F838074   LW V1, -32652(GP)
783:                         c=sram_read_byte(--state->gap_first);
9D008F24  2484FFFF   ADDIU A0, A0, -1
784:                         sram_write_byte(--state->tail,c);
9D008F34  8F828074   LW V0, -32652(GP)
9D008F38  8C44000C   LW A0, 12(V0)
9D008F3C  2484FFFF   ADDIU A0, A0, -1
9D008F40  AC44000C   SW A0, 12(V0)
9D008F44  0F404E6C   JAL sram_write_byte
9D008F48  02002821   ADDU A1, S0, ZERO
785:                         return c;
786:                     }else{
787:                         return 0;
788:                     }
789:                 }// sram_cahr_left()
790:                 
791:                 // char sram_char_right()
792:                 //avance d'un caractère dans la mémoire SPI RAM
793:                 //renvoie le caractère ou zéro si déjà à la fin du texte.
794:                 static char sram_char_right(){
795:                     char c;
796:                     if (state->tail<MAX_SIZE){
9D009070  8F838074   LW V1, -32652(GP)
797:                         c=sram_read_byte(state->tail++);
9D009088  24820001   ADDIU V0, A0, 1
798:                         sram_write_byte(state->gap_first++,c);
9D009098  8F828074   LW V0, -32652(GP)
9D00909C  8C440008   LW A0, 8(V0)
9D0090A0  24830001   ADDIU V1, A0, 1
9D0090A4  AC430008   SW V1, 8(V0)
9D0090A8  0F404E6C   JAL sram_write_byte
9D0090AC  02002821   ADDU A1, S0, ZERO
799:                         return c;
800:                     }else{
801:                         return 0;
802:                     }
803:                 }
804:                 
805:                 // int sram_line_home(char *line, bool move_back)
806:                 // Compte les caractères à gauche du curseur jusqu'au début de la ligne.
807:                 // dépose tous les caractères situés avant le curseur 
808:                 // jusqu'au début dans 'line'.
809:                 // Si 'move_back' est vrai recule le curseur au début de la ligne
810:                 // retourne le nombre de caractères déposés dans 'line'.
811:                 int sram_line_home(char *line, bool move_back){
9D0089A4  27BDFF88   ADDIU SP, SP, -120
9D0089A8  AFBF0074   SW RA, 116(SP)
9D0089AC  AFB30070   SW S3, 112(SP)
9D0089B0  AFB2006C   SW S2, 108(SP)
9D0089B4  AFB10068   SW S1, 104(SP)
9D0089B8  AFB00064   SW S0, 100(SP)
9D0089BC  00809021   ADDU S2, A0, ZERO
812:                     int j,llen,size;
813:                     uint32_t from;
814:                     char c,buf[CHAR_PER_LINE];
815:                     
816:                     if ((from=state->gap_first)){
9D0089C0  8F828074   LW V0, -32652(GP)
9D0089C4  8C440008   LW A0, 8(V0)
9D0089C8  5080003D   BEQL A0, ZERO, 0x9D008AC0
9D0089CC  A2400000   SB ZERO, 0(S2)
9D0089D0  00A09821   ADDU S3, A1, ZERO
817:                         size=min(from,CHAR_PER_LINE);
9D0089D4  2C910051   SLTIU S1, A0, 81
9D0089D8  24020050   ADDIU V0, ZERO, 80
9D0089DC  0091100B   MOVN V0, A0, S1
9D0089E0  00408821   ADDU S1, V0, ZERO
818:                         sram_read_block(from-size,buf,size);
9D0089E4  00822023   SUBU A0, A0, V0
9D0089E8  27A50010   ADDIU A1, SP, 16
9D0089EC  0F404E81   JAL sram_read_block
9D0089F0  00403021   ADDU A2, V0, ZERO
819:                         j=size-1;
9D0089F4  2623FFFF   ADDIU V1, S1, -1
820:                         llen=0;
9D008A18  00008021   ADDU S0, ZERO, ZERO
821:                         while((j>-1) && (llen<LINE_MAX_LEN) && ((c=buf[j--])!=A_LF)){
9D0089F8  0460001E   BLTZ V1, 0x9D008A74
9D0089FC  03A31821   ADDU V1, SP, V1
9D008A00  80640010   LB A0, 16(V1)
9D008A04  2403000A   ADDIU V1, ZERO, 10
9D008A08  1083001C   BEQ A0, V1, 0x9D008A7C
9D008A0C  2622FFFE   ADDIU V0, S1, -2
9D008A10  27A30010   ADDIU V1, SP, 16
9D008A14  00621021   ADDU V0, V1, V0
9D008A1C  2406004F   ADDIU A2, ZERO, 79
9D008A20  2407000A   ADDIU A3, ZERO, 10
9D008A28  52300009   BEQL S1, S0, 0x9D008A50
9D008A2C  02003021   ADDU A2, S0, ZERO
9D008A30  52060009   BEQL S0, A2, 0x9D008A58
9D008A34  02003021   ADDU A2, S0, ZERO
9D008A38  2442FFFF   ADDIU V0, V0, -1
9D008A3C  80430001   LB V1, 1(V0)
9D008A40  5467FFF9   BNEL V1, A3, 0x9D008A28
9D008A44  26100001   ADDIU S0, S0, 1
9D008A48  0B402294   J 0x9D008A50
9D008A4C  02003021   ADDU A2, S0, ZERO
9D008A74  0B4022A0   J 0x9D008A80
9D008A78  00008021   ADDU S0, ZERO, ZERO
9D008A7C  00008021   ADDU S0, ZERO, ZERO
822:                             llen++;
9D008A24  26100001   ADDIU S0, S0, 1
823:                         }//while
824:                         if (llen){
9D008A50  50C0000C   BEQL A2, ZERO, 0x9D008A84
9D008A54  02501021   ADDU V0, S2, S0
825:                             memcpy((void*)line,(void*)(buf+(size-llen)),llen);
9D008A58  02262823   SUBU A1, S1, A2
9D008A5C  02402021   ADDU A0, S2, ZERO
9D008A60  27A20010   ADDIU V0, SP, 16
9D008A64  0F406E68   JAL memcpy
9D008A68  00452821   ADDU A1, V0, A1
826:                         }
827:                         line[llen]=0;
9D008A6C  0B4022A1   J 0x9D008A84
9D008A70  02501021   ADDU V0, S2, S0
9D008A80  02501021   ADDU V0, S2, S0
9D008A84  A0400000   SB ZERO, 0(V0)
828:                         if (move_back){
9D008A88  1260000F   BEQ S3, ZERO, 0x9D008AC8
9D008A8C  02001021   ADDU V0, S0, ZERO
829:                             state->gap_first-=llen;
9D008A90  8F828074   LW V0, -32652(GP)
9D008A94  8C430008   LW V1, 8(V0)
9D008A98  00701823   SUBU V1, V1, S0
9D008A9C  AC430008   SW V1, 8(V0)
830:                             state->tail-=llen;
9D008AA0  8C44000C   LW A0, 12(V0)
9D008AA4  00902023   SUBU A0, A0, S0
9D008AA8  AC44000C   SW A0, 12(V0)
831:                             sram_write_block(state->tail,(uint8_t*)line,llen);
9D008AAC  02402821   ADDU A1, S2, ZERO
9D008AB0  0F404EA1   JAL sram_write_block
9D008AB4  02003021   ADDU A2, S0, ZERO
9D008AB8  0B4022B2   J 0x9D008AC8
9D008ABC  02001021   ADDU V0, S0, ZERO
832:                         }
833:                         return llen;
834:                     }else{
835:                         line[0]=0;
836:                         return 0;
9D008AC0  0B4022B2   J 0x9D008AC8
9D008AC4  00001021   ADDU V0, ZERO, ZERO
837:                     }
838:                 }//int sram_line_home(char *line,, bool move_back)
9D008AC8  8FBF0074   LW RA, 116(SP)
9D008ACC  8FB30070   LW S3, 112(SP)
9D008AD0  8FB2006C   LW S2, 108(SP)
9D008AD4  8FB10068   LW S1, 104(SP)
9D008AD8  8FB00064   LW S0, 100(SP)
9D008ADC  03E00008   JR RA
9D008AE0  27BD0078   ADDIU SP, SP, 120
839:                 
840:                 // int sram_line_end(char *line, bool move_forward)
841:                 // compte le nombre de caractères jusqu'à la fin de la ligne excluant le LF.
842:                 // Si 'move_back' est vrai déplace le curseur texte à cette position.
843:                 // dépose les caractères à droite du curseur dans 'line'
844:                 // retourne le nombre de caractères comptés.
845:                 int sram_line_end(char *line, bool move_forward){
9D008B24  27BDFFD8   ADDIU SP, SP, -40
9D008B28  AFBF0024   SW RA, 36(SP)
9D008B2C  AFB30020   SW S3, 32(SP)
9D008B30  AFB2001C   SW S2, 28(SP)
9D008B34  AFB10018   SW S1, 24(SP)
9D008B38  AFB00014   SW S0, 20(SP)
9D008B3C  00808821   ADDU S1, A0, ZERO
846:                     int llen,size;
847:                     char c;
848:                     
849:                     c=sram_get_char();
9D008B40  0F4021D3   JAL sram_get_char
9D008B44  00A09821   ADDU S3, A1, ZERO
850:                     if (c && (c!=A_LF)){
9D008B48  5040002F   BEQL V0, ZERO, 0x9D008C08
9D008B4C  A2200000   SB ZERO, 0(S1)
9D008B50  2403000A   ADDIU V1, ZERO, 10
9D008B54  1043002B   BEQ V0, V1, 0x9D008C04
9D008B58  8F828074   LW V0, -32652(GP)
851:                         size=min(LAST_COL,MAX_SIZE-state->tail);
9D008B5C  8C44000C   LW A0, 12(V0)
9D008B60  3C020001   LUI V0, 1
9D008B64  00441023   SUBU V0, V0, A0
9D008B68  2C52004F   SLTIU S2, V0, 79
9D008B6C  2403004E   ADDIU V1, ZERO, 78
9D008B70  0052180B   MOVN V1, V0, S2
9D008B74  00609021   ADDU S2, V1, ZERO
852:                         sram_read_block(state->tail,(uint8_t*)line,size);
9D008B78  02202821   ADDU A1, S1, ZERO
9D008B7C  0F404E81   JAL sram_read_block
9D008B80  00603021   ADDU A2, V1, ZERO
853:                         llen=0;
854:                         while ((llen<size) && (line[llen]!=A_LF)){
9D008B84  1A40000D   BLEZ S2, 0x9D008BBC
9D008B88  00008021   ADDU S0, ZERO, ZERO
9D008B8C  82230000   LB V1, 0(S1)
9D008B90  2402000A   ADDIU V0, ZERO, 10
9D008B94  10620009   BEQ V1, V0, 0x9D008BBC
9D008B98  2403000A   ADDIU V1, ZERO, 10
9D008BA0  12500007   BEQ S2, S0, 0x9D008BC0
9D008BA4  02301021   ADDU V0, S1, S0
9D008BA8  80420000   LB V0, 0(V0)
9D008BAC  5443FFFC   BNEL V0, V1, 0x9D008BA0
9D008BB0  26100001   ADDIU S0, S0, 1
9D008BB4  0B4022F0   J 0x9D008BC0
9D008BB8  02301021   ADDU V0, S1, S0
855:                             llen++;
9D008B9C  26100001   ADDIU S0, S0, 1
856:                         }
857:                         line[llen]=0;
9D008BBC  02301021   ADDU V0, S1, S0
9D008BC0  A0400000   SB ZERO, 0(V0)
858:                         if (move_forward){
9D008BC4  12600011   BEQ S3, ZERO, 0x9D008C0C
9D008BC8  02001021   ADDU V0, S0, ZERO
859:                             sram_write_block(state->gap_first,(uint8_t*)line,llen);
9D008BCC  8F828074   LW V0, -32652(GP)
9D008BD0  8C440008   LW A0, 8(V0)
9D008BD4  02202821   ADDU A1, S1, ZERO
9D008BD8  0F404EA1   JAL sram_write_block
9D008BDC  02003021   ADDU A2, S0, ZERO
860:                             state->gap_first+=llen;
9D008BE0  8F828074   LW V0, -32652(GP)
9D008BE4  8C430008   LW V1, 8(V0)
9D008BE8  00701821   ADDU V1, V1, S0
9D008BEC  AC430008   SW V1, 8(V0)
861:                             state->tail+=llen;
9D008BF0  8C43000C   LW V1, 12(V0)
9D008BF4  00701821   ADDU V1, V1, S0
9D008BF8  AC43000C   SW V1, 12(V0)
9D008BFC  0B402303   J 0x9D008C0C
9D008C00  02001021   ADDU V0, S0, ZERO
862:                         }
863:                         return llen;
864:                     }else{
865:                         line[0]=0;
9D008C04  A2200000   SB ZERO, 0(S1)
866:                         return 0;
9D008C08  00001021   ADDU V0, ZERO, ZERO
867:                     }
868:                 }//int sram_line_end(char *line, bool move_forward)
9D008C0C  8FBF0024   LW RA, 36(SP)
9D008C10  8FB30020   LW S3, 32(SP)
9D008C14  8FB2001C   LW S2, 28(SP)
9D008C18  8FB10018   LW S1, 24(SP)
9D008C1C  8FB00014   LW S0, 20(SP)
9D008C20  03E00008   JR RA
9D008C24  27BD0028   ADDIU SP, SP, 40
869:                 
870:                 // void sram_delete_to_end()
871:                 // supprime tous les caractères de la ligne à partir du curseur
872:                 // jusqu'à la fin de la ligne excepté le LF
873:                 static void sram_delete_to_end(){
874:                     int size, j=0,deleted=0;
875:                     char buf[CHAR_PER_LINE];
876:                     
877:                     size=min(CHAR_PER_LINE,MAX_SIZE-state->gap_first);
878:                     if (size){
879:                         sram_read_block(state->tail,buf,size);
880:                         while(j<size && buf[j++]!=A_LF){
881:                             deleted++;
882:                         }
883:                         state->tail+=deleted;
884:                         state->fsize-=deleted;
885:                     }
886:                     
887:                 }// void sram_delete_to_end()
888:                 
889:                 bool in_slot(uint32_t saddr){
890:                     return (saddr>=state->gap_first) && (saddr<state->tail);
9D008C94  8F838074   LW V1, -32652(GP)
9D008C98  8C650008   LW A1, 8(V1)
9D008C9C  0085282B   SLTU A1, A0, A1
9D008CA0  14A00003   BNE A1, ZERO, 0x9D008CB0
9D008CA4  00001021   ADDU V0, ZERO, ZERO
9D008CA8  8C62000C   LW V0, 12(V1)
9D008CAC  0082102B   SLTU V0, A0, V0
891:                 }
9D008CB0  03E00008   JR RA
9D008CB4  00000000   NOP
892:                 
893:                 // int get_line(char *line, uint32_t from)
894:                 // accumule dans 'line' les caractères à partir de 'from' jusqu'à la fin de ligne excluant le LF
895:                 // retourne le nombre de caractères accumulés.
896:                 // initialement 'from' devrait pointé le premier caractère d'une ligne.
897:                 // conditions:
898:                 //   line est un tampon d'au moins CHAR_PER_LINE caractères.
899:                 static int get_line(char *line, unsigned *from){
9D008CB8  27BDFFD0   ADDIU SP, SP, -48
9D008CBC  AFBF002C   SW RA, 44(SP)
9D008CC0  AFB50028   SW S5, 40(SP)
9D008CC4  AFB40024   SW S4, 36(SP)
9D008CC8  AFB30020   SW S3, 32(SP)
9D008CCC  AFB2001C   SW S2, 28(SP)
9D008CD0  AFB10018   SW S1, 24(SP)
9D008CD4  AFB00014   SW S0, 20(SP)
9D008CD8  00809021   ADDU S2, A0, ZERO
9D008CDC  00A0A021   ADDU S4, A1, ZERO
900:                     int size, llen;
901:                     unsigned saddr;
902:                     char c;
903:                     
904:                     size=0;
905:                     saddr=*from;
9D008CE0  8CB30000   LW S3, 0(A1)
906:                     if (saddr<state->gap_first){
9D008CE4  8F828074   LW V0, -32652(GP)
9D008CE8  8C420008   LW V0, 8(V0)
9D008CEC  0262182B   SLTU V1, S3, V0
9D008CF0  1060000B   BEQ V1, ZERO, 0x9D008D20
9D008CF4  00008821   ADDU S1, ZERO, ZERO
907:                         size=min(CHAR_PER_LINE,state->gap_first-saddr);
9D008CF8  00531023   SUBU V0, V0, S3
9D008CFC  2C510051   SLTIU S1, V0, 81
9D008D00  24030050   ADDIU V1, ZERO, 80
9D008D04  0051180B   MOVN V1, V0, S1
9D008D08  00608821   ADDU S1, V1, ZERO
908:                         sram_read_block(saddr,(uint8_t*)line,size);
9D008D0C  02602021   ADDU A0, S3, ZERO
9D008D10  02402821   ADDU A1, S2, ZERO
9D008D14  0F404E81   JAL sram_read_block
9D008D18  00603021   ADDU A2, V1, ZERO
909:                         saddr+=size;
9D008D1C  02719821   ADDU S3, S3, S1
910:                     }
911:                     if (in_slot(saddr)){
9D008D20  0F402325   JAL in_slot
9D008D24  02602021   ADDU A0, S3, ZERO
9D008D28  10400004   BEQ V0, ZERO, 0x9D008D3C
9D008D2C  2A220050   SLTI V0, S1, 80
912:                         saddr=state->tail;
9D008D30  8F828074   LW V0, -32652(GP)
9D008D34  8C53000C   LW S3, 12(V0)
913:                     }
914:                     if (size<CHAR_PER_LINE){
9D008D38  2A220050   SLTI V0, S1, 80
9D008D3C  1040000C   BEQ V0, ZERO, 0x9D008D70
9D008D40  3C030001   LUI V1, 1
915:                         llen=size;
916:                         size=min(CHAR_PER_LINE-size,MAX_SIZE-saddr);
9D008D44  00731823   SUBU V1, V1, S3
9D008D48  24020050   ADDIU V0, ZERO, 80
9D008D4C  00511023   SUBU V0, V0, S1
9D008D50  0043A82B   SLTU S5, V0, V1
9D008D54  0075100A   MOVZ V0, V1, S5
9D008D58  0040A821   ADDU S5, V0, ZERO
917:                         sram_read_block(saddr,(uint8_t*)(line+llen),size);
9D008D5C  02602021   ADDU A0, S3, ZERO
9D008D60  02512821   ADDU A1, S2, S1
9D008D64  0F404E81   JAL sram_read_block
9D008D68  00403021   ADDU A2, V0, ZERO
918:                         size+=llen;
9D008D6C  02358821   ADDU S1, S1, S5
919:                     }
920:                     llen=0;
9D008DAC  00001021   ADDU V0, ZERO, ZERO
921:                     while ((llen<size) && ((c=line[llen])!=A_LF)){llen++;}
9D008D70  1A20000E   BLEZ S1, 0x9D008DAC
9D008D74  2402000A   ADDIU V0, ZERO, 10
9D008D78  82500000   LB S0, 0(S2)
9D008D7C  12020020   BEQ S0, V0, 0x9D008E00
9D008D80  00001021   ADDU V0, ZERO, ZERO
9D008D84  2404000A   ADDIU A0, ZERO, 10
9D008D88  24420001   ADDIU V0, V0, 1
9D008D8C  50510009   BEQL V0, S1, 0x9D008DB4
9D008D90  02429021   ADDU S2, S2, V0
9D008D94  02421821   ADDU V1, S2, V0
9D008D98  80700000   LB S0, 0(V1)
9D008D9C  5604FFFB   BNEL S0, A0, 0x9D008D8C
9D008DA0  24420001   ADDIU V0, V0, 1
9D008DA4  0B402381   J 0x9D008E04
9D008DA8  02429021   ADDU S2, S2, V0
922:                     line[llen]=0;
9D008DB0  02429021   ADDU S2, S2, V0
9D008DB4  A2400000   SB ZERO, 0(S2)
9D008E00  02429021   ADDU S2, S2, V0
9D008E04  A2400000   SB ZERO, 0(S2)
923:                     saddr=(*from)+llen;
9D008DB8  8E840000   LW A0, 0(S4)
9D008E08  8E840000   LW A0, 0(S4)
9D008E0C  0B402372   J 0x9D008DC8
9D008E10  00441821   ADDU V1, V0, A0
924:                     if (c==A_LF){saddr++;}
9D008DBC  2405000A   ADDIU A1, ZERO, 10
9D008DC0  16050002   BNE S0, A1, 0x9D008DCC
9D008DC4  00441821   ADDU V1, V0, A0
9D008DC8  24630001   ADDIU V1, V1, 1
925:                     if (((*from)<state->tail) && (saddr>=state->gap_first)){
9D008DCC  8F858074   LW A1, -32652(GP)
9D008DD0  8CA6000C   LW A2, 12(A1)
9D008DD4  0086202B   SLTU A0, A0, A2
9D008DD8  5080000E   BEQL A0, ZERO, 0x9D008E14
9D008DDC  AE830000   SW V1, 0(S4)
9D008DE0  8CA40008   LW A0, 8(A1)
9D008DE4  0064282B   SLTU A1, V1, A0
9D008DE8  54A0000A   BNEL A1, ZERO, 0x9D008E14
9D008DEC  AE830000   SW V1, 0(S4)
926:                         *from=state->tail+saddr-state->gap_first;
9D008DF0  00C42023   SUBU A0, A2, A0
9D008DF4  00831821   ADDU V1, A0, V1
9D008DF8  0B402385   J 0x9D008E14
9D008DFC  AE830000   SW V1, 0(S4)
927:                     }else{
928:                         *from=saddr;
929:                     }
930:                     return llen;
931:                 }// int get_line(char *line, uint32_t from)
9D008E14  8FBF002C   LW RA, 44(SP)
9D008E18  8FB50028   LW S5, 40(SP)
9D008E1C  8FB40024   LW S4, 36(SP)
9D008E20  8FB30020   LW S3, 32(SP)
9D008E24  8FB2001C   LW S2, 28(SP)
9D008E28  8FB10018   LW S1, 24(SP)
9D008E2C  8FB00014   LW S0, 20(SP)
9D008E30  03E00008   JR RA
9D008E34  27BD0030   ADDIU SP, SP, 48
932:                 
933:                 static void fill_screen(){
9D008E38  27BDFF88   ADDIU SP, SP, -120
9D008E3C  AFBF0074   SW RA, 116(SP)
9D008E40  AFB20070   SW S2, 112(SP)
9D008E44  AFB1006C   SW S1, 108(SP)
9D008E48  AFB00068   SW S0, 104(SP)
934:                     char buf[CHAR_PER_LINE];
935:                     unsigned from;
936:                     int i;
937:                     
938:                     memset(screen,0,SCREEN_SIZE);
9D008E4C  8F8480CC   LW A0, -32564(GP)
9D008E50  00002821   ADDU A1, ZERO, ZERO
9D008E54  0F40775D   JAL memset
9D008E58  24060910   ADDIU A2, ZERO, 2320
939:                     from=state->scr_first;
9D008E5C  8F828074   LW V0, -32652(GP)
9D008E60  8C420004   LW V0, 4(V0)
9D008E64  AFA20060   SW V0, 96(SP)
940:                     i=0;
941:                     while ((i<EDITOR_LINES) && (from<MAX_SIZE)){
9D008E68  3C030001   LUI V1, 1
9D008E6C  0043102B   SLTU V0, V0, V1
9D008E70  14400016   BNE V0, ZERO, 0x9D008ECC
9D008E74  27A40010   ADDIU A0, SP, 16
9D008E9C  12120006   BEQ S0, S2, 0x9D008EB8
9D008EA0  8F828074   LW V0, -32652(GP)
9D008EA4  8FA20060   LW V0, 96(SP)
9D008EA8  0051102B   SLTU V0, V0, S1
9D008EAC  1440FFF4   BNE V0, ZERO, 0x9D008E80
9D008EB0  27A40010   ADDIU A0, SP, 16
9D008EE4  3C110001   LUI S1, 1
9D008EE8  0B4023A9   J 0x9D008EA4
9D008EEC  24120910   ADDIU S2, ZERO, 2320
942:                         get_line(buf,&from);
9D008E80  0F40232E   JAL get_line
9D008E84  27A50060   ADDIU A1, SP, 96
9D008ECC  0F40232E   JAL get_line
9D008ED0  27A50060   ADDIU A1, SP, 96
943:                         strcpy(_screen_line(i++),buf);
9D008E88  8F8480CC   LW A0, -32564(GP)
9D008E8C  00902021   ADDU A0, A0, S0
9D008E90  0F406D40   JAL strcpy
9D008E94  27A50010   ADDIU A1, SP, 16
9D008E98  26100050   ADDIU S0, S0, 80
9D008ED4  8F8480CC   LW A0, -32564(GP)
9D008ED8  0F406D40   JAL strcpy
9D008EDC  27A50010   ADDIU A1, SP, 16
9D008EE0  24100050   ADDIU S0, ZERO, 80
944:                     }
945:                     state->flags.update=true;
9D008E78  0B4023AE   J 0x9D008EB8
9D008E7C  8F828074   LW V0, -32652(GP)
9D008EB4  8F828074   LW V0, -32652(GP)
9D008EB8  9043001C   LBU V1, 28(V0)
9D008EBC  24040001   ADDIU A0, ZERO, 1
9D008EC0  7C8318C4   INS V1, A0, 3, 1
9D008EC4  0B4023BC   J 0x9D008EF0
9D008EC8  A043001C   SB V1, 28(V0)
946:                 }
9D008EF0  8FBF0074   LW RA, 116(SP)
9D008EF4  8FB20070   LW S2, 112(SP)
9D008EF8  8FB1006C   LW S1, 108(SP)
9D008EFC  8FB00068   LW S0, 104(SP)
9D008F00  03E00008   JR RA
9D008F04  27BD0078   ADDIU SP, SP, 120
947:                 
948:                 
949:                 static void update_display(){
9D008580  27BDFFE0   ADDIU SP, SP, -32
9D008584  AFBF001C   SW RA, 28(SP)
9D008588  AFB10018   SW S1, 24(SP)
9D00858C  AFB00014   SW S0, 20(SP)
950:                     int i=0;
951:                     
952:                     clear_screen(con);
9D008590  0F404F63   JAL clear_screen
9D008594  97848062   LHU A0, -32670(GP)
9D008598  00008021   ADDU S0, ZERO, ZERO
953:                     while ((i<EDITOR_LINES)){
9D00859C  24110910   ADDIU S1, ZERO, 2320
9D0085B4  1611FFFB   BNE S0, S1, 0x9D0085A4
9D0085B8  97848062   LHU A0, -32670(GP)
954:                         println(con,_screen_line(i++));
9D0085A0  97848062   LHU A0, -32670(GP)
9D0085A4  8F8580CC   LW A1, -32564(GP)
9D0085A8  0F405062   JAL println
9D0085AC  00B02821   ADDU A1, A1, S0
9D0085B0  26100050   ADDIU S0, S0, 80
955:                     }
956:                     set_curpos(con,state->scr_col,state->scr_line);
9D0085BC  8F828074   LW V0, -32652(GP)
9D0085C0  80450011   LB A1, 17(V0)
9D0085C4  0F404FB2   JAL set_curpos
9D0085C8  80460010   LB A2, 16(V0)
957:                     state->flags.update=0;
9D0085CC  8F828074   LW V0, -32652(GP)
9D0085D0  9043001C   LBU V1, 28(V0)
9D0085D4  7C0318C4   INS V1, ZERO, 3, 1
9D0085D8  A043001C   SB V1, 28(V0)
958:                 }//f();
9D0085DC  8FBF001C   LW RA, 28(SP)
9D0085E0  8FB10018   LW S1, 24(SP)
9D0085E4  8FB00014   LW S0, 20(SP)
9D0085E8  03E00008   JR RA
9D0085EC  27BD0020   ADDIU SP, SP, 32
959:                 
960:                 
961:                 const char no_name[]="unnamed";
962:                 void update_status_line(){
963:                     char status[80];
964:                     char *file_name;
965:                     
966:                     invert_video(con,true);
9D009E00  97848062   LHU A0, -32670(GP)
9D009E04  0F404FE7   JAL invert_video
9D009E08  24050001   ADDIU A1, ZERO, 1
967:                     clear_line(con,STATUS_LINE);
9D009E0C  97848062   LHU A0, -32670(GP)
9D009E10  0F4050A4   JAL clear_line
9D009E14  2405001D   ADDIU A1, ZERO, 29
968:                     sprintf(status,"%s,\tsize: %d",fname[0]?fname:no_name,state->fsize);
9D009DBC  3C129D02   LUI S2, -25342
9D009DC0  26528898   ADDIU S2, S2, -30568
9D009E18  8F868070   LW A2, -32656(GP)
9D009E1C  80C20000   LB V0, 0(A2)
9D009E20  14400003   BNE V0, ZERO, 0x9D009E30
9D009E24  27A40018   ADDIU A0, SP, 24
9D009E28  3C069D02   LUI A2, -25342
9D009E2C  24C68914   ADDIU A2, A2, -30444
9D009E30  02402821   ADDU A1, S2, ZERO
9D009E34  8F828074   LW V0, -32652(GP)
9D009E38  0F407973   JAL _sprintf_cdnopsuxX
9D009E3C  8C470000   LW A3, 0(V0)
969:                     print(con,status);
9D009E40  97848062   LHU A0, -32670(GP)
9D009E44  0F404FCC   JAL print
9D009E48  27A50018   ADDIU A1, SP, 24
970:                     set_curpos(con,40,STATUS_LINE);
9D009E4C  97848062   LHU A0, -32670(GP)
9D009E50  24050028   ADDIU A1, ZERO, 40
9D009E54  0F404FB2   JAL set_curpos
9D009E58  2406001D   ADDIU A2, ZERO, 29
971:                     sprintf(status,"line: %0d/%0d,\tcol: %0d",
9D009DC4  3C119D02   LUI S1, -25342
9D009DC8  263188A8   ADDIU S1, S1, -30552
9D009E60  8C460014   LW A2, 20(V0)
9D009E64  8C470018   LW A3, 24(V0)
9D009E68  80420011   LB V0, 17(V0)
9D009E6C  24420001   ADDIU V0, V0, 1
9D009E70  AFA20010   SW V0, 16(SP)
9D009E74  27A40018   ADDIU A0, SP, 24
9D009E78  02202821   ADDU A1, S1, ZERO
9D009E7C  24C60001   ADDIU A2, A2, 1
9D009E80  0F407973   JAL _sprintf_cdnopsuxX
9D009E84  24E70001   ADDIU A3, A3, 1
972:                             state->file_line+1,state->lines_count+1,state->scr_col+1);
9D009E5C  8F828074   LW V0, -32652(GP)
973:                     print(con,status);
9D009E88  97848062   LHU A0, -32670(GP)
9D009E8C  0F404FCC   JAL print
9D009E90  27A50018   ADDIU A1, SP, 24
974:                     invert_video(con,false);
9D009E94  97848062   LHU A0, -32670(GP)
9D009E98  0F404FE7   JAL invert_video
9D009E9C  00002821   ADDU A1, ZERO, ZERO
975:                     set_curpos(con,state->scr_col,state->scr_line);
9D009EA0  8F828074   LW V0, -32652(GP)
9D009EA4  97848062   LHU A0, -32670(GP)
9D009EA8  80450011   LB A1, 17(V0)
9D009EAC  0F404FB2   JAL set_curpos
9D009EB0  80460010   LB A2, 16(V0)
976:                 }
977:                 
978:                 static void line_up(){
9D009004  27BDFFE8   ADDIU SP, SP, -24
9D009008  AFBF0014   SW RA, 20(SP)
9D00900C  AFB00010   SW S0, 16(SP)
979:                     uint8_t col,llen, line[CHAR_PER_LINE];
980:                     
981:                     col=state->scr_col;
9D009010  8F828074   LW V0, -32652(GP)
982:                     line_home();
9D009014  0F4022B9   JAL line_home
9D009018  90500011   LBU S0, 17(V0)
983:                     char_left();
9D00901C  0F4023C2   JAL char_left
9D009020  00000000   NOP
984:                     while ((col<state->scr_col) && char_left()){}
9D009024  8F828074   LW V0, -32652(GP)
9D009028  80420011   LB V0, 17(V0)
9D00902C  0202102A   SLT V0, S0, V0
9D009030  10400006   BEQ V0, ZERO, 0x9D00904C
9D009034  8FBF0014   LW RA, 20(SP)
9D009038  0F4023C2   JAL char_left
9D00903C  00000000   NOP
9D009040  1440FFF9   BNE V0, ZERO, 0x9D009028
9D009044  8F828074   LW V0, -32652(GP)
985:                 }//f()
9D009048  8FBF0014   LW RA, 20(SP)
9D00904C  8FB00010   LW S0, 16(SP)
9D009050  03E00008   JR RA
9D009054  27BD0018   ADDIU SP, SP, 24
986:                 
987:                 static void line_down(){
9D009168  27BDFFE0   ADDIU SP, SP, -32
9D00916C  AFBF001C   SW RA, 28(SP)
9D009170  AFB20018   SW S2, 24(SP)
9D009174  AFB10014   SW S1, 20(SP)
9D009178  AFB00010   SW S0, 16(SP)
988:                     uint8_t col,llen;
989:                     
990:                     col=state->scr_col;
9D00917C  8F828074   LW V0, -32652(GP)
991:                     line_end();
9D009180  0F40230A   JAL line_end
9D009184  90510011   LBU S1, 17(V0)
992:                     char_right();
9D009188  0F402416   JAL char_right
9D00918C  00000000   NOP
993:                     llen=strlen(_screen_line(state->scr_line));
9D009190  8F928074   LW S2, -32652(GP)
9D009194  82420010   LB V0, 16(S2)
9D009198  00021900   SLL V1, V0, 4
9D00919C  00021180   SLL V0, V0, 6
9D0091A0  00621021   ADDU V0, V1, V0
9D0091A4  8F8480CC   LW A0, -32564(GP)
9D0091A8  0F406EC2   JAL strlen
9D0091AC  00822021   ADDU A0, A0, V0
994:                     if (llen<col){
9D0091B0  304200FF   ANDI V0, V0, 255
9D0091B4  0051102B   SLTU V0, V0, S1
9D0091B8  14400007   BNE V0, ZERO, 0x9D0091D8
9D0091BC  02208021   ADDU S0, S1, ZERO
995:                         line_end();
9D0091D8  0F40230A   JAL line_end
9D0091DC  00000000   NOP
9D0091E0  0B402481   J 0x9D009204
9D0091E4  8FBF001C   LW RA, 28(SP)
996:                     }else{
997:                         while ((col>state->scr_col)){char_right();}
9D0091C0  82420011   LB V0, 17(S2)
9D0091C4  0051882A   SLT S1, V0, S1
9D0091C8  16200007   BNE S1, ZERO, 0x9D0091E8
9D0091CC  8FBF001C   LW RA, 28(SP)
9D0091E8  0F402416   JAL char_right
9D0091EC  00000000   NOP
9D0091F0  8F828074   LW V0, -32652(GP)
9D0091F4  80420011   LB V0, 17(V0)
9D0091F8  0050102A   SLT V0, V0, S0
9D0091FC  1440FFFA   BNE V0, ZERO, 0x9D0091E8
9D009200  8FBF001C   LW RA, 28(SP)
998:                     }
999:                 }//f()
9D0091D0  0B402482   J 0x9D009208
9D0091D4  8FB20018   LW S2, 24(SP)
9D009204  8FB20018   LW S2, 24(SP)
9D009208  8FB10014   LW S1, 20(SP)
9D00920C  8FB00010   LW S0, 16(SP)
9D009210  03E00008   JR RA
9D009214  27BD0020   ADDIU SP, SP, 32
1000:                
1001:                static int screen_scroll_down(){
1002:                    char buf[CHAR_PER_LINE];
1003:                    int llen;
1004:                    
1005:                    llen=sram_line_home(buf,false);
9D008F88  27A40010   ADDIU A0, SP, 16
1006:                    state->scr_first=state->gap_first-llen;
9D008F98  8F828074   LW V0, -32652(GP)
1007:                    fill_screen();
9D008FA4  0F40238E   JAL fill_screen
9D008FA8  AC430004   SW V1, 4(V0)
1008:                    return llen;
1009:                }
1010:                
1011:                //déplace le curseur vers la gauche d'un caractère
1012:                static bool char_left(){
9D008F08  27BDFF98   ADDIU SP, SP, -104
9D008F0C  AFBF0064   SW RA, 100(SP)
9D008F10  AFB00060   SW S0, 96(SP)
1013:                    int llen;
1014:                    
1015:                    if (sram_char_left()){
9D008F4C  12000029   BEQ S0, ZERO, 0x9D008FF4
9D008F50  00001021   ADDU V0, ZERO, ZERO
1016:                        if (state->scr_col){
9D008F54  8F828074   LW V0, -32652(GP)
9D008F58  80430011   LB V1, 17(V0)
9D008F5C  50600005   BEQL V1, ZERO, 0x9D008F74
9D008F60  8C430014   LW V1, 20(V0)
1017:                            state->scr_col--;
9D008F64  2463FFFF   ADDIU V1, V1, -1
9D008F68  A0430011   SB V1, 17(V0)
9D008F6C  0B4023FD   J 0x9D008FF4
9D008F70  24020001   ADDIU V0, ZERO, 1
1018:                        }else{
1019:                            state->file_line--;
9D008F74  2463FFFF   ADDIU V1, V1, -1
9D008F78  AC430014   SW V1, 20(V0)
1020:                            if (!state->scr_line){
9D008F7C  80430010   LB V1, 16(V0)
9D008F80  5460000C   BNEL V1, ZERO, 0x9D008FB4
9D008F84  2463FFFF   ADDIU V1, V1, -1
1021:                                llen=screen_scroll_down();
1022:                            }else{
1023:                                state->scr_line--;
9D008FB4  7C031C20   SEB V1, V1
9D008FB8  A0430010   SB V1, 16(V0)
1024:                                llen=strlen(_screen_line(state->scr_line));
9D008FBC  00031100   SLL V0, V1, 4
9D008FC0  00031980   SLL V1, V1, 6
9D008FC4  00431821   ADDU V1, V0, V1
9D008FC8  8F8480CC   LW A0, -32564(GP)
9D008FCC  0F406EC2   JAL strlen
9D008FD0  00832021   ADDU A0, A0, V1
9D008FD4  00408021   ADDU S0, V0, ZERO
1025:                            }
1026:                            state->scr_col=llen;
9D008FD8  8F838074   LW V1, -32652(GP)
9D008FDC  7C102C20   SEB A1, S0
9D008FE0  A0650011   SB A1, 17(V1)
1027:                            set_curpos(con,state->scr_col,state->scr_line);
9D008FE4  97848062   LHU A0, -32670(GP)
9D008FE8  0F404FB2   JAL set_curpos
9D008FEC  80660010   LB A2, 16(V1)
1028:                        }
1029:                        return true;
9D008FF0  24020001   ADDIU V0, ZERO, 1
1030:                    }else{
1031:                        return false;
1032:                    }
1033:                }//f()
9D008FF4  8FBF0064   LW RA, 100(SP)
9D008FF8  8FB00060   LW S0, 96(SP)
9D008FFC  03E00008   JR RA
9D009000  27BD0068   ADDIU SP, SP, 104
1034:                
1035:                static void screen_scroll_up(){
1036:                    state->scr_first+=strlen(screen)+1;
9D009108  0F406EC2   JAL strlen
1037:                    fill_screen();
9D00911C  0F40238E   JAL fill_screen
9D009120  AE020004   SW V0, 4(S0)
1038:                }
1039:                
1040:                //déplace le curseur vers la droite d'un caractère
1041:                static bool char_right(){
9D009058  27BDFFD8   ADDIU SP, SP, -40
9D00905C  AFBF0024   SW RA, 36(SP)
9D009060  AFB30020   SW S3, 32(SP)
9D009064  AFB2001C   SW S2, 28(SP)
9D009068  AFB10018   SW S1, 24(SP)
9D00906C  AFB00014   SW S0, 20(SP)
1042:                    char buf[CHAR_PER_LINE];
1043:                    uint32_t from;
1044:                    
1045:                    if (sram_char_right()){
9D0090B0  12000026   BEQ S0, ZERO, 0x9D00914C
9D0090B4  00001021   ADDU V0, ZERO, ZERO
1046:                        if (state->scr_col<strlen(_screen_line(state->scr_line))){
9D0090B8  8F908074   LW S0, -32652(GP)
9D0090BC  82120011   LB S2, 17(S0)
9D0090C0  8F9380CC   LW S3, -32564(GP)
9D0090C4  82110010   LB S1, 16(S0)
9D0090C8  00112100   SLL A0, S1, 4
9D0090CC  00111180   SLL V0, S1, 6
9D0090D0  00822021   ADDU A0, A0, V0
9D0090D4  0F406EC2   JAL strlen
9D0090D8  02642021   ADDU A0, S3, A0
9D0090DC  0242102B   SLTU V0, S2, V0
9D0090E0  50400004   BEQL V0, ZERO, 0x9D0090F4
9D0090E4  8E020014   LW V0, 20(S0)
1047:                            state->scr_col++;
9D0090E8  26520001   ADDIU S2, S2, 1
9D0090EC  0B40244D   J 0x9D009134
9D0090F0  A2120011   SB S2, 17(S0)
1048:                        }else{
1049:                            state->file_line++;
9D0090F4  24420001   ADDIU V0, V0, 1
9D0090F8  AE020014   SW V0, 20(S0)
1050:                            state->scr_col=0;
1051:                            if (state->scr_line==LAST_LINE){
9D0090FC  2402001C   ADDIU V0, ZERO, 28
9D009100  1622000A   BNE S1, V0, 0x9D00912C
9D009104  A2000011   SB ZERO, 17(S0)
1052:                                screen_scroll_up();
1053:                            }else{
1054:                                state->scr_line++;
9D00912C  26310001   ADDIU S1, S1, 1
9D009130  A2110010   SB S1, 16(S0)
1055:                            }
1056:                        } 
1057:                        set_curpos(con,state->scr_col,state->scr_line);
9D009124  0B40244E   J 0x9D009138
9D009128  8F828074   LW V0, -32652(GP)
9D009134  8F828074   LW V0, -32652(GP)
9D009138  97848062   LHU A0, -32670(GP)
9D00913C  80450011   LB A1, 17(V0)
9D009140  0F404FB2   JAL set_curpos
9D009144  80460010   LB A2, 16(V0)
1058:                        return true;
9D009148  24020001   ADDIU V0, ZERO, 1
1059:                    }//if
1060:                    return false;
1061:                }//f()
9D00914C  8FBF0024   LW RA, 36(SP)
9D009150  8FB30020   LW S3, 32(SP)
9D009154  8FB2001C   LW S2, 28(SP)
9D009158  8FB10018   LW S1, 24(SP)
9D00915C  8FB00014   LW S0, 20(SP)
9D009160  03E00008   JR RA
9D009164  27BD0028   ADDIU SP, SP, 40
1062:                
1063:                static void delete_left(){
1064:                    if (char_left()){
9D00A614  0F4023C2   JAL char_left
9D00A618  00000000   NOP
9D00A61C  10400005   BEQ V0, ZERO, 0x9D00A634
9D00A620  240401F4   ADDIU A0, ZERO, 500
1065:                        delete_at();
9D00A624  0F40249B   JAL delete_at
9D00A628  00000000   NOP
1066:                    }else{
1067:                        _beep();
9D00A634  0F406085   JAL tone
9D00A638  24050064   ADDIU A1, ZERO, 100
1068:                    }
1069:                } //f()
1070:                
1071:                // supprime le caractère à la position du curseur
1072:                static void delete_at(){
9D00926C  27BDFFD0   ADDIU SP, SP, -48
9D009270  AFBF002C   SW RA, 44(SP)
9D009274  AFB60028   SW S6, 40(SP)
9D009278  AFB50024   SW S5, 36(SP)
9D00927C  AFB40020   SW S4, 32(SP)
9D009280  AFB3001C   SW S3, 28(SP)
9D009284  AFB20018   SW S2, 24(SP)
9D009288  AFB10014   SW S1, 20(SP)
9D00928C  AFB00010   SW S0, 16(SP)
1073:                    int col,count,llen,llen_next;
1074:                    
1075:                    if (state->tail<MAX_SIZE){
9D009290  8F908074   LW S0, -32652(GP)
9D009294  8E11000C   LW S1, 12(S0)
9D009298  3C020001   LUI V0, 1
9D00929C  0222102B   SLTU V0, S1, V0
9D0092A0  1040004C   BEQ V0, ZERO, 0x9D0093D4
9D0092A4  8F9480CC   LW S4, -32564(GP)
1076:                        col=state->scr_col;
9D0092A8  82150011   LB S5, 17(S0)
1077:                        llen=strlen(_screen_line(state->scr_line));
9D0092AC  82120010   LB S2, 16(S0)
9D0092B0  0012B100   SLL S6, S2, 4
9D0092B4  00121180   SLL V0, S2, 6
9D0092B8  02C2B021   ADDU S6, S6, V0
9D0092BC  0F406EC2   JAL strlen
9D0092C0  02962021   ADDU A0, S4, S6
9D0092C4  00409821   ADDU S3, V0, ZERO
1078:                        if (col<llen){
9D0092C8  02A2102A   SLT V0, S5, V0
9D0092CC  50400024   BEQL V0, ZERO, 0x9D009360
9D0092D0  26440050   ADDIU A0, S2, 80
1079:                            state->tail++;
9D0092D4  26310001   ADDIU S1, S1, 1
9D0092D8  AE11000C   SW S1, 12(S0)
1080:                            state->fsize--;
9D0092DC  8E020000   LW V0, 0(S0)
9D0092E0  2442FFFF   ADDIU V0, V0, -1
9D0092E4  AE020000   SW V0, 0(S0)
1081:                            memmove(_screen_line(state->scr_line)+col,
9D0092E8  8F8280CC   LW V0, -32564(GP)
9D0092EC  02D52021   ADDU A0, S6, S5
9D0092F4  00442021   ADDU A0, V0, A0
9D0092F8  00452821   ADDU A1, V0, A1
9D0092FC  2406004F   ADDIU A2, ZERO, 79
9D009300  0F4079A7   JAL memmove
9D009304  00D53023   SUBU A2, A2, S5
1082:                                    _screen_line(state->scr_line)+col+1,
9D0092F0  24850001   ADDIU A1, A0, 1
1083:                                    CHAR_PER_LINE-col-1);
1084:                            set_curpos(con,0,state->scr_line);
9D009308  97848062   LHU A0, -32670(GP)
9D00930C  00002821   ADDU A1, ZERO, ZERO
9D009310  0F404FB2   JAL set_curpos
9D009314  82060010   LB A2, 16(S0)
1085:                            clear_eol(con);
9D009318  0F404F6F   JAL clear_eol
9D00931C  97848062   LHU A0, -32670(GP)
1086:                            print(con,_screen_line(state->scr_line));
9D009320  8F828074   LW V0, -32652(GP)
9D009324  80420010   LB V0, 16(V0)
9D009328  00021900   SLL V1, V0, 4
9D00932C  00021180   SLL V0, V0, 6
9D009330  00621021   ADDU V0, V1, V0
9D009334  97848062   LHU A0, -32670(GP)
9D009338  8F8580CC   LW A1, -32564(GP)
9D00933C  0F404FCC   JAL print
9D009340  00A22821   ADDU A1, A1, V0
1087:                            set_curpos(con,state->scr_col,state->scr_line);
9D009344  8F828074   LW V0, -32652(GP)
9D009348  97848062   LHU A0, -32670(GP)
9D00934C  80450011   LB A1, 17(V0)
9D009350  0F404FB2   JAL set_curpos
9D009354  80460010   LB A2, 16(V0)
9D009358  0B4024F9   J 0x9D0093E4
9D00935C  8FBF002C   LW RA, 44(SP)
1088:                        }else{
1089:                           llen_next=strlen(_screen_line(state->scr_line+1));
9D009360  0F406EC2   JAL strlen
9D009364  02842021   ADDU A0, S4, A0
1090:                           if ((llen+llen_next)<=LINE_MAX_LEN){
9D009368  02621021   ADDU V0, S3, V0
9D00936C  28420050   SLTI V0, V0, 80
9D009370  1040000A   BEQ V0, ZERO, 0x9D00939C
9D009374  2402004F   ADDIU V0, ZERO, 79
1091:                               state->tail++;
9D009378  26310001   ADDIU S1, S1, 1
9D00937C  AE11000C   SW S1, 12(S0)
1092:                               state->fsize--;
9D009380  8E020000   LW V0, 0(S0)
9D009384  2442FFFF   ADDIU V0, V0, -1
9D009388  AE020000   SW V0, 0(S0)
1093:                               state->lines_count--;
9D00938C  8E020018   LW V0, 24(S0)
9D009390  2442FFFF   ADDIU V0, V0, -1
9D009394  0B4024F1   J 0x9D0093C4
9D009398  AE020018   SW V0, 24(S0)
1094:                           }else{
1095:                               count=LINE_MAX_LEN-llen;
9D00939C  00539823   SUBU S3, V0, S3
1096:                               sram_move(state->tail,state->tail+1,count);
9D0093A0  02202021   ADDU A0, S1, ZERO
9D0093A4  26250001   ADDIU A1, S1, 1
9D0093A8  0F404F13   JAL sram_move
9D0093AC  02603021   ADDU A2, S3, ZERO
1097:                               sram_write_byte(state->tail+count,A_LF);
9D0093B0  8F828074   LW V0, -32652(GP)
9D0093B4  8C44000C   LW A0, 12(V0)
9D0093B8  02642021   ADDU A0, S3, A0
9D0093BC  0F404E6C   JAL sram_write_byte
9D0093C0  2405000A   ADDIU A1, ZERO, 10
1098:                           }
1099:                           fill_screen();
9D0093C4  0F40238E   JAL fill_screen
9D0093C8  00000000   NOP
1100:                        }
1101:                    }else{
1102:                        _beep();
9D0093D4  240401F4   ADDIU A0, ZERO, 500
9D0093D8  0F406085   JAL tone
9D0093DC  24050064   ADDIU A1, ZERO, 100
1103:                        return;
1104:                    }
1105:                    
1106:                }//delete_at()
9D0093CC  0B4024F9   J 0x9D0093E4
9D0093D0  8FBF002C   LW RA, 44(SP)
9D0093E0  8FBF002C   LW RA, 44(SP)
9D0093E4  8FB60028   LW S6, 40(SP)
9D0093E8  8FB50024   LW S5, 36(SP)
9D0093EC  8FB40020   LW S4, 32(SP)
9D0093F0  8FB3001C   LW S3, 28(SP)
9D0093F4  8FB20018   LW S2, 24(SP)
9D0093F8  8FB10014   LW S1, 20(SP)
9D0093FC  8FB00010   LW S0, 16(SP)
9D009400  03E00008   JR RA
9D009404  27BD0030   ADDIU SP, SP, 48
1107:                
1108:                
1109:                //efface tous les caractères à partir du curseur
1110:                //jusqu'à la fin de ligne.
1111:                //si le curseur est au début de ligne
1112:                //la ligne est supprimée au complet LF inclus.
1113:                static void delete_to_end(){
1114:                    int count,col,llen;
1115:                
1116:                    llen=strlen(_screen_line(state->scr_line));
9D00A6F4  8F948074   LW S4, -32652(GP)
9D00A6F8  82820010   LB V0, 16(S4)
9D00A6FC  0002A900   SLL S5, V0, 4
9D00A700  00021180   SLL V0, V0, 6
9D00A704  02A2A821   ADDU S5, S5, V0
9D00A708  8F8480CC   LW A0, -32564(GP)
9D00A70C  0F406EC2   JAL strlen
9D00A710  00952021   ADDU A0, A0, S5
1117:                    if (state->scr_col){
9D00A714  82830011   LB V1, 17(S4)
9D00A718  50600012   BEQL V1, ZERO, 0x9D00A764
9D00A71C  8E83000C   LW V1, 12(S4)
1118:                        count=llen-state->scr_col;
9D00A720  00431023   SUBU V0, V0, V1
1119:                        if (count){
9D00A724  5040016A   BEQL V0, ZERO, 0x9D00ACD0
9D00A728  93828068   LBU V0, -32664(GP)
1120:                            state->tail+=count;
9D00A72C  8E84000C   LW A0, 12(S4)
9D00A730  00822021   ADDU A0, A0, V0
9D00A734  AE84000C   SW A0, 12(S4)
1121:                            state->fsize-=count;
9D00A738  8E840000   LW A0, 0(S4)
9D00A73C  00821023   SUBU V0, A0, V0
9D00A740  AE820000   SW V0, 0(S4)
1122:                            _screen_put(state->scr_line,state->scr_col,0);
9D00A744  8F8280CC   LW V0, -32564(GP)
9D00A748  0055A821   ADDU S5, V0, S5
9D00A74C  02A31821   ADDU V1, S5, V1
9D00A750  A0600000   SB ZERO, 0(V1)
1123:                            clear_eol(con);
9D00A754  0F404F6F   JAL clear_eol
9D00A758  97848062   LHU A0, -32670(GP)
1124:                        }
1125:                    }else{
1126:                        state->tail+=llen;
9D00A764  00621821   ADDU V1, V1, V0
9D00A768  AE83000C   SW V1, 12(S4)
1127:                        state->fsize-=llen;
9D00A76C  8E830000   LW V1, 0(S4)
9D00A770  00621023   SUBU V0, V1, V0
9D00A774  AE820000   SW V0, 0(S4)
1128:                        state->scr_col=0;
1129:                        if (sram_get_char()==A_LF){
9D00A778  0F4021D3   JAL sram_get_char
9D00A77C  A2800011   SB ZERO, 17(S4)
9D00A780  2403000A   ADDIU V1, ZERO, 10
9D00A784  1443000B   BNE V0, V1, 0x9D00A7B4
9D00A788  00000000   NOP
1130:                            state->tail++;
9D00A78C  8F828074   LW V0, -32652(GP)
9D00A790  8C43000C   LW V1, 12(V0)
9D00A794  24630001   ADDIU V1, V1, 1
9D00A798  AC43000C   SW V1, 12(V0)
1131:                            state->fsize--;
9D00A79C  8C430000   LW V1, 0(V0)
9D00A7A0  2463FFFF   ADDIU V1, V1, -1
9D00A7A4  AC430000   SW V1, 0(V0)
1132:                            state->lines_count--;
9D00A7A8  8C430018   LW V1, 24(V0)
9D00A7AC  2463FFFF   ADDIU V1, V1, -1
9D00A7B0  AC430018   SW V1, 24(V0)
1133:                        }
1134:                        fill_screen();
9D00A7B4  0F40238E   JAL fill_screen
9D00A7B8  00000000   NOP
1135:                    }
1136:                 }//f()
1137:                
1138:                //efface tous les caratères à gauche du curseur
1139:                //jusqu'au début de la ligne.
1140:                static void delete_to_start(){
1141:                    int col;
1142:                    
1143:                    col=state->scr_col;
9D00A644  8F948074   LW S4, -32652(GP)
9D00A648  82820011   LB V0, 17(S4)
1144:                    if (col){
9D00A64C  504001A0   BEQL V0, ZERO, 0x9D00ACD0
9D00A650  93828068   LBU V0, -32664(GP)
1145:                        state->gap_first-=col;
9D00A654  8E830008   LW V1, 8(S4)
9D00A658  00621823   SUBU V1, V1, V0
9D00A65C  AE830008   SW V1, 8(S4)
1146:                        state->fsize-=col;
9D00A660  8E830000   LW V1, 0(S4)
9D00A664  00621823   SUBU V1, V1, V0
9D00A668  AE830000   SW V1, 0(S4)
1147:                        memmove(_screen_line(state->scr_line),_screen_line(state->scr_line)+col,CHAR_PER_LINE-col);
9D00A66C  8F8380CC   LW V1, -32564(GP)
9D00A670  82850010   LB A1, 16(S4)
9D00A674  00052100   SLL A0, A1, 4
9D00A678  00052980   SLL A1, A1, 6
9D00A67C  00852021   ADDU A0, A0, A1
9D00A680  00822821   ADDU A1, A0, V0
9D00A684  00642021   ADDU A0, V1, A0
9D00A688  00652821   ADDU A1, V1, A1
9D00A68C  24060050   ADDIU A2, ZERO, 80
9D00A690  0F4079A7   JAL memmove
9D00A694  00C23023   SUBU A2, A2, V0
1148:                        state->scr_col=0;
9D00A698  A2800011   SB ZERO, 17(S4)
1149:                        set_curpos(con,0,state->scr_line);
9D00A69C  97848062   LHU A0, -32670(GP)
9D00A6A0  00002821   ADDU A1, ZERO, ZERO
9D00A6A4  0F404FB2   JAL set_curpos
9D00A6A8  82860010   LB A2, 16(S4)
1150:                        clear_eol(con);
9D00A6AC  0F404F6F   JAL clear_eol
9D00A6B0  97848062   LHU A0, -32670(GP)
1151:                        print(con,_screen_line(state->scr_line));
9D00A6B4  8F828074   LW V0, -32652(GP)
9D00A6B8  80420010   LB V0, 16(V0)
9D00A6BC  00021900   SLL V1, V0, 4
9D00A6C0  00021180   SLL V0, V0, 6
9D00A6C4  00621021   ADDU V0, V1, V0
9D00A6C8  97848062   LHU A0, -32670(GP)
9D00A6CC  8F8580CC   LW A1, -32564(GP)
9D00A6D0  0F404FCC   JAL print
9D00A6D4  00A22821   ADDU A1, A1, V0
1152:                        set_curpos(con,0,state->scr_line);
9D00A6D8  97848062   LHU A0, -32670(GP)
9D00A6DC  00002821   ADDU A1, ZERO, ZERO
9D00A6E0  8F828074   LW V0, -32652(GP)
9D00A6E4  0F404FB2   JAL set_curpos
9D00A6E8  80460010   LB A2, 16(V0)
1153:                    }
1154:                }//f()
1155:                
1156:                
1157:                static void insert_char(char c){
9D00989C  27BDFFE8   ADDIU SP, SP, -24
9D0098A0  AFBF0014   SW RA, 20(SP)
9D0098A4  AFB00010   SW S0, 16(SP)
1158:                    if (sram_insert_char(c)){
9D0098A8  0F4021E1   JAL sram_insert_char
9D0098AC  00808021   ADDU S0, A0, ZERO
9D0098B0  10400029   BEQ V0, ZERO, 0x9D009958
9D0098B4  8F828074   LW V0, -32652(GP)
1159:                        if (state->flags.insert){
9D0098B8  8C43001C   LW V1, 28(V0)
9D0098BC  30630001   ANDI V1, V1, 1
9D0098C0  50600005   BEQL V1, ZERO, 0x9D0098D8
9D0098C4  80430010   LB V1, 16(V0)
1160:                            fill_screen();
9D0098C8  0F40238E   JAL fill_screen
9D0098CC  00000000   NOP
9D0098D0  0B40263F   J 0x9D0098FC
9D0098D4  97848062   LHU A0, -32670(GP)
1161:                        }else{
1162:                            _screen_put(state->scr_line,state->scr_col,c);
9D0098D8  80420011   LB V0, 17(V0)
9D0098DC  00032100   SLL A0, V1, 4
9D0098E0  00031980   SLL V1, V1, 6
9D0098E4  00831821   ADDU V1, A0, V1
9D0098E8  00621821   ADDU V1, V1, V0
9D0098EC  8F8280CC   LW V0, -32564(GP)
9D0098F0  00431821   ADDU V1, V0, V1
9D0098F4  A0700000   SB S0, 0(V1)
1163:                        }
1164:                        set_curpos(con,0,state->scr_line);
9D0098F8  97848062   LHU A0, -32670(GP)
9D0098FC  00002821   ADDU A1, ZERO, ZERO
9D009900  8F828074   LW V0, -32652(GP)
9D009904  0F404FB2   JAL set_curpos
9D009908  80460010   LB A2, 16(V0)
1165:                        print(con,_screen_line(state->scr_line));
9D00990C  8F828074   LW V0, -32652(GP)
9D009910  80420010   LB V0, 16(V0)
9D009914  00021900   SLL V1, V0, 4
9D009918  00021180   SLL V0, V0, 6
9D00991C  00621021   ADDU V0, V1, V0
9D009920  97848062   LHU A0, -32670(GP)
9D009924  8F8580CC   LW A1, -32564(GP)
9D009928  0F404FCC   JAL print
9D00992C  00A22821   ADDU A1, A1, V0
1166:                        state->scr_col++;
9D009930  8F828074   LW V0, -32652(GP)
9D009934  90450011   LBU A1, 17(V0)
9D009938  24A50001   ADDIU A1, A1, 1
9D00993C  7C052C20   SEB A1, A1
9D009940  A0450011   SB A1, 17(V0)
1167:                        set_curpos(con,state->scr_col,state->scr_line);
9D009944  97848062   LHU A0, -32670(GP)
9D009948  0F404FB2   JAL set_curpos
9D00994C  80460010   LB A2, 16(V0)
9D009950  0B40265A   J 0x9D009968
9D009954  8FBF0014   LW RA, 20(SP)
1168:                    }else{
1169:                        _beep();
9D009958  240401F4   ADDIU A0, ZERO, 500
9D00995C  0F406085   JAL tone
9D009960  24050064   ADDIU A1, ZERO, 100
1170:                        return;
1171:                    }
1172:                }//f()
9D009964  8FBF0014   LW RA, 20(SP)
9D009968  8FB00010   LW S0, 16(SP)
9D00996C  03E00008   JR RA
9D009970  27BD0018   ADDIU SP, SP, 24
1173:                
1174:                // insère des espaces jusqu'au début de la prochaine colonne.
1175:                static void insert_tabulation(){
1176:                    int w,count,llen;
1177:                    
1178:                    w=get_tab_width(con);
9D00A594  0F405098   JAL get_tab_width
9D00A598  97848062   LHU A0, -32670(GP)
1179:                    count=w-state->scr_col%w;
9D00A59C  8F838074   LW V1, -32652(GP)
9D00A5A0  80640011   LB A0, 17(V1)
9D00A5A4  0082001A   DIV A0, V0
9D00A5A8  004001F4   TEQ V0, ZERO
9D00A5AC  0000A010   MFHI S4
9D00A5B0  0054A023   SUBU S4, V0, S4
1180:                    llen=strlen(_screen_line(state->scr_line));
9D00A5B4  80620010   LB V0, 16(V1)
9D00A5B8  00021900   SLL V1, V0, 4
9D00A5BC  00021180   SLL V0, V0, 6
9D00A5C0  00621021   ADDU V0, V1, V0
9D00A5C4  8F8480CC   LW A0, -32564(GP)
9D00A5C8  0F406EC2   JAL strlen
9D00A5CC  00822021   ADDU A0, A0, V0
1181:                    count=min(count,LINE_MAX_LEN-llen);
9D00A5D0  2403004F   ADDIU V1, ZERO, 79
9D00A5D4  00621023   SUBU V0, V1, V0
9D00A5D8  0282182A   SLT V1, S4, V0
9D00A5DC  0043A00A   MOVZ S4, V0, V1
1182:                    while (count--){
9D00A5E0  128001BB   BEQ S4, ZERO, 0x9D00ACD0
9D00A5E4  93828068   LBU V0, -32664(GP)
9D00A5F4  1680FFFC   BNE S4, ZERO, 0x9D00A5E8
9D00A5F8  93828068   LBU V0, -32664(GP)
9D00A5FC  0B402B34   J 0x9D00ACD0
9D00A600  00000000   NOP
1183:                        insert_char(' ');
9D00A5E8  0F402627   JAL insert_char
9D00A5EC  24040020   ADDIU A0, ZERO, 32
9D00A5F0  2694FFFF   ADDIU S4, S4, -1
1184:                    }
1185:                }// insert_tabulation()
1186:                
1187:                static void line_home(){
9D008AE4  27BDFF98   ADDIU SP, SP, -104
9D008AE8  AFBF0064   SW RA, 100(SP)
1188:                    char buf[CHAR_PER_LINE];
1189:                    int llen;
1190:                    llen=sram_line_home(buf,true);
9D008AEC  27A40010   ADDIU A0, SP, 16
9D008AF0  0F402269   JAL sram_line_home
9D008AF4  24050001   ADDIU A1, ZERO, 1
1191:                    if (llen){
9D008AF8  10400008   BEQ V0, ZERO, 0x9D008B1C
9D008AFC  8FBF0064   LW RA, 100(SP)
1192:                        state->scr_col=0;
9D008B00  8F828074   LW V0, -32652(GP)
9D008B04  A0400011   SB ZERO, 17(V0)
1193:                        set_curpos(con,state->scr_col,state->scr_line);
9D008B08  97848062   LHU A0, -32670(GP)
9D008B0C  00002821   ADDU A1, ZERO, ZERO
9D008B10  0F404FB2   JAL set_curpos
9D008B14  80460010   LB A2, 16(V0)
1194:                    }
1195:                }//f()
9D008B18  8FBF0064   LW RA, 100(SP)
9D008B1C  03E00008   JR RA
9D008B20  27BD0068   ADDIU SP, SP, 104
1196:                
1197:                static void line_end(){
9D008C28  27BDFF90   ADDIU SP, SP, -112
9D008C2C  AFBF006C   SW RA, 108(SP)
9D008C30  AFB10068   SW S1, 104(SP)
9D008C34  AFB00064   SW S0, 100(SP)
1198:                    int llen;
1199:                    char buf[CHAR_PER_LINE];
1200:                    llen=sram_line_end(buf,true);
9D008C38  27A40010   ADDIU A0, SP, 16
9D008C3C  0F4022C9   JAL sram_line_end
9D008C40  24050001   ADDIU A1, ZERO, 1
1201:                    if (llen){
9D008C44  1040000F   BEQ V0, ZERO, 0x9D008C84
9D008C48  8FBF006C   LW RA, 108(SP)
1202:                        state->scr_col=strlen(_screen_line(state->scr_line));
9D008C4C  8F918074   LW S1, -32652(GP)
9D008C50  82300010   LB S0, 16(S1)
9D008C54  00101900   SLL V1, S0, 4
9D008C58  00101180   SLL V0, S0, 6
9D008C5C  00621021   ADDU V0, V1, V0
9D008C60  8F8480CC   LW A0, -32564(GP)
9D008C64  0F406EC2   JAL strlen
9D008C68  00822021   ADDU A0, A0, V0
9D008C6C  7C022C20   SEB A1, V0
9D008C70  A2250011   SB A1, 17(S1)
1203:                        set_curpos(con,state->scr_col,state->scr_line);
9D008C74  97848062   LHU A0, -32670(GP)
9D008C78  0F404FB2   JAL set_curpos
9D008C7C  02003021   ADDU A2, S0, ZERO
1204:                    }
1205:                }//f()
9D008C80  8FBF006C   LW RA, 108(SP)
9D008C84  8FB10068   LW S1, 104(SP)
9D008C88  8FB00064   LW S0, 100(SP)
9D008C8C  03E00008   JR RA
9D008C90  27BD0070   ADDIU SP, SP, 112
1206:                
1207:                 static void line_break(){
1208:                     if (sram_insert_char(A_LF)){
9D00A7C4  0F4021E1   JAL sram_insert_char
9D00A7C8  2404000A   ADDIU A0, ZERO, 10
9D00A7CC  10400019   BEQ V0, ZERO, 0x9D00A834
9D00A7D0  8F948074   LW S4, -32652(GP)
1209:                         state->lines_count++;
9D00A7D4  8E820018   LW V0, 24(S4)
9D00A7D8  24420001   ADDIU V0, V0, 1
9D00A7DC  AE820018   SW V0, 24(S4)
1210:                         state->file_line++;
9D00A7E0  8E820014   LW V0, 20(S4)
9D00A7E4  24420001   ADDIU V0, V0, 1
9D00A7E8  AE820014   SW V0, 20(S4)
1211:                         state->scr_col=0;
9D00A7EC  A2800011   SB ZERO, 17(S4)
1212:                         state->scr_line++;
9D00A7F0  92820010   LBU V0, 16(S4)
9D00A7F4  24420001   ADDIU V0, V0, 1
9D00A7F8  7C021420   SEB V0, V0
9D00A7FC  A2820010   SB V0, 16(S4)
1213:                         if (state->scr_line>LAST_LINE){
9D00A800  2842001D   SLTI V0, V0, 29
9D00A804  14400007   BNE V0, ZERO, 0x9D00A824
9D00A808  00000000   NOP
1214:                             state->scr_first+=strlen(screen)+1;
9D00A80C  0F406EC2   JAL strlen
9D00A810  8F8480CC   LW A0, -32564(GP)
9D00A814  8E830004   LW V1, 4(S4)
9D00A818  24630001   ADDIU V1, V1, 1
9D00A81C  00621021   ADDU V0, V1, V0
9D00A820  AE820004   SW V0, 4(S4)
1215:                         }
1216:                         fill_screen();
9D00A824  0F40238E   JAL fill_screen
9D00A828  00000000   NOP
1217:                     }else{
1218:                         _beep();
9D00A834  240401F4   ADDIU A0, ZERO, 500
9D00A838  0F406085   JAL tone
9D00A83C  24050064   ADDIU A1, ZERO, 100
1219:                     }
1220:                }//f()
1221:                
1222:                static void file_home(){
1223:                    while (state->file_line){
9D00A1D8  8F828074   LW V0, -32652(GP)
9D00A1DC  8C420014   LW V0, 20(V0)
9D00A1E0  14400091   BNE V0, ZERO, 0x9D00A428
9D00A1E4  00000000   NOP
9D00A1E8  0B402910   J 0x9D00A440
9D00A1EC  00000000   NOP
9D00A430  8F828074   LW V0, -32652(GP)
9D00A434  8C420014   LW V0, 20(V0)
9D00A438  1440FFFB   BNE V0, ZERO, 0x9D00A428
9D00A43C  00000000   NOP
1224:                        line_up();
9D00A428  0F402401   JAL line_up
9D00A42C  00000000   NOP
1225:                    }
1226:                    line_home();
9D00A440  0F4022B9   JAL line_home
9D00A444  00000000   NOP
1227:                }//f()
1228:                
1229:                static void file_end(){
9D009218  27BDFFE8   ADDIU SP, SP, -24
9D00921C  AFBF0014   SW RA, 20(SP)
1230:                    while (state->file_line < state->lines_count){
9D009220  8F828074   LW V0, -32652(GP)
9D009224  8C430014   LW V1, 20(V0)
9D009228  8C420018   LW V0, 24(V0)
9D00922C  0062102B   SLTU V0, V1, V0
9D009230  10400009   BEQ V0, ZERO, 0x9D009258
9D009234  00000000   NOP
9D009240  8F828074   LW V0, -32652(GP)
9D009244  8C430014   LW V1, 20(V0)
9D009248  8C420018   LW V0, 24(V0)
9D00924C  0062102B   SLTU V0, V1, V0
9D009250  1440FFF9   BNE V0, ZERO, 0x9D009238
9D009254  00000000   NOP
1231:                        line_down();
9D009238  0F40245A   JAL line_down
9D00923C  00000000   NOP
1232:                    }
1233:                    line_end();
9D009258  0F40230A   JAL line_end
9D00925C  00000000   NOP
1234:                }//f()
9D009260  8FBF0014   LW RA, 20(SP)
9D009264  03E00008   JR RA
9D009268  27BD0018   ADDIU SP, SP, 24
1235:                
1236:                static void page_up(){
1237:                    int count;
1238:                
1239:                    count=state->scr_line+EDITOR_LINES;
9D00A470  8F828074   LW V0, -32652(GP)
1240:                    while (state->file_line && count){
9D00A478  8C420014   LW V0, 20(V0)
9D00A494  8F828074   LW V0, -32652(GP)
1241:                        line_up();
9D00A48C  0F402401   JAL line_up
1242:                        count--;
1243:                    }
1244:                    line_home();
9D00A4AC  0F4022B9   JAL line_home
9D00A4B0  00000000   NOP
1245:                }
1246:                
1247:                static void page_down(){
1248:                    int count;
1249:                    count=EDITOR_LINES-state->scr_line;
9D00A4BC  8F828074   LW V0, -32652(GP)
1250:                    while ((state->file_line<state->lines_count) && count){
9D00A4CC  8C430014   LW V1, 20(V0)
9D00A4F0  8F828074   LW V0, -32652(GP)
1251:                        line_down();
9D00A4E8  0F40245A   JAL line_down
1252:                        count--;
1253:                    }
1254:                    line_home();
9D00A510  0F4022B9   JAL line_home
1255:                    if (state->file_line<state->lines_count){
9D00A518  8F828074   LW V0, -32652(GP)
1256:                        state->scr_first=state->gap_first;
9D00A530  8C430008   LW V1, 8(V0)
1257:                        state->scr_line=0;
1258:                        fill_screen();
9D00A538  0F40238E   JAL fill_screen
9D00A53C  A0400010   SB ZERO, 16(V0)
1259:                    }
1260:                }
1261:                
1262:                // avance le curseur au prochain caractère alphanumérique.
1263:                static char forward_alnum(char c){
1264:                    while (c && !isalnum(c)){
9D00A3A8  10400248   BEQ V0, ZERO, 0x9D00ACCC
1265:                        char_right();
9D00A378  0F402416   JAL char_right
1266:                        c=_screen_get(state->scr_line,state->scr_col);
9D00A380  8F838074   LW V1, -32652(GP)
9D00A384  80620010   LB V0, 16(V1)
9D00A388  80630011   LB V1, 17(V1)
9D00A38C  00022100   SLL A0, V0, 4
9D00A390  00021180   SLL V0, V0, 6
9D00A394  00821021   ADDU V0, A0, V0
9D00A398  00431021   ADDU V0, V0, V1
9D00A39C  8F8380CC   LW V1, -32564(GP)
9D00A3A0  00621021   ADDU V0, V1, V0
9D00A3A4  80420000   LB V0, 0(V0)
9D00A3A8  10400248   BEQ V0, ZERO, 0x9D00ACCC
9D00A3AC  00501021   ADDU V0, V0, S0
9D00A3B0  90420000   LBU V0, 0(V0)
9D00A3B4  30420007   ANDI V0, V0, 7
9D00A3B8  1040FFEF   BEQ V0, ZERO, forward_alnum
9D00A3BC  93828068   LBU V0, -32664(GP)
9D00A3C0  0B402B34   J 0x9D00ACD0
9D00A3C4  00000000   NOP
1267:                    }
1268:                    return c;
1269:                }// forward_next_alnum()
1270:                
1271:                // avance le curseur au prochain caractère qui n'est pas alphanumérique.
1272:                static char forward_not_alnum(char c){
1273:                    while (c && isalnum(c)){
9D00A370  14600015   BNE V1, ZERO, 0x9D00A3C8
9D00A374  00000000   NOP
9D00A3F8  10400234   BEQ V0, ZERO, 0x9D00ACCC
9D00A3FC  00501021   ADDU V0, V0, S0
9D00A400  90420000   LBU V0, 0(V0)
9D00A404  30420007   ANDI V0, V0, 7
9D00A408  1440FFEF   BNE V0, ZERO, 0x9D00A3C8
9D00A40C  00000000   NOP
9D00A410  0B4028DE   J forward_alnum
9D00A414  00000000   NOP
1274:                        char_right();
9D00A3C8  0F402416   JAL char_right
9D00A3CC  00000000   NOP
1275:                        c=_screen_get(state->scr_line,state->scr_col);
9D00A3D0  8F838074   LW V1, -32652(GP)
9D00A3D4  80620010   LB V0, 16(V1)
9D00A3D8  80630011   LB V1, 17(V1)
9D00A3DC  00022100   SLL A0, V0, 4
9D00A3E0  00021180   SLL V0, V0, 6
9D00A3E4  00821021   ADDU V0, A0, V0
9D00A3E8  00431021   ADDU V0, V0, V1
9D00A3EC  8F8380CC   LW V1, -32564(GP)
9D00A3F0  00621021   ADDU V0, V1, V0
9D00A3F4  80420000   LB V0, 0(V0)
1276:                    }
1277:                    return c;
1278:                }
1279:                
1280:                static void word_right(){
1281:                    char c;
1282:                
1283:                    c=_screen_get(state->scr_line,state->scr_col);
9D00A330  8F838074   LW V1, -32652(GP)
9D00A334  80620010   LB V0, 16(V1)
9D00A338  80630011   LB V1, 17(V1)
9D00A33C  00022100   SLL A0, V0, 4
9D00A340  00021180   SLL V0, V0, 6
9D00A344  00821021   ADDU V0, A0, V0
9D00A348  00431021   ADDU V0, V0, V1
9D00A34C  8F8380CC   LW V1, -32564(GP)
9D00A350  00621021   ADDU V0, V1, V0
9D00A354  80420000   LB V0, 0(V0)
1284:                    while (c){
9D00A358  1040025C   BEQ V0, ZERO, 0x9D00ACCC
9D00A35C  00501821   ADDU V1, V0, S0
1285:                        if (!isalnum(c)){
9D009DDC  3C109D02   LUI S0, -25342
9D009DE0  2610CB59   ADDIU S0, S0, -13479
9D00A360  90630000   LBU V1, 0(V1)
9D00A364  30630007   ANDI V1, V1, 7
9D00A368  10600003   BEQ V1, ZERO, forward_alnum
9D00A36C  00000000   NOP
1286:                            c=forward_alnum(c);
1287:                            break;
1288:                        }else{
1289:                            c=forward_not_alnum(c);
1290:                        }
1291:                    }//if
1292:                }//word_right()
1293:                
1294:                static char back_alnum(char c){
1295:                    while (state->scr_col && !isalnum(c)){
9D00A25C  80420011   LB V0, 17(V0)
9D00A29C  1040028B   BEQ V0, ZERO, 0x9D00ACCC
1296:                        char_left();
9D00A270  0F4023C2   JAL char_left
1297:                        c=_screen_get(state->scr_line,state->scr_col);
9D00A278  8F838074   LW V1, -32652(GP)
1298:                    }
1299:                    return c;
1300:                }//back_next_alnum()
1301:                
1302:                static char back_not_alnum(char c){
1303:                    while (state->scr_col && isalnum(c)){
9D00A2EC  10400006   BEQ V0, ZERO, 0x9D00A308
1304:                        char_left();
9D00A2C0  0F4023C2   JAL char_left
1305:                        c=_screen_get(state->scr_line,state->scr_col);
9D00A2C8  8F838074   LW V1, -32652(GP)
1306:                    }
1307:                    return c;
1308:                }// back_next_not_alnum()
1309:                
1310:                
1311:                static void word_left(){
1312:                    char c;
1313:                    
1314:                    c=_screen_get(state->scr_line,state->scr_col);
9D00A220  8F838074   LW V1, -32652(GP)
9D00A224  80620010   LB V0, 16(V1)
9D00A228  80630011   LB V1, 17(V1)
9D00A22C  00022100   SLL A0, V0, 4
9D00A230  00021180   SLL V0, V0, 6
9D00A234  00821021   ADDU V0, A0, V0
9D00A238  00431021   ADDU V0, V0, V1
9D00A23C  8F8380CC   LW V1, -32564(GP)
9D00A240  00621021   ADDU V0, V1, V0
9D00A244  0B4028C2   J 0x9D00A308
9D00A248  80430000   LB V1, 0(V0)
1315:                    while (state->scr_col){
9D00A308  8F828074   LW V0, -32652(GP)
9D00A30C  80440011   LB A0, 17(V0)
9D00A310  1480FFCE   BNE A0, ZERO, 0x9D00A24C
9D00A314  00702021   ADDU A0, V1, S0
1316:                        if (!isalnum(c)){
9D00A24C  90840000   LBU A0, 0(A0)
9D00A250  30840007   ANDI A0, A0, 7
9D00A254  1480001A   BNE A0, ZERO, back_not_alnum
9D00A258  00000000   NOP
1317:                            c=back_alnum(c);
1318:                            break;
1319:                        }else{
1320:                            c=back_not_alnum(c);
1321:                        }
1322:                    }
1323:                }//word_left()
1324:                
1325:                static void jump_to_line(uint16_t line_no){
9D009408  27BDFFE0   ADDIU SP, SP, -32
9D00940C  AFBF001C   SW RA, 28(SP)
9D009410  AFB10018   SW S1, 24(SP)
9D009414  AFB00014   SW S0, 20(SP)
1326:                    line_home();
9D009418  0F4022B9   JAL line_home
9D00941C  00808821   ADDU S1, A0, ZERO
1327:                    if (line_no>state->lines_count){
9D009420  8F828074   LW V0, -32652(GP)
9D009424  8C430018   LW V1, 24(V0)
9D009428  0071182B   SLTU V1, V1, S1
9D00942C  50600005   BEQL V1, ZERO, 0x9D009444
9D009430  8C420014   LW V0, 20(V0)
1328:                        file_end();
9D009434  0F402486   JAL file_end
9D009438  00000000   NOP
9D00943C  0B402529   J 0x9D0094A4
9D009440  8F828074   LW V0, -32652(GP)
1329:                    }else if (line_no<state->file_line){
9D009444  0222182B   SLTU V1, S1, V0
9D009448  14600006   BNE V1, ZERO, 0x9D009464
9D00944C  02208021   ADDU S0, S1, ZERO
1330:                                while (line_no<state->file_line){line_up();}
9D009464  0F402401   JAL line_up
9D009468  00000000   NOP
9D00946C  8F828074   LW V0, -32652(GP)
9D009470  8C420014   LW V0, 20(V0)
9D009474  0202102B   SLTU V0, S0, V0
9D009478  1440FFFA   BNE V0, ZERO, 0x9D009464
9D00947C  8F828074   LW V0, -32652(GP)
9D009480  0B40252A   J 0x9D0094A8
9D009484  80430010   LB V1, 16(V0)
1331:                        }else{
1332:                                while (state->file_line<line_no){line_down();}
9D009450  0051882B   SLTU S1, V0, S1
9D009454  1620000C   BNE S1, ZERO, 0x9D009488
9D009458  8F828074   LW V0, -32652(GP)
9D009488  0F40245A   JAL line_down
9D00948C  00000000   NOP
9D009490  8F828074   LW V0, -32652(GP)
9D009494  8C420014   LW V0, 20(V0)
9D009498  0050102B   SLTU V0, V0, S0
9D00949C  1440FFFA   BNE V0, ZERO, 0x9D009488
9D0094A0  8F828074   LW V0, -32652(GP)
1333:                    }//if
1334:                    if (state->scr_line){
9D00945C  0B40252A   J 0x9D0094A8
9D009460  80430010   LB V1, 16(V0)
9D0094A4  80430010   LB V1, 16(V0)
9D0094A8  10600006   BEQ V1, ZERO, 0x9D0094C4
9D0094AC  8FBF001C   LW RA, 28(SP)
1335:                        state->scr_first=state->gap_first;
9D0094B0  8C430008   LW V1, 8(V0)
9D0094B4  AC430004   SW V1, 4(V0)
1336:                        state->scr_line=0;
1337:                        fill_screen();
9D0094B8  0F40238E   JAL fill_screen
9D0094BC  A0400010   SB ZERO, 16(V0)
1338:                    }
1339:                }//jump_to_line()
9D0094C0  8FBF001C   LW RA, 28(SP)
9D0094C4  8FB10018   LW S1, 24(SP)
9D0094C8  8FB00014   LW S0, 20(SP)
9D0094CC  03E00008   JR RA
9D0094D0  27BD0020   ADDIU SP, SP, 32
1340:                
1341:                static void goto_line(){
1342:                    uint8_t llen;
1343:                    char line[16];
1344:                    uint16_t line_no=0;
1345:                    
1346:                    invert_display(true);
9D00AB74  0F40212D   JAL invert_display
9D00AB78  24040001   ADDIU A0, ZERO, 1
1347:                    print(con,"goto line: ");
9D00AB7C  97848062   LHU A0, -32670(GP)
9D00AB80  3C059D02   LUI A1, -25342
9D00AB84  0F404FCC   JAL print
9D00AB88  24A588E4   ADDIU A1, A1, -30492
1348:                    llen=read_line(con,line,16);
9D00AB8C  97848062   LHU A0, -32670(GP)
9D00AB90  27A50018   ADDIU A1, SP, 24
9D00AB94  0F404F93   JAL read_line
9D00AB98  24060010   ADDIU A2, ZERO, 16
9D00AB9C  0040A021   ADDU S4, V0, ZERO
1349:                    invert_display(false);
9D00ABA0  0F40212D   JAL invert_display
9D00ABA4  00002021   ADDU A0, ZERO, ZERO
1350:                    if (llen){
9D00ABA8  52800049   BEQL S4, ZERO, 0x9D00ACD0
9D00ABAC  93828068   LBU V0, -32664(GP)
1351:                        line_no=atoi((const char*)line);
9D00ABB0  0F407787   JAL atoi
9D00ABB4  27A40018   ADDIU A0, SP, 24
1352:                        jump_to_line(--line_no);
9D00ABB8  2442FFFF   ADDIU V0, V0, -1
9D00ABBC  0F402502   JAL jump_to_line
9D00ABC0  3044FFFF   ANDI A0, V0, -1
9D00ABC4  0B402B34   J 0x9D00ACD0
9D00ABC8  93828068   LBU V0, -32664(GP)
9D00ABCC  0F402609   JAL new_file
9D00ABD0  00002021   ADDU A0, ZERO, ZERO
9D00ABD4  0B402B34   J 0x9D00ACD0
9D00ABD8  93828068   LBU V0, -32664(GP)
9D00ABDC  0F402187   JAL ask_confirm
9D00ABE0  00000000   NOP
9D00ABE4  1040003A   BEQ V0, ZERO, 0x9D00ACD0
9D00ABE8  93828068   LBU V0, -32664(GP)
9D00ABEC  0F40212D   JAL invert_display
9D00ABF0  24040001   ADDIU A0, ZERO, 1
9D00ABF4  97848062   LHU A0, -32670(GP)
9D00ABF8  0F404FCC   JAL print
9D00ABFC  02C02821   ADDU A1, S6, ZERO
9D00AC00  0F402220   JAL get_file_name
9D00AC04  27A40018   ADDIU A0, SP, 24
9D00AC08  10400009   BEQ V0, ZERO, 0x9D00AC30
9D00AC0C  3C049D02   LUI A0, -25342
9D00AC10  0F40223A   JAL file_exist
9D00AC14  27A40018   ADDIU A0, SP, 24
9D00AC18  10400005   BEQ V0, ZERO, 0x9D00AC30
9D00AC1C  3C049D02   LUI A0, -25342
9D00AC20  0F402578   JAL load_file
9D00AC24  27A40018   ADDIU A0, SP, 24
9D00AC28  0B402B0F   J 0x9D00AC3C
9D00AC2C  00000000   NOP
9D00AC30  248488FC   ADDIU A0, A0, -30468
9D00AC34  0F40224E   JAL ed_error
9D00AC38  00002821   ADDU A1, ZERO, ZERO
9D00AC3C  0F40212D   JAL invert_display
9D00AC40  00002021   ADDU A0, ZERO, ZERO
9D00AC44  0B402B34   J 0x9D00ACD0
9D00AC48  93828068   LBU V0, -32664(GP)
9D00AC4C  0F402187   JAL ask_confirm
9D00AC50  00000000   NOP
9D00AC54  1040001E   BEQ V0, ZERO, 0x9D00ACD0
9D00AC58  93828068   LBU V0, -32664(GP)
9D00AC5C  0F407BCB   JAL free
9D00AC60  8F848070   LW A0, -32656(GP)
9D00AC64  0F407BCB   JAL free
9D00AC68  8F848074   LW A0, -32652(GP)
9D00AC6C  0F407BCB   JAL free
9D00AC70  8F84806C   LW A0, -32660(GP)
9D00AC74  0F407BCB   JAL free
9D00AC78  8F8480CC   LW A0, -32564(GP)
9D00AC7C  0F403BF3   JAL vga_set_cursor
9D00AC80  00002021   ADDU A0, ZERO, ZERO
9D00AC84  24020001   ADDIU V0, ZERO, 1
9D00AC88  0B402B36   J 0x9D00ACD8
9D00AC8C  A3828068   SB V0, -32664(GP)
9D00AC90  0F4026DE   JAL save_file
9D00AC94  00000000   NOP
9D00AC98  0B402B34   J 0x9D00ACD0
9D00AC9C  93828068   LBU V0, -32664(GP)
9D00ACA0  2443FFE0   ADDIU V1, V0, -32
9D00ACA4  306300FF   ANDI V1, V1, 255
9D00ACA8  2C630060   SLTIU V1, V1, 96
9D00ACAC  10600005   BEQ V1, ZERO, 0x9D00ACC4
9D00ACB0  240401F4   ADDIU A0, ZERO, 500
9D00ACB4  0F402627   JAL insert_char
9D00ACB8  7C022420   SEB A0, V0
9D00ACBC  0B402B34   J 0x9D00ACD0
9D00ACC0  93828068   LBU V0, -32664(GP)
9D00ACC4  0F406085   JAL tone
9D00ACC8  24050064   ADDIU A1, ZERO, 100
9D00ACCC  93828068   LBU V0, -32664(GP)
9D00ACD0  1040FC45   BEQ V0, ZERO, 0x9D009DE8
9D00ACD4  8F828074   LW V0, -32652(GP)
9D00ACD8  97848062   LHU A0, -32670(GP)
9D00ACDC  0F404FE7   JAL invert_video
9D00ACE0  00002821   ADDU A1, ZERO, ZERO
9D00ACE4  0F404F63   JAL clear_screen
9D00ACE8  97848062   LHU A0, -32670(GP)
9D00ACEC  8FBF0094   LW RA, 148(SP)
9D00ACF0  8FBE0090   LW S8, 144(SP)
9D00ACF4  8FB7008C   LW S7, 140(SP)
9D00ACF8  8FB60088   LW S6, 136(SP)
9D00ACFC  8FB50084   LW S5, 132(SP)
9D00AD00  8FB40080   LW S4, 128(SP)
9D00AD04  8FB3007C   LW S3, 124(SP)
9D00AD08  8FB20078   LW S2, 120(SP)
9D00AD0C  8FB10074   LW S1, 116(SP)
9D00AD10  8FB00070   LW S0, 112(SP)
9D00AD14  03E00008   JR RA
9D00AD18  27BD0098   ADDIU SP, SP, 152
1353:                    }
1354:                }
1355:                
1356:                   
---  /home/jacques/github/vpc-32vga/console.c  ----------------------------------------------------------
1:                   /*
2:                   * Copyright 2013,2017,2018 Jacques Deschênes
3:                   * This file is part of VPC-32v.
4:                   *
5:                   *     VPC-32v is free software: you can redistribute it and/or modify
6:                   *     it under the terms of the GNU General Public License as published by
7:                   *     the Free Software Foundation, either version 3 of the License, or
8:                   *     (at your option) any later version.
9:                   *
10:                  *     VPC-32v is distributed in the hope that it will be useful,
11:                  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  *     GNU General Public License for more details.
14:                  *
15:                  *     You should have received a copy of the GNU General Public License
16:                  *     along with VPC-32v.  If not, see <http://www.gnu.org/licenses/>.
17:                  */
18:                  
19:                  /*
20:                   *  Name: console.c
21:                   *  Description: text console for NTSC video output
22:                   *  Author: Jacques Deschênes
23:                   *  Date Created: 2013-09-06
24:                   *  rev: 2017-08-02
25:                   */
26:                  
27:                  #include <string.h>
28:                  #include "console.h"
29:                  #include "hardware/HardwareProfile.h"
30:                  #include "hardware/serial_comm/serial_comm.h"
31:                  #include "hardware/ps2_kbd/keyboard.h"
32:                  #include "hardware/tvout/vga.h"
33:                  #include "vt100.h"
34:                  
35:                  
36:                  static int tab_width=4;
37:                  
38:                  void uppercase(char *str){// in situ uppercase
39:                      while (*str){
9D013D4C  80820000   LB V0, 0(A0)
9D013D50  1040000C   BEQ V0, ZERO, 0x9D013D84
9D013D54  304200FF   ANDI V0, V0, 255
9D013D78  80820000   LB V0, 0(A0)
9D013D7C  1440FFF6   BNE V0, ZERO, 0x9D013D58
9D013D80  304200FF   ANDI V0, V0, 255
9D013D84  03E00008   JR RA
9D013D88  00000000   NOP
40:                          if (*str>='a' && *str<='z') *str-=32;
9D013D58  2443FF9F   ADDIU V1, V0, -97
9D013D5C  306300FF   ANDI V1, V1, 255
9D013D60  2C63001A   SLTIU V1, V1, 26
9D013D64  50600004   BEQL V1, ZERO, 0x9D013D78
9D013D68  24840001   ADDIU A0, A0, 1
9D013D6C  2442FFE0   ADDIU V0, V0, -32
9D013D70  A0820000   SB V0, 0(A0)
41:                          str++;
9D013D74  24840001   ADDIU A0, A0, 1
9D013D78  80820000   LB V0, 0(A0)
9D013D7C  1440FFF6   BNE V0, ZERO, 0x9D013D58
9D013D80  304200FF   ANDI V0, V0, 255
9D013D84  03E00008   JR RA
9D013D88  00000000   NOP
42:                      }
43:                  }
44:                  
45:                   // efface l'écran et positionne le curseur à {0,0}
46:                  void clear_screen(dev_t dev){
9D013D8C  27BDFFE8   ADDIU SP, SP, -24
47:                      if (dev==VGA_CONSOLE){
9D013D90  14800005   BNE A0, ZERO, 0x9D013DA8
9D013D94  AFBF0014   SW RA, 20(SP)
48:                          vga_clear_screen();
9D013D98  0F40397D   JAL vga_clear_screen
9D013D9C  00000000   NOP
9D013DA0  0B404F6D   J 0x9D013DB4
9D013DA4  8FBF0014   LW RA, 20(SP)
49:                      }else{
50:                          vt_clear_screen();
9D013DA8  0F405B21   JAL vt_clear_screen
9D013DAC  00000000   NOP
51:                      }
52:                  }
9D013DB0  8FBF0014   LW RA, 20(SP)
9D013DB4  03E00008   JR RA
9D013DB8  27BD0018   ADDIU SP, SP, 24
53:                  
54:                  // efface la fin de la ligne à partir du curseur.
55:                  void clear_eol(dev_t dev){
9D013DBC  27BDFFE8   ADDIU SP, SP, -24
56:                      if (dev==VGA_CONSOLE){
9D013DC0  14800005   BNE A0, ZERO, 0x9D013DD8
9D013DC4  AFBF0014   SW RA, 20(SP)
57:                          vga_clear_eol();
9D013DC8  0F403ABE   JAL vga_clear_eol
9D013DCC  00000000   NOP
9D013DD0  0B404F79   J 0x9D013DE4
9D013DD4  8FBF0014   LW RA, 20(SP)
58:                      }else{
59:                          vt_clear_eol();
9D013DD8  0F405B28   JAL vt_clear_eol
9D013DDC  00000000   NOP
60:                      }
61:                  }
9D013DE0  8FBF0014   LW RA, 20(SP)
9D013DE4  03E00008   JR RA
9D013DE8  27BD0018   ADDIU SP, SP, 24
62:                  
63:                  // retourne une touche du clavier si disponible
64:                  // sinon retourne 0.
65:                  unsigned char get_key(dev_t dev){
9D013DEC  27BDFFE8   ADDIU SP, SP, -24
66:                      if (dev==VGA_CONSOLE){
9D013DF0  14800005   BNE A0, ZERO, 0x9D013E08
9D013DF4  AFBF0014   SW RA, 20(SP)
67:                          return kbd_get_key();
9D013DF8  0F405FCC   JAL kbd_get_key
9D013DFC  00000000   NOP
9D013E00  0B404F85   J 0x9D013E14
9D013E04  8FBF0014   LW RA, 20(SP)
68:                      }else{
69:                          return vt_get_char();
9D013E08  0F405B44   JAL vt_get_char
9D013E0C  00000000   NOP
70:                      }
71:                  }
9D013E10  8FBF0014   LW RA, 20(SP)
9D013E14  03E00008   JR RA
9D013E18  27BD0018   ADDIU SP, SP, 24
72:                   // attend réception d'un caractère
73:                  unsigned char wait_key(dev_t dev){
9D013E1C  27BDFFE8   ADDIU SP, SP, -24
74:                      if (dev==VGA_CONSOLE){
9D013E20  14800005   BNE A0, ZERO, 0x9D013E38
9D013E24  AFBF0014   SW RA, 20(SP)
75:                          return kbd_wait_key();
9D013E28  0F405FE2   JAL kbd_wait_key
9D013E2C  00000000   NOP
9D013E30  0B404F91   J 0x9D013E44
9D013E34  8FBF0014   LW RA, 20(SP)
76:                      }else{
77:                          return vt_wait_char();
9D013E38  0F405B75   JAL vt_wait_char
9D013E3C  00000000   NOP
78:                      }
79:                  }
9D013E40  8FBF0014   LW RA, 20(SP)
9D013E44  03E00008   JR RA
9D013E48  27BD0018   ADDIU SP, SP, 24
80:                  
81:                  unsigned char read_line(dev_t dev, unsigned char *ibuff,unsigned char max_char){ // lit une ligne au clavier, retourne la longueur de texte.
9D013E4C  27BDFFE8   ADDIU SP, SP, -24
9D013E50  AFBF0014   SW RA, 20(SP)
9D013E54  00A01021   ADDU V0, A1, ZERO
82:                      if (dev==VGA_CONSOLE){
9D013E58  14800005   BNE A0, ZERO, 0x9D013E70
9D013E5C  00C02821   ADDU A1, A2, ZERO
83:                          return kbd_read_line(ibuff,max_char);
9D013E60  0F405FF2   JAL kbd_read_line
9D013E64  00402021   ADDU A0, V0, ZERO
9D013E68  0B404FA0   J 0x9D013E80
9D013E6C  8FBF0014   LW RA, 20(SP)
84:                      }else{
85:                          return ser_read_line(ibuff,max_char);
9D013E70  0F40551A   JAL ser_read_line
9D013E74  00402021   ADDU A0, V0, ZERO
9D013E78  304200FF   ANDI V0, V0, 255
86:                      }
87:                  }
9D013E7C  8FBF0014   LW RA, 20(SP)
9D013E80  03E00008   JR RA
9D013E84  27BD0018   ADDIU SP, SP, 24
88:                  
89:                  // retourne les coordonnées du curseur texte.
90:                  text_coord_t get_curpos(dev_t dev){
9D013E88  27BDFFE8   ADDIU SP, SP, -24
9D013E8C  AFBF0014   SW RA, 20(SP)
9D013E90  AFB00010   SW S0, 16(SP)
91:                      if (dev==VGA_CONSOLE){
9D013E94  14A00005   BNE A1, ZERO, 0x9D013EAC
9D013E98  00808021   ADDU S0, A0, ZERO
92:                          return vga_get_curpos();
9D013E9C  0F403AE8   JAL vga_get_curpos
9D013EA0  00000000   NOP
9D013EA4  0B404FAE   J 0x9D013EB8
9D013EA8  02001021   ADDU V0, S0, ZERO
93:                      }else{
94:                          return vt_get_curpos();
9D013EAC  0F405B31   JAL vt_get_curpos
9D013EB0  00000000   NOP
95:                      }
96:                  }
9D013EB4  02001021   ADDU V0, S0, ZERO
9D013EB8  8FBF0014   LW RA, 20(SP)
9D013EBC  8FB00010   LW S0, 16(SP)
9D013EC0  03E00008   JR RA
9D013EC4  27BD0018   ADDIU SP, SP, 24
97:                  
98:                  // positionnne le curseur texte
99:                  void set_curpos(dev_t dev,int x, int y){
9D013EC8  27BDFFE8   ADDIU SP, SP, -24
100:                     if (dev==VGA_CONSOLE){
9D013ECC  14800006   BNE A0, ZERO, 0x9D013EE8
9D013ED0  AFBF0014   SW RA, 20(SP)
101:                         vga_set_curpos(x,y);
9D013ED4  30A4FFFF   ANDI A0, A1, -1
9D013ED8  0F403BB2   JAL vga_set_curpos
9D013EDC  30C5FFFF   ANDI A1, A2, -1
9D013EE0  0B404FBE   J 0x9D013EF8
9D013EE4  8FBF0014   LW RA, 20(SP)
102:                     }else{
103:                         vt_set_curpos(x,y);
9D013EE8  00A02021   ADDU A0, A1, ZERO
9D013EEC  0F405B33   JAL vt_set_curpos
9D013EF0  00C02821   ADDU A1, A2, ZERO
104:                     }
105:                 }
9D013EF4  8FBF0014   LW RA, 20(SP)
9D013EF8  03E00008   JR RA
9D013EFC  27BD0018   ADDIU SP, SP, 24
106:                 
107:                 void put_char(dev_t dev, char c){
9D013F00  27BDFFE8   ADDIU SP, SP, -24
108:                     if (dev==VGA_CONSOLE){
9D013F04  14800005   BNE A0, ZERO, 0x9D013F1C
9D013F08  AFBF0014   SW RA, 20(SP)
109:                         vga_put_char(c);
9D013F0C  0F403A08   JAL vga_put_char
9D013F10  00A02021   ADDU A0, A1, ZERO
9D013F14  0B404FCA   J 0x9D013F28
9D013F18  8FBF0014   LW RA, 20(SP)
110:                     }else{
111:                         vt_put_char(c);
9D013F1C  0F405BA6   JAL vt_put_char
9D013F20  00A02021   ADDU A0, A1, ZERO
112:                     }
113:                 }
9D013F24  8FBF0014   LW RA, 20(SP)
9D013F28  03E00008   JR RA
9D013F2C  27BD0018   ADDIU SP, SP, 24
114:                 
115:                 void print(dev_t dev, const char *str){
9D013F38  27BDFFE8   ADDIU SP, SP, -24
116:                     if (!str) return;
9D013F30  10A0000C   BEQ A1, ZERO, 0x9D013F64
9D013F34  00000000   NOP
117:                     if (dev==VGA_CONSOLE){
9D013F3C  14800005   BNE A0, ZERO, 0x9D013F54
9D013F40  AFBF0014   SW RA, 20(SP)
118:                         vga_print(str);
9D013F44  0F403AA2   JAL vga_print
9D013F48  00A02021   ADDU A0, A1, ZERO
9D013F4C  0B404FD8   J 0x9D013F60
9D013F50  8FBF0014   LW RA, 20(SP)
119:                     }else{
120:                         vt_print(str);
9D013F54  0F405BCA   JAL vt_print
9D013F58  00A02021   ADDU A0, A1, ZERO
121:                     }
122:                 }
9D013F5C  8FBF0014   LW RA, 20(SP)
9D013F60  27BD0018   ADDIU SP, SP, 24
9D013F64  03E00008   JR RA
9D013F68  00000000   NOP
123:                 
124:                 void spaces(dev_t dev, unsigned char count){
9D013F6C  27BDFFE8   ADDIU SP, SP, -24
125:                     if (dev==VGA_CONSOLE){
9D013F70  14800005   BNE A0, ZERO, 0x9D013F88
9D013F74  AFBF0014   SW RA, 20(SP)
126:                         vga_spaces(count);
9D013F78  0F403B6E   JAL vga_spaces
9D013F7C  00A02021   ADDU A0, A1, ZERO
9D013F80  0B404FE5   J 0x9D013F94
9D013F84  8FBF0014   LW RA, 20(SP)
127:                     }else{
128:                         vt_spaces(count);
9D013F88  0F405B7D   JAL vt_spaces
9D013F8C  00A02021   ADDU A0, A1, ZERO
129:                     }
130:                 }
9D013F90  8FBF0014   LW RA, 20(SP)
9D013F94  03E00008   JR RA
9D013F98  27BD0018   ADDIU SP, SP, 24
131:                 
132:                 void invert_video(dev_t dev, BOOL yes){
9D013F9C  27BDFFE8   ADDIU SP, SP, -24
133:                     if (dev==VGA_CONSOLE){
9D013FA0  14800005   BNE A0, ZERO, 0x9D013FB8
9D013FA4  AFBF0014   SW RA, 20(SP)
134:                         vga_invert_video(yes);
9D013FA8  0F403B5E   JAL vga_invert_video
9D013FAC  30A400FF   ANDI A0, A1, 255
9D013FB0  0B404FF1   J 0x9D013FC4
9D013FB4  8FBF0014   LW RA, 20(SP)
135:                     }else{
136:                         vt_invert_video(yes);
9D013FB8  0F405BD9   JAL vt_invert_video
9D013FBC  00A02021   ADDU A0, A1, ZERO
137:                     }
138:                 }
9D013FC0  8FBF0014   LW RA, 20(SP)
9D013FC4  03E00008   JR RA
9D013FC8  27BD0018   ADDIU SP, SP, 24
139:                 
140:                 void crlf(dev_t dev){
9D013FCC  27BDFFE8   ADDIU SP, SP, -24
141:                     if (dev==VGA_CONSOLE){
9D013FD0  14800005   BNE A0, ZERO, 0x9D013FE8
9D013FD4  AFBF0014   SW RA, 20(SP)
142:                         vga_crlf();
9D013FD8  0F4039F9   JAL vga_crlf
9D013FDC  00000000   NOP
9D013FE0  0B404FFD   J 0x9D013FF4
9D013FE4  8FBF0014   LW RA, 20(SP)
143:                     }else{
144:                         vt_crlf();
9D013FE8  0F405BEB   JAL vt_crlf
9D013FEC  00000000   NOP
145:                     }
146:                 }
9D013FF0  8FBF0014   LW RA, 20(SP)
9D013FF4  03E00008   JR RA
9D013FF8  27BD0018   ADDIU SP, SP, 24
147:                 
148:                 void print_int(dev_t dev, int number, int width){
9D013FFC  27BDFFD0   ADDIU SP, SP, -48
9D014000  AFBF002C   SW RA, 44(SP)
149:                     int sign=0;
150:                     char str[18], *d;
151:                     str[17]=0;
9D014004  A3A00021   SB ZERO, 33(SP)
152:                     str[16]=' ';
9D014008  24020020   ADDIU V0, ZERO, 32
9D01400C  A3A20020   SB V0, 32(SP)
9D014010  28C30011   SLTI V1, A2, 17
9D014014  24020010   ADDIU V0, ZERO, 16
9D014018  0043300A   MOVZ A2, V0, V1
153:                     d=&str[15];
154:                     if (width>16){width=16;}
155:                     if (number<0){
9D01401C  04A10004   BGEZ A1, 0x9D014030
9D014020  00005021   ADDU T2, ZERO, ZERO
156:                         sign=1;
9D01402C  240A0001   ADDIU T2, ZERO, 1
157:                         number = -number;
9D014024  00052823   SUBU A1, ZERO, A1
158:                         width--;
9D014028  24C6FFFF   ADDIU A2, A2, -1
159:                     }
160:                     if (!number){
9D014030  14A00005   BNE A1, ZERO, 0x9D014048
9D014034  24020030   ADDIU V0, ZERO, 48
161:                         *d--='0';
9D014038  A3A2001F   SB V0, 31(SP)
9D014040  0B405025   J 0x9D014094
9D014044  27A3001E   ADDIU V1, SP, 30
162:                         width--;
9D01403C  24C6FFFF   ADDIU A2, A2, -1
163:                     }
164:                     while (number>0){
9D014048  18A00012   BLEZ A1, 0x9D014094
9D01404C  27A3001F   ADDIU V1, SP, 31
9D01408C  1C40FFF2   BGTZ V0, 0x9D014058
9D014090  24C6FFFF   ADDIU A2, A2, -1
165:                        *d--=(number%10)+'0';
9D014050  3C096666   LUI T1, 26214
9D014054  25296667   ADDIU T1, T1, 26215
9D014058  2463FFFF   ADDIU V1, V1, -1
9D01405C  00A90018   MULT 0, A1, T1
9D014060  00001010   MFHI V0
9D014064  00021083   SRA V0, V0, 2
9D014068  00053FC3   SRA A3, A1, 31
9D01406C  00471023   SUBU V0, V0, A3
9D014070  00024040   SLL T0, V0, 1
9D014074  000238C0   SLL A3, V0, 3
9D014078  01073821   ADDU A3, T0, A3
9D01407C  00A72823   SUBU A1, A1, A3
9D014080  24A50030   ADDIU A1, A1, 48
9D014084  A0650001   SB A1, 1(V1)
166:                         number /= 10;
9D014088  00402821   ADDU A1, V0, ZERO
167:                         width--;
168:                     }
169:                     if (sign){*d--='-';}
9D014094  11400003   BEQ T2, ZERO, 0x9D0140A4
9D014098  2402002D   ADDIU V0, ZERO, 45
9D01409C  A0620000   SB V0, 0(V1)
9D0140A0  2463FFFF   ADDIU V1, V1, -1
170:                     while (width>0){
9D0140A4  18C00009   BLEZ A2, 0x9D0140CC
9D0140A8  00601021   ADDU V0, V1, ZERO
9D0140AC  00C03821   ADDU A3, A2, ZERO
9D0140B0  00663023   SUBU A2, V1, A2
9D0140C0  5446FFFE   BNEL V0, A2, 0x9D0140BC
9D0140C4  A0450000   SB A1, 0(V0)
9D0140C8  00671823   SUBU V1, V1, A3
171:                         *d--=' ';
9D0140B4  24050020   ADDIU A1, ZERO, 32
9D0140B8  A0450000   SB A1, 0(V0)
9D0140BC  2442FFFF   ADDIU V0, V0, -1
172:                         width--;
173:                     }
174:                     print(dev,++d);
9D0140CC  0F404FCC   JAL print
9D0140D0  24650001   ADDIU A1, V1, 1
175:                 }
9D0140D4  8FBF002C   LW RA, 44(SP)
9D0140D8  03E00008   JR RA
9D0140DC  27BD0030   ADDIU SP, SP, 48
176:                 
177:                 void print_hex(dev_t dev, unsigned hex, int width){
9D0140E0  27BDFFD0   ADDIU SP, SP, -48
9D0140E4  AFBF002C   SW RA, 44(SP)
178:                     char c[18], *d;
179:                     int i;
180:                     c[17]=0;
9D0140E8  A3A00021   SB ZERO, 33(SP)
181:                     c[16]=' ';
9D0140EC  24020020   ADDIU V0, ZERO, 32
9D0140F0  A3A20020   SB V0, 32(SP)
9D0140F4  28C30011   SLTI V1, A2, 17
9D0140F8  24020010   ADDIU V0, ZERO, 16
182:                     d= &c[15];
9D014118  27A3001F   ADDIU V1, SP, 31
183:                     if (width>16){width=16;}
184:                     if (!hex){*d--='0'; width--;}
9D0140FC  14A00006   BNE A1, ZERO, 0x9D014118
9D014100  0043300A   MOVZ A2, V0, V1
9D014104  24020030   ADDIU V0, ZERO, 48
9D014108  A3A2001F   SB V0, 31(SP)
9D01410C  24C6FFFF   ADDIU A2, A2, -1
9D014110  0B405053   J 0x9D01414C
9D014114  27A3001E   ADDIU V1, SP, 30
185:                     while (hex){
9D014144  14A0FFF5   BNE A1, ZERO, 0x9D01411C
9D014148  24C6FFFF   ADDIU A2, A2, -1
186:                         *d=hex%16+'0';
9D01411C  30A2000F   ANDI V0, A1, 15
9D014120  24470030   ADDIU A3, V0, 48
9D014130  0B40504F   J 0x9D01413C
9D014134  A0670000   SB A3, 0(V1)
187:                         if (*d>'9'){
9D014124  28E8003A   SLTI T0, A3, 58
9D014128  51000003   BEQL T0, ZERO, 0x9D014138
9D01412C  24420037   ADDIU V0, V0, 55
188:                             *d+=7;
9D014138  A0620000   SB V0, 0(V1)
189:                         }
190:                         hex>>=4;
9D01413C  00052902   SRL A1, A1, 4
191:                         d--;
9D014140  2463FFFF   ADDIU V1, V1, -1
192:                         width--;
193:                     }
194:                     while(width>0){
9D01414C  18C00009   BLEZ A2, 0x9D014174
9D014150  00601021   ADDU V0, V1, ZERO
9D014154  00C03821   ADDU A3, A2, ZERO
9D014158  00663023   SUBU A2, V1, A2
9D014168  5446FFFE   BNEL V0, A2, 0x9D014164
9D01416C  A0450000   SB A1, 0(V0)
9D014170  00671823   SUBU V1, V1, A3
195:                         *d--=' ';
9D01415C  24050020   ADDIU A1, ZERO, 32
9D014160  A0450000   SB A1, 0(V0)
9D014164  2442FFFF   ADDIU V0, V0, -1
196:                         width--;
197:                     }
198:                     print(dev,++d);
9D014174  0F404FCC   JAL print
9D014178  24650001   ADDIU A1, V1, 1
199:                 }
9D01417C  8FBF002C   LW RA, 44(SP)
9D014180  03E00008   JR RA
9D014184  27BD0030   ADDIU SP, SP, 48
200:                 
201:                 void println(dev_t dev,const char *str){
9D014188  27BDFFE8   ADDIU SP, SP, -24
202:                     if (!str){
9D01418C  14A00005   BNE A1, ZERO, 0x9D0141A4
9D014190  AFBF0014   SW RA, 20(SP)
203:                         crlf(dev);
9D014194  0F404FF3   JAL crlf
9D014198  00000000   NOP
9D01419C  0B405072   J 0x9D0141C8
9D0141A0  8FBF0014   LW RA, 20(SP)
204:                     }else if (dev==VGA_CONSOLE){
9D0141A4  14800005   BNE A0, ZERO, 0x9D0141BC
9D0141A8  00000000   NOP
205:                         vga_println(str);
9D0141AC  0F403AB1   JAL vga_println
9D0141B0  00A02021   ADDU A0, A1, ZERO
9D0141B4  0B405072   J 0x9D0141C8
9D0141B8  8FBF0014   LW RA, 20(SP)
206:                     }else{
207:                         vt_println(str);
9D0141BC  0F405BF2   JAL vt_println
9D0141C0  00A02021   ADDU A0, A1, ZERO
208:                     }
209:                 }
9D0141C4  8FBF0014   LW RA, 20(SP)
9D0141C8  03E00008   JR RA
9D0141CC  27BD0018   ADDIU SP, SP, 24
210:                 
211:                 void scroll_down(dev_t dev){
9D0141D0  27BDFFE8   ADDIU SP, SP, -24
212:                     if (dev==VGA_CONSOLE){
9D0141D4  14800005   BNE A0, ZERO, 0x9D0141EC
9D0141D8  AFBF0014   SW RA, 20(SP)
213:                         vga_scroll_down();
9D0141DC  0F4039A3   JAL vga_scroll_down
9D0141E0  00000000   NOP
9D0141E4  0B40507E   J 0x9D0141F8
9D0141E8  8FBF0014   LW RA, 20(SP)
214:                     }else{
215:                         vt_scroll_down();
9D0141EC  0F405C0A   JAL vt_scroll_down
9D0141F0  00000000   NOP
216:                     }
217:                 }
9D0141F4  8FBF0014   LW RA, 20(SP)
9D0141F8  03E00008   JR RA
9D0141FC  27BD0018   ADDIU SP, SP, 24
218:                 
219:                 void scroll_up(dev_t dev){
9D014200  27BDFFE8   ADDIU SP, SP, -24
220:                     if (dev==VGA_CONSOLE){
9D014204  14800005   BNE A0, ZERO, 0x9D01421C
9D014208  AFBF0014   SW RA, 20(SP)
221:                         vga_scroll_up();
9D01420C  0F403993   JAL vga_scroll_up
9D014210  00000000   NOP
9D014214  0B40508A   J 0x9D014228
9D014218  8FBF0014   LW RA, 20(SP)
222:                     }else{
223:                         vt_scroll_up();
9D01421C  0F405BFB   JAL vt_scroll_up
9D014220  00000000   NOP
224:                     }
225:                 }
9D014224  8FBF0014   LW RA, 20(SP)
9D014228  03E00008   JR RA
9D01422C  27BD0018   ADDIU SP, SP, 24
226:                 
227:                 
228:                 void set_tab_witdh(dev_t dev, int width){
9D014230  27BDFFE8   ADDIU SP, SP, -24
229:                     if (dev==VGA_CONSOLE){
9D014234  14800005   BNE A0, ZERO, 0x9D01424C
9D014238  AFBF0014   SW RA, 20(SP)
230:                         vga_set_tab_width(width);
9D01423C  0F403ABA   JAL vga_set_tab_width
9D014240  30A400FF   ANDI A0, A1, 255
9D014244  0B405096   J 0x9D014258
9D014248  8FBF0014   LW RA, 20(SP)
231:                     }else{
232:                         vt_set_tab_width(width);
9D01424C  0F405C0C   JAL vt_set_tab_width
9D014250  00A02021   ADDU A0, A1, ZERO
233:                     }
234:                 }
9D014254  8FBF0014   LW RA, 20(SP)
9D014258  03E00008   JR RA
9D01425C  27BD0018   ADDIU SP, SP, 24
235:                 
236:                 int get_tab_width(dev_t dev){
9D014260  27BDFFE8   ADDIU SP, SP, -24
237:                     if (dev==VGA_CONSOLE){
9D014264  14800005   BNE A0, ZERO, 0x9D01427C
9D014268  AFBF0014   SW RA, 20(SP)
238:                         return vga_get_tab_width();
9D01426C  0F403ABC   JAL vga_get_tab_width
9D014270  00000000   NOP
9D014274  0B4050A2   J 0x9D014288
9D014278  8FBF0014   LW RA, 20(SP)
239:                     }else{
240:                         return vt_get_tab_width();
9D01427C  0F405C0E   JAL vt_get_tab_width
9D014280  00000000   NOP
241:                     }
242:                     
243:                 }
9D014284  8FBF0014   LW RA, 20(SP)
9D014288  03E00008   JR RA
9D01428C  27BD0018   ADDIU SP, SP, 24
244:                 
245:                  // efface la ligne désignée au complet. et laisse le curseur au début
246:                 void clear_line(dev_t dev, unsigned line){
9D014290  27BDFFE8   ADDIU SP, SP, -24
247:                     if (dev==VGA_CONSOLE){
9D014294  14800005   BNE A0, ZERO, 0x9D0142AC
9D014298  AFBF0014   SW RA, 20(SP)
248:                         vga_clear_line(line);
9D01429C  0F403BD6   JAL vga_clear_line
9D0142A0  00A02021   ADDU A0, A1, ZERO
9D0142A4  0B4050AE   J 0x9D0142B8
9D0142A8  8FBF0014   LW RA, 20(SP)
249:                     }else{
250:                         vt_clear_line(line);
9D0142AC  0F405B8C   JAL vt_clear_line
9D0142B0  00A02021   ADDU A0, A1, ZERO
251:                     }
252:                 }
9D0142B4  8FBF0014   LW RA, 20(SP)
9D0142B8  03E00008   JR RA
9D0142BC  27BD0018   ADDIU SP, SP, 24
---  /build/bamboo/xml-data/build-dir/XC32-CYIMG-BLD/xc32-XC32-release-1_44/src48x/gcc/libgcc/libgcc2.c  
9D015B38  00C04021   ADDU T0, A2, ZERO
9D015F9C  00C04021   ADDU T0, A2, ZERO
9D015B3C  00804821   ADDU T1, A0, ZERO
9D015FA0  00801021   ADDU V0, A0, ZERO
9D015B40  14E0003B   BNE A3, ZERO, 0x9D015C30
9D015B44  00A01821   ADDU V1, A1, ZERO
9D015FA4  14E0003F   BNE A3, ZERO, 0x9D0160A4
9D015FA8  00A04821   ADDU T1, A1, ZERO
9D015B48  00A6102B   SLTU V0, A1, A2
9D015B4C  10400048   BEQ V0, ZERO, 0x9D015C70
9D015B50  70C21020   CLZ V0, A2
9D015FAC  00A6182B   SLTU V1, A1, A2
9D015FB0  10600047   BEQ V1, ZERO, 0x9D0160D0
9D015FB4  70C31820   CLZ V1, A2
9D015B54  50400008   BEQL V0, ZERO, 0x9D015B78
9D015B58  00083402   SRL A2, T0, 16
9D015FB8  50600008   BEQL V1, ZERO, 0x9D015FDC
9D015FBC  00081C02   SRL V1, T0, 16
9D015B68  00464004   SLLV T0, A2, V0
9D015FCC  00664004   SLLV T0, A2, V1
9D015B5C  00021823   SUBU V1, ZERO, V0
9D015B60  00452804   SLLV A1, A1, V0
9D015B64  00641806   SRLV V1, A0, V1
9D015B6C  00651825   OR V1, V1, A1
9D015FC0  00034823   SUBU T1, ZERO, V1
9D015FC4  00652804   SLLV A1, A1, V1
9D015FC8  01244806   SRLV T1, A0, T1
9D015FD0  01254825   OR T1, T1, A1
9D015B70  00444804   SLLV T1, A0, V0
9D015FD4  00641004   SLLV V0, A0, V1
9D015B74  00083402   SRL A2, T0, 16
9D015B78  0066001B   DIVU V1, A2
9D015B7C  00C001F4   TEQ A2, ZERO
9D015B80  00002010   MFHI A0
9D015B84  00005812   MFLO T3
9D015B88  310CFFFF   ANDI T4, T0, -1
9D015B8C  00095402   SRL T2, T1, 16
9D015B90  716C5802   MUL T3, T3, T4
9D015B94  00042400   SLL A0, A0, 16
9D015B98  008A5025   OR T2, A0, T2
9D015B9C  014B682B   SLTU T5, T2, T3
9D015BA0  0066001B   DIVU V1, A2
9D015BA4  00C001F4   TEQ A2, ZERO
9D015BA8  51A00009   BEQL T5, ZERO, 0x9D015BD0
9D015BAC  014B5023   SUBU T2, T2, T3
9D015BB0  01485021   ADDU T2, T2, T0
9D015BB4  0148182B   SLTU V1, T2, T0
9D015BB8  54600005   BNEL V1, ZERO, 0x9D015BD0
9D015BBC  014B5023   SUBU T2, T2, T3
9D015BC0  014B202B   SLTU A0, T2, T3
9D015BC4  01481821   ADDU V1, T2, T0
9D015BC8  0064500B   MOVN T2, V1, A0
9D015BCC  014B5023   SUBU T2, T2, T3
9D015BD0  3123FFFF   ANDI V1, T1, -1
9D015BD4  0146001B   DIVU T2, A2
9D015BD8  00C001F4   TEQ A2, ZERO
9D015BDC  00004810   MFHI T1
9D015BE0  00002012   MFLO A0
9D015BE4  708C2002   MUL A0, A0, T4
9D015BE8  00094C00   SLL T1, T1, 16
9D015BEC  01234825   OR T1, T1, V1
9D015BF0  0124182B   SLTU V1, T1, A0
9D015BF4  0146001B   DIVU T2, A2
9D015BF8  00C001F4   TEQ A2, ZERO
9D015BFC  50600009   BEQL V1, ZERO, 0x9D015C24
9D015C00  01244823   SUBU T1, T1, A0
9D015C04  01284821   ADDU T1, T1, T0
9D015C08  0128182B   SLTU V1, T1, T0
9D015C0C  54600005   BNEL V1, ZERO, 0x9D015C24
9D015C10  01244823   SUBU T1, T1, A0
9D015C14  0124182B   SLTU V1, T1, A0
9D015C18  01284021   ADDU T0, T1, T0
9D015C1C  0103480B   MOVN T1, T0, V1
9D015C20  01244823   SUBU T1, T1, A0
9D015FD8  00081C02   SRL V1, T0, 16
9D015FDC  0123001B   DIVU T1, V1
9D015FE0  006001F4   TEQ V1, ZERO
9D015FE4  00006010   MFHI T4
9D015FE8  00005812   MFLO T3
9D015FEC  310AFFFF   ANDI T2, T0, -1
9D015FF0  00022402   SRL A0, V0, 16
9D015FF4  00003012   MFLO A2
9D015FF8  716A3802   MUL A3, T3, T2
9D015FFC  000C6400   SLL T4, T4, 16
9D016000  01842025   OR A0, T4, A0
9D016004  0087602B   SLTU T4, A0, A3
9D016008  0123001B   DIVU T1, V1
9D01600C  006001F4   TEQ V1, ZERO
9D016010  1180000B   BEQ T4, ZERO, 0x9D016040
9D016014  00872823   SUBU A1, A0, A3
9D016018  00882021   ADDU A0, A0, T0
9D01601C  0088282B   SLTU A1, A0, T0
9D016020  14A00006   BNE A1, ZERO, 0x9D01603C
9D016024  2566FFFF   ADDIU A2, T3, -1
9D016028  0087282B   SLTU A1, A0, A3
9D01602C  10A00004   BEQ A1, ZERO, 0x9D016040
9D016030  00872823   SUBU A1, A0, A3
9D016034  2566FFFE   ADDIU A2, T3, -2
9D016038  00882021   ADDU A0, A0, T0
9D01603C  00872823   SUBU A1, A0, A3
9D016040  3042FFFF   ANDI V0, V0, -1
9D016044  00A3001B   DIVU A1, V1
9D016048  006001F4   TEQ V1, ZERO
9D01604C  00004810   MFHI T1
9D016050  00003812   MFLO A3
9D016054  00002012   MFLO A0
9D016058  70EA5002   MUL T2, A3, T2
9D01605C  00094C00   SLL T1, T1, 16
9D016060  01221025   OR V0, T1, V0
9D016064  004A482B   SLTU T1, V0, T2
9D016068  00A3001B   DIVU A1, V1
9D01606C  006001F4   TEQ V1, ZERO
9D016070  51200009   BEQL T1, ZERO, 0x9D016098
9D016074  00061400   SLL V0, A2, 16
9D016078  00481021   ADDU V0, V0, T0
9D01607C  0048402B   SLTU T0, V0, T0
9D016080  15000004   BNE T0, ZERO, 0x9D016094
9D016084  24E4FFFF   ADDIU A0, A3, -1
9D016088  004A502B   SLTU T2, V0, T2
9D01608C  24E7FFFE   ADDIU A3, A3, -2
9D016090  00EA200B   MOVN A0, A3, T2
9D016094  00061400   SLL V0, A2, 16
9D016098  00821025   OR V0, A0, V0
9D01609C  03E00008   JR RA
9D0160A0  00001821   ADDU V1, ZERO, ZERO
9D015C70  14C00006   BNE A2, ZERO, 0x9D015C8C
9D015C74  71021020   CLZ V0, T0
9D0160D0  14C00006   BNE A2, ZERO, 0x9D0160EC
9D0160D4  71031820   CLZ V1, T0
9D015C78  24020001   ADDIU V0, ZERO, 1
9D015C7C  0046001B   DIVU V0, A2
9D015C80  00C001F4   TEQ A2, ZERO
9D015C84  00004012   MFLO T0
9D0160D8  24030001   ADDIU V1, ZERO, 1
9D0160DC  0066001B   DIVU V1, A2
9D0160E0  00C001F4   TEQ A2, ZERO
9D0160E4  00004012   MFLO T0
9D015C88  71021020   CLZ V0, T0
9D0160E8  71031820   CLZ V1, T0
9D015C8C  5440007D   BNEL V0, ZERO, 0x9D015E84
9D015C90  00484004   SLLV T0, T0, V0
9D0160EC  5460007B   BNEL V1, ZERO, 0x9D0162DC
9D0160F0  00684004   SLLV T0, T0, V1
9D015C94  00A82823   SUBU A1, A1, T0
9D015C98  00081C02   SRL V1, T0, 16
9D015C9C  3107FFFF   ANDI A3, T0, -1
9D0160F4  00A82023   SUBU A0, A1, T0
9D0160F8  00083C02   SRL A3, T0, 16
9D0160FC  310BFFFF   ANDI T3, T0, -1
9D016100  24030001   ADDIU V1, ZERO, 1
9D015E84  24090020   ADDIU T1, ZERO, 32
9D015E88  01224823   SUBU T1, T1, V0
9D0162DC  24020020   ADDIU V0, ZERO, 32
9D0162E0  00431023   SUBU V0, V0, V1
9D015E8C  01255006   SRLV T2, A1, T1
9D0162E4  00454806   SRLV T1, A1, V0
9D015EA8  00452804   SLLV A1, A1, V0
9D015EAC  01244806   SRLV T1, A0, T1
9D015EB0  01252825   OR A1, T1, A1
9D016300  00652804   SLLV A1, A1, V1
9D016304  00441006   SRLV V0, A0, V0
9D016308  00452825   OR A1, V0, A1
9D015EB8  00444804   SLLV T1, A0, V0
9D016310  00641004   SLLV V0, A0, V1
9D015E90  00081C02   SRL V1, T0, 16
9D015E94  0143001B   DIVU T2, V1
9D015E98  006001F4   TEQ V1, ZERO
9D015E9C  00003010   MFHI A2
9D015EA0  00005812   MFLO T3
9D015EA4  3107FFFF   ANDI A3, T0, -1
9D015EB4  00056402   SRL T4, A1, 16
9D015EBC  71675802   MUL T3, T3, A3
9D015EC0  00063400   SLL A2, A2, 16
9D015EC4  01863025   OR A2, T4, A2
9D015EC8  00CB202B   SLTU A0, A2, T3
9D015ECC  0143001B   DIVU T2, V1
9D015ED0  006001F4   TEQ V1, ZERO
9D015ED4  50800006   BEQL A0, ZERO, 0x9D015EF0
9D015ED8  00CB3023   SUBU A2, A2, T3
9D015EDC  00C83021   ADDU A2, A2, T0
9D015EE0  00C8202B   SLTU A0, A2, T0
9D015EE4  10800024   BEQ A0, ZERO, 0x9D015F78
9D015EE8  00CB502B   SLTU T2, A2, T3
9D015EEC  00CB3023   SUBU A2, A2, T3
9D015EF0  30AAFFFF   ANDI T2, A1, -1
9D015EF4  00C3001B   DIVU A2, V1
9D015EF8  006001F4   TEQ V1, ZERO
9D015EFC  00002010   MFHI A0
9D015F00  00002812   MFLO A1
9D015F04  70A72802   MUL A1, A1, A3
9D015F08  00042400   SLL A0, A0, 16
9D015F0C  008A2025   OR A0, A0, T2
9D015F10  0085502B   SLTU T2, A0, A1
9D015F14  00C3001B   DIVU A2, V1
9D015F18  006001F4   TEQ V1, ZERO
9D015F1C  5140FF60   BEQL T2, ZERO, 0x9D015CA0
9D015F20  00852823   SUBU A1, A0, A1
9D015F24  00882021   ADDU A0, A0, T0
9D015F28  0088302B   SLTU A2, A0, T0
9D015F2C  54C0FF5C   BNEL A2, ZERO, 0x9D015CA0
9D015F30  00852823   SUBU A1, A0, A1
9D015F34  0085502B   SLTU T2, A0, A1
9D015F38  00883021   ADDU A2, A0, T0
9D015F3C  00CA200B   MOVN A0, A2, T2
9D015F40  0B405728   J 0x9D015CA0
9D015F44  00852823   SUBU A1, A0, A1
9D015F78  00C82021   ADDU A0, A2, T0
9D015F7C  0B4057BB   J 0x9D015EEC
9D015F80  008A300B   MOVN A2, A0, T2
9D0162E8  00083C02   SRL A3, T0, 16
9D0162EC  0127001B   DIVU T1, A3
9D0162F0  00E001F4   TEQ A3, ZERO
9D0162F4  00003010   MFHI A2
9D0162F8  00006012   MFLO T4
9D0162FC  310BFFFF   ANDI T3, T0, -1
9D01630C  00056C02   SRL T5, A1, 16
9D016314  00001812   MFLO V1
9D016318  718B5002   MUL T2, T4, T3
9D01631C  00063400   SLL A2, A2, 16
9D016320  01A63025   OR A2, T5, A2
9D016324  00CA202B   SLTU A0, A2, T2
9D016328  0127001B   DIVU T1, A3
9D01632C  00E001F4   TEQ A3, ZERO
9D016330  5080000B   BEQL A0, ZERO, 0x9D016360
9D016334  00CA3023   SUBU A2, A2, T2
9D016338  00C83021   ADDU A2, A2, T0
9D01633C  00C8202B   SLTU A0, A2, T0
9D016340  14800006   BNE A0, ZERO, 0x9D01635C
9D016344  2583FFFF   ADDIU V1, T4, -1
9D016348  00CA202B   SLTU A0, A2, T2
9D01634C  50800004   BEQL A0, ZERO, 0x9D016360
9D016350  00CA3023   SUBU A2, A2, T2
9D016354  2583FFFE   ADDIU V1, T4, -2
9D016358  00C83021   ADDU A2, A2, T0
9D01635C  00CA3023   SUBU A2, A2, T2
9D016360  30ACFFFF   ANDI T4, A1, -1
9D016364  00C7001B   DIVU A2, A3
9D016368  00E001F4   TEQ A3, ZERO
9D01636C  00002010   MFHI A0
9D016370  00005012   MFLO T2
9D016374  00004812   MFLO T1
9D016378  714B2802   MUL A1, T2, T3
9D01637C  00042400   SLL A0, A0, 16
9D016380  008C2025   OR A0, A0, T4
9D016384  0085602B   SLTU T4, A0, A1
9D016388  00C7001B   DIVU A2, A3
9D01638C  00E001F4   TEQ A3, ZERO
9D016390  5180000B   BEQL T4, ZERO, 0x9D0163C0
9D016394  00031C00   SLL V1, V1, 16
9D016398  00882021   ADDU A0, A0, T0
9D01639C  0088302B   SLTU A2, A0, T0
9D0163A0  14C00006   BNE A2, ZERO, 0x9D0163BC
9D0163A4  2549FFFF   ADDIU T1, T2, -1
9D0163A8  0085302B   SLTU A2, A0, A1
9D0163AC  50C00004   BEQL A2, ZERO, 0x9D0163C0
9D0163B0  00031C00   SLL V1, V1, 16
9D0163B4  2549FFFE   ADDIU T1, T2, -2
9D0163B8  00882021   ADDU A0, A0, T0
9D0163BC  00031C00   SLL V1, V1, 16
9D0163C0  00852023   SUBU A0, A0, A1
9D0163C4  0B405841   J 0x9D016104
9D0163C8  01231825   OR V1, T1, V1
9D015CA0  00092402   SRL A0, T1, 16
9D015CA4  00A3001B   DIVU A1, V1
9D015CA8  006001F4   TEQ V1, ZERO
9D015CAC  00005010   MFHI T2
9D015CB0  00003012   MFLO A2
9D015CB4  70C73002   MUL A2, A2, A3
9D015CB8  000A5400   SLL T2, T2, 16
9D015CBC  01442025   OR A0, T2, A0
9D015CC0  0086502B   SLTU T2, A0, A2
9D015CC4  00A3001B   DIVU A1, V1
9D015CC8  006001F4   TEQ V1, ZERO
9D015CCC  51400009   BEQL T2, ZERO, 0x9D015CF4
9D015CD0  00862023   SUBU A0, A0, A2
9D015CD4  00882021   ADDU A0, A0, T0
9D015CD8  0088282B   SLTU A1, A0, T0
9D015CDC  54A00005   BNEL A1, ZERO, 0x9D015CF4
9D015CE0  00862023   SUBU A0, A0, A2
9D015CE4  0086502B   SLTU T2, A0, A2
9D015CE8  00882821   ADDU A1, A0, T0
9D015CEC  00AA200B   MOVN A0, A1, T2
9D015CF0  00862023   SUBU A0, A0, A2
9D015CF4  3126FFFF   ANDI A2, T1, -1
9D015CF8  0083001B   DIVU A0, V1
9D015CFC  006001F4   TEQ V1, ZERO
9D015D00  00004810   MFHI T1
9D015D04  00002812   MFLO A1
9D015D08  70A72802   MUL A1, A1, A3
9D015D0C  00094C00   SLL T1, T1, 16
9D015D10  01264825   OR T1, T1, A2
9D015D14  0125302B   SLTU A2, T1, A1
9D015D18  0083001B   DIVU A0, V1
9D015D1C  006001F4   TEQ V1, ZERO
9D015D20  50C00009   BEQL A2, ZERO, 0x9D015D48
9D015D24  01254823   SUBU T1, T1, A1
9D015D28  01284821   ADDU T1, T1, T0
9D015D2C  0128182B   SLTU V1, T1, T0
9D015D30  54600005   BNEL V1, ZERO, 0x9D015D48
9D015D34  01254823   SUBU T1, T1, A1
9D015D38  0125182B   SLTU V1, T1, A1
9D015D3C  01284021   ADDU T0, T1, T0
9D015D40  0103480B   MOVN T1, T0, V1
9D015D44  01254823   SUBU T1, T1, A1
9D016104  00023402   SRL A2, V0, 16
9D016108  0087001B   DIVU A0, A3
9D01610C  00E001F4   TEQ A3, ZERO
9D016110  00006810   MFHI T5
9D016114  00006012   MFLO T4
9D016118  00004812   MFLO T1
9D01611C  718B5002   MUL T2, T4, T3
9D016120  000D6C00   SLL T5, T5, 16
9D016124  01A63025   OR A2, T5, A2
9D016128  00CA682B   SLTU T5, A2, T2
9D01612C  0087001B   DIVU A0, A3
9D016130  00E001F4   TEQ A3, ZERO
9D016134  11A00009   BEQ T5, ZERO, 0x9D01615C
9D016138  00CA2823   SUBU A1, A2, T2
9D01613C  00C83021   ADDU A2, A2, T0
9D016140  00C8202B   SLTU A0, A2, T0
9D016144  14800004   BNE A0, ZERO, 0x9D016158
9D016148  2589FFFF   ADDIU T1, T4, -1
9D01614C  00CA202B   SLTU A0, A2, T2
9D016150  548000A6   BNEL A0, ZERO, 0x9D0163EC
9D016154  2589FFFE   ADDIU T1, T4, -2
9D016158  00CA2823   SUBU A1, A2, T2
9D01615C  3042FFFF   ANDI V0, V0, -1
9D016160  00A7001B   DIVU A1, A3
9D016164  00E001F4   TEQ A3, ZERO
9D016168  00005010   MFHI T2
9D01616C  00003012   MFLO A2
9D016170  00002012   MFLO A0
9D016174  70CB5802   MUL T3, A2, T3
9D016178  000A5400   SLL T2, T2, 16
9D01617C  01421025   OR V0, T2, V0
9D016180  004B502B   SLTU T2, V0, T3
9D016184  00A7001B   DIVU A1, A3
9D016188  00E001F4   TEQ A3, ZERO
9D01618C  51400009   BEQL T2, ZERO, 0x9D0161B4
9D016190  00091400   SLL V0, T1, 16
9D016194  00481021   ADDU V0, V0, T0
9D016198  0048402B   SLTU T0, V0, T0
9D01619C  15000004   BNE T0, ZERO, 0x9D0161B0
9D0161A0  24C4FFFF   ADDIU A0, A2, -1
9D0161A4  004B582B   SLTU T3, V0, T3
9D0161A8  24C6FFFE   ADDIU A2, A2, -2
9D0161AC  00CB200B   MOVN A0, A2, T3
9D0161B0  00091400   SLL V0, T1, 16
9D0161B4  03E00008   JR RA
9D0161B8  00821025   OR V0, A0, V0
9D0163EC  0B405856   J 0x9D016158
9D015C24  00491006   SRLV V0, T1, V0
9D015D48  00491006   SRLV V0, T1, V0
9D015C28  03E00008   JR RA
9D015C2C  00001821   ADDU V1, ZERO, ZERO
9D015D4C  03E00008   JR RA
9D015D50  00001821   ADDU V1, ZERO, ZERO
9D015C30  00A7102B   SLTU V0, A1, A3
9D015C34  14400047   BNE V0, ZERO, 0x9D015D54
9D015C38  70EA5020   CLZ T2, A3
9D0160A4  00A7102B   SLTU V0, A1, A3
9D0160A8  14400044   BNE V0, ZERO, 0x9D0161BC
9D0160AC  70E84020   CLZ T0, A3
9D0161BC  00001821   ADDU V1, ZERO, ZERO
9D0161C0  03E00008   JR RA
9D0161C4  00001021   ADDU V0, ZERO, ZERO
9D015D54  00801021   ADDU V0, A0, ZERO
9D015D58  03E00008   JR RA
9D015D5C  00A01821   ADDU V1, A1, ZERO
9D015C3C  15400048   BNE T2, ZERO, 0x9D015D60
9D015C40  240B0020   ADDIU T3, ZERO, 32
9D0160B0  55000045   BNEL T0, ZERO, 0x9D0161C8
9D0160B4  24020020   ADDIU V0, ZERO, 32
9D015C44  00E5102B   SLTU V0, A3, A1
9D015C48  14400005   BNE V0, ZERO, 0x9D015C60
9D015C4C  00861023   SUBU V0, A0, A2
9D015C50  0086402B   SLTU T0, A0, A2
9D015C54  15000089   BNE T0, ZERO, 0x9D015E7C
9D015C58  00801021   ADDU V0, A0, ZERO
9D0160B8  00E5282B   SLTU A1, A3, A1
9D0160BC  14A000C8   BNE A1, ZERO, 0x9D0163E0
9D0160C0  0086302B   SLTU A2, A0, A2
9D0160C4  38C20001   XORI V0, A2, 1
9D0160C8  03E00008   JR RA
9D0160CC  00001821   ADDU V1, ZERO, ZERO
9D0163E0  00001821   ADDU V1, ZERO, ZERO
9D015C5C  00861023   SUBU V0, A0, A2
9D015C60  00A72823   SUBU A1, A1, A3
9D015C64  0082202B   SLTU A0, A0, V0
9D015C68  03E00008   JR RA
9D015C6C  00A41823   SUBU V1, A1, A0
9D015D60  016A5823   SUBU T3, T3, T2
9D0161C8  00481023   SUBU V0, V0, T0
9D015D64  01473804   SLLV A3, A3, T2
9D015D68  01661006   SRLV V0, A2, T3
9D015D6C  00473825   OR A3, V0, A3
9D0161CC  01073804   SLLV A3, A3, T0
9D0161D0  00461806   SRLV V1, A2, V0
9D0161D4  00673825   OR A3, V1, A3
9D015D9C  01463004   SLLV A2, A2, T2
9D015D70  01656806   SRLV T5, A1, T3
9D0161D8  00455006   SRLV T2, A1, V0
9D015D8C  01452804   SLLV A1, A1, T2
9D015D90  01641006   SRLV V0, A0, T3
9D015D94  00451025   OR V0, V0, A1
9D0161F4  01052804   SLLV A1, A1, T0
9D0161F8  00441006   SRLV V0, A0, V0
9D0161FC  00452825   OR A1, V0, A1
9D015D74  00074C02   SRL T1, A3, 16
9D015D78  01A9001B   DIVU T5, T1
9D015D7C  012001F4   TEQ T1, ZERO
9D015D80  00006010   MFHI T4
9D015D84  00001812   MFLO V1
9D015D88  30EEFFFF   ANDI T6, A3, -1
9D015D98  00022C02   SRL A1, V0, 16
9D015DA0  00004012   MFLO T0
9D015DA4  706E7802   MUL T7, V1, T6
9D015DA8  000C6400   SLL T4, T4, 16
9D015DAC  01856025   OR T4, T4, A1
9D015DB0  018F282B   SLTU A1, T4, T7
9D015DB4  01A9001B   DIVU T5, T1
9D015DB8  012001F4   TEQ T1, ZERO
9D015DBC  10A0000A   BEQ A1, ZERO, 0x9D015DE8
9D015DC0  01442004   SLLV A0, A0, T2
9D015DC4  01876021   ADDU T4, T4, A3
9D015DC8  0187282B   SLTU A1, T4, A3
9D015DCC  14A00006   BNE A1, ZERO, 0x9D015DE8
9D015DD0  2468FFFF   ADDIU T0, V1, -1
9D015DD4  018F282B   SLTU A1, T4, T7
9D015DD8  50A00004   BEQL A1, ZERO, 0x9D015DEC
9D015DDC  018F6023   SUBU T4, T4, T7
9D015DE0  2468FFFE   ADDIU T0, V1, -2
9D015DE4  01876021   ADDU T4, T4, A3
9D015DE8  018F6023   SUBU T4, T4, T7
9D015DEC  3042FFFF   ANDI V0, V0, -1
9D015DF0  0189001B   DIVU T4, T1
9D015DF4  012001F4   TEQ T1, ZERO
9D015DF8  00002810   MFHI A1
9D015DFC  00001812   MFLO V1
9D015E00  00006812   MFLO T5
9D015E04  706E7002   MUL T6, V1, T6
9D015E08  00052C00   SLL A1, A1, 16
9D015E0C  00A21025   OR V0, A1, V0
9D015E10  004E282B   SLTU A1, V0, T6
9D015E14  0189001B   DIVU T4, T1
9D015E18  012001F4   TEQ T1, ZERO
9D015E1C  50A00006   BEQL A1, ZERO, 0x9D015E38
9D015E20  00084400   SLL T0, T0, 16
9D015E24  00471021   ADDU V0, V0, A3
9D015E28  0047282B   SLTU A1, V0, A3
9D015E2C  10A0004C   BEQ A1, ZERO, 0x9D015F60
9D015E30  246DFFFF   ADDIU T5, V1, -1
9D015E34  00084400   SLL T0, T0, 16
9D015E38  01A84025   OR T0, T5, T0
9D015E3C  004E1023   SUBU V0, V0, T6
9D015F60  004E282B   SLTU A1, V0, T6
9D015F64  50A0FFB4   BEQL A1, ZERO, 0x9D015E38
9D015F68  00084400   SLL T0, T0, 16
9D015F6C  246DFFFE   ADDIU T5, V1, -2
9D015F70  0B40578D   J 0x9D015E34
9D015F74  00471021   ADDU V0, V0, A3
9D0161DC  00071C02   SRL V1, A3, 16
9D0161E0  0143001B   DIVU T2, V1
9D0161E4  006001F4   TEQ V1, ZERO
9D0161E8  00004810   MFHI T1
9D0161EC  00006812   MFLO T5
9D0161F0  30EBFFFF   ANDI T3, A3, -1
9D016200  00057402   SRL T6, A1, 16
9D016204  00001012   MFLO V0
9D016208  71AB6002   MUL T4, T5, T3
9D01620C  00094C00   SLL T1, T1, 16
9D016210  012E4825   OR T1, T1, T6
9D016214  012C702B   SLTU T6, T1, T4
9D016218  0143001B   DIVU T2, V1
9D01621C  006001F4   TEQ V1, ZERO
9D016220  11C0000A   BEQ T6, ZERO, 0x9D01624C
9D016224  01063004   SLLV A2, A2, T0
9D016228  01274821   ADDU T1, T1, A3
9D01622C  0127502B   SLTU T2, T1, A3
9D016230  15400006   BNE T2, ZERO, 0x9D01624C
9D016234  25A2FFFF   ADDIU V0, T5, -1
9D016238  012C502B   SLTU T2, T1, T4
9D01623C  51400004   BEQL T2, ZERO, 0x9D016250
9D016240  012C4823   SUBU T1, T1, T4
9D016244  25A2FFFE   ADDIU V0, T5, -2
9D016248  01274821   ADDU T1, T1, A3
9D01624C  012C4823   SUBU T1, T1, T4
9D016250  30A5FFFF   ANDI A1, A1, -1
9D016254  0123001B   DIVU T1, V1
9D016258  006001F4   TEQ V1, ZERO
9D01625C  00006810   MFHI T5
9D016260  00006012   MFLO T4
9D016264  00005012   MFLO T2
9D016268  718B5802   MUL T3, T4, T3
9D01626C  000D6C00   SLL T5, T5, 16
9D016270  01A52825   OR A1, T5, A1
9D016274  00AB682B   SLTU T5, A1, T3
9D016278  0123001B   DIVU T1, V1
9D01627C  006001F4   TEQ V1, ZERO
9D016280  51A0000B   BEQL T5, ZERO, 0x9D0162B0
9D016284  00021400   SLL V0, V0, 16
9D016288  00A72821   ADDU A1, A1, A3
9D01628C  00A7182B   SLTU V1, A1, A3
9D016290  14600006   BNE V1, ZERO, 0x9D0162AC
9D016294  258AFFFF   ADDIU T2, T4, -1
9D016298  00AB182B   SLTU V1, A1, T3
9D01629C  50600004   BEQL V1, ZERO, 0x9D0162B0
9D0162A0  00021400   SLL V0, V0, 16
9D0162A4  258AFFFE   ADDIU T2, T4, -2
9D0162A8  00A72821   ADDU A1, A1, A3
9D0162AC  00021400   SLL V0, V0, 16
9D0162B0  01421025   OR V0, T2, V0
9D0162B4  00AB2823   SUBU A1, A1, T3
9D015E40  01060019   MULTU 0, T0, A2
9D015E44  00004810   MFHI T1
9D015E5C  00003012   MFLO A2
9D0162B8  00460019   MULTU 0, V0, A2
9D0162BC  00003810   MFHI A3
9D015E48  0049182B   SLTU V1, V0, T1
9D015E4C  1460003E   BNE V1, ZERO, 0x9D015F48
9D015E50  00004012   MFLO T0
9D015E54  1049004B   BEQ V0, T1, 0x9D015F84
9D015E58  00491823   SUBU V1, V0, T1
9D015F84  0088182B   SLTU V1, A0, T0
9D0162C0  00A7182B   SLTU V1, A1, A3
9D0162C4  14600044   BNE V1, ZERO, 0x9D0163D8
9D0162C8  00003012   MFLO A2
9D0162CC  10A7003F   BEQ A1, A3, 0x9D0163CC
9D0162D0  01042004   SLLV A0, A0, T0
9D0163CC  0086302B   SLTU A2, A0, A2
9D0163D0  10C0FFC0   BEQ A2, ZERO, 0x9D0162D4
9D0163D4  00000000   NOP
9D0162D4  03E00008   JR RA
9D0162D8  00001821   ADDU V1, ZERO, ZERO
9D0163D8  0B4058B5   J 0x9D0162D4
9D0163DC  2442FFFF   ADDIU V0, V0, -1
9D015F48  01063023   SUBU A2, T0, A2
9D015F4C  01271823   SUBU V1, T1, A3
9D015F50  0106402B   SLTU T0, T0, A2
9D015F54  00681823   SUBU V1, V1, T0
9D015F58  0B405798   J 0x9D015E60
9D015F5C  00431823   SUBU V1, V0, V1
9D015E60  00863023   SUBU A2, A0, A2
9D015E64  0086202B   SLTU A0, A0, A2
9D015E68  00641823   SUBU V1, V1, A0
9D015E6C  01631004   SLLV V0, V1, T3
9D015E70  01463006   SRLV A2, A2, T2
9D015E74  00461025   OR V0, V0, A2
9D015E78  01431806   SRLV V1, V1, T2
9D015E7C  03E00008   JR RA
9D015E80  00000000   NOP
9D015E84  24090020   ADDIU T1, ZERO, 32
9D015E88  01224823   SUBU T1, T1, V0
9D015E8C  01255006   SRLV T2, A1, T1
9D015E90  00081C02   SRL V1, T0, 16
9D015E94  0143001B   DIVU T2, V1
9D015E98  006001F4   TEQ V1, ZERO
9D015E9C  00003010   MFHI A2
9D015EA0  00005812   MFLO T3
9D015EA4  3107FFFF   ANDI A3, T0, -1
9D015EA8  00452804   SLLV A1, A1, V0
9D015EAC  01244806   SRLV T1, A0, T1
9D015EB0  01252825   OR A1, T1, A1
9D015EB4  00056402   SRL T4, A1, 16
9D015EB8  00444804   SLLV T1, A0, V0
9D015EBC  71675802   MUL T3, T3, A3
9D015EC0  00063400   SLL A2, A2, 16
9D015EC4  01863025   OR A2, T4, A2
9D015EC8  00CB202B   SLTU A0, A2, T3
9D015ECC  0143001B   DIVU T2, V1
9D015ED0  006001F4   TEQ V1, ZERO
9D015ED4  50800006   BEQL A0, ZERO, 0x9D015EF0
9D015ED8  00CB3023   SUBU A2, A2, T3
9D015EDC  00C83021   ADDU A2, A2, T0
9D015EE0  00C8202B   SLTU A0, A2, T0
9D015EE4  10800024   BEQ A0, ZERO, 0x9D015F78
9D015EE8  00CB502B   SLTU T2, A2, T3
9D015EEC  00CB3023   SUBU A2, A2, T3
9D015EF0  30AAFFFF   ANDI T2, A1, -1
9D015EF4  00C3001B   DIVU A2, V1
9D015EF8  006001F4   TEQ V1, ZERO
9D015EFC  00002010   MFHI A0
9D015F00  00002812   MFLO A1
9D015F04  70A72802   MUL A1, A1, A3
9D015F08  00042400   SLL A0, A0, 16
9D015F0C  008A2025   OR A0, A0, T2
9D015F10  0085502B   SLTU T2, A0, A1
9D015F14  00C3001B   DIVU A2, V1
9D015F18  006001F4   TEQ V1, ZERO
9D015F1C  5140FF60   BEQL T2, ZERO, 0x9D015CA0
9D015F20  00852823   SUBU A1, A0, A1
9D015F24  00882021   ADDU A0, A0, T0
9D015F28  0088302B   SLTU A2, A0, T0
9D015F2C  54C0FF5C   BNEL A2, ZERO, 0x9D015CA0
9D015F30  00852823   SUBU A1, A0, A1
9D015F34  0085502B   SLTU T2, A0, A1
9D015F38  00883021   ADDU A2, A0, T0
9D015F3C  00CA200B   MOVN A0, A2, T2
9D015F40  0B405728   J 0x9D015CA0
9D015F44  00852823   SUBU A1, A0, A1
9D015F48  01063023   SUBU A2, T0, A2
9D015F4C  01271823   SUBU V1, T1, A3
9D015F50  0106402B   SLTU T0, T0, A2
9D015F54  00681823   SUBU V1, V1, T0
9D015F58  0B405798   J 0x9D015E60
9D015F5C  00431823   SUBU V1, V0, V1
9D015F60  004E282B   SLTU A1, V0, T6
9D015F64  50A0FFB4   BEQL A1, ZERO, 0x9D015E38
9D015F68  00084400   SLL T0, T0, 16
9D015F6C  246DFFFE   ADDIU T5, V1, -2
9D015F70  0B40578D   J 0x9D015E34
9D015F74  00471021   ADDU V0, V0, A3
9D015F78  00C82021   ADDU A0, A2, T0
9D015F7C  0B4057BB   J 0x9D015EEC
9D015F80  008A300B   MOVN A2, A0, T2
9D015F84  0088182B   SLTU V1, A0, T0
9D015F88  5460FFF0   BNEL V1, ZERO, 0x9D015F4C
9D015F8C  01063023   SUBU A2, T0, A2
9D015F90  00003012   MFLO A2
9D015F94  0B405798   J 0x9D015E60
9D015F98  00001821   ADDU V1, ZERO, ZERO
9D0163E4  03E00008   JR RA
9D0163E8  24020001   ADDIU V0, ZERO, 1
9D0163EC  0B405856   J 0x9D016158
9D0163F0  00C83021   ADDU A2, A2, T0
---  /build/bamboo/xml-data/build-dir/XC32-CYIMG-BLD/xc32-XC32-release-1_44/pic32-libs/libpic32/arch/mips/setjmp.S
9D01E55C  AC900000   SW S0, 0(A0)
9D01E588  03E00008   JR RA
9D01E590  8C900000   LW S0, 0(A0)
9D01E5B8  14A00002   BNE A1, ZERO, 0x9D01E5C4
9D01E5C0  24050001   ADDIU A1, ZERO, 1
9D01E5C4  03E00008   JR RA
